<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://0808200.xyz/bedstone/browser-working-principle/part4/lesson20.html"><meta property="og:site_name" content="𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"><meta property="og:title" content="async await使用同步方式写异步代码"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-12-29T09:56:01.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-12-29T09:56:01.000Z"><meta name="baidu-site-verification" content="4H7tszevS8"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#5c92d1"><link rel="icon" href="/favicon.ico"><link rel="icon" href="/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#5c92d1"><link rel="apple-touch-icon" href="/assets/icon/apple-touch-icon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>async await使用同步方式写异步代码 | 𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ</title><meta name="description" content="𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ personal blog.">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/css/styles.a3b28925.css">
    <link rel="preload" href="/assets/js/runtime~app.15b5cca0.js" as="script"><link rel="preload" href="/assets/css/styles.a3b28925.css" as="style"><link rel="preload" href="/assets/js/31606.23ba15c3.js" as="script"><link rel="preload" href="/assets/js/app.7ad4ad60.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.png" alt="𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"><!----><span class="site-name hide-in-pad">𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="随笔"><span class="title"><span class="icon iconfont icon-note" style=""></span>随笔</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/note/" class="nav-link" aria-label="随笔"><span class="icon iconfont icon-note" style=""></span>随笔<!----></a></li><li class="dropdown-item"><a href="/note/moodEssay/" class="nav-link" aria-label="心情随笔"><span class="icon iconfont icon-leaf" style=""></span>心情随笔<!----></a></li><li class="dropdown-item"><a href="/note/moodArticle/" class="nav-link" aria-label="心情文章"><span class="icon iconfont icon-flower" style=""></span>心情文章<!----></a></li><li class="dropdown-item"><a href="/note/lifeDiary/" class="nav-link" aria-label="生活日记"><span class="icon iconfont icon-form" style=""></span>生活日记<!----></a></li><li class="dropdown-item"><a href="/note/inOnLife/" class="nav-link" aria-label="人生感悟"><span class="icon iconfont icon-nodeJS" style=""></span>人生感悟<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="代码笔记"><span class="title"><span class="icon iconfont icon-code" style=""></span>代码笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/code/" class="nav-link" aria-label="代码笔记"><span class="icon iconfont icon-code" style=""></span>代码笔记<!----></a></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>前端</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vue2/" class="nav-link" aria-label="vue2 源码解析"><span class="icon iconfont icon-vue" style=""></span>vue2 源码解析<!----></a></li><li class="dropdown-subitem"><a href="/react/" class="nav-link" aria-label="React 源码解析"><span class="icon iconfont icon-code" style=""></span>React 源码解析<!----></a></li><li class="dropdown-subitem"><a href="/vue3/" class="nav-link" aria-label="Vue3 源码解析"><span class="icon iconfont icon-typescript" style=""></span>Vue3 源码解析<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>产品设计</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/design/" class="nav-link" aria-label="UI 设计"><span class="icon iconfont icon-skin" style=""></span>UI 设计<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>后端运维</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/linux/" class="nav-link" aria-label="Linux"><span class="icon iconfont icon-linux" style=""></span>Linux<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="软件教程"><span class="title"><span class="icon iconfont icon-software" style=""></span>软件教程</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/software/" class="nav-link" aria-label="软件教程"><span class="icon iconfont icon-software" style=""></span>软件教程<!----></a></li><li class="dropdown-item"><a href="/software/vscode/" class="nav-link" aria-label="VS Code"><span class="icon iconfont icon-vscode" style=""></span>VS Code<!----></a></li><li class="dropdown-item"><a href="/software/git/" class="nav-link" aria-label="Git"><span class="icon iconfont icon-git" style=""></span>Git<!----></a></li><li class="dropdown-item"><a href="/software/comsol/" class="nav-link" aria-label="COMSOL"><span class="icon iconfont icon-app" style=""></span>COMSOL<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="前端基石"><span class="title"><span class="icon iconfont icon-bedstone" style=""></span>前端基石</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/bedstone/" class="nav-link" aria-label="前端基石"><span class="icon iconfont icon-software" style=""></span>前端基石<!----></a></li><li class="dropdown-item"><a href="/bedstone/computer-memory-detail/" class="nav-link" aria-label="计算机内存机制"><!---->计算机内存机制<!----></a></li><li class="dropdown-item"><a href="/bedstone/browser-working-principle/" class="nav-link active" aria-label="浏览器工作原理与实践"><!---->浏览器工作原理与实践<!----></a></li><li class="dropdown-item"><a href="/bedstone/beauty-of-design-pattern/" class="nav-link" aria-label="设计模式之美"><!---->设计模式之美<!----></a></li><li class="dropdown-item"><a href="/bedstone/google-v8" class="nav-link" aria-label="Chrome V8 让你更懂JavaScript"><!---->Chrome V8 让你更懂JavaScript<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><!----><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><div id="docsearch-container"></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/" class="nav-link sidebar-link sidebar-page" aria-label="浏览器工作原理与实践"><!---->浏览器工作原理与实践<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-guide" style=""></span><span class="title">宏观视角上的浏览器</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/part1/lesson01.html" class="nav-link sidebar-link sidebar-page" aria-label="Chrome架构：仅仅打开了1个页面，为什么有4个进程"><!---->Chrome架构：仅仅打开了1个页面，为什么有4个进程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part1/lesson02.html" class="nav-link sidebar-link sidebar-page" aria-label="TCP协议：如何保证页面文件能被完整送达浏览器"><!---->TCP协议：如何保证页面文件能被完整送达浏览器<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part1/lesson03.html" class="nav-link sidebar-link sidebar-page" aria-label="HTTP请求流程：为什么很多站点第二次打开速度会很快"><!---->HTTP请求流程：为什么很多站点第二次打开速度会很快<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part1/lesson04.html" class="nav-link sidebar-link sidebar-page" aria-label="导航流程：从输入URL到页面展示这中间发生了什么"><!---->导航流程：从输入URL到页面展示这中间发生了什么<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part1/lesson05.html" class="nav-link sidebar-link sidebar-page" aria-label="渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的"><!---->渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part1/lesson06.html" class="nav-link sidebar-link sidebar-page" aria-label="渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的"><!---->渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-guide" style=""></span><span class="title">浏览器中的JavaScript执行机制</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/part2/lesson07.html" class="nav-link sidebar-link sidebar-page" aria-label="变量提升：JavaScript代码是按顺序执行的吗"><!---->变量提升：JavaScript代码是按顺序执行的吗<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part2/lesson08.html" class="nav-link sidebar-link sidebar-page" aria-label="调用栈：为什么JavaScript代码会出现栈溢出"><!---->调用栈：为什么JavaScript代码会出现栈溢出<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part2/lesson09.html" class="nav-link sidebar-link sidebar-page" aria-label="块级作用域：var缺陷以及为什么要引入let和const"><!---->块级作用域：var缺陷以及为什么要引入let和const<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part2/lesson10.html" class="nav-link sidebar-link sidebar-page" aria-label="作用域链和闭包：代码中出现相同的变量，JavaScript引擎如何选择"><!---->作用域链和闭包：代码中出现相同的变量，JavaScript引擎如何选择<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part2/lesson11.html" class="nav-link sidebar-link sidebar-page" aria-label="this：从JavaScript执行上下文视角讲this"><!---->this：从JavaScript执行上下文视角讲this<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-guide" style=""></span><span class="title">V8工作原理</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/part3/lesson12.html" class="nav-link sidebar-link sidebar-page" aria-label="栈空间和堆空间：数据是如何存储的"><!---->栈空间和堆空间：数据是如何存储的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part3/lesson13.html" class="nav-link sidebar-link sidebar-page" aria-label="垃圾回收：垃圾数据如何自动回收"><!---->垃圾回收：垃圾数据如何自动回收<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part3/lesson14.html" class="nav-link sidebar-link sidebar-page" aria-label="编译器和解析器：V8如何执行一段JavaScript代码的"><!---->编译器和解析器：V8如何执行一段JavaScript代码的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-guide" style=""></span><span class="title">浏览器中的页面循环系统</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/part4/lesson15.html" class="nav-link sidebar-link sidebar-page" aria-label="消息队列和事件循环：页面是怎么活起来的"><!---->消息队列和事件循环：页面是怎么活起来的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part4/lesson16.html" class="nav-link sidebar-link sidebar-page" aria-label="Webapi：setTimeout是怎么实现的"><!---->Webapi：setTimeout是怎么实现的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part4/lesson17.html" class="nav-link sidebar-link sidebar-page" aria-label="Webapi：XMLHttpRequest是怎么实现的"><!---->Webapi：XMLHttpRequest是怎么实现的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part4/lesson18.html" class="nav-link sidebar-link sidebar-page" aria-label="宏任务和微任务：不是所有的任务都是一个待遇"><!---->宏任务和微任务：不是所有的任务都是一个待遇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part4/lesson19.html" class="nav-link sidebar-link sidebar-page" aria-label="使用Promise告别回调函数"><!---->使用Promise告别回调函数<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="async await使用同步方式写异步代码"><!---->async await使用同步方式写异步代码<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html#生成器-vs-协程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="生成器 VS 协程"><!---->生成器 VS 协程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html#async-await" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="async/await"><!---->async/await<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html#总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="总结"><!---->总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-guide" style=""></span><span class="title">浏览器中的页面</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson21.html" class="nav-link sidebar-link sidebar-page" aria-label="页面性能分析：利用chrome做web性能分析"><!---->页面性能分析：利用chrome做web性能分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson22.html" class="nav-link sidebar-link sidebar-page" aria-label="DOM树：JavaScript是如何影响DOM树构建的"><!---->DOM树：JavaScript是如何影响DOM树构建的<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson23.html" class="nav-link sidebar-link sidebar-page" aria-label="渲染流水线：CSS如何影响首次加载时的白屏时间？"><!---->渲染流水线：CSS如何影响首次加载时的白屏时间？<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson24.html" class="nav-link sidebar-link sidebar-page" aria-label="分层和合成机制：为什么css动画比JavaScript高效"><!---->分层和合成机制：为什么css动画比JavaScript高效<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson25.html" class="nav-link sidebar-link sidebar-page" aria-label="页面性能：如何系统优化页面"><!---->页面性能：如何系统优化页面<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson26.html" class="nav-link sidebar-link sidebar-page" aria-label="虚拟DOM：虚拟DOM和实际DOM有何不同"><!---->虚拟DOM：虚拟DOM和实际DOM有何不同<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson27.html" class="nav-link sidebar-link sidebar-page" aria-label="PWA：解决了web应用哪些问题"><!---->PWA：解决了web应用哪些问题<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part5/lesson28.html" class="nav-link sidebar-link sidebar-page" aria-label="webComponent：像搭积木一样构建web应用"><!---->webComponent：像搭积木一样构建web应用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-guide" style=""></span><span class="title">浏览器中的网络</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson29.html" class="nav-link sidebar-link sidebar-page" aria-label="HTTP1：HTTP性能优化"><!---->HTTP1：HTTP性能优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson30.html" class="nav-link sidebar-link sidebar-page" aria-label="HTTP2：如何提升网络速度"><!---->HTTP2：如何提升网络速度<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson31.html" class="nav-link sidebar-link sidebar-page" aria-label="HTTP3：甩掉TCP、TCL包袱 构建高效网络"><!---->HTTP3：甩掉TCP、TCL包袱 构建高效网络<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson32.html" class="nav-link sidebar-link sidebar-page" aria-label="同源策略：为什么XMLHttpRequst不能跨域请求资源"><!---->同源策略：为什么XMLHttpRequst不能跨域请求资源<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson33.html" class="nav-link sidebar-link sidebar-page" aria-label="跨站脚本攻击XSS：为什么cookie中有httpOnly属性"><!---->跨站脚本攻击XSS：为什么cookie中有httpOnly属性<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson34.html" class="nav-link sidebar-link sidebar-page" aria-label="CSRF攻击：陌生链接不要随便点"><!---->CSRF攻击：陌生链接不要随便点<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson35.html" class="nav-link sidebar-link sidebar-page" aria-label="沙盒：页面和系统之间的隔离墙"><!---->沙盒：页面和系统之间的隔离墙<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/bedstone/browser-working-principle/part6/lesson36.html" class="nav-link sidebar-link sidebar-page" aria-label="HTTPS：让数据传输更安全"><!---->HTTPS：让数据传输更安全<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->async await使用同步方式写异步代码</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年12月29日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://0808200.xyz" target="_blank" rel="noopener noreferrer">𝐺𝑜𝑜𝑔𝑥ℎ</a></span><span property="author" content="𝐺𝑜𝑜𝑔𝑥ℎ"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年12月29日</span><meta property="datePublished" content="2022-12-29T09:56:01.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年12月29日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 13 分钟</span><meta property="timeRequired" content="PT13M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html#生成器-vs-协程" class="router-link-active router-link-exact-active toc-link level2">生成器 VS 协程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html#async-await" class="router-link-active router-link-exact-active toc-link level2">async/await</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/bedstone/browser-working-principle/part4/lesson20.html#总结" class="router-link-active router-link-exact-active toc-link level2">总结</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="async-await使用同步方式写异步代码" tabindex="-1"><a class="header-anchor" href="#async-await使用同步方式写异步代码" aria-hidden="true">#</a> async await使用同步方式写异步代码</h1><p>在上篇文章中，我们介绍了怎么使用 Promise 来实现回调操作，使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p><p>比如下面这样一个实际的使用场景：我先请求极客邦的内容，等返回信息之后，我再请求极客邦的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，这和我们上篇文章中讲的 XFetch 很像，只不过 fetch 是浏览器原生支持的，并有没利用 XMLHttpRequest 来封装。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org/test&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这段 Promise 代码可以看出来，使用 promise.then 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，使得代码依然不是太容易阅读。基于这个原因，ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。你可以参考下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response1&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span>
    <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org/test&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response2&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。但是很多人都习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程，因为这中间隐藏了一些容易让人迷惑的细节。</p><p>那么本篇文章我们继续深入，看看 JavaScript 引擎是如何实现 async/await 的。如果上来直接介绍 async/await 的使用方式的话，那么你可能会有点懵，所以我们就从其最底层的技术点一步步往上讲解，从而带你彻底弄清楚 async 和 await 到底是怎么工作的。</p><p>本文我们首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制——协程（Coroutine）；又因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的。</p><h2 id="生成器-vs-协程" tabindex="-1"><a class="header-anchor" href="#生成器-vs-协程" aria-hidden="true">#</a> 生成器 VS 协程</h2><p>我们先来看看什么是生成器函数？</p><p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。我们可以看下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot; 开始执行第一段 &quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">&#39;generator 2&#39;</span>
 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot; 开始执行第二段 &quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">&#39;generator 2&#39;</span>
 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot; 开始执行第三段 &quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">&#39;generator 2&#39;</span>
 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot; 执行结束 &quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">&#39;generator 2&#39;</span>
<span class="token punctuation">}</span>
 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;main 0&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;main 1&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;main 2&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;main 3&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;main 4&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p><ul><li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li><li>外部函数可以通过 next 方法恢复函数的执行</li></ul><p>关于函数的暂停和恢复，相信你一定很好奇这其中的原理，那么接下来我们就来简单介绍下 JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的，这也会有助于你理解后面要介绍的 async/await。</p><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p><p><img src="https://blog.poetries.top/img/static/gitee/2019/11/46.png" alt=""></p><p><strong>从图中可以看出来协程的四点规则：</strong></p><ul><li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li><li>要让 gen 协程执行，需要通过调用 gen.next。</li><li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li><li>如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</li></ul><p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p><p>要搞清楚上面的问题，你需要关注以下两点内容。</p><p>第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p><p>第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</p><p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图</p><p><img src="https://blog.poetries.top/img/static/gitee/2019/11/47.png" alt=""></p><p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//foo 函数</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response1&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span>
    <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org/test&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response2&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 执行 foo 函数的代码</span>
<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">getGenPromise</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value
<span class="token punctuation">}</span>
<span class="token function">getGenPromise</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response1&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">getGenPromise</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response2&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p><ul><li>首先执行的是let gen = foo()，创建了 gen 协程。</li><li>然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</li><li>gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</li><li>父协程恢复执行后，调用 response1.then 方法等待请求结果。</li><li>等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</li></ul><p>以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response1&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span>
    <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.geekbang.org/test&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;response2&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">co</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p><h2 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> async/await</h2><p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了 async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实 async/await 技术背后的秘密就是 Promise 和生成器应用，往低层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。</p><p><strong>1. async</strong></p><p>我们先来看看 async 到底是什么？根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p><p>对 async 函数的理解，这里需要重点关注两个词：异步执行和隐式返回 Promise。</p><p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回 Promise 的，你可以参考下面的代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>async function foo() {
    return 2
}

console.log(foo())  // Promise {&lt;resolved&gt;: 2}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行这段代码，我们可以看到调用 async 声明的 foo 函数返回了一个 Promise 对象，状态是 resolved，返回结果如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Promise {&lt;resolved&gt;: 2}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2. await</strong></p><p>我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">100</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p><p><img src="https://blog.poetries.top/img/static/gitee/2019/11/48.png" alt=""></p><p>结合上图，我们来一起分析下 async/await 的执行流程。</p><p>首先，执行console.log(0)这个语句，打印出来 0。</p><p>紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的console.log(1)语句，并打印出 1。</p><p>接下来就执行到 foo 函数中的await 100这个语句了，这里是我们分析的重点，因为在执行await 100这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p><p>当执行到await 100时，会默认创建一个 Promise 对象，代码如下所示：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> promise_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列（上一篇文章中我们讲解过）。</p><p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。</p><p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。</p><p>接下来继续执行父协程的流程，这里我们执行console.log(3)，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有resolve(100)的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>promise_<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
   <span class="token comment">// 回调函数被激活后</span>
  <span class="token comment">// 将主线程控制权交给 foo 协程，并将 vaule 值传给协程</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p><p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p><p>以上就是 <code>await/async</code> 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的主要内容。</p><ul><li>Promise 的编程模型依然充斥着大量的 then 方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的 then 函数，这就是 async/await 出现的原因。</li><li>使用 async/await 可以实现用同步代码的风格来编写异步代码，这是因为 async/await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</li><li>另外，V8 引擎还为 async/await 做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对 async/await 的理解。</li><li><code>async/await</code> 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 <code>async/await</code>，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise</li></ul></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/gongxho/gongxho.github.io/edit/main/src/bedstone/browser-working-principle/part4/lesson20.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/12/29 09:56:01</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: gxh522@qq.com">googxh</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/bedstone/browser-working-principle/part4/lesson19.html" class="nav-link prev" aria-label="使用Promise告别回调函数"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->使用Promise告别回调函数</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022-present Mr.Googxh</div></footer><!--]--></div><!--]--><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.15b5cca0.js" defer></script><script src="/assets/js/31606.23ba15c3.js" defer></script><script src="/assets/js/app.7ad4ad60.js" defer></script>
  </body>
</html>
