<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://0808200.xyz/rss.xml" rel="self" type="application/rss+xml"/>
    <title>𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ</title>
    <link>https://0808200.xyz/</link>
    <description>𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ personal blog.</description>
    <language>zh-CN</language>
    <pubDate>Fri, 01 Jul 2022 10:04:30 GMT</pubDate>
    <lastBuildDate>Fri, 01 Jul 2022 10:04:30 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>随笔</category>
    <category>设计</category>
    <category>硬件</category>
    <category>Linux</category>
    <category>基础</category>
    <category>服务器</category>
    <category>软件</category>
    <category>Android</category>
    <category>前端</category>
    <category>后端</category>
    <category>GitHub</category>
    <category>教程</category>
    <category>小程序</category>
    <category>Node.js</category>
    <category>Vue</category>
    <category>JavaScript</category>
    <item>
      <title>人生感悟</title>
      <link>https://0808200.xyz/note/inOnLife/</link>
      <guid>https://0808200.xyz/note/inOnLife/</guid>
      <source url="https://0808200.xyz/rss.xml">人生感悟</source>
      <pubDate>Wed, 29 Jun 2022 10:08:18 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="心情随笔" tabindex="-1"> 心情随笔</h2>
<div><p>介绍</p>
<p>醉生梦死</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【一】</title>
      <link>https://0808200.xyz/note/lifeDiary/1.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/1.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【一】</source>
      <category>随笔</category>
      <pubDate>Sat, 18 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【一】" tabindex="-1"> 笑谈人生【一】</h1>
<div style="text-align: center"><p>精打细算你失去了多少，</p>
<p>求而不得你烦恼了多少，</p>
<p>斤斤计较你结怨了多少，</p>
<p>贪心不灭你造恶了多少，</p>
<p>日复一日你能放下多少，</p>
<p>千方百计你能得到多少，</p>
<p>人生在世你能享受多少，</p>
<p>临命终时你能带走多少?</p>
<p>唯大肚能容，</p>
<p>容天下难容之事，</p>
<p>只开口一笑，</p>
<p>笑世上可笑之人。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【二】</title>
      <link>https://0808200.xyz/note/lifeDiary/2.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/2.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【二】</source>
      <category>随笔</category>
      <pubDate>Sun, 19 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【二】" tabindex="-1"> 笑谈人生【二】</h1>
<div style="text-align: center"><p>梦，不能做得太深，深了，难以清醒；</p>
<p>话，不能说得太满，满了，难以相通；</p>
<p>调，不能定得太高，高了，难以合声；</p>
<p>事，不能做得太绝，绝了，难以进退；</p>
<p>情，不能陷得太深，深了，难以自拔；</p>
<p>利，不能看得太重，重了，难以明志；</p>
<p>人，不能做得太假，假了，难以交心。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【三】</title>
      <link>https://0808200.xyz/note/lifeDiary/3.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/3.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【三】</source>
      <category>随笔</category>
      <pubDate>Fri, 17 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【三】" tabindex="-1"> 笑谈人生【三】</h1>
<div style="text-align: center"><p>人生就是一阵风，起了，没了。</p>
<p>理想就是一盏灯，燃了，灭了。</p>
<p>人情就是一阵雨，下了，干了。</p>
<p>朋友就是一层云，聚了，散了。</p>
<p>闲愁就是一壶酒，醉了，醒了。</p>
<p>寂寞就是一颗星，闪了，灭了。</p>
<p>孤独就是一轮月，升了，落了。</p>
<p>死亡就是一场梦，累了，睡了。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【四】</title>
      <link>https://0808200.xyz/note/lifeDiary/4.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/4.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【四】</source>
      <category>随笔</category>
      <pubDate>Sun, 26 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【四】" tabindex="-1"> 笑谈人生【四】</h1>
<div style="text-align: center"><p>只有淡然的心态，</p>
<p>才是人生的成熟。</p>
<p>越长大就越孤单，</p>
<p>越长大就越无奈。</p>
<p>曾经我们可以</p>
<p>肆无忌惮说的话，</p>
<p>不计后果做的事，</p>
<p>在长大的那一天，</p>
<p>终于被硬生生地</p>
<p>压回到了心底。</p>
<p>长大了，懂事了，</p>
<p>心却复杂起来了。</p>
<p>还是觉得淡然最好，</p>
<p>简单心态最快乐。</p>
<p>人生之事，计较越多，烦恼越多。</p>
<p>淡然，才是一种彻悟。</p>
<p>怀着淡然，笑看人生。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【五】</title>
      <link>https://0808200.xyz/note/lifeDiary/5.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/5.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【五】</source>
      <category>随笔</category>
      <pubDate>Wed, 29 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【五】" tabindex="-1"> 笑谈人生【五】</h1>
<div style="text-align: center"><p>人生犹如一首歌，</p>
<p>音调高低起伏，</p>
<p>旋律抑扬顿挫；</p>
<p>人生仿佛一本书，</p>
<p>写满酸甜苦辣，</p>
<p>记录喜怒哀乐；</p>
<p>人生就像一局棋，</p>
<p>处处布满危险，</p>
<p>也撒遍了机遇；</p>
<p>人生恰似一条路，</p>
<p>有山重水复的坎坷，</p>
<p>也有柳暗花明的坦途；</p>
<p>人生如同一条河，</p>
<p>有时九曲回肠，</p>
<p>有时一泻千里。</p>
<p>成败自清醒，</p>
<p>是非一笑过。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【六】</title>
      <link>https://0808200.xyz/note/lifeDiary/6.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/6.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【六】</source>
      <category>随笔</category>
      <pubDate>Thu, 30 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【六】" tabindex="-1"> 笑谈人生【六】</h1>
<div style="text-align: center"><p>人之所以会烦恼，就是记性太好。</p>
<p>人之所以会痛苦，就是追求太多。</p>
<p>人之所以不快乐，就是计较太多。</p>
<p>人之所以不幸福，就是不会知足。</p>
<p>人之所以活的累，就是想的太多。</p>
<p>人，永远是矛盾的主体，</p>
<p>经常处在困惑中，</p>
<p>夹在世俗的单行道上，</p>
<p>走不远，也回不去。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【七】</title>
      <link>https://0808200.xyz/note/lifeDiary/7.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/7.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【七】</source>
      <category>随笔</category>
      <pubDate>Fri, 31 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【七】" tabindex="-1"> 笑谈人生【七】</h1>
<div style="text-align: center"><p>当你成长跟不上知识更新时，</p>
<p>你的学习会出问题；</p>
<p>当你成长跟不上恋人配偶时，</p>
<p>你的感情会出问题；</p>
<p>当你成长跟不上朋友时，</p>
<p>你的友谊会出问题；</p>
<p>当你成长跟不上公司节奏时，</p>
<p>你的工作会出问题；</p>
<p>当你成长跟不上孩子思维时，</p>
<p>你的沟通会出问题!</p>
<p>我们一生努力的结果，</p>
<p>不过是配得起身边的人，</p>
<p>大家彼此欣赏，</p>
<p>相依相伴，</p>
<p>携手一生。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【八】</title>
      <link>https://0808200.xyz/note/lifeDiary/8.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/8.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【八】</source>
      <category>随笔</category>
      <pubDate>Fri, 31 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【八】" tabindex="-1"> 笑谈人生【八】</h1>
<p>人生不易，且行且珍惜。</p>
<div style="text-align: center"><p>♢</p>
</div>
<p>幸福不在于拥有很多，而在于拥有很少也已满足，所谓知足常乐亦如此。浮躁的人们，总是习惯等待一段时光沉淀后，掸去风尘，才会感叹当时的美好；总是欢在一段光阴中回忆另一段光阴里的故事。可是流水里洒落的光阴，一路向东，不会停留，多少年的走过，也只能给彼此留下一份淡淡的回忆。</p>
<div style="text-align: center"><p>♢</p>
</div>
<p>与其华丽撞墙，不如优雅转身，给自己一个迂回的空间，学会思索，慢慢调整。人生最曼妙的风景，不是追名逐利，风光无限，而是内心的淡定与从容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【九】</title>
      <link>https://0808200.xyz/note/lifeDiary/9.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/9.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【九】</source>
      <category>随笔</category>
      <pubDate>Sun, 02 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【九】" tabindex="-1"> 笑谈人生【九】</h1>
<div style="text-align: center"><p>不打扰别人，</p>
<p>不怠慢自己，</p>
<p>不挥霍信任，</p>
<p>不讨好，不盲从，</p>
<p>不做道德上的英雄，</p>
<p>足矣!</p>
<p>人生有许多的如果，</p>
<p>却只有一个结果。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>生活日记</title>
      <link>https://0808200.xyz/note/lifeDiary/</link>
      <guid>https://0808200.xyz/note/lifeDiary/</guid>
      <source url="https://0808200.xyz/rss.xml">生活日记</source>
      <category>随笔</category>
      <pubDate>Wed, 29 Jun 2022 10:08:18 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>介绍</p>
<p>油盐酱醋</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈坦然】</title>
      <link>https://0808200.xyz/note/lifeDiary/calm.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/calm.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈坦然】</source>
      <category>随笔</category>
      <pubDate>Wed, 17 Jan 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈坦然】" tabindex="-1"> 笑谈人生【谈坦然】</h1>
<p>人生旅程中，顺畅也好，低谷也罢，都应该坦然面对。因为在这世界上，本不存在极乐天堂，无人能从世俗的羁绊中解脱出来，我们所能做的，只是爬起来比倒下去多一次，用汗水代替口水而已；</p>
<p>也唯有如此，方能让生命在磨难中得到升华。</p>
<p>我们要坚信人生没有过不去的坎，以勇敢的姿态迎接命运的挑战。</p>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈选择】</title>
      <link>https://0808200.xyz/note/lifeDiary/choice.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/choice.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈选择】</source>
      <category>随笔</category>
      <pubDate>Tue, 18 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈选择】" tabindex="-1"> 笑谈人生【谈选择】</h1>
<p>生活中有太多的选择，时刻考验着我们的心智。我们在一次次选择中成长。经历让我们承受太多无奈，些许的沧桑也被岁月刻在脸上。点点滴滴琐碎的融入，伴着侵入骨髓的苦楚，在崎岖不平的路上使我们跌跌撞撞，在断续的跌倒爬起中变得坚强。心中有所选择，有份属于自己的坚持，是件令人高兴的事。心中有梦，就不怕前路茫茫。有所追求，心灵就不会迷失，不会沉沦。即使面对凄风冷雨，也会默默的坚持。有时候一种选择，就是一种力量。这种强大的支撑，让我们不惧怕冷言冷语，即使没人理解，也固执的给自己力量，告诉自己: 风雨过后，会有不一样的风景，风雨冲洗过的天空，空气更好。</p>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈感情】</title>
      <link>https://0808200.xyz/note/lifeDiary/emotion.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/emotion.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈感情】</source>
      <category>随笔</category>
      <pubDate>Fri, 07 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈感情】" tabindex="-1"> 笑谈人生【谈感情】</h1>
<p>并不是所有的感情都会久远，比如爱情，又比如友情。</p>
<p>有些人，也许从未想过会有交集，可是冥冥中注定的一样，就走在了一起；有些人，曾经同甘共苦、患难与共，一起走过了数年或数十年，却渐渐地淡却了。可能是双方同时的，也可能是有一方在先，而另一方自然就放弃了。回忆总是美好的，无论回忆里有哭、有笑，想起那些朋友，会由衷的觉得，生命中曾经有你，真好! 可是依然无法改变现实，有些人确实疏远了。</p>
<p>我相信，没有人会毫无原因就疏远谁，也更不会因为时间和距离刻意去忘记谁。冷漠的背后，必然有让人伤心的事，那些事无法轻易忘记。这样的决绝是否会让人费解，甚至会让人误解?</p>
<p>在生命的旅途中，一定会有一些人陪你走完某段路，然后各不相干，这就是所谓的过客。其实本来可以走得更远，只因为有的人没有珍惜，所以走向了分离。既然选择了不同的路，就要做好自己承担的准备。不会有那么一个人，永远的陪你走下去。你的路对了，错了，都与别人无关。不要怨天尤人，也不要埋怨谁舍你而去。一些人近了，一些人必然就远了。不要计较谁先转身，离开了谁。只要明白，你走了，就不会有人等你。爱情也好，友情也罢，顺其自然，不要强求。</p>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈亲情】</title>
      <link>https://0808200.xyz/note/lifeDiary/family.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/family.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈亲情】</source>
      <category>随笔</category>
      <pubDate>Tue, 04 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈亲情】" tabindex="-1"> 笑谈人生【谈亲情】</h1>
<div style="text-align: center"><p>成长中的亲情，</p>
<p>不像爱情那样多情，</p>
<p>不像友情那样述说，</p>
<p>却是最长久的感情。</p>
<p>我们每天</p>
<p>都在亲人的关怀下，</p>
<p>幸福的生活着。</p>
<p>♢</p>
<p>亲情，</p>
<p>不像爱情那样浓烈，</p>
<p>不像友情那样欢笑，</p>
<p>却能在平淡日子里</p>
<p>默默的温暖着我们，</p>
<p>平淡得</p>
<p>让我们有所忽略。</p>
<p>♢</p>
<p>青春年少的叛逆，</p>
<p>是我们最难回首的曾经，</p>
<p>是否还记得，</p>
<p>你因为父母的一声责骂就摔门而出，</p>
<p>许多天不说一句话；</p>
<p>是否还记得，</p>
<p>你出了远门，</p>
<p>好久也不打个电话回去，</p>
<p>父母是有多么的牵挂；</p>
<p>是否还记得，</p>
<p>你每次被人欺负，</p>
<p>父母是有多么的心疼?</p>
<p>♢</p>
<p>亲情，</p>
<p>虽然只占了生命的一部分，</p>
<p>只是一生中的一个片段，</p>
<p>但是，</p>
<p>他们确实是</p>
<p>值得一生去珍惜和留念的那些人。</p>
<p>那些渐渐老去的亲人，</p>
<p>那些渐渐模糊的背影，</p>
<p>是我们一生需要珍藏的最美时光。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈友情】</title>
      <link>https://0808200.xyz/note/lifeDiary/friendship.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/friendship.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈友情】</source>
      <category>随笔</category>
      <pubDate>Fri, 07 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈友情】" tabindex="-1"> 笑谈人生【谈友情】</h1>
<div style="text-align: center"><p>成长中的友情，</p>
<p>或许没有爱情那样一见倾心，</p>
<p>却是日久生情最好的写照。</p>
<p>也许爱情是眼泪，</p>
<p>友情是纸巾，</p>
<p>爱情是那个会让你流泪的东西，</p>
<p>而友情就是帮你擦泪的东西。</p>
<p>在如今高中的那些朋友，</p>
<p>是对整个人生影响最大的人群之一，</p>
<p>如今的我们不需也不应谈恋爱，</p>
<p>但我们必须会有一些朋友，</p>
<p>来充实自己的生活。</p>
<p>♢</p>
<p>你还记得吗?</p>
<p>当你考试失利，</p>
<p>萎靡不振的时候，</p>
<p>是谁在你耳边说些安慰的话，</p>
<p>帮你走出学习的压力；</p>
<p>当你感情受挫，</p>
<p>恋爱不顺的时候，</p>
<p>是谁充当你的心理导师，</p>
<p>帮你走出情感的阴影；</p>
<p>当你陷入流言蜚语，</p>
<p>遭遇他人误解的时候，</p>
<p>是谁不顾别人的冷眼，</p>
<p>帮你澄清难解的误会?</p>
<p>♢</p>
<p>友情，</p>
<p>像一股涓涓细流，</p>
<p>是一点一滴的累积起来的情感，</p>
<p>不会一涌而出，</p>
<p>却能在最需要的时候</p>
<p>给你一口救命的甘甜。</p>
<p>友情，就是这样。</p>
<p>你一路前行，</p>
<p>他一路跟随，</p>
<p>只要彼此相惜，</p>
<p>一定不会走丢。</p>
<p>我的朋友们，</p>
<p>一路上有你们，真好!</p>
<p>这份最美的时光，</p>
<p>我一定藏在心底。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈淡泊】</title>
      <link>https://0808200.xyz/note/lifeDiary/indifferent.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/indifferent.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈淡泊】</source>
      <category>随笔</category>
      <pubDate>Fri, 07 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈淡泊】" tabindex="-1"> 笑谈人生【谈淡泊】</h1>
<div style="text-align: center"><p>何为淡泊?</p>
<p>淡泊就是</p>
<p>对世间事洞明后的淡然，</p>
<p>不争，不辩，</p>
<p>不急，不燥，</p>
<p>以平常心态</p>
<p>去面对生活。</p>
<p>淡中出真味，</p>
<p>常中识英奇。</p>
<p>淡泊的人处事低调，</p>
<p>得也不喜，失也不悲。</p>
<p>淡泊的人，</p>
<p>是识尽愁滋味后的</p>
<p>不知愁滋味。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈生命】</title>
      <link>https://0808200.xyz/note/lifeDiary/life.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/life.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈生命】</source>
      <category>随笔</category>
      <pubDate>Tue, 04 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈生命】" tabindex="-1"> 笑谈人生【谈生命】</h1>
<div style="text-align: center"><p>生命的美丽，</p>
<p>永远展现在她无时无刻无处不在的进取中；</p>
<p>就像大树的美丽，</p>
<p>是展现在它负势向上高耸入云蓬勃生机中；</p>
<p>就像雄鹰的美丽，</p>
<p>是展现在它搏风击雨如苍天之魂的翱翔中；</p>
<p>就像江河的美丽，</p>
<p>是展现在它波涛汹涌承载船只的奔腾之中。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈爱情】</title>
      <link>https://0808200.xyz/note/lifeDiary/love.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/love.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈爱情】</source>
      <category>随笔</category>
      <pubDate>Fri, 07 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈爱情】" tabindex="-1"> 笑谈人生【谈爱情】</h1>
<div style="text-align: center"><p>成长中的爱情，</p>
<p>伴随着淡淡苦涩，</p>
<p>却是永远的珍藏。</p>
<p>没有人知道</p>
<p>什么时候的遇见是对的遇见，</p>
<p>什么时候遇到的人是对的人，</p>
<p>即使相爱的两人最终分开，</p>
<p>也只不过是命运</p>
<p>和我们说了一个幸福的谎言。</p>
<p>当这个谎言被戳破时，</p>
<p>每个人似乎都理性了一截，</p>
<p>这就是所谓的成长。</p>
<p>♢</p>
<p>初恋，</p>
<p>一直是很多人无法绕过的心结，</p>
<p>也是青春年少最深刻的记忆，</p>
<p>或许最初的恋爱给人们一个共识，</p>
<p>那是不掺带任何杂质的恋爱，</p>
<p>也是最纯净的爱情。</p>
<p>♢</p>
<p>喜欢的人不一定非要相交，</p>
<p>相交过后是远远的相离，</p>
<p>而相互平行，</p>
<p>却能看到彼此的生活轨迹，</p>
<p>默默的相望，</p>
<p>胜过一切千言万语。</p>
<p>逝去的爱情，</p>
<p>虽没能走到最后，</p>
<p>却是短短一生里的最美时光。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈纯真】</title>
      <link>https://0808200.xyz/note/lifeDiary/pure.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/pure.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈纯真】</source>
      <category>随笔</category>
      <pubDate>Mon, 03 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈纯真】" tabindex="-1"> 笑谈人生【谈纯真】</h1>
<div style="text-align: center"><p>我喜欢简单的人、简单的事，</p>
<p>傻傻的，</p>
<p>每天简简单单的过日子。</p>
<p>我也想像曾经那样，</p>
<p>几个人围在一起，</p>
<p>总有说不完的话，</p>
<p>不耍心计，</p>
<p>不挖苦，</p>
<p>不讽刺，</p>
<p>都真诚的去对待每一个人。</p>
<p>可是那逝去的时光，</p>
<p>真的能得以复返么?</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈路】</title>
      <link>https://0808200.xyz/note/lifeDiary/road.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/road.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈路】</source>
      <category>随笔</category>
      <pubDate>Wed, 31 Oct 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈路】" tabindex="-1"> 笑谈人生【谈路】</h1>
<p>人，不应该总选择轻松的路，而应该选择正确的道路，无论路途多么遥远，永远不要放弃，坚持走下去，肯定会有意想不到的风景。也许不在你本来想走的路上，也不是你本来想登临的山顶，可另一条路也有另一条路的风景，不同的山顶也一样会有美丽的日出，所以更多时候，不如试着静下心来，走上一条新路。</p>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈一步】</title>
      <link>https://0808200.xyz/note/lifeDiary/step.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/step.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈一步】</source>
      <category>随笔</category>
      <pubDate>Mon, 03 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈一步】" tabindex="-1"> 笑谈人生【谈一步】</h1>
<div style="text-align: center"><p>一步很短，一生很长。</p>
<p>一步近在脚下，一生漫远无边。</p>
<p>一步易于修饰，一生难于描画。</p>
<p>一步短暂瞬间，一生烛照永恒。</p>
<p>每一步都刻满一生的选择，</p>
<p>每一步都关及一生的希望，</p>
<p>每一步都镶了时间的密码，</p>
<p>每一步都相扣一生的成败。</p>
<p>走对一步人生会光明一片，</p>
<p>走错一步人生会惨淡黑暗。</p>
<p>关键时一步，决定着一生。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>笑谈人生【谈岁月】</title>
      <link>https://0808200.xyz/note/lifeDiary/year.html</link>
      <guid>https://0808200.xyz/note/lifeDiary/year.html</guid>
      <source url="https://0808200.xyz/rss.xml">笑谈人生【谈岁月】</source>
      <category>随笔</category>
      <pubDate>Tue, 04 Sep 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="笑谈人生【谈岁月】" tabindex="-1"> 笑谈人生【谈岁月】</h1>
<div style="text-align: center"><p>岁月，当真无情。</p>
<p>任凭沧海桑田，世事变迁，</p>
<p>它都冷眼旁观，</p>
<p>绝不会为任何一个人，</p>
<p>放慢脚步，停留驻足。</p>
<p>时光的流逝，</p>
<p>仿佛一双苍老又温柔的手，</p>
<p>不停的推着我们向前、再向前。</p>
<p>不论我们多么急于向前，</p>
<p>抑或渴望停留，</p>
<p>时间它都会不紧不慢，</p>
<p>遵循着它的轨迹与速度，</p>
<p>一刻不停地向前进行着。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>心情文章</title>
      <link>https://0808200.xyz/note/moodArticle/</link>
      <guid>https://0808200.xyz/note/moodArticle/</guid>
      <source url="https://0808200.xyz/rss.xml">心情文章</source>
      <description>介绍
风花雪月

</description>
      <category>随笔</category>
      <pubDate>Wed, 29 Jun 2022 10:08:18 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>介绍</p>
<p>风花雪月</p>
</div>

]]></content:encoded>
    </item>
    <item>
      <title>心情随笔</title>
      <link>https://0808200.xyz/note/moodEssay/</link>
      <guid>https://0808200.xyz/note/moodEssay/</guid>
      <source url="https://0808200.xyz/rss.xml">心情随笔</source>
      <description>介绍
春夏秋冬

</description>
      <category>随笔</category>
      <pubDate>Wed, 29 Jun 2022 10:08:18 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>介绍</p>
<p>春夏秋冬</p>
</div>

]]></content:encoded>
    </item>
    <item>
      <title>Googxh 介绍</title>
      <link>https://0808200.xyz/about/</link>
      <guid>https://0808200.xyz/about/</guid>
      <source url="https://0808200.xyz/rss.xml">Googxh 介绍</source>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<i>Content not supported</i>]]></content:encoded>
      <enclosure url="https://0808200.xyz/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>代码笔记</title>
      <link>https://0808200.xyz/code/</link>
      <guid>https://0808200.xyz/code/</guid>
      <source url="https://0808200.xyz/rss.xml">代码笔记</source>
      <description>此处存放一些代码笔记。
</description>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>此处存放一些代码笔记。</p>

<h2 id="目录" tabindex="-1"> 目录</h2>
<h3 id="基础" tabindex="-1"> 基础</h3>
<ul>
<li>
<p><a href="/code/basic/">基础知识</a></p>
</li>
<li>
<p><a href="/code/windows/">Windows 基础</a></p>
</li>
<li>
<p><a href="/code/github/">GitHub 介绍</a></p>
</li>
</ul>
<h3 id="前端开发" tabindex="-1"> 前端开发</h3>
<ul>
<li>
<p><a href="/code/website/">网站相关</a></p>
</li>
<li>
<p><a href="/code/vue/">Vue 相关</a></p>
</li>
<li>
<p><a href="/code/mini-app/">小程序教程</a></p>
</li>
<li>
<p><a href="/code/node-js/">Node.js</a></p>
</li>
</ul>
<h3 id="代码学习" tabindex="-1"> 代码学习</h3>
<ul>
<li>
<p><a href="/code/language/">代码学习</a></p>
</li>
<li>
<p><a href="/code/language/learning.html">如何学习一门语言</a></p>
</li>
<li>
<p><a href="/code/language/js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/python/">Python 教程</a> (编写中...)</p>
</li>
<li>
<p><a href="/code/language/markdown/">Markdown 教程</a></p>
</li>
<li>
<p><a href="/code/language/yaml/">YAML 教程</a></p>
</li>
<li>
<p><a href="/code/language/json/">JSON 教程</a></p>
</li>
</ul>
<h3 id="app" tabindex="-1"> APP</h3>
<ul>
<li><a href="/code/Android/">Android 开发</a></li>
</ul>
<h3 id="后端开发" tabindex="-1"> 后端开发</h3>
<ul>
<li><a href="/code/backEnd/">后端开发</a></li>
</ul>
<h3 id="代码学习网站" tabindex="-1"> 代码学习网站</h3>
<h3 id="优质网站" tabindex="-1"> 优质网站</h3>
<ul>
<li>
<p><a href="https://wangdoc.com/" target="_blank" rel="noopener noreferrer">网道</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener noreferrer">廖雪峰的网站</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div><p>相关信息</p>
<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>
</div>
</li>
</ul>
<h3 id="杂牌网站" tabindex="-1"> 杂牌网站</h3>
<ul>
<li>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn" target="_blank" rel="noopener noreferrer">w3cschool</a> <i>Content not supported</i> <i>Content not supported</i> <i>Content not supported</i></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener noreferrer">w3school</a> <i>Content not supported</i></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>APP 组件设计规范</title>
      <link>https://0808200.xyz/design/APP.html</link>
      <guid>https://0808200.xyz/design/APP.html</guid>
      <source url="https://0808200.xyz/rss.xml">APP 组件设计规范</source>
      <description>本文对应用程序设计中常见的组件及其作用进行了介绍。
</description>
      <category>设计</category>
      <pubDate>Sun, 24 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文对应用程序设计中常见的组件及其作用进行了介绍。</p>

<h2 id="页面总体布局" tabindex="-1"> 页面总体布局</h2>
<ul>
<li>
<h3 id="navigationbar" tabindex="-1"> navigationbar</h3>
<p>简称 Navbar 也就是导航栏。</p>
<p>主要负责承接页面的导航操作。</p>
<p>在内部界面上，一般左侧展示返回操作，居中显示页面标题，右侧展示更多操作。</p>
<p>在主页上，主要承载 tabpage 对应的功能展示与触发。</p>
<p>在 navbar 上，设计要突出质感，应该以简约为主。</p>
<p>使用不鲜明的颜色，可以使用 APP 或网页对的主体色。</p>
<p>可附以纯色 icon。</p>
<p>不能太吸睛导致用户对页面内容注意的分散。</p>
<p>有条件的情况下应该设计其切换动效。</p>
<p><img src="@source/design/assets/navbar1.jpg" alt="图片">
<img src="@source/design/assets/navbar2.jpg" alt="图片">
<img src="@source/design/assets/navbar3.jpg" alt="图片"></p>
</li>
</ul>
<p>好文推荐: <a href="https://www.jianshu.com/p/6037e4f79f4d" target="_blank" rel="noopener noreferrer">iOS 导航栏动效设计思路</a></p>
<ul>
<li>
<h3 id="tabbar" tabindex="-1"> Tabbar</h3>
<p>APP 打开后底部的操作栏叫 tabbar，一般设置 2-5 个模块，每个模块应该设计 logo 与文字，对应的界面叫 tabpage。</p>
<p>在 logo 上应以简约为主，应当设计设置点击与激活效果。</p>
<p>tabpage 的设置要慎重，分类展示 APP 最关键的几个分项设置，并在每个界面内展示具体内容。</p>
<p><img src="@source/design/assets/tab1.jpg" alt="图片">
<img src="@source/design/assets/tab2.jpg" alt="图片"></p>
</li>
</ul>
<h3 id="page" tabindex="-1"> Page</h3>
<p>App 每个页面的背景色，除了纯文章之外不应采用纯白色，设计可以向 APP 主题色靠拢。</p>
<p>应当针对不同设备造成的不同长宽比、分辨率设置不同的页面排版样式，并制作不同的 UI 布局。</p>
<p><img src="@source/design/assets/pc.png" alt="图片">
<img src="@source/design/assets/phone.png" alt="图片">
<img src="@source/design/assets/phone1.png" alt="图片">
<img src="@source/design/assets/phone2.png" alt="图片"></p>
<ul>
<li>
<h3 id="sider" tabindex="-1"> Sider</h3>
<p>侧边栏，可以设置侧边固定按钮点击弹出或者从左向右滑动弹出式。</p>
<p>一般用于承载不需要展示的一些设置项、介绍项、个人信息项。</p>
<p><img src="@source/design/assets/sider1.jpg" alt="图片">
<img src="@source/design/assets/sider2.png" alt="图片"></p>
</li>
</ul>
<h2 id="ui-元素" tabindex="-1"> UI 元素</h2>
<ul>
<li>
<h3 id="grid" tabindex="-1"> Grid</h3>
<p>九宫格结构，实际使用的时候 3×3、4×2 都有广泛使用。</p>
<p>Gird 结构主要用于罗列展示各项功能，或者是各项板块。</p>
<p>各元素应该以上部的圆形或异形图标于下部的说明文字为主。</p>
<p>在移动设备上一般不显示边框、不设计点击动效，而在 PC 与 HD 恰好相反。</p>
<p><img src="@source/design/assets/grid1.jpg" alt="图片">
<img src="@source/design/assets/grid2.jpg" alt="图片"></p>
</li>
<li>
<h3 id="menu" tabindex="-1"> Menu</h3>
<p>菜单有多种表现方式，比如 float menu、pop-up menu、modal menu、dropdown 等。</p>
</li>
<li>
<h3 id="其他元素可以参考ant-design" tabindex="-1"> 其他元素可以参考<a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener noreferrer">Ant-design</a></h3>
</li>
</ul>
<h2 id="杂项" tabindex="-1"> 杂项</h2>
<h3 id="mask-设计" tabindex="-1"> Mask 设计</h3>
<p>灰色的半透明遮罩叫 mask</p>
<p>当透明度很高，感受很小的时候一般设计成可穿透，也就是说点击相当于直接点击蒙层下部区域。</p>
<p>透明度中等的一般式可触摸做取消热区的，也就是点击会取消。</p>
<p>不可穿透的 mask，也就是说点击没有反应，一般要给非常高的不透明度，用户只能点叉号取消。(一般用于弹出推广)</p>
<h3 id="设计趋势" tabindex="-1"> 设计趋势</h3>
<p>目前以 iOS 特有的苹果风，Windows 上的 Aero 效果(毛玻璃效果)与安卓的 Material Design 设计为主。</p>
<h4 id="图标" tabindex="-1"> 图标</h4>
<p>常用实心矢量图标</p>
<h4 id="移动端" tabindex="-1"> 移动端</h4>
<p>分割线和边框目前采用已经比较少。</p>
<h4 id="pc" tabindex="-1"> PC</h4>
<p>增强鼠标移动与网页的交互带来沉浸式的体验。</p>
<h4 id="突出质感" tabindex="-1"> 突出质感</h4>
<p>因为不同机型现实效果不一样，普遍采用圆角、阴影、以及毛玻璃效果，还有避免用纯色背景转而用略蓝略灰的色调突出质感。</p>
<h4 id="增强反馈感" tabindex="-1"> 增强反馈感</h4>
<p>每次点击时和点击之后出发的效果都能在屏幕上让用户感知自己的操作(即我刚刚点了按钮，按钮生效产生了某种操作)</p>
]]></content:encoded>
    </item>
    <item>
      <title>UI 设计</title>
      <link>https://0808200.xyz/design/</link>
      <guid>https://0808200.xyz/design/</guid>
      <source url="https://0808200.xyz/rss.xml">UI 设计</source>
      <description>本文列出了一些 UI 设计相关的资源。
</description>
      <category>设计</category>
      <pubDate>Sun, 24 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文列出了一些 UI 设计相关的资源。</p>

<h2 id="相关教程" tabindex="-1"> 相关教程</h2>
<ul>
<li>
<p><a href="/design/icon/">图标设计教程</a></p>
</li>
<li>
<p><a href="/design/navigation/">导航设计教程</a></p>
</li>
</ul>
<h2 id="配色" tabindex="-1"> 配色</h2>
<ul>
<li>
<p><a href="http://www.ruanyifeng.com/blog/2019/03/coloring-scheme.html" target="_blank" rel="noopener noreferrer">阮一峰 - 配色方案</a></p>
</li>
<li>
<p><a href="https://webgradients.com/" target="_blank" rel="noopener noreferrer">网页背景渐变色</a></p>
</li>
</ul>
<h2 id="设计" tabindex="-1"> 设计</h2>
<ul>
<li>
<p><a href="https://developer.apple.com/design/tips/" target="_blank" rel="noopener noreferrer">Apple 设计原则</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/design/" target="_blank" rel="noopener noreferrer">Apple 设计</a></p>
</li>
<li>
<p><a href="/design/APP.html">App 组件设计规范</a></p>
</li>
</ul>
<h2 id="网站组件" tabindex="-1"> 网站组件</h2>
<ul>
<li>
<p><a href="https://ant.design/index-cn" target="_blank" rel="noopener noreferrer">Ant Design</a></p>
</li>
<li>
<p><a href="https://weui.io/" target="_blank" rel="noopener noreferrer">WeUI</a></p>
</li>
</ul>
<h2 id="小程序组件库" tabindex="-1"> 小程序组件库</h2>
<ul>
<li>
<p><a href="https://youzan.github.io/vant-weapp/" target="_blank" rel="noopener noreferrer">Vant</a></p>
</li>
<li>
<p><a href="https://www.color-ui.com/" target="_blank" rel="noopener noreferrer">Color UI</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>机械硬盘</title>
      <link>https://0808200.xyz/hardware/HDD.html</link>
      <guid>https://0808200.xyz/hardware/HDD.html</guid>
      <source url="https://0808200.xyz/rss.xml">机械硬盘</source>
      <category>硬件</category>
      <pubDate>Fri, 05 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>现代计算机大部分文件存储功能都是由机械硬盘这种设备提供的。(现在的 SSD 和闪存从概念和逻辑上都部分继承自机械硬盘，所以使用机械硬盘来进行理解也是没有问题的)</p>
<p>机械硬盘能实现信息存储的功能基于: 磁性存储介质能够被磁化，且磁化后会长久保留被磁化的状态，这种被磁化状态能够被读取出来，同时这种磁化状态还能够不断被修改，磁化正好有两个方向，所以可以表示 0 和 1。
于是硬盘就是把这种磁性存储介质做成一个个盘片，每一个盘片上都分布着数量巨大的磁性存储单位，使用磁性读写头对盘片进行写入和读取(从原理上类似黑胶唱片的播放)。</p>
<p>一个硬盘中的磁性存储单位数以亿计(1T 硬盘就有约 80 亿个)，所以需要一套规则来规划信息如何存取(比如一本存储信息的书我们还会分为页，每一页从上到下从左到右读取，同时还有章节目录)
于是就有了这些物理、逻辑概念:</p>
<ol>
<li>
<p>一个硬盘有多张盘片叠成，不同盘片有编号</p>
</li>
<li>
<p>每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号</p>
</li>
<li>
<p>每条磁道上都有一圈存储颗粒，每 512 * 8(512 字节，0.5KB)个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位</p>
</li>
<li>
<p>N 个扇区可以组成簇，N 取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位</p>
</li>
<li>
<p>所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位</p>
</li>
</ol>
<p>磁头读写文件的时候，首先是分区读写的，由 inode 编号(区内唯一的编号)找到对应的磁道和扇区，然后一个柱面一个柱面地进行读写。机械硬盘的读写控制系统是一个令人叹为观止的精密工程(一个盘面上有几亿个存储单位，每个磁道宽度不到几十纳米，磁盘每分钟上万转)，同时关于读写的逻辑也是有诸多细节(比如扇区的编号并不是连续的)，非常有意思，可以自行搜索文章拓展阅读。</p>
]]></content:encoded>
    </item>
    <item>
      <title>硬件相关</title>
      <link>https://0808200.xyz/hardware/</link>
      <guid>https://0808200.xyz/hardware/</guid>
      <source url="https://0808200.xyz/rss.xml">硬件相关</source>
      <description> 硬件相关
这里是一些常见的硬件相关的问题总结，供访客查阅。
</description>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="硬件相关" tabindex="-1"> 硬件相关</h1>
<p>这里是一些常见的硬件相关的问题总结，供访客查阅。</p>

]]></content:encoded>
    </item>
    <item>
      <title>CPU 的架构</title>
      <link>https://0808200.xyz/hardware/structure.html</link>
      <guid>https://0808200.xyz/hardware/structure.html</guid>
      <source url="https://0808200.xyz/rss.xml">CPU 的架构</source>
      <category>硬件</category>
      <pubDate>Fri, 05 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>CPU 内部已经含有一些微指令，我们所使用的软件都要经过 CPU 内部的微指令集来达成才行。那这些指令集的设计主要又被分为两种设计理念，这就是目前世界上常见到的两种主要 CPU 架构，分别是: 精简指令集(RISC)与复杂指令集(CISC) 系统。</p>
<h2 id="精简指令集" tabindex="-1"> 精简指令集</h2>
<p>精简指令集，(Reduced Instruction Set Computer, RISC) 的设计中，微指令集较为精简。每个指令的执行时间都很短，完成的动作也很单纯，指令的执行性能较佳；但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC 微指令集 CPU 主要例如甲骨文(Oracle) 公司的 SPARC 系列、IBM 公司的 Power Architecture (包括 PowerPC) 系列、与 ARM 公司(ARM Holdings) 的 ARM CPU 系列等。</p>
<p>在应用方面，SPARC CPU 的电脑常用于学术领域的大型工作站中，包括银行金融体系的主要伺服器也都有这类的电脑架构；至于 PowerPC 架构的应用上，例如索尼(Sony)公司出产的 Play Station 3(PS3)就是使用 PowerPC 架构的 Cell 处理器；那 ARM 的 ARM 呢? 您常使用的各厂牌手机、PDA、导航系统、网络设备(交换器、路由器等)等，几乎都是使用 ARM 架构的 CPU。目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构。</p>
<h2 id="复杂指令集" tabindex="-1"> 复杂指令集</h2>
<p>复杂指令集，(Complex Instruction Set Computer, CISC)。与 RISC 不同的，CISC 在微指令集的每个小指令可以执行一些较低阶的硬体操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86 架构的 CPU。</p>
<p>由于 AMD、Intel、VIA 所开发出来的 x86 架构 CPU 被大量使用于个人电脑(Personal computer)用途上面，因此，个人电脑常被称为 x86 架构的电脑! 那为何称为 x86 架构呢? 这是因为最早的那颗 Intel 发展出来的 CPU 代号称为 8086，后来依此架构又开发出 80286, 80386...，因此这种架构的 CPU 就被称为 x86 架构了。</p>
<p>在 2003 年以前由 Intel 所开发的 x86 架构 CPU 由 8 位数升级到 16、32 位数，后来 AMD 依此架构修改新一代的 CPU 为 64 位数， 为了区别两者的差异，因此 64 位数的个人电脑 CPU 又被统称为 x86_64 的架构。</p>
<div><p>提示</p>
<p>所谓的位数指的是 CPU 一次资料读取的最大量! 64 位数 CPU 代表 CPU 一次可以读写 64bits 这么多的资料，32 位数 CPU 则是 CPU 一次只能读取 32 位数的意思。因为 CPU 读取资料量有限制，因此能够从记忆体中读写的资料也就有所限制。所以，一般 32 位数的 CPU 所能读写的最大资料量是 4GB。</p>
</div>
<p>那么不同的 x86 架构的 CPU 有什么差异呢? 除了 CPU 的整体结构(如第二层快取、每次运行可执行的指令数等)之外， 主要是在于微指令集的不同。新的 x86 的 CPU 大多含有很先进的微指令集， 这些微指令集可以加速多媒体程序的运行，也能够加强虚拟化的性能，而且某些微指令集更能够增加能源效率，降低 CPU 耗电量。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux</title>
      <link>https://0808200.xyz/linux/</link>
      <guid>https://0808200.xyz/linux/</guid>
      <source url="https://0808200.xyz/rss.xml">Linux</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="linux-教程" tabindex="-1"> Linux 教程</h2>
<ul>
<li>
<p><a href="/linux/intro/">Linux 介绍</a></p>
<ul>
<li>
<p><a href="/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/linux/file/">Linux 文件</a></p>
<ul>
<li>
<p><a href="/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="/linux/file/mount.html">挂载</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/linux/command/">Linux 命令</a></p>
<ul>
<li>
<p><a href="/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="ubuntu" tabindex="-1"> ubuntu</h2>
<ul>
<li><a href="/linux/ubuntu/">点击前往</a></li>
</ul>
<h2 id="centos" tabindex="-1"> CentOS</h2>
<ul>
<li><a href="/linux/centos.html">点击前往</a></li>
</ul>
<h2 id="wsl" tabindex="-1"> WSL</h2>
<ul>
<li><a href="/linux/WSL.html">点击前往</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>WSL</title>
      <link>https://0808200.xyz/linux/WSL.html</link>
      <guid>https://0808200.xyz/linux/WSL.html</guid>
      <source url="https://0808200.xyz/rss.xml">WSL</source>
      <description>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。
</description>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>

<h2 id="ubuntu" tabindex="-1"> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2 id="wsl-文件位置" tabindex="-1"> WSL 文件位置</h2>
<div><pre><code>C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="重启-wsl" tabindex="-1"> 重启 WSL</h2>
<p>使用</p>
<div><pre><code>net stop LxssManager
</code></pre><div aria-hidden="true"><div></div></div></div><p>和</p>
<div><pre><code>net start LxssManager
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CentOS 教程</title>
      <link>https://0808200.xyz/linux/centos.html</link>
      <guid>https://0808200.xyz/linux/centos.html</guid>
      <source url="https://0808200.xyz/rss.xml">CentOS 教程</source>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="管理工具" tabindex="-1"> 管理工具</h2>
<ul>
<li>yum (Centos 7)</li>
<li>dnf (Centos 8)</li>
</ul>
<h2 id="yarn" tabindex="-1"> yarn</h2>
<div><pre><code><span>curl</span> --silent --location https://dl.yarnpkg.com/rpm/yarn.repo <span>|</span> <span>sudo</span> <span>tee</span> /etc/yum.repos.d/yarn.repo

<span>sudo</span> yum <span>install</span> <span>yarn</span>
<span>## OR ##</span>
<span>sudo</span> dnf <span>install</span> <span>yarn</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ssh</title>
      <link>https://0808200.xyz/linux/ssh.html</link>
      <guid>https://0808200.xyz/linux/ssh.html</guid>
      <source url="https://0808200.xyz/rss.xml">ssh</source>
      <category>基础</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用密码登录" tabindex="-1"> 使用密码登录</h2>
<ol>
<li>
<p>执行以下命令，连接 Linux 云服务器。</p>
<div><pre><code><span>ssh</span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
</li>
<li>
<p>输入已获取的密码，按 Enter，即可完成登录。</p>
</li>
</ol>
<h2 id="使用密钥登录" tabindex="-1"> 使用密钥登录</h2>
<ol>
<li>
<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>
<div><pre><code><span>chmod</span> <span>400</span> <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>执行以下命令，进行远程登录。</p>
<div><pre><code><span>ssh</span> -i <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
<p>例如，执行 <code>ssh -i &quot;id_rsa&quot; ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>
</li>
</ol>
<h2 id="断开链接" tabindex="-1"> 断开链接</h2>
<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>微分方程</title>
      <link>https://0808200.xyz/math/differential-equation.html</link>
      <guid>https://0808200.xyz/math/differential-equation.html</guid>
      <source url="https://0808200.xyz/rss.xml">微分方程</source>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="概念" tabindex="-1"> 概念</h2>
<ul>
<li>
<p>微分方程表示未知函数，未知函数的导数与自变量之间的关系的方程。</p>
</li>
<li>
<p>阶: 未知函数的最高阶的导数叫阶数</p>
</li>
<li>
<p>一般形式: <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.138em;vertical-align:-0.25em;"></span><span style="margin-right:0.13889em;">F</span><span>(</span><span>x</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span>…</span><span style="margin-right:0.1667em;"></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>(</span><span>n</span><span>)</span></span></span></span></span></span></span></span></span><span>)</span></span></span></span></p>
<p>如果最高阶导数可以被解出，则有 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0824em;vertical-align:-0.1944em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>(</span><span>n</span><span>)</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1.138em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span>…</span><span style="margin-right:0.1667em;"></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>(</span><span>n</span><span>−</span><span>1</span><span>)</span></span></span></span></span></span></span></span></span><span>)</span></span></span></span></p>
</li>
<li>
<p>解: 找到令方程变为恒等式的函数</p>
</li>
<li>
<p>通解: 解中含有任意常数，且常数的个数与阶数相同</p>
</li>
<li>
<p>初值条件: 给出特定 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>x</span></span></span></span> 下， <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0824em;vertical-align:-0.1944em;"></span><span style="margin-right:0.03588em;">y</span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span>…</span><span style="margin-right:0.1667em;"></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>(</span><span>n</span><span>)</span></span></span></span></span></span></span></span></span></span></span></span> 的值，此时求出的解为该条件下的特解。</p>
</li>
<li>
<p>可分离变量: 形如 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03588em;">g</span><span>(</span><span style="margin-right:0.03588em;">y</span><span>)</span><span>d</span><span style="margin-right:0.03588em;">y</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span><span>d</span><span>x</span></span></span></span> 的形式</p>
<p>如果 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span></span></span></span>, <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03588em;">g</span><span>(</span><span style="margin-right:0.03588em;">y</span><span>)</span></span></span></span> 连续，且有 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03588em;">g</span><span>(</span><span style="margin-right:0.03588em;">y</span><span>)</span><span style="margin-right:0.2778em;"></span><span><span><span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span><span><span></span></span></span><span></span></span></span></span></span></span><span><span style="height:0.3669em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>，则可以积分出 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>G</span><span>(</span><span style="margin-right:0.03588em;">y</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.13889em;">F</span><span>(</span><span>x</span><span>)</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6833em;"></span><span style="margin-right:0.07153em;">C</span></span></span></span></p>
<p>令 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>Φ</span><span>(</span><span>x</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.526em;vertical-align:-0.936em;"></span><span><span></span><span><span><span><span style="height:1.59em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span>G</span><span><span><span><span style="height:0.6779em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>(</span><span style="margin-right:0.03588em;">y</span><span>)</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.13889em;">F</span><span><span><span><span style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>(</span><span>x</span><span>)</span></span></span></span><span>​</span></span><span><span style="height:0.936em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.526em;vertical-align:-0.936em;"></span><span><span></span><span><span><span><span style="height:1.59em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">g</span><span>(</span><span style="margin-right:0.03588em;">y</span><span>)</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span style="height:3em;"></span><span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span></span></span></span><span>​</span></span><span><span style="height:0.936em;"><span></span></span></span></span></span><span></span></span></span></span></span>，则 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span style="margin-right:0.03588em;">y</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>Φ</span><span>(</span><span>x</span><span>)</span></span></span></span> 即为通解。</p>
</li>
<li>
<p>齐次方程: 可化为</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Mr.Googxh 的随笔</title>
      <link>https://0808200.xyz/note/</link>
      <guid>https://0808200.xyz/note/</guid>
      <source url="https://0808200.xyz/rss.xml">Mr.Googxh 的随笔</source>
      <category>随笔</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里是一些随笔。</p>
<h2 id="心情随笔" tabindex="-1"> 心情随笔</h2>
<div><p>介绍</p>
<p>随笔</p>
</div>
<h2 id="心情文章" tabindex="-1"> 心情文章</h2>
<div><p>介绍</p>
<p>文章</p>
</div>
<h2 id="生活日记" tabindex="-1"> 生活日记</h2>
<div><p>介绍</p>
<p>日记</p>
</div>
<h2 id="人生感悟" tabindex="-1"> 人生感悟</h2>
<div><p>介绍</p>
<p>感悟</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>软件教程</title>
      <link>https://0808200.xyz/software/</link>
      <guid>https://0808200.xyz/software/</guid>
      <source url="https://0808200.xyz/rss.xml">软件教程</source>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="代码编辑器" tabindex="-1"> 代码编辑器</h2>
<ul>
<li><a href="/software/editor.html">编辑器介绍</a></li>
</ul>
<h2 id="团队协作" tabindex="-1"> 团队协作</h2>
<p>开发项目的代码版本管理以及多人协作使用 Git 软件</p>
<ul>
<li>
<p><a href="/software/git/">Git 教程</a></p>
</li>
<li>
<p><a href="/code/github/">GitHub 介绍</a></p>
</li>
</ul>
<h2 id="浏览器" tabindex="-1"> 浏览器</h2>
<p>在开发中，调试网页推荐使用 Chrome。</p>
<ul>
<li><a href="/software/chrome.html">Chrome 介绍</a></li>
</ul>
<h2 id="后端" tabindex="-1"> 后端</h2>
<h3 id="http-server" tabindex="-1"> Http Server</h3>
<p>网站已经停止使用 Apache Lounge 编译的 httpd Apache。目前迁移到更加轻量，并发性能更好的 Nginx 上。</p>
<ul>
<li>
<p><a href="/software/apache.html">Apache</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/software/nginx.html">Nginx</a></p>
</li>
</ul>
<h3 id="抓包与-api-调试" tabindex="-1"> 抓包与 API 调试</h3>
<ul>
<li><a href="/software/postman.html">Postman</a></li>
</ul>
<h2 id="工具软件" tabindex="-1"> 工具软件</h2>
<ul>
<li><a href="/software/tool/">查看详情</a></li>
</ul>
<h2 id="手机-app" tabindex="-1"> 手机 APP</h2>
<h3 id="sololearn" tabindex="-1"> soloLearn</h3>
<p>一个代码在线学习社区，只有英文版。由于代码语义贴近英文原生逻辑，十分建议在编辑代码时 “think in English”。</p>
<p>软件中的 code playground 可以在线运行大部分代码，大家在手机上就可以进行练习与尝试。</p>
<h2 id="adobe-软件" tabindex="-1"> Adobe 软件</h2>
<p>Adobe 全系软件的获取，请见 <a href="https://www.weibo.com/vposy" target="_blank" rel="noopener noreferrer">vposy 的微博</a> 的置顶帖。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Apache</title>
      <link>https://0808200.xyz/software/apache.html</link>
      <guid>https://0808200.xyz/software/apache.html</guid>
      <source url="https://0808200.xyz/rss.xml">Apache</source>
      <description>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。
</description>
      <category>服务器</category>
      <pubDate>Thu, 12 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。</p>

<h2 id="apache-是什么" tabindex="-1"> Apache 是什么</h2>
<p>Apache HTTP Server (简称 Apache )是 Apache 软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。</p>
<p>Apache HTTP 服务器是一个模块化的服务器，源于 NCSAhttpd 服务器，经过多次修改，成为世界使用排名第一的 Web 服务器软件。
它可以运行在几乎所有广泛使用的计算机平台上。</p>
<h2 id="apache-模块" tabindex="-1"> Apache 模块</h2>
<p>Apache 通过引入各种模块来完成不同的功能。</p>
<h2 id="apache-官方文档" tabindex="-1"> Apache 官方文档</h2>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/zh-cn/" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<h2 id="apache-配置" tabindex="-1"> Apache 配置</h2>
<p>Apache 通过 conf 文件夹下的 httpd.conf 来配置。</p>
<div><pre><code><span># 此处填入 Apache 的路径</span>
<span>Define</span> SRVROOT <span>"U:/Apache"</span>
<span>ServerRoot</span> <span>"<span>${SRVROOT}</span>"</span>
<span>Listen</span> 127.0.0.1:80
<span>Listen</span> 127.0.0.1:443

<span>LoadModule</span> auth_basic_module modules/mod_auth_basic.so
<span>LoadModule</span> authz_core_module modules/mod_authz_core.so
<span>LoadModule</span> deflate_module modules/mod_deflate.so
<span>LoadModule</span> dir_module modules/mod_dir.so
<span>LoadModule</span> env_module modules/mod_env.so
<span>LoadModule</span> isapi_module modules/mod_isapi.so
<span>LoadModule</span> log_config_module modules/mod_log_config.so
<span>LoadModule</span> mime_module modules/mod_mime.so
<span>LoadModule</span> negotiation_module modules/mod_negotiation.so
<span>LoadModule</span> proxy_http2_module modules/mod_proxy_http2.so
<span>LoadModule</span> ratelimit_module modules/mod_ratelimit.so
<span>LoadModule</span> rewrite_module modules/mod_rewrite.so
<span>LoadModule</span> setenvif_module modules/mod_setenvif.so
<span>LoadModule</span> ssl_module modules/mod_ssl.so
<span># 此处填入 PHP 的 ssh 组件路径</span>
<span>LoadFile</span> <span>"u:/php/libssh2.dll"</span>
<span># 此处填入 PHP 的 Apache 组件路径</span>
<span>LoadModule</span> php7_module <span>"u:/PHP/php7apache2_4.dll"</span>
<span># 此处填入 PHP 的路径</span>
PHPIniDir <span>"u:/PHP"</span>

<span><span><span>&lt;</span>IfModule</span><span> unixd_module</span><span>></span></span>
<span>User</span> daemon
<span>Group</span> daemon
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span>ServerAdmin</span> mister-hope@outlook.com
<span>ServerName</span> localhost

<span><span><span>&lt;</span>Directory</span><span> /</span><span>></span></span>
  <span>AllowOverride</span> none
  <span>Require</span> all denied
<span><span><span>&lt;/</span>Directory</span><span>></span></span>

<span>DocumentRoot</span> <span>"<span>${SRVROOT}</span>/htdocs"</span>
<span><span><span>&lt;</span>Directory</span><span> <span>"<span>${SRVROOT}</span>/htdocs"</span></span><span>></span></span>
  <span>Options</span> FollowSymLinks
  <span>AllowOverride</span> All
  <span>Require</span> all granted
<span><span><span>&lt;/</span>Directory</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> dir_module</span><span>></span></span>
  <span>DirectoryIndex</span> index.html index.php
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>Files</span><span> <span>".ht*"</span></span><span>></span></span>
  <span>Require</span> all denied
<span><span><span>&lt;/</span>Files</span><span>></span></span>

<span>ErrorLog</span> <span>"logs/error.log"</span>
<span>LogLevel</span> info

<span><span><span>&lt;</span>IfModule</span><span> log_config_module</span><span>></span></span>
  <span>LogFormat</span> <span>"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \"<span>%r</span>\" %>s <span>%b</span> \"<span>%{Referer}</span>i\" \"<span>%{User-Agent}</span>i\""</span> combined
  <span>LogFormat</span> <span>"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \"<span>%r</span>\" %>s <span>%b</span>"</span> common
  <span><span><span>&lt;</span>IfModule</span><span> logio_module</span><span>></span></span>
    <span>LogFormat</span> <span>"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \"<span>%r</span>\" %>s <span>%b</span> \"<span>%{Referer}</span>i\" \"<span>%{User-Agent}</span>i\" <span>%I</span> <span>%O</span>"</span> combinedio
  <span><span><span>&lt;/</span>IfModule</span><span>></span></span>
  <span>CustomLog</span> <span>"logs/access.log"</span> common
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> alias_module</span><span>></span></span>
  <span>ScriptAlias</span> /cgi-bin/ <span>"<span>${SRVROOT}</span>/cgi-bin/"</span>
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>Directory</span><span> <span>"<span>${SRVROOT}</span>/cgi-bin"</span></span><span>></span></span>
  <span>AllowOverride</span> None
  <span>Options</span> None
  <span>Require</span> all granted
<span><span><span>&lt;/</span>Directory</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> headers_module</span><span>></span></span>
  <span>RequestHeader</span> unset Proxy early
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> mime_module</span><span>></span></span>
  <span>TypesConfig</span> conf/mime.types
  <span>AddHandler</span> application/x-httpd-php .php
  <span>AddType</span> application/x-compress .Z
  <span>AddType</span> application/x-gzip .gz .tgz
  <span>AddType</span> application/x-httpd-php .php .html
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> proxy_html_module</span><span>></span></span>
  <span>Include</span> conf/extra/proxy-html.conf
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>
<span><span><span>&lt;</span>IfModule</span><span> ssl_module</span><span>></span></span>
  <span>SSLRandomSeed</span> startup builtin
  <span>SSLRandomSeed</span> connect builtin
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>VirtualHost</span><span> *<span>:</span>80</span><span>></span></span>
  <span>ServerAdmin</span> mister-hope@outlook.com
  <span>ServerName</span> nenu.com
  <span>ServerAlias</span> innenu
  <span>DocumentRoot</span> <span>"<span>${SRVROOT}</span>/htdocs"</span>
<span><span><span>&lt;/</span>VirtualHost</span><span>></span></span>

<span><span><span>&lt;</span>VirtualHost</span><span> *<span>:</span>443</span><span>></span></span>
  <span>ServerAdmin</span> mister-hope@outlook.com
  <span>ServerName</span> mrhope.com
  <span>ServerAlias</span> mrhope
  <span>DocumentRoot</span> <span>"<span>${SRVROOT}</span>/htdocs"</span>
<span><span><span>&lt;/</span>VirtualHost</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<h3 id="serverroot" tabindex="-1"> ServerRoot</h3>
<p>指定服务器的根目录</p>
</li>
<li>
<h3 id="listen" tabindex="-1"> Listen</h3>
<p>指定服务器监听的 IP 与 port</p>
</li>
<li>
<h3 id="loadmodule" tabindex="-1"> LoadModule</h3>
<p>加载指定的模块来使服务器调用</p>
</li>
<li>
<h3 id="phpinidir" tabindex="-1"> PHPIniDir</h3>
<p>指定 PHP 目录</p>
</li>
<li>
<h3 id="unixd-module" tabindex="-1"> unixd_module</h3>
<p>分配用户权限</p>
</li>
<li>
<h3 id="serveradmin" tabindex="-1"> ServerAdmin</h3>
<p>服务器管理员</p>
</li>
<li>
<h3 id="servername" tabindex="-1"> ServerName</h3>
<p>服务器名称</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Chrome</title>
      <link>https://0808200.xyz/software/chrome.html</link>
      <guid>https://0808200.xyz/software/chrome.html</guid>
      <source url="https://0808200.xyz/rss.xml">Chrome</source>
      <description>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。
</description>
      <category>软件</category>
      <pubDate>Fri, 13 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Chrome 如今可以说是一家独大。很多国内浏览器都是基于 Chromium 内核的套壳浏览器。</p>
<p>Chrome 内核更新频繁，速度和安全性高，对新特性支持非常良好。另外谷歌具有十分强大的开发者工具，是前端开发使用的首选浏览器。目前最新的版本是 85。</p>
<h2 id="配置" tabindex="-1"> 配置</h2>
<p>由于 Chrome 是谷歌出品的浏览器，所以搜索栏默认使用 Google 搜索，而在中国无法访问 Google 服务，所以需要在右上角的菜单中选择设置，在搜索引擎设置中改为百度即可正常使用。</p>
<p><img src="@source/software/assets/searchEngine.png" alt="更改页面"></p>
<h2 id="快捷键" tabindex="-1"> 快捷键</h2>
<p>Chrome 具有很多快捷键，熟练掌握后可以大幅减少时间。</p>
<ul>
<li><code>Ctrl + J</code>: 打开下载页面；</li>
<li><code>Ctrl + H</code>: 打开历史页面；</li>
<li><code>Ctrl + T</code>: 打开新标签页；</li>
<li><code>Ctrl + Shift + T</code>: 恢复上一个关闭的标签页；</li>
<li><code>Ctrl + N</code>: 打开新的窗口；</li>
<li><code>Ctrl + W</code>: 关闭当前标签页；</li>
<li><code>Ctrl + Tab</code>: 切换标签页；</li>
<li><code>Ctrl + Shift + Tab</code>: 反向切换标签页；</li>
<li><code>Ctrl + F</code>: 反向切换标签页；</li>
<li><code>Ctrl + Shift + I</code> 或 <code>F12</code>: 打开开发者工具；</li>
</ul>
<h2 id="开发者工具" tabindex="-1"> 开发者工具</h2>
<p><img src="@source/software/assets/devTool.png" alt="开发者工具"></p>
<p>使用 <code>Ctrl + Shift + I</code> 或 <code>F12</code> 即可打开开发者工具，在开发者工具里，您可以自由的对任何网页进行调试。</p>
<h2 id="chrome-推荐扩展" tabindex="-1"> Chrome 推荐扩展</h2>
<ul>
<li>AdGuard: 广告屏蔽；</li>
<li>Adobe Acrobat: 将当前网页转为 Adobe PDF 文件；</li>
<li>Betternet Unlimited Free VPN Proxy: 免费的 VPN 代理；</li>
<li>Checker Plus for Gmail™: Gmail 邮件管理；</li>
<li>Convertio: 非常强大的文件在线转换；</li>
<li>Dark Reader: 为网页启用夜间模式；</li>
<li>Enhanced GitHub: 能够展示仓库大小，文件大小和快速下载按钮；</li>
<li>Evernote Web Clipper: 印象笔记剪藏，非常好用的保存工具；</li>
<li>Google 翻译: 谷歌翻译软件；</li>
<li>ImTranslator: 翻译，字典，声音</li>
<li>Infinity: 一款非常好的标签页软件；</li>
<li>Office Online: 在线查看并编辑 Office 文件；</li>
<li>React Developer Tools: React 开发者工具</li>
<li>Save to Pocket: 离线网页的最佳插件；</li>
<li>VPN Free - Betternet Unlimited VPN Proxy: 一款免费的 VPN 插件；</li>
<li>Vue.js Devtools: Vue.js 的开发者工具；</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>代码编辑器</title>
      <link>https://0808200.xyz/software/editor.html</link>
      <guid>https://0808200.xyz/software/editor.html</guid>
      <source url="https://0808200.xyz/rss.xml">代码编辑器</source>
      <category>软件</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>
<p><a href="/software/vscode/">VS Code</a></p>
<p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。</p>
<p>VS Code 具有最大的编辑器社区，插件是所有编辑器里最全的。可以通过安装扩展实现几乎所有的功能，但扩展设置界面对新手不够友好，适合有一定经验的开发者。</p>
<div><p>提示</p>
<p>推荐使用轻量的 Visual Studio Code。</p>
</div>
</li>
<li>
<p>其他代码编辑器</p>
<p>在不同领域的开发者可能会偏向不同种类的开发工具。下面列举其他常见的代码编辑器。</p>
<ul>
<li>WebStorm 是专业的 web 开发工具，提供格式化、代码补全等选项。</li>
<li>PhpStorm 是专业的 php 开发工具，提供格式化、代码补全等选项。</li>
<li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener noreferrer">notepad++</a></li>
<li><a href="https://atom.io/" target="_blank" rel="noopener noreferrer">atom</a></li>
<li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener noreferrer">sublime text</a></li>
</ul>
</li>
</ul>
<div><p>IDE 与编辑器</p>
<p>IDE 和编辑器是有区别的:</p>
<ul>
<li>
<p>IDE: 对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</p>
</li>
<li>
<p>编辑器: 要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</p>
</li>
</ul>
<p>需要注意的是，VS Code 的定位是编辑器，而非 IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://0808200.xyz/software/nginx.html</link>
      <guid>https://0808200.xyz/software/nginx.html</guid>
      <source url="https://0808200.xyz/rss.xml">Nginx</source>
      <description>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。
</description>
      <category>服务器</category>
      <pubDate>Fri, 13 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>

<h2 id="启动-停止和重新加载配置" tabindex="-1"> 启动，停止和重新加载配置</h2>
<p>要启动 nginx，请运行可执行文件。一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>
<div><pre><code>nginx -s signal
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中 <code>signal</code> 可能是以下之一:</p>
<ul>
<li>stop - 快速关机</li>
<li>quit — 正常关机</li>
<li>reload — 重新加载配置文件</li>
<li>reopen — 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构" tabindex="-1"> 配置文件的结构</h2>
<p>Nginx 由受配置文件中指定的指令控制的模块组成。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>
<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。<code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>
<p><code>#</code> 号后的其余行被视为注释。</p>
<h2 id="提供静态内容" tabindex="-1"> 提供静态内容</h2>
<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>
<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 <code>index.html</code> 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>
<p>接下来，打开配置文件。默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。现在，注释掉所有这些块并启动一个新的服务器块:</p>
<div><pre><code><span><span>http</span></span> <span>{</span>
  <span><span>server</span></span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>
<p>将以下位置块添加到服务器块:</p>
<div><pre><code><span><span>location</span> /</span> <span>{</span>
  <span><span>root</span> /data/www</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>
<p>接下来，添加第二个位置块:</p>
<div><pre><code><span><span>location</span> /images/</span> <span>{</span>
  <span><span>root</span> /data</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>
<p>服务器块的最终配置应如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>root</span> /data/www</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。如果该文件不存在，nginx 将发送一个注明 404 错误的响应。URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>
<p>要应用新配置，请启动 nginx (如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code> 信号:</p>
<div><pre><code>nginx -s reload
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>
<h2 id="设置简单的代理服务器" tabindex="-1"> 设置简单的代理服务器</h2>
<p>Nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>
<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>
<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>listen</span> <span>8080</span></span><span>;</span>
  <span><span>root</span> /data/up1</span><span>;</span>

  <span><span>location</span> /</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>
<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。修改后的位置块如下所示:</p>
<div><pre><code><span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
  <span><span>root</span> /data/images</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。正则表达式应以 <code>~</code> 开头。相应的请求将被映射到 <code>/ data/images</code> 目录。</p>
<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>
<p>代理服务器的最终配置如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080/</span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>
<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>
<p>还有许多其他指令可用于进一步配置代理连接。</p>
<h2 id="设置-fastcgi-代理" tabindex="-1"> 设置 FastCGI 代理</h2>
<p>Nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>
<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。配置的结果为:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>fastcgi_pass</span>  localhost:9000</span><span>;</span>
    <span><span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
    <span><span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span></span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://docs.nginx.com/nginx/admin-guide/" target="_blank" rel="noopener noreferrer">点击此处</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Postman</title>
      <link>https://0808200.xyz/software/postman.html</link>
      <guid>https://0808200.xyz/software/postman.html</guid>
      <source url="https://0808200.xyz/rss.xml">Postman</source>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="postman" tabindex="-1"> Postman</h1>
<p>Postman 是一个强大的抓包与网络调试工具。</p>
]]></content:encoded>
    </item>
    <item>
      <title>应用基础知识</title>
      <link>https://0808200.xyz/code/Android/base.html</link>
      <guid>https://0808200.xyz/code/Android/base.html</guid>
      <source url="https://0808200.xyz/rss.xml">应用基础知识</source>
      <description>本章包含了一些关于 Android 开发的基础内容。
</description>
      <category>Android</category>
      <pubDate>Wed, 08 Apr 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章包含了一些关于 Android 开发的基础内容。</p>

<p>您可以使用 Kotlin、Java 和 C++ 语言编写 Android 应用。Android SDK 工具会将您的代码连同任何数据和资源文件编译成一个 APK(Android 软件包)，即带有 <code>.apk</code> 后缀的归档文件。一个 APK 文件包含 Android 应用的所有内容，它也是 Android 设备用来安装应用的文件。</p>
<p>每个 Android 应用都处于各自的安全沙盒中，并受以下 Android 安全功能的保护:</p>
<ul>
<li>
<p>Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户；
默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID(该 ID 仅由系统使用，应用并不知晓)。系统会为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件；</p>
</li>
<li>
<p>每个进程都拥有自己的虚拟机 (VM)，因此应用代码独立于其他应用而运行。</p>
</li>
<li>
<p>默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 系统会在需要执行任何应用组件时启动该进程，然后当不再需要该进程或系统必须为其他应用恢复内存时，其便会关闭该进程。</p>
</li>
</ul>
<p>Android 系统实现了最小权限原则。换言之，默认情况下，每个应用只能访问执行其工作所需的组件，而不能访问其他组件。这样便能创建非常安全的环境，在此环境中，应用无法访问其未获得权限的系统部分。不过，应用仍可通过一些途径与其他应用共享数据以及访问系统服务:</p>
<ul>
<li>
<p>可以安排两个应用共享同一 Linux 用户 ID，在此情况下，二者便能访问彼此的文件。为节省系统资源，也可安排拥有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM。应用还必须使用相同的证书进行签名。</p>
</li>
<li>
<p>应用可以请求访问设备数据(如用户的联系人、短信消息、可装载存储装置(SD 卡)、相机、蓝牙等)的权限。用户必须明确授予这些权限。如需了解详细信息，请参阅使用系统权限。</p>
</li>
</ul>
<h2 id="应用组件" tabindex="-1"> 应用组件</h2>
<p>应用组件是 Android 应用的基本构建块。每个组件都是一个入口点，系统或用户可通过该入口点进入您的应用。有些组件会依赖于其他组件。</p>
<p>共有四种不同的应用组件类型:</p>
<ul>
<li>Activity</li>
<li>服务</li>
<li>广播接收器</li>
<li>内容提供程序</li>
</ul>
<p>每种类型都有不同的用途和生命周期，后者会定义如何创建和销毁组件。</p>
<h3 id="activity" tabindex="-1"> Activity</h3>
<p>Activity 是与用户交互的入口点。它表示拥有界面的单个屏幕。例如，电子邮件应用可能有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。尽管这些 Activity 通过协作在电子邮件应用中形成一种紧密结合的用户体验，但每个 Activity 都独立于其他 Activity 而存在。因此，其他应用可以启动其中任何一个 Activity(如果电子邮件应用允许)。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。Activity 有助于完成系统和应用程序之间的以下重要交互:</p>
<ul>
<li>
<p>追踪用户当前关心的内容(屏幕上显示的内容)，以确保系统继续运行托管 Activity 的进程。</p>
</li>
<li>
<p>了解先前使用的进程包含用户可能返回的内容(已停止的 Activity)，从而更优先保留这些进程。</p>
</li>
<li>
<p>帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 Activity。</p>
</li>
<li>
<p>提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些用户流。(此处最经典的示例是共享。)</p>
</li>
</ul>
<p>您需将 Activity 作为 Activity 类的子类来实现。如需了解有关 Activity 类的更多信息，请参阅 Activity 开发者指南。</p>
<h2 id="服务" tabindex="-1"> 服务</h2>
<p>服务是一个通用入口点，用于因各种原因使应用在后台保持运行状态。它是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供界面。例如，当用户使用其他应用时，服务可能会在后台播放音乐或通过网络获取数据，但这不会阻断用户与 Activity 的交互。诸如 Activity 等其他组件可以启动服务，使该服务运行或绑定到该服务，以便与其进行交互。事实上，有两种截然不同的语义服务可以告知系统如何管理应用: 已启动服务会告知系统使其运行至工作完毕。此类工作可以是在后台同步一些数据，或者在用户离开应用后继续播放音乐。在后台同步数据或播放音乐也代表了两种不同类型的已启动服务，而这些服务可以修改系统处理它们的方式:</p>
<ul>
<li>
<p>音乐播放是用户可直接感知的服务，因此，应用会向用户发送通知，表明其希望成为前台，从而告诉系统此消息；在此情况下，系统明白它应尽全力维持该服务进程运行，因为进程消失会令用户感到不快。</p>
</li>
<li>
<p>通常，用户不会意识到常规后台服务正处于运行状态，因此系统可以更自由地管理其进程。如果系统需要使用 RAM 来处理用户更迫切关注的内容，则其可能允许终止服务(然后在稍后的某个时刻重启服务)。</p>
</li>
</ul>
<p>绑定服务之所以能运行，原因是某些其他应用(或系统)已表示希望使用该服务。从根本上讲，这是为另一个进程提供 API 的服务。因此，系统会知晓这些进程之间存在依赖关系，所以如果进程 A 绑定到进程 B 中的服务，系统便知道自己需使进程 B(及其服务)为进程 A 保持运行状态。此外，如果进程 A 是用户关心的内容，系统随即也知道将进程 B 视为用户关心的内容。由于存在灵活性(无论好坏)，服务已成为非常有用的构建块，并且可实现各种高级系统概念。动态壁纸、通知侦听器、屏幕保护程序、输入方法、无障碍功能服务以及众多其他核心系统功能均可构建为在其运行时由应用实现、系统绑定的服务。</p>
<p>您需将服务作为 Service 的子类来实现。如需了解有关 Service 类的更多信息，请参阅服务开发者指南。</p>
<h2 id="广播接收器" tabindex="-1"> 广播接收器</h2>
<p>借助广播接收器组件，系统能够在常规用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。由于广播接收器是另一个明确定义的应用入口，因此系统甚至可以向当前未运行的应用传递广播。例如，应用可通过调度提醒来发布通知，以告知用户即将发生的事件。而且，通过将该提醒传递给应用的广播接收器，应用在提醒响起之前即无需继续运行。许多广播均由系统发起，例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可发起广播，例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示界面，但其可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的通道，旨在执行极少量的工作。例如，它可能会根据带 JobScheduler 的事件调度 JobService 来执行某项工作
广播接收器作为 BroadcastReceiver 的子类实现，并且每条广播都作为 Intent 对象进行传递。如需了解详细信息，请参阅 BroadcastReceiver 类。</p>
<h2 id="内容提供程序" tabindex="-1"> 内容提供程序</h2>
<p>内容提供程序管理一组共享的应用数据，您可以将这些数据存储在文件系统、SQLite 数据库、网络中或者您的应用可访问的任何其他持久化存储位置。其他应用可通过内容提供程序查询或修改数据(如果内容提供程序允许)。例如，Android 系统可提供管理用户联系人信息的内容提供程序。因此，任何拥有适当权限的应用均可查询内容提供程序(如 <code>ContactsContract.Data</code>)，以读取和写入特定人员的相关信息。我们很容易将内容提供程序看作数据库上的抽象，因为其内置的大量 API 和支持时常适用于这一情况。但从系统设计的角度看，二者的核心目的不同。对系统而言，内容提供程序是应用的入口点，用于发布由 URI 架构识别的已命名数据项。因此，应用可以决定如何将其包含的数据映射到 URI 命名空间，进而将这些 URI 分发给其他实体。反之，这些实体也可使用分发的 URI 来访问数据。在管理应用的过程中，系统可以执行以下特殊操作:</p>
<ul>
<li>
<p>分配 URI 无需应用保持运行状态，因此 URI 可在其所属的应用退出后继续保留。当系统必须从相应的 URI 检索应用数据时，系统只需确保所属应用仍处于运行状态。</p>
</li>
<li>
<p>这些 URI 还会提供重要的细粒度安全模型。例如，应用可将其所拥有图像的 URI 放到剪贴板上，但将其内容提供程序锁定，以便其他应用程序无法随意访问它。当第二个应用尝试访问剪贴板上的 URI 时，系统可允许该应用通过临时的 URI 授权来访问数据，这样便只能访问 URI 后面的数据，而非第二个应用中的其他任何内容。</p>
</li>
</ul>
<p>内容提供程序也适用于读取和写入您的应用不共享的私有数据。</p>
<p>内容提供程序作为 ContentProvider 的子类实现，并且其必须实现一组标准 API，以便其他应用能够执行事务。如需了解详细信息，请参阅内容提供程序开发者指南。</p>
<hr>
<p>Android 系统设计的独特之处在于，任何应用都可启动其他应用的组件。例如，当您想让用户使用设备相机拍摄照片时，另一个应用可能也可执行该操作，因而您的应用便可使用该应用，而非自行产生一个 Activity 来拍摄照片。您无需加入甚至链接到该相机应用的代码。只需启动拍摄照片的相机应用中的 Activity 即可。完成拍摄时，系统甚至会将照片返回您的应用，以便您使用。对用户而言，这就如同相机是您应用的一部分。</p>
<p>当系统启动某个组件时，它会启动该应用的进程(如果尚未运行)，并实例化该组件所需的类。例如，如果您的应用启动相机应用中拍摄照片的 Activity，则该 Activity 会在属于相机应用的进程(而非您的应用进程)中运行。因此，与大多数其他系统上的应用不同，Android 应用并没有单个入口点(即没有 main() 函数)。</p>
<p>由于系统在单独的进程中运行每个应用，且其文件权限会限制对其他应用的访问，因此您的应用无法直接启动其他应用中的组件，但 Android 系统可以。如要启动其他应用中的组件，请向系统传递一条消息，说明启动特定组件的 Intent。系统随后便会为您启动该组件。</p>
<h2 id="启动组件" tabindex="-1"> 启动组件</h2>
<p>在四种组件类型中，有三种(Activity、服务和广播接收器)均通过异步消息 Intent 进行启动。Intent 会在运行时对各个组件进行互相绑定。您可以将 Intent 视为从其他组件(无论该组件是属于您的应用还是其他应用)请求操作的信使。</p>
<p>您需使用 Intent 对象创建 Intent，该对象通过定义消息来启动特定组件(显式 Intent)或特定的组件类型(隐式 Intent)。</p>
<p>对于 Activity 和服务，Intent 会定义要执行的操作(例如，查看或发送某内容)，并且可指定待操作数据的 URI，以及正在启动的组件可能需要了解的信息。例如，Intent 可能会传达对 Activity 的请求，以便显示图像或打开网页。在某些情况下，您可以通过启动 Activity 来接收结果，这样 Activity 还会返回 Intent 中的结果。例如，您可以发出一个 Intent，让用户选取某位联系人并将其返回给您。返回 Intent 包含指向所选联系人的 URI。</p>
<p>对于广播接收器，Intent 只会定义待广播的通知。例如，指示设备电池电量不足的广播只包含指示“电池电量不足”的已知操作字符串。</p>
<p>与 Activity、服务和广播接收器不同，内容提供程序并非由 Intent 启动。相反，它们会在成为 ContentResolver 的请求目标时启动。内容解析程序会通过内容提供程序处理所有直接事务，因此通过提供程序执行事务的组件便无需执行事务，而是改为在 ContentResolver 对象上调用方法。这会在内容提供程序与请求信息的组件之间留出一个抽象层(以确保安全)。</p>
<p>每种组件都有不同的启动方法:</p>
<ul>
<li>
<p>如要启动 Activity，您可以向 startActivity() 或 startActivityForResult() 传递 Intent(当您想让 Activity 返回结果时)，或者为其安排新任务。</p>
</li>
<li>
<p>在 Android 5.0(API 级别 21)及更高版本中，您可以使用 JobScheduler 类来调度操作。对于早期 Android 版本，您可以通过向 startService() 传递 Intent 来启动服务(或对执行中的服务下达新指令)。您也可通过向将 bindService() 传递 Intent 来绑定到该服务。</p>
</li>
<li>
<p>您可以通过向 <code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code> 或 <code>sendStickyBroadcast()</code> 等方法传递 Intent 来发起广播。</p>
</li>
<li>
<p>您可以通过在 ContentResolver 上调用 <code>query()</code>，对内容提供程序执行查询。</p>
</li>
</ul>
<p>如需了解有关 Intent 用法的详细信息，请参阅 Intent 和 Intent 过滤器文档。以下文档将为您详细介绍如何启动特定组件: Activity、服务、BroadcastReceiver 和内容提供程序。</p>
<h2 id="清单文件" tabindex="-1"> 清单文件</h2>
<p>在 Android 系统启动应用组件之前，系统必须通过读取应用的清单文件 (AndroidManifest.xml) 确认组件存在。您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。</p>
<p>除了声明应用的组件外，清单文件还有许多其他作用，如:</p>
<ul>
<li>
<p>确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限。</p>
</li>
<li>
<p>根据应用使用的 API，声明应用所需的最低 API 级别。</p>
</li>
<li>
<p>声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕。</p>
</li>
<li>
<p>声明应用需要链接的 API 库(Android 框架 API 除外)，如 Google 地图库。</p>
</li>
</ul>
<h3 id="声明组件" tabindex="-1"> 声明组件</h3>
<p>清单文件的主要任务是告知系统应用组件的相关信息。例如，清单文件可按如下所示声明 Activity:</p>
<div><pre><code><span>&lt;?xml version="1.0" encoding="utf-8"?></span>
<span><span><span>&lt;</span>manifest</span> <span>...</span> <span>></span></span>
  <span><span><span>&lt;</span>application</span> <span><span>android:</span>icon</span><span><span>=</span><span>"</span>@drawable/app_icon.png<span>"</span></span> <span>...</span> <span>></span></span>
    <span><span><span>&lt;</span>activity</span> <span><span>android:</span>name</span><span><span>=</span><span>"</span>com.example.project.ExampleActivity<span>"</span></span> <span><span>android:</span>label</span><span><span>=</span><span>"</span>@string/example_label<span>"</span></span> <span>...</span> <span>></span></span>
    <span><span><span>&lt;/</span>activity</span><span>></span></span>
    ...
  <span><span><span>&lt;/</span>application</span><span>></span></span>
<span><span><span>&lt;/</span>manifest</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在 <code>&lt;application&gt;</code> 元素中，android:icon 属性指向标识应用的图标所对应的资源。</p>
<p>在 <code>&lt;activity&gt;</code> 元素中，android:name 属性指定 Activity 子类的完全限定类名，<code>android:label</code> 属性指定用作 Activity 的用户可见标签的字符串。</p>
<p>您必须使用以下元素声明所有应用组件:</p>
<ul>
<li>
<p>Activity 的 <code>&lt;activity&gt;</code> 元素。</p>
</li>
<li>
<p>服务的 <code>&lt;service&gt;</code> 元素。</p>
</li>
<li>
<p>广播接收器的 <code>&lt;receiver&gt;</code> 元素。</p>
</li>
<li>
<p>内容提供程序的 <code>&lt;provider&gt;</code> 元素。</p>
</li>
</ul>
<p>如果未在清单文件中声明源代码中包含的 Activity、服务和内容提供程序，则这些组件对系统不可见，因此也永远不会运行。不过，您可以 BroadcastReceiver 对象的形式，在清单中声明或在代码中动态创建广播接收器；以及通过调用 <code>registerReceiver()</code>，在系统中注册广播接收器。</p>
<p>如需详细了解如何为您的应用构建清单文件，请参阅 AndroidManifest.xml 文件文档。</p>
<h3 id="声明组件功能" tabindex="-1"> 声明组件功能</h3>
<p>如上文启动组件中所述，您可以使用 Intent 来启动 Activity、服务和广播接收器。您可以通过在 Intent 中显式命名目标组件(使用组件类名)来使用 Intent。您还可使用隐式 Intent，通过它来描述要执行的操作类型和待操作数据(可选)。借助隐式 Intent，系统能够在设备上找到可执行该操作的组件，并启动该组件。如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。</p>
<div><p>警告</p>
<p>如果您使用 Intent 来启动 Service，请使用显式 Intent 来确保应用的安全性。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0 (API 级别 21) 开始，如果使用隐式 Intent 调用 <code>bindService()</code>，系统会抛出异常。请勿为您的服务声明 Intent 过滤器。</p>
</div>
<p>通过将收到的 Intent 与设备上其他应用的清单文件中提供的 Intent 过滤器进行比较，系统便可识别能响应 Intent 的组件。</p>
<p>在应用的清单文件中声明 Activity 时，您可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。您可以将 <code>&lt;intent-filter&gt;</code> 元素作为组件声明元素的子项进行添加，从而为您的组件声明 Intent 过滤器。</p>
<p>例如，如果您构建的电子邮件应用包含用于撰写新电子邮件的 Activity，则可通过声明 Intent 过滤器来响应 “send” Intent(目的是发送新电子邮件)，如下方示例所示:</p>
<div><pre><code><span><span><span>&lt;</span>manifest</span> <span>...</span> <span>></span></span>
  ...
  <span><span><span>&lt;</span>application</span> <span>...</span> <span>></span></span>
    <span><span><span>&lt;</span>activity</span> <span><span>android:</span>name</span><span><span>=</span><span>"</span>com.example.project.ComposeEmailActivity<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>intent-filter</span><span>></span></span>
        <span><span><span>&lt;</span>action</span> <span><span>android:</span>name</span><span><span>=</span><span>"</span>android.intent.action.SEND<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>data</span> <span><span>android:</span>type</span><span><span>=</span><span>"</span>*/*<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>category</span> <span><span>android:</span>name</span><span><span>=</span><span>"</span>android.intent.category.DEFAULT<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;/</span>intent-filter</span><span>></span></span>
    <span><span><span>&lt;/</span>activity</span><span>></span></span>
  <span><span><span>&lt;/</span>application</span><span>></span></span>
<span><span><span>&lt;/</span>manifest</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果另一个应用创建包含 <code>ACTION_SEND</code> 操作的 Intent 并将其传递到 <code>startActivity()</code>，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。</p>
<p>如需了解有关创建 Intent 过滤器的详细信息，请参阅 Intent 和 Intent 过滤器文档。</p>
<h3 id="声明应用要求" tabindex="-1"> 声明应用要求</h3>
<p>Android 设备多种多样，但并非所有设备都提供相同的特性和功能。以防将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为该应用支持的设备类型明确定义一个配置文件。其中的大多数声明只是为了提供信息，系统并不会读取它们，但 Google Play 等外部服务会读取它们，以便在用户通过其设备搜索应用时为用户提供过滤功能。</p>
<p>例如，如果您的应用需要相机功能，并使用 Android 2.1 (API 级别 7) 中引入的 API，您必须在清单文件中声明以下要求，如下方示例所示</p>
<div><pre><code><span><span><span>&lt;</span>manifest</span> <span>...</span> <span>></span></span>
  <span><span><span>&lt;</span>uses-feature</span> <span><span>android:</span>name</span><span><span>=</span><span>"</span>android.hardware.camera.any<span>"</span></span> <span><span>android:</span>required</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>uses-sdk</span> <span><span>android:</span>minSdkVersion</span><span><span>=</span><span>"</span>7<span>"</span></span> <span><span>android:</span>targetSdkVersion</span><span><span>=</span><span>"</span>19<span>"</span></span> <span>/></span></span>
  ...
<span><span><span>&lt;/</span>manifest</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>通过示例中所述的声明，没有相机且 Android 版本低于 2.1 的设备将无法从 Google Play 安装您的应用。不过，您可以声明您的应用使用相机，但并不要求必须使用。在此情况下，您的应用必须将 required 属性设置为 false，并在运行时检查设备是否拥有相机，然后根据需要停用任何相机功能。</p>
<p>如需详细了解如何管理应用与不同设备的兼容性，请参阅设备兼容性文档。</p>
<h2 id="应用资源" tabindex="-1"> 应用资源</h2>
<p>Android 应用并非仅包含代码，它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。例如，您可以通过 XML 文件定义 Activity 界面的动画、菜单、样式、颜色和布局。借助应用资源，您无需修改代码即可轻松更新应用的各种特性。通过提供备用资源集，您可以针对各种设备配置(如不同的语言和屏幕尺寸)优化您的应用。</p>
<p>对于您在 Android 项目中加入的每一项资源，SDK 构建工具均会定义唯一的整型 ID，您可以利用此 ID 来引用资源，这些资源或来自应用代码，或来自 XML 中定义的其他资源。例如，如果您的应用包含名为 <code>logo.png</code> 的图像文件(保存在 <code>res/drawable/</code> 目录中)，则 SDK 工具会生成名为 <code>R.drawable.logo</code> 的资源 ID。此 ID 映射到应用特定的整型数，您可以利用它来引用该图像，并将其插入您的界面。</p>
<p>如果提供与源代码分离的资源，则其中最重要的一个优点在于，您可以提供适用于不同设备配置的备用资源。例如，通过在 XML 中定义界面字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。然后，Android 系统会根据向资源目录名称追加的语言限定符 (如为法语字符串值追加 <code>res/values-fr/</code>) 和用户的语言设置，对您的界面应用相应的语言字符串。</p>
<p>Android 支持许多不同的备用资源限定符。限定符是资源目录名称中加入的短字符串，用于定义这些资源适用的设备配置。例如，您应根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。当设备屏幕为纵向(长型)时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向(宽型)时，可以按水平方向排列按钮。如要根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。然后，系统会根据当前设备方向自动应用相应的布局。</p>
<p>如需详细了解可以在应用中加入的不同资源类型以及如何针对不同设备配置创建备用资源，请阅读提供资源。如要详细了解最佳做法和设计生产质量的稳健应用，请参阅应用架构指南。</p>
]]></content:encoded>
    </item>
    <item>
      <title>应用资源概览</title>
      <link>https://0808200.xyz/code/Android/resource.html</link>
      <guid>https://0808200.xyz/code/Android/resource.html</guid>
      <source url="https://0808200.xyz/rss.xml">应用资源概览</source>
      <description>资源是指代码使用的附加文件和静态内容，例如位图、布局定义、界面字符串、动画说明等。
</description>
      <category>Android</category>
      <pubDate>Thu, 09 Apr 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>资源是指代码使用的附加文件和静态内容，例如位图、布局定义、界面字符串、动画说明等。</p>

<p>您应始终外部化应用资源(例如图像和代码中的字符串)，以便单独对其进行维护。此外，您还应为特定设备配置提供备用资源，方法是将其进行分组并放入专门命名的资源目录中。在运行时，Android 会根据当前配置使用合适的资源。例如，您可能需根据屏幕尺寸提供不同的界面布局，或根据语言设置提供不同的字符串。</p>
<p>外部化应用资源后，您便可使用在项目 R 类中生成的资源 ID 来访问这些资源。本文档会介绍如何对 Android 项目中的资源进行分组，如何为特定的设备配置提供备用资源，以及如何从您的应用代码或其他 XML 文件访问这些资源。</p>
<h2 id="分组资源类型" tabindex="-1"> 分组资源类型</h2>
<p>您应将各类资源放入项目 <code>res/</code> 目录的特定子目录中。例如，以下是一个简单项目的文件层次结构:</p>
<div><pre><code>MyProject/
  src/
    MyActivity.java
  res/
    drawable/
      graphic.png
    layout/
      main.xml
      info.xml
    mipmap/
      icon.png
    values/
      strings.xml
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如此示例所示，<code>res/</code> 目录包含所有资源(在子目录中): 一个图像资源、两个布局资源、启动器图标的 <code>mipmap/</code> 目录以及一个字符串资源文件。资源目录名称非常重要，具体说明请见表 1。</p>
<p>表 1. 项目 <code>res/</code> 目录中支持的资源目录。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>animator/</td>
<td>用于定义属性动画的 XML 文件。</td>
</tr>
<tr>
<td>anim/</td>
<td>用于定义渐变动画的 XML 文件。(属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 animator/ 目录。)</td>
</tr>
<tr>
<td>color/</td>
<td>用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源</td>
</tr>
<tr>
<td>drawable/</td>
<td>位图文件(.png、.9.png、.jpg、.gif)或编译为以下可绘制对象资源子类型的 XML 文件: <br />位图文件<br />九宫格(可调整大小的位图)<br />状态列表<br />形状<br />动画可绘制对象<br />其他可绘制对象<br />请参阅 Drawable 资源。</td>
</tr>
<tr>
<td>mipmap/</td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。</td>
</tr>
<tr>
<td>layout/</td>
<td>用于定义用户界面布局的 XML 文件。请参阅布局资源。</td>
</tr>
<tr>
<td>menu/</td>
<td>用于定义应用菜单(如选项菜单、上下文菜单或子菜单)的 XML 文件。请参阅菜单资源。</td>
</tr>
<tr>
<td>raw/</td>
<td>需以原始形式保存的任意文件。如要使用原始 InputStream 打开这些资源，请使用资源 ID(即 <code>R.raw.filename</code>)调用 <code>Resources.openRawResource()</code>。<br />但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录(而非 <code>res/raw/</code>)下。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。</td>
</tr>
<tr>
<td>values/</td>
<td>包含字符串、整型数和颜色等简单值的 XML 文件。<br />其他 <code>res/</code> 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均会定义一个资源。例如，<code>&lt;string&gt;</code> 元素会创建 R.string 资源，<code>&lt;color&gt;</code> 元素会创建 R.color 资源。<br />由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定: <br />arrays.xml: 资源数组(类型数组)。<br />colors.xml: 颜色值。<br />dimens.xml: 尺寸值。<br />strings.xml: 字符串值。<br />styles.xml: 样式。<br />请参阅字符串资源、样式资源和更多资源类型。</td>
</tr>
<tr>
<td>xml/</td>
<td>可在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件(如可搜索配置)都必须保存在此处。</td>
</tr>
<tr>
<td>font/</td>
<td>带有扩展名的字体文件(如 .ttf、.otf 或 .ttc)，或包含 <code>&lt;font-family&gt;</code> 元素的 XML 文件。如需详细了解作为资源的字体，请参阅 XML 中的字体。</td>
</tr>
</tbody>
</table>
<div><p>警告</p>
<p>切勿将资源文件直接保存在 <code>res/</code> 目录内，因为这样会造成编译错误。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Angular</title>
      <link>https://0808200.xyz/code/angular/</link>
      <guid>https://0808200.xyz/code/angular/</guid>
      <source url="https://0808200.xyz/rss.xml">Angular</source>
      <description>Angular 是 Google 官方在 2016 年 9 月出品的一款框架。
框架强制 Typescript，更倾向于大型项目。
</description>
      <category>前端</category>
      <pubDate>Wed, 06 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Angular 是 Google 官方在 2016 年 9 月出品的一款框架。</p>
<p>框架强制 Typescript，更倾向于大型项目。</p>

<div><p>Angular 的优点</p>
<ol>
<li>零配置 CLI，享受到 webpack 每次升级的好处，但是不用关心任何 webpack config</li>
<li>官方提供所有的必须组件(http、router、animation、ssr、e2e 等等)，在 2000+ 内部应用测试之后才会发布，基本零 bug，并且保证在未来很多年内一直保证兼容升级</li>
<li>提供官方的应用市场和 low code 生成工具，一行命令就可以生成 Dashboard 和各种页面</li>
<li>框架 100% 由 TypeScript 开发，并且生态内的所有三方库都是(只能用) TypeScript 开发</li>
<li>内置 RxJS，并且从 View 的操作到 Http 全部都是 Reactive 的，可以随意组合</li>
<li>每次升级只要运行一行命令就会帮您修复所有的可能的不兼容问题</li>
<li>通过 Template 隔绝底层的 Compiler 升级成本，Compiler 迭代了三代，性能不断提升，bundle size 不断减少，但是用户代码一行不用改</li>
</ol>
</div>
<p>Angular 写起来其实是有诸多限制的，但是对企业的大型项目来说，这些限制与规范会带来多人协同开发和后期维护上的简便。</p>
<p>如果您在前端框架上追求的更多是: 升级稳定、标准统一、长期维护成本低、协作方便，不需要频繁重构，Angular 的使用感受应该还是相当不错的，这也是为什么目前大量企业用户会选择 Angular 的原因。</p>
<h2 id="相关链接" tabindex="-1"> 相关链接</h2>
<ul>
<li><a href="https://angular.io/docs" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://angular.cn/docs" target="_blank" rel="noopener noreferrer">中文文档</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>后端开发</title>
      <link>https://0808200.xyz/code/backEnd/</link>
      <guid>https://0808200.xyz/code/backEnd/</guid>
      <source url="https://0808200.xyz/rss.xml">后端开发</source>
      <category>后端</category>
      <pubDate>Tue, 10 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="后端入门" tabindex="-1"> 后端入门</h2>
<h3 id="php" tabindex="-1"> PHP</h3>
<p>PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言，免费，并且使用非常广泛。PHP (全称 Hypertext Preprocessor，即超文本预处理器)是一种通用开源脚本语言。</p>
<p>PHP 手册:</p>
<ul>
<li>
<p><a href="http://www.w3school.com.cn/php/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/php/php-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<p>如果服务器访问数量不大的情况下，PHP 作为一种门槛低，开发方便的脚本语言，还是挺受到欢迎的。</p>
<h3 id="asp" tabindex="-1"> ASP</h3>
<p>ASP 文件可包含文本、HTML 标签和脚本。ASP 文件中的脚本可在服务器上执行。由于 ASP 在服务器上运行，浏览器无需支持客户端脚本就可以显示 ASP 文件!</p>
<ul>
<li>
<p><a href="http://www.w3school.com.cn/asp/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/asp/asp-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<div><p>提示</p>
<p>更多详情有待日后补充</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>操作系统</title>
      <link>https://0808200.xyz/code/basic/OS.html</link>
      <guid>https://0808200.xyz/code/basic/OS.html</guid>
      <source url="https://0808200.xyz/rss.xml">操作系统</source>
      <description>操作系统 (Operating System，OS) 是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)。
</description>
      <category>基础</category>
      <pubDate>Thu, 26 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>操作系统 (Operating System，OS) 是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)。</p>

<p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如:</p>
<ol>
<li>
<p>文件系统</p>
<p>提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</p>
</li>
<li>
<p>设备驱动程序</p>
<p>提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。简单来说，就是让您能吃到鸡蛋，但不用养一只鸡。</p>
</li>
<li>
<p>用户接口</p>
<p>操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。</p>
</li>
<li>
<p>系统服务程序</p>
<p>当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</p>
</li>
</ol>
<p>打个比方，操作系统就好像是一个政府，其它软件都会被它管控；操作系统在给其他软件提供各种便利的同时，还会约束其他软件不能为所欲为。</p>
<p><img src="@source/code/basic/assets/OS.gif" alt="操作系统结构示意图"></p>
<p>目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS，嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等。</p>
]]></content:encoded>
    </item>
    <item>
      <title>基础介绍</title>
      <link>https://0808200.xyz/code/basic/</link>
      <guid>https://0808200.xyz/code/basic/</guid>
      <source url="https://0808200.xyz/rss.xml">基础介绍</source>
      <description>这些是一些最为基础的内容，是后来补充进博客中的，供访客查阅。
</description>
      <category>基础</category>
      <pubDate>Thu, 26 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>这些是一些最为基础的内容，是后来补充进博客中的，供访客查阅。</p>

<ul>
<li>
<p><a href="/code/basic/computer.html">计算机</a></p>
</li>
<li>
<p><a href="/code/basic/OS.html">操作系统</a></p>
</li>
<li>
<p><a href="/code/basic/file-extension.html">文件扩展名</a></p>
</li>
<li>
<p><a href="/code/basic/encoding.html">文件编码</a></p>
</li>
<li>
<p><a href="/code/basic/path.html">路径</a></p>
</li>
<li>
<p><a href="/code/basic/glob.html">Glob 模式介绍</a></p>
</li>
<li>
<p><a href="/code/basic/debug.html">开发简介</a></p>
</li>
<li>
<p><a href="/code/basic/ci.html">持续集成</a></p>
</li>
<li>
<p><a href="/code/basic/license.html">许可介绍</a></p>
</li>
<li>
<p><a href="/code/basic/open-source-and-free.html">开源与免费</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>持续集成</title>
      <link>https://0808200.xyz/code/basic/ci.html</link>
      <guid>https://0808200.xyz/code/basic/ci.html</guid>
      <source url="https://0808200.xyz/rss.xml">持续集成</source>
      <description>持续集成 (Continuous Integration) 指的是，频繁地 (一天多次) 将代码集成到主干，每次集成都通过自动化的构建 (包括编译，发布，自动化测试) 来验证，从而尽早地发现集成错误。
持续集成的目的让产品可以快速迭代，同时还能保持高质量。就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整，使得问题不会放大到其他部分和后面的环节。
</description>
      <category>基础</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>持续集成 (Continuous Integration) 指的是，频繁地 (一天多次) 将代码集成到主干，每次集成都通过自动化的构建 (包括编译，发布，自动化测试) 来验证，从而尽早地发现集成错误。</p>
<p>持续集成的目的让产品可以快速迭代，同时还能保持高质量。就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整，使得问题不会放大到其他部分和后面的环节。</p>

<h2 id="介绍" tabindex="-1"> 介绍</h2>
<p>持续集成 (CI) 是一种需要频繁提交代码到共享仓库的软件实践。频繁提交代码能较早检测到错误，减少在查找错误来源时开发者需要调试的代码量。 频繁的代码更新也更便于从软件开发团队的不同成员合并更改。 这对开发者非常有益，他们可以将更多时间用于编写代码，而减少在调试错误或解决合并冲突上所花的时间。</p>
<p>提交代码到仓库时，可以持续创建并测试代码，以确保提交未引入错误。 您的测试可以包括代码语法检查 (检查样式格式) 、安全性检查、代码覆盖率、功能测试及其他自定义检查。</p>
<p>创建和测试代码需要服务器。 您可以在推送代码到仓库之前在本地创建并测试更新，也可以使用 CI 服务器检查仓库中的新代码提交。</p>
<h3 id="要点" tabindex="-1"> 要点</h3>
<p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ol>
<li>
<p>提高开发效率</p>
</li>
<li>
<p>快速发现并定位 Bugs</p>
</li>
<li>
<p>更快速发布更新</p>
</li>
</ol>
<hr>
<p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p>
<h2 id="持续交付" tabindex="-1"> 持续交付</h2>
<p><strong>持续交付 (Continuous Delivery) 指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong> 如果评审通过，代码就进入生产阶段。</p>
<p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
<p>持续交付意味着所有的变更都可以被部署到生产环境中，如果代码没有问题，可以继续手动部署到生产环境中。</p>
<h2 id="持续部署" tabindex="-1"> 持续部署</h2>
<p><strong>持续部署 (Continuous Deployment) 是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</strong></p>
<p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p>
<h2 id="流程" tabindex="-1"> 流程</h2>
<p>一个大型项目严格的流程如下:</p>
<ol>
<li>
<p>提交</p>
<p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 (commit)。</p>
</li>
<li>
<p>测试 (第一轮)</p>
<p>代码仓库对 commit 操作配置了钩子 (hook) ，只要提交代码或者合并进主干，就会跑自动化测试。</p>
<p>测试分为好几种,</p>
<ul>
<li>单元测试: 针对函数或模块的测试</li>
<li>集成测试: 针对整体产品的某个功能的测试，又称功能测试</li>
<li>端对端测试: 从用户界面直达数据库的全链路测试</li>
</ul>
<p>第一轮至少要跑单元测试。</p>
</li>
<li>
<p>构建</p>
<p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>
<p>交付后，就先进行构建 (build)，再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源 (样式表、JS 脚本、图片) 等等。</p>
<p>常用的构建工具如下,</p>
<ul>
<li>Jenkins</li>
<li>Travis</li>
<li>Codeship</li>
<li>Strider</li>
</ul>
<p>Jenkins 和 Strider 是开源软件， Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。</p>
</li>
<li>
<p>测试 (第二轮)</p>
<p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>
<p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p>
<p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p>
</li>
<li>
<p>部署</p>
<p>通过了第二轮测试，当前代码就是一个可以直接部署的版本 (artifact)。将这个版本的所有文件打包 (tar filename.tar *) 存档，发到生产服务器。</p>
<p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接 (symlink) 指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible， Chef， Puppet 等。</p>
</li>
<li>
<p>回滚</p>
<p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>计算机</title>
      <link>https://0808200.xyz/code/basic/computer.html</link>
      <guid>https://0808200.xyz/code/basic/computer.html</guid>
      <source url="https://0808200.xyz/rss.xml">计算机</source>
      <description>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。
计算机的核心就是: 接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯。
</description>
      <category>基础</category>
      <pubDate>Thu, 26 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。</p>
<p>计算机的核心就是: 接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯。</p>

<div><p>提示</p>
<p>也就是说一般商店用的简易型加减乘除计算机、手机、卫星定位系统(GPS)、提款机(ATM)、个人电脑、笔记本电脑(包括 notebook 与 netbook)，还有平板电脑与智能手机等，都叫计算机。</p>
</div>
<h2 id="组成" tabindex="-1"> 组成</h2>
<p>计算机由硬件和软件组成:</p>
<h3 id="硬件" tabindex="-1"> 硬件</h3>
<p>硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等；</p>
<p>严格意义上讲，硬件可以分为三个部分:</p>
<ul>
<li>输入单元: 包括键盘、鼠标、读卡器、扫描器、手写板、触控屏等等一堆；</li>
<li>主机部分: 这个就是系统单元，被主机机壳保护住了，里面含有主板、CPU 、内存、硬盘等；</li>
<li>输出单元: 例如显示器、打印机等等</li>
</ul>
<p>计算机的重点在于中央处理器 (Central Processing Unit, CPU)，CPU 为一个具有特定功能的晶片，里头含有微指令集，如果您想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内建的微指令集才可以。由于 CPU 的工作主要在于管理与运算，因此在 CPU 内又可分为两个主要的单元，分别是: 算数逻辑单元与控制单元。其中算数逻辑单元主要负责程式运算与逻辑判断，控制单元则主要在协调各周边元件与各单元间的工作。</p>
<p>既然 CPU 的重点是在进行运算与判断，那么要被运算与判断的资料是从哪里来的? CPU 读取的资料都是从内存来的! 内存内的资料则是从输入单元所传输进来! 而 CPU 处理完毕的资料也必须要先写回内存中，最后资料才从内存传输到输出单元。</p>
<h3 id="软件" tabindex="-1"> 软件</h3>
<p>软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。</p>
]]></content:encoded>
    </item>
    <item>
      <title>开发简介</title>
      <link>https://0808200.xyz/code/basic/debug.html</link>
      <guid>https://0808200.xyz/code/basic/debug.html</guid>
      <source url="https://0808200.xyz/rss.xml">开发简介</source>
      <description>开发是根据用户要求建造出合理程序的过程。过程一般是用某种程序设计语言来实现的。通常采用开发工具可以进行开发。
</description>
      <category>基础</category>
      <pubDate>Fri, 27 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>开发是根据用户要求建造出合理程序的过程。过程一般是用某种程序设计语言来实现的。通常采用开发工具可以进行开发。</p>

<h2 id="小团队的具体分工" tabindex="-1"> 小团队的具体分工</h2>
<p>对于小团队而言，经典的划分主要还分为三个板块</p>
<h3 id="ui-设计" tabindex="-1"> UI 设计</h3>
<p>UI 即 User Interface (用户界面) 的简称。泛指用户的操作界面。UI 设计主要指界面的样式，美观程度。而使用上，对软件的人机交互、操作逻辑、界面美观的整体设计则是同样重要的另一个门道。</p>
<p>UI 可以让软件变得有个性有品味，还要让软件的操作变得舒适、简单、自由，充分体现软件的定位和特点。</p>
<div><p>提示</p>
<p>在开发中，UI 设计主要指<strong>界面元素设计</strong>和<strong>交互设计</strong>两部分。</p>
</div>
<h3 id="前端开发" tabindex="-1"> 前端开发</h3>
<p>前端开发是创建 Web 页面或 App 等前端界面呈现给用户的过程。前端开发通过 HTML，CSS 及 JavaScript 以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。</p>
<div><p>提示</p>
<p>在开发中，前端开发直接<strong>使用 UI 设计提供的素材</strong>并参照 UI 设计提供的<strong>界面图与交互逻辑</strong>对其设想进行<strong>实现</strong>。</p>
</div>
<h3 id="后端开发" tabindex="-1"> 后端开发</h3>
<p>根据正在处理的应用程序的大小和范围，后端开发人员要做的事情有很大的不同。在 Web 开发世界中，大多数后端开发人员从事于构建他们正在工作的应用程序背后的实际逻辑。其负责是网站后台逻辑的设计和实现还有用户及网站的数据的保存和读取。</p>
<div><p>提示</p>
<p>在开发中，后端开发提供与其他服务器<strong>交互数据</strong>，为用户<strong>检索或转换数据</strong>并<strong>对用户数据加以收集与储存</strong>。</p>
</div>
<h2 id="公司开发" tabindex="-1"> 公司开发</h2>
<div><p>注</p>
<p>如果从职位细分的话，可以分出产品、交互、设计、开发、测试、策划、运营、维护等。</p>
</div>
<h3 id="产品设计" tabindex="-1"> 产品设计</h3>
<p>产品设计对应产品经理，一般负责整体内容的构思，这一过程可能还包括用户和市场调研，确定要做的产品的功能、大致交互格式，也就是将成品的草稿设计出来，</p>
<h3 id="设计师" tabindex="-1"> 设计师</h3>
<p>设计师主要和产品设计合作，对一个 App 或者网站的大致页面布局、交互流程进行设计，并提供大致的页面切图，交互流程文档等。</p>
<h3 id="交互" tabindex="-1"> 交互</h3>
<p>交互一般负责具体交互流程的细节，会逐步细化，考虑用户习惯，操作的步骤以及长度。综合考量整个交互设计对用户体验以及流失率、活跃程度的影响。</p>
<h3 id="开发" tabindex="-1"> 开发</h3>
<p>在实际的大型公司发开产品的过程中，开发直接就可以拿到页面的设计图以及完善的交互流程文档，开发的工作就是去实现相应的页面与动画。</p>
<p>在这一过程中，前端和后端约定接口和参数，前端负责 App 或网站，后端负责服务器上的数据存储与服务。</p>
<h3 id="测试" tabindex="-1"> 测试</h3>
<p>通常情况下，测试和开发会完全分开，测试人员在未参与开发的情况下模拟用户，在不同情况下进行测试，以确保产品不会出现问题。</p>
<p>这里常见的测试有风险测试、压力测试与异常行为测试等。测试软件是否有安全漏洞，是否可承担大量的访问以及是否在一些非常规交互下可以正常工作。</p>
<h3 id="运营" tabindex="-1"> 运营</h3>
<p>一般一款产品需要宣发和后续的持续运营，一般就通过偏市场方向的策划和运营进行相关设计，并指导开发进行相关活动的编写与上线。</p>
<h3 id="运维" tabindex="-1"> 运维</h3>
<p>一款产品的后端存储可能需要定期的备份与维护，同时软件后端部署的服务器可能要定期的修复漏洞与升级，就需要有专门的人员来进行这一工作，</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机编码介绍</title>
      <link>https://0808200.xyz/code/basic/encoding.html</link>
      <guid>https://0808200.xyz/code/basic/encoding.html</guid>
      <source url="https://0808200.xyz/rss.xml">计算机编码介绍</source>
      <description>计算机，不能直接存储文字，存储的是编码。
计算机只能处理二进制的数据，也就是说计算机只能处理数字。如果要处理文本，比如: 0-9、a-z、A-Z，就必须先把文本转换为数字才能处理。对于这些字符，可以定义一套规则来显示，比如: A 用 110 表示，B 用 111 表示等。
</description>
      <category>基础</category>
      <pubDate>Fri, 27 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>计算机，不能直接存储文字，存储的是编码。</p>
<p>计算机只能处理二进制的数据，也就是说计算机只能处理数字。如果要处理文本，比如: <code>0-9</code>、<code>a-z</code>、<code>A-Z</code>，就必须先把文本转换为数字才能处理。对于这些字符，可以定义一套规则来显示，比如: <code>A</code> 用 <code>110</code> 表示，<code>B</code> 用 <code>111</code> 表示等。</p>

<h2 id="字符编码" tabindex="-1"> 字符编码</h2>
<p>最早的计算机在设计时采用 8 个比特(bit)作为一个字节(byte)，所以，一个字节能表示的最大的整数就是 255(二进制 11111111=十进制 255)，如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 <code>65535</code>，4 个字节可以表示的最大整数是 <code>4294967295</code>。</p>
<p>由于计算机是美国人发明的，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。</p>
<p>您可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode 标准也在不断发展，但最常用的是用两个字节表示一个字符(如果要用到非常偏僻的字符，就需要 4 个字节)。现代操作系统和大多数编程语言都直接支持 Unicode。</p>
<p>现在，捋一捋 ASCII 编码和 Unicode 编码的区别: ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节。</p>
<p>字母 A 用 ASCII 编码是十进制的 65，二进制的 01000001；</p>
<p>字符 0 用 ASCII 编码是十进制的 48，二进制的 00110000，注意字符 <code>'0'</code> 和整数 <code>0</code> 是不同的；</p>
<p>汉字中已经超出了 ASCII 编码的范围，用 Unicode 编码是十进制的 20013，二进制的 01001110 00101101。</p>
<p>您可以猜测，如果把 ASCII 编码的 A 用 Unicode 编码，只需要在前面补 0 就可以，因此，A 的 Unicode 编码是 00000000 01000001。</p>
<p>新的问题又出现了: 如果统一成 Unicode 编码，乱码问题从此消失了。但是，如果您写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果您要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间:</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>01000001</td>
<td>00000000 01000001</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td>x</td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>从上面的表格还可以发现，UTF-8 编码有一个额外的好处，就是 ASCII 编码实际上可以被看成是 UTF-8 编码的一部分，所以，大量只支持 ASCII 编码的历史遗留软件可以在 UTF-8 编码下继续工作。</p>
<p>搞清楚 ASCII、Unicode 和 UTF-8 的关系，现在可以总结计算机系统通用的字符编码工作方式:</p>
<p>在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。</p>
<p>用编辑器编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件:</p>
<i>Content not supported</i><p>浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器:</p>
<p>所以您看到很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code> 的信息，表示该网页正是用的 UTF-8 编码。</p>
<h2 id="ascii-码" tabindex="-1"> ASCII 码</h2>
<p>美国发布的，用 1 个字节 (8 位二进制) 来表示一个字符，共可以表示 2<sup>8</sup>=256 个字符。</p>
<p>美国的国家语言是英语，只要能表示 0-9、a-z、A-Z、特殊符号。</p>
<h2 id="ansi-编码" tabindex="-1"> ANSI 编码</h2>
<p><strong>每个国家为了显示本国的语言，都对 ASCII 码进行了扩展</strong>。用 2 个字节 (16 位二进制) 来表示一个汉字，共可以表示 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>16</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>65536</span></span></span></span> 个汉字。例如:</p>
<ul>
<li>中国的 ANSI 编码是 GB2312 编码(简体)，对 6763 汉字进行编码，含 600 多特殊字符。另外还有 GBK(简体)。</li>
<li>日本的 ANSI 编码是 JIS 编码。</li>
<li>台湾的 ANSI 编码是 BIG5 编码(繁体)。</li>
</ul>
<h3 id="gbk" tabindex="-1"> GBK</h3>
<p>对 GB2312 进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了 2.1 万左右。并提供了 1890 个汉字码位。<code>K</code> 的含义就是“扩展”。</p>
<h2 id="unicode-编码-统一编码" tabindex="-1"> Unicode 编码(统一编码)</h2>
<p>用 4 个字节 (32 位二进制) 来表示一个字符，想法不错，但效率太低。例如，字母 A 用 ASCII 表示的话一个字节就够，可用 Unicode 编码的话，得用 4 个字节表示，造成了空间的极大浪费。A 的 Unicode 编码是 <code>0000 0000 0000 0000 0000 0000 0100 0000</code></p>
<h2 id="utf-8-unicode-transform-format-编码" tabindex="-1"> UTF-8 (Unicode Transform Format)编码</h2>
<p>根据字符的不同，选择其编码的长度。比如:一个字符 A 用 1 个字节表示，一个汉字用 2 个字节表示。</p>
<p>毫无疑问，开发中，都用 <strong>UTF-8</strong> 编码吧，准没错。</p>
<div><p>提示</p>
<p><strong>中文能够使用的字符集两种:</strong></p>
<ul>
<li>
<p>第一种:UTF-8。UTF-8 是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、老挝语……</p>
</li>
<li>
<p>第二种:GBK (对 GB2312 进行了扩展)。gb2312 是国标，是中国的字库，里面<strong>仅</strong>涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。</p>
</li>
</ul>
<p>字库规模: UTF-8 (字全) &gt; gb2312 (只有汉字)</p>
<p>保存大小: UTF-8 (更臃肿、加载更慢) &gt; gb2312 (更小巧，加载更快)</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>文件名与文件扩展名</title>
      <link>https://0808200.xyz/code/basic/file-extension.html</link>
      <guid>https://0808200.xyz/code/basic/file-extension.html</guid>
      <source url="https://0808200.xyz/rss.xml">文件名与文件扩展名</source>
      <category>基础</category>
      <pubDate>Thu, 26 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="文件名" tabindex="-1"> 文件名</h2>
<p>文件名就是文件的名称，是为了方便人们区分计算机中的不同文件，而给每个文件设定一个指定的名称。</p>
<p>文件名不能包含控制字符: <code>&lt;</code> <code>&gt;</code> <code>/</code> <code>\</code> <code>|</code> <code>:</code> <code>&quot;</code> <code>*</code> <code>?</code></p>
<h2 id="文件扩展名" tabindex="-1"> 文件扩展名</h2>
<p>文件扩展名 (filename extension) 也称为文件的延伸文件名、后缀名，是操作系统用来标记文件类型的一种机制。通常来说，一个扩展名是跟在主文件名后面的，由一个分隔符分隔。</p>
<p>文件扩展名是早期操作系统 (如 VMS / CP / M / DOS 等) 用来标志文件格式的一种机制，其更重要的作用是让系统决定当用户想打开这个文件的时候用哪种软件运行，如 Windows 系统中 exe 文件是可执行文件，doc 文件默认用 Microsoft Word 打开的 Word 文件。</p>
<div><p>误区</p>
<ol>
<li>
<p>文件扩展名是一个文件的必要构成部分。❌</p>
<p>任何一个文件可以有或没有扩展名。对于打开文件操作，没有扩展名的文件需要选择程序去打开它，有扩展名的文件会自动用设置好的程序(如有)去尝试打开，文件扩展名是一个常规文件的构成部分，但一个文件并不一定需要一个扩展名。</p>
</li>
<li>
<p>文件扩展名表明了该文件是何种类型。❌</p>
<p>文件扩展名可以人为设定，扩展名为 TXT 的文件有可能是一张图片，同样，扩展名为 MP3 的文件，依然可能是一个视频。</p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Glob</title>
      <link>https://0808200.xyz/code/basic/glob.html</link>
      <guid>https://0808200.xyz/code/basic/glob.html</guid>
      <source url="https://0808200.xyz/rss.xml">Glob</source>
      <description>本文介绍 Glob 匹配。
</description>
      <category>基础</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文介绍 Glob 匹配。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Glob 是当您要进行路径匹配时键入的模式。</p>
<p>在解析一条匹配模式前，Glob 首先将 <code>{}</code> 部分展开为一组匹配模式。<code>{}</code> 内的模式之间使用逗号分隔。</p>
<p>如 <code>a{/b/c,bcd}</code> 将扩展为 <code>a/b/c</code> 和 <code>abcd</code></p>
<p><code>{}</code> 可以嵌套，可与其他模式联用。</p>
<p>Glob 的魔术字符如下:</p>
<ul>
<li>
<p><code>*</code>: 匹配路径部分中的 0 个或多个字符</p>
</li>
<li>
<p><code>?</code>: 匹配单个字符</p>
</li>
<li>
<p><code>[...]</code>: 匹配字符范围。<code>[^...]</code>和 <code>[!...]</code> 表示匹配不在范围内的字符</p>
<details><summary>例子</summary>
<ul>
<li><code>[xyz].js</code> 只能匹配 <code>x.js</code>, <code>y.js</code>, <code>z.js</code>，但不会匹配 <code>xy.js</code>, <code>xyz.js</code> 等，因为整个中括号只代表一个字符。其等价于 <code>[x-z].js</code></li>
<li><code>[!xyz].js</code> 能匹配 <code>a.js</code>, <code>b.js</code>, <code>u.js</code>，但不会匹配 <code>x.js</code>, <code>y.js</code> <code>z.js</code>，<code>ab.js</code> 等。其等价于 <code>[^xyz].js</code> 和 <code>[!x-z].js</code>。</li>
</ul>
</details>
</li>
<li>
<p><code>!(pattern|pattern|pattern)</code>: 匹配与提供的任何模式都不匹配的任何内容。</p>
</li>
<li>
<p><code>?(pattern|pattern|pattern)</code>: 匹配 0 或一个内部模式。</p>
</li>
<li>
<p><code>+(pattern|pattern|pattern)</code> 匹配一个或多个内部模式。</p>
</li>
<li>
<p><code>*(a|b|c)</code>: 匹配 0 或多个内部模式。</p>
</li>
<li>
<p><code>@(pattern|pat*|pat?erN)</code>: 匹配恰好一个内部模式。</p>
</li>
<li>
<p><code>**</code>: 如果其在路径部分中单独出现，则匹配路径中的 0 个或多个目录与子目录。请注意它不对 symlinked 目录 (符号链接目录) 进行爬取。</p>
<details><summary>例子</summary>
<ul>
<li><code>**</code> 能匹配匹配所有的目录和文件。</li>
<li><code>**/*.js</code> 能匹配所有的 js 文件。</li>
<li><code>a/**/b.txt</code> 能匹配目录里任何一个 a 文件夹内的所有 b.txt 文件。</li>
</ul>
</details>
</li>
</ul>
<h2 id="开头的文件与文件夹" tabindex="-1"> <code>.</code> 开头的文件与文件夹</h2>
<p>由于以 <code>.</code> 开头的文件或文件夹在 Unix 中视为隐藏文件或文件夹，故 Glob 不会匹配任何以 <code>.</code> 开头的路径部分，如 <code>.github/dependabot.yml</code> 或 <code>.eslintrc.js</code>。</p>
<p>如果的确想要匹配 <code>.</code> 开头的文件或文件夹，可以显示标注出来，如 <code>.*.js</code> 可以匹配 <code>.eslintrc.js</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>开源协议</title>
      <link>https://0808200.xyz/code/basic/license.html</link>
      <guid>https://0808200.xyz/code/basic/license.html</guid>
      <source url="https://0808200.xyz/rss.xml">开源协议</source>
      <description>开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织 (Open Source Initiative) 认可的开源许可协议来保证开源工作者的权益。
开源协议规定了您在使用开源软件时的权利和责任，也就是规定了您可以做什么，不可以做什么。
开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。
</description>
      <category>基础</category>
      <pubDate>Fri, 27 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织 (Open Source Initiative) 认可的开源许可协议来保证开源工作者的权益。</p>
<p>开源协议规定了您在使用开源软件时的权利和责任，也就是规定了您可以做什么，不可以做什么。</p>
<p>开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。</p>

<p>对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。</p>
<h2 id="gnu-gpl" tabindex="-1"> GNU GPL</h2>
<blockquote>
<p>GNU General Public License，GNU 通用公共许可证</p>
</blockquote>
<p>只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件。</p>
<p>遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。</p>
<p>GPL 开源协议的主要特点:</p>
<ul>
<li>
<p>复制自由</p>
<p>允许把软件复制到任何人的电脑中，并且不限制复制的数量。</p>
</li>
<li>
<p>传播自由</p>
</li>
</ul>
<p>允许软件以各种形式进行传播。</p>
<ul>
<li>
<p>收费传播</p>
<p>允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。</p>
</li>
<li>
<p>修改自由</p>
<p>允许开发人员增加或删除软件的功能，但软件修改后必须依然基于 GPL 许可协议授权。</p>
</li>
</ul>
<h2 id="bsd" tabindex="-1"> BSD</h2>
<blockquote>
<p>Berkeley Software Distribution，伯克利软件发布版) 协议</p>
</blockquote>
<p>BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件:</p>
<ul>
<li>如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。</li>
<li>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。</li>
<li>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</li>
</ul>
<p>BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。</p>
<h2 id="apache-许可证版本" tabindex="-1"> Apache 许可证版本</h2>
<blockquote>
<p>(Apache License Version) 协议</p>
</blockquote>
<p>Apache 开源协议</p>
<p>Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。</p>
<p>现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件:</p>
<ul>
<li>该软件及其衍生品必须继续使用 Apache 许可协议。</li>
<li>如果修改了程序源代码，需要在文档中进行声明。</li>
<li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li>
<li>如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。</li>
</ul>
<h2 id="mit" tabindex="-1"> MIT</h2>
<blockquote>
<p>(Massachusetts Institute of Technology) 协议</p>
</blockquote>
<p>目前限制最少的开源许可协议之一(比 BSD 和 Apache 的限制都少)，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。</p>
<p>使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。</p>
<h2 id="gun-lgpl" tabindex="-1"> GUN LGPL</h2>
<blockquote>
<p>(GNU Lesser General Public License，GNU 宽通用公共许可证)</p>
</blockquote>
<p>LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议。</p>
<p>LGPL 允许商业软件通过类库引用(link)的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此 LGPL 协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<h2 id="如何选择开源协议" tabindex="-1"> 如何选择开源协议</h2>
<p>世界上的开源协议有上百种，很少有人能彻底搞清它们之间的区别，即使在最流行的六种开源协议——GPL、BSD、MIT、Mozilla、Apache 和 LGPL——之中做选择，也很复杂。</p>
<p>乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议，大家看了一目了然，真是清爽。</p>
<i>Content not supported</i>]]></content:encoded>
    </item>
    <item>
      <title>开源与免费</title>
      <link>https://0808200.xyz/code/basic/open-source-and-free.html</link>
      <guid>https://0808200.xyz/code/basic/open-source-and-free.html</guid>
      <source url="https://0808200.xyz/rss.xml">开源与免费</source>
      <description>开源软件和免费软件是两个概念:


开源软件是指公开源代码的软件。开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。


免费软件就是免费提供给用户使用的软件，但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。


</description>
      <category>基础</category>
      <pubDate>Fri, 05 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>开源软件和免费软件是两个概念:</p>
<ul>
<li>
<p>开源软件是指公开源代码的软件。开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。</p>
</li>
<li>
<p>免费软件就是免费提供给用户使用的软件，但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。</p>
</li>
</ul>

<h2 id="免费软件" tabindex="-1"> 免费软件</h2>
<p>免费软件的例子比比皆是，QQ、微信、迅雷、酷狗、360 等都是免费软件，您可以随意使用，尽情蹂躏；但是，如果您嫌弃它们复杂，自己删除了一些无用的功能，然后在网上发布了一个精简版本供大家下载，那么您就离法院的传票不远了。</p>
<h2 id="开源软件" tabindex="-1"> 开源软件</h2>
<p>开源软件是不抵触商业的，开源的目的也不是做慈善事业，而是通过更多人的参与，减少软件的缺陷，丰富软件的功能，同时也避免了少数人在软件里留一些不正当的后门。开源软件最终还会反哺商业，让商业公司为用户提供更好的产品。</p>
<p>Android 就是大众最熟知的一款开源操作系统，它除了用在手机上，还用在汽车、平板电脑、电视、智能手表等其它硬件平台，小米、华为、OPPO、三星等都是 Android 的受益者，他们都赚得盆满钵满。</p>
<p>很多著名的开源项目背后都有商业公司支撑，它们的开发者也都有正式的工作，享受和我们一样的社会福利；如果一个成功的开源项目背后没有商业公司，这反而是不健康的，社会需要开源和商业之间的互补来促进技术的革新。</p>
<p>开源软件和商业公司的裙带关系:</p>
<ul>
<li>
<p>Android 由全球最大的互联网公司 Google 支持；</p>
</li>
<li>
<p>市场占有率最高的关系型数据库 mysql 已经被上市公司 Oracle 收购；</p>
</li>
<li>
<p>linux 不但被 Microsoft、IBM、Intel、SAMSUNG 等巨头免费赞助，还接收它们贡献的源代码；</p>
</li>
<li>
<p>Python 目前属于 python.org 开源组织，它收到了 Facebook、Google、Amazon、Redhat、Microsoft 等商业公司的赞助。</p>
</li>
</ul>
<h2 id="开源软件的盈利模式" tabindex="-1"> 开源软件的盈利模式</h2>
<p>伟大的开源软件的背后都有巨量的资金流入，没有资金支撑的开源软件是无法长久的。那么，开源软件究竟是如何盈利的呢?</p>
<ol>
<li>
<p>双重许可</p>
<p>有些开源软件不但有一个免费的基础版本，还有一个收费的商业版本。免费版本能够促进传播，让用户爱上该软件；收费版本功能更加丰富，还提供技术支持。这种情况在开源界非常普遍。</p>
<p>例如 MySQL 就同时推出面向个人和企业的两种版本，即开源版本和专业版本，分别采用不同的授权方式: 开源版本完全免费以便更好的推广，而从专业版的许可销售和支持服务获得收入。</p>
</li>
<li>
<p>技术支持</p>
<p>很多软件在使用上不收取费用，但当用户在使用产品遇到困难，需要技术支持的时候，就需要付费了。技术支持收费的这项服务，也是一些开源公司的生计之路。</p>
<p>例如，最大的开源软件公司 Redhat 被 IBM 收购，卖了 340 亿美元。Redhat 虽然提供免费的 Linux 发行版(当然也有收费的版本)，但是当使用者遇到技术障碍，或者想升级硬件的时候，Redhat 可以提供付费支持。</p>
<p>举个例子，纽交所在用免费的红帽 Linux 系统交易股票。英特尔最近升级了处理器，纽交所想用新处理器提高效率，但这需要有人为新硬件部署新的系统和应用程序。同样的事每隔几年会发生一次。纽交所可以养一个团队自己完成所有系统维护、开发工作，也可以花钱请红帽的工程师来做。相当数量的企业用户都选择了后者。</p>
</li>
<li>
<p>附加服务</p>
<p>JBoss 就是这种模式的典型代表。JBoss 应用服务器完全免费，而通过提供技术文档、培训、二次开发支持等技术服务而获得收入。</p>
<p>开源软件出版商 O’Reilly 公司也是这种模式，它不遗余力地联系开源软件的权威人士，组织各种开源软件的会议，虽然知识是免费的，但承载知识的书籍却是收费的。</p>
</li>
<li>
<p>应用服务托管(ASP)</p>
<p>例如 PHP Live ! 就是一种构架于 PHP、MySQL 之上的开源软件，它可为企业用户提供实时交谈服务。目前已经有数十家公开提供 PHP Live! 托管服务的应用服务提供商。</p>
</li>
<li>
<p>软硬件一体化</p>
<p>比如 IBM、HP 等服务器供应商巨头，通过捆绑免费的 Linux 操作系统销售硬件服务器。SUN 公司近期将其 Solaris 操作系统开放源码，以确保服务器硬件的销售收入，也是这种模式的体现。</p>
<p>这些巨头每年在开源软件领域的投入巨大，但这一切并非是做善事，它们可以从配置了开源软件的硬件中获得巨额回报。</p>
</li>
<li>
<p>部分组件收费</p>
<p>开源免费的软件可以满足大部分用户的需求，但是也有很多用户需要一些特殊的定制服务，这个时候软件公司就会收取一定的费用。</p>
</li>
<li>
<p>版权收费</p>
<p>虽然代码是开源的，但很多作者会采用一些开源协议来限制自己版权问题，如果用户想要去版权，是需要另外付费的。</p>
</li>
<li>
<p>捐款/赞助</p>
<p>很多开源软件都有一些捐款渠道，喜爱该软件的用户，或者该软件的受益者都可以进行资金支持。</p>
<p>例如，Python 就有一个软件基金协会，它收到了来自 Facebook、Amazon、Google、Redhat、Microsoft 等巨头的赞助。</p>
<p>这些公司也不傻，他们为什么会赞助 Python 呢? 因为这些公司大量使用了 Python 语言，他们希望 Python 能够持续发展，如果 Python 倒了，他们也会跟着倒霉。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>路径</title>
      <link>https://0808200.xyz/code/basic/path.html</link>
      <guid>https://0808200.xyz/code/basic/path.html</guid>
      <source url="https://0808200.xyz/rss.xml">路径</source>
      <description>无论是我们想直接访问一个文件，还是在一个文件中希望访问另一个文件，都涉及到一个获取文件的操作。而无论是在 Windows 中还是在 Linux 中，文件的具体位置都用文档的路径标注。
路径常常涉及到物理路径，相对路径，绝对路径，根目录的概念，现加以说明。
</description>
      <category>基础</category>
      <pubDate>Fri, 20 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>无论是我们想直接访问一个文件，还是在一个文件中希望访问另一个文件，都涉及到一个获取文件的操作。而无论是在 Windows 中还是在 Linux 中，文件的具体位置都用文档的路径标注。</p>
<p>路径常常涉及到物理路径，相对路径，绝对路径，根目录的概念，现加以说明。</p>

<h2 id="物理路径" tabindex="-1"> 物理路径</h2>
<p>物理路径的英文全称是: Physical path，它就是指硬盘上文件的路径，比如下面的文件位置表示方法:</p>
<div><pre><code>d:\wwwroot\html\a.html
d:\wwwroot\html\photo\b.html
d:\wwwroot\html\photo\c.html
d:\wwwroot\html\photo\ours\d.html
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>D:</code> 与 <code>d:</code> 均可。盘符不分大小写。</p>
</blockquote>
<p>一般来说物理路径可用于访问本地文件，即不通过 WEB 服务器(如: 本地调试)等的情况下。</p>
<h2 id="相对路径" tabindex="-1"> 相对路径</h2>
<p>相对路径的英文全称是 Relative Path，我们可以从以下三个方面来了解它的用法 (以“物理路径”中的位置情况为例):</p>
<ul>
<li>
<p>如何表示同级目录的文件</p>
<p>b.html 和 c.html 在同一个文件夹下，如果 b.html 需要链接到 c.html，可以在 b.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>./c.html<span>"</span></span><span>></span></span>同目录下文件间互相链接<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>代码中的 <code>./</code> 代表同级目录。</p>
<p><code>./</code>是相对路径，也可以省略不写，省略不写，即直接以文件夹或文件名称开头的路径也是相对路径。</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>./c.html<span>"</span></span><span>></span></span>同目录下文件间互相链接<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>如何表示上级目录的文件</p>
<p>a.html 是 b.html 和 c.html 的上级目录中的文件，如果 b.html 或 c.html 链接到 a.html，可以在 b.html 或 c.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>../a.html<span>"</span></span><span>></span></span>链接到上级目录中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>代码中的 <code>../</code> 代表一级上级目录(间隔一个目录)。</p>
<p>需要注意的是: “<code>../../</code>”代表二级上级目录(间隔两个目录)，比如 a.html 是 d.html 的前两级目录，同时 d.html 需要链接到 a.html，可以在 d.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>../../a.html<span>"</span></span><span>></span></span>链接到上级目录的上级目录中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>如何表示子目录的文件</p>
<p>b.html 和 c.html 是 a.html 的子目录中的文件，如果需要在 a.html 中链接到 b.html， 可以在 a.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>photo/b.html<span>"</span></span><span>></span></span>链接到子目录(photo)中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
如果需要在a.html中链接到d.html，可以在a.html中这样写
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>photo/ours/d.html<span>"</span></span><span>></span></span>链接到子目录(photo/ourd/)中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
</ul>
<h2 id="绝对路径" tabindex="-1"> 绝对路径</h2>
<p>绝对路径的英文全称是 Absolute Path，它就是带有网址的路径。比如您有一个域名 www.deerol.com，其域名指向 d:\wwwroot，那么上面的四个文件就可以这么表示:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/a.html<span>"</span></span><span>></span></span>链接到a.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/photo/b.html<span>"</span></span><span>></span></span>链接到b.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/photo/c.html<span>"</span></span><span>></span></span>链接到c.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/photo/ours/d.html<span>"</span></span><span>></span></span>链接到d.html<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="根目录" tabindex="-1"> 根目录</h2>
<p>根目录的英文全称是 Root directory，去掉绝对路径前面的域名就是根目录，所以它可以理解为是网站的最上层目录。它的表示方法如下:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/a.html<span>"</span></span><span>></span></span>链接到a.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/photo/b.html<span>"</span></span><span>></span></span>链接到b.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/photo/c.html<span>"</span></span><span>></span></span>链接到c.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/photo/ours/d.html<span>"</span></span><span>></span></span>链接到d.html<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>在服务器上，根目录即代表网站主页所在的目录。网站服务器一般只能访问网站主页所在文件夹内的文件与文件夹。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub</title>
      <link>https://0808200.xyz/code/github/</link>
      <guid>https://0808200.xyz/code/github/</guid>
      <source url="https://0808200.xyz/rss.xml">GitHub</source>
      <category>GitHub</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="快速上手" tabindex="-1"> 快速上手</h2>
<ul>
<li>
<p><a href="/code/github/intro.html">GitHub 介绍</a></p>
</li>
<li>
<p><a href="/code/github/pr.html">Pull Request</a></p>
</li>
<li>
<p><a href="/code/github/semantic.html">语义化提交</a></p>
</li>
<li>
<p><a href="/code/github/pages.html">GitHub Pages</a></p>
</li>
<li>
<p><a href="/code/github/speedup.html">利用 Gitee 加速 GitHub 克隆</a></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github" target="_blank" rel="noopener noreferrer">全部文档</a></li>
</ul>
<h3 id="入门指南" tabindex="-1"> 入门指南</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="快速入门" tabindex="-1"> 快速入门</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/set-up-git" target="_blank" rel="noopener noreferrer">设置 Git</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/create-a-repo" target="_blank" rel="noopener noreferrer">创建仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/fork-a-repo" target="_blank" rel="noopener noreferrer">复刻仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/be-social" target="_blank" rel="noopener noreferrer">社交化</a></li>
</ul>
<h3 id="了解-github" tabindex="-1"> 了解 GitHub</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/types-of-github-accounts" target="_blank" rel="noopener noreferrer">账户类型</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/access-permissions-on-github#%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7" target="_blank" rel="noopener noreferrer">GitHub 上的访问权限</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener noreferrer">GitHub 词汇表</a></li>
</ul>
<h2 id="生态系统" tabindex="-1"> 生态系统</h2>
<h3 id="github-cli" tabindex="-1"> GitHub Cli</h3>
<p>GitHub CLI 是用于在计算机上使用 GitHub 功能的命令行工具。</p>
<p>GitHub CLI 是用于从计算机的命令行使用 GitHub 的开源工具。从命令行操作时，您可以使用 GitHub CLI 来节省时间并避免切换上下文。</p>
<p>您可以将以下 GitHub 功能与 GitHub CLI 结合使用。</p>
<ul>
<li>查看、创建、克隆和复刻仓库</li>
<li>创建、关闭和列出议题和拉取请求</li>
<li>审查、差异和合并拉取请求</li>
<li>创建、编辑、列出和查看 Gist</li>
</ul>
<p>有关 GitHub CLI 用途的更多信息，请参阅 <a href="https://cli.github.com/manual" target="_blank" rel="noopener noreferrer">GitHub CLI 手册</a>。</p>
<h3 id="github-desktop" tabindex="-1"> GitHub Desktop</h3>
<p>GitHub Desktop 使用可视界面扩展并简化您的 Git 和 GitHub 工作流程。</p>
<p>GitHub Desktop 是一种开源工具，可帮助您提高工作效率。GitHub Desktop 鼓励您和您的团队使用最佳实践协作处理 Git 和 GitHub。</p>
<p>您可以使用 GitHub Desktop 执行许多任务，包括:</p>
<ul>
<li>以交互方式将更改添加到提交中</li>
<li>快速将合作作者提交到提交中</li>
<li>检出具有拉取请求的分支并查看 CI 状态</li>
<li>比较更改的图像</li>
</ul>
<p>有关 GitHub Desktop 的更多信息，请参阅 GitHub Desktop 文档中的 <a href="https://docs.github.com/cn/free-pro-team@latest/desktop/installing-and-configuring-github-desktop" target="_blank" rel="noopener noreferrer">安装和配置 GitHub Desktop</a>。</p>
<h3 id="手机版-github" tabindex="-1"> 手机版 GitHub</h3>
<p>从移动设备对 GitHub 上的工作进行分类、协作和管理。</p>
<p>手机版 GitHub 目前作为 Android 和 iOS app 提供给 GitHub.com 用户。</p>
<p>手机版 GitHub 为您提供随时随地快速高效使用 GitHub 的方式。手机版 GitHub 是通过可信的第一方客户端应用程序访问 GitHub 数据的安全可靠方式。</p>
<p>通过 手机版 GitHub，您可以:</p>
<ul>
<li>管理、分类和清除通知</li>
<li>阅读、审查及协作处理问题和拉取请求</li>
<li>搜索、浏览用户、仓库和组织以及与之交互</li>
<li>当有人提及您的用户名时收到推送通知</li>
</ul>
<h4 id="安装-手机版-github" tabindex="-1"> 安装 手机版 GitHub</h4>
<p>要安装 Android 或 iOS 版 手机版 GitHub，请参阅 <a href="https://github.com/mobile" target="_blank" rel="noopener noreferrer">手机版 GitHub</a>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>自动部署</title>
      <link>https://0808200.xyz/code/github/deploy.html</link>
      <guid>https://0808200.xyz/code/github/deploy.html</guid>
      <source url="https://0808200.xyz/rss.xml">自动部署</source>
      <description>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。
</description>
      <category>GitHub</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>

<div><p>提示</p>
<p>由于 Centos 仍然是用 GitV1，本教程使用 Ubuntu 20.04 进行教学。</p>
</div>
<h2 id="服务器" tabindex="-1"> 服务器</h2>
<p>为了能供自动部署到服务器，我们需要让服务器的网站目录成为一个 Git 仓库，这样我们可以在 GitHub Actions 中，通过向服务器对应 GitHub 仓库推送网站内容，使服务器网站获得自动更新。下面是服务器侧的部署配置</p>
<h3 id="添加账户" tabindex="-1"> 添加账户</h3>
<p>为了安全，首先需要使用命令创建 Git 用户，为了安全请务必设置密码。</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>之后，查看部署目录所在组，git 用户添加到组中。</p>
<div><pre><code><span>usermod</span> -a -G <span>&lt;</span>目录所在组<span>></span> <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后将部署目录的权限设置为 <code>775</code>，即允许同组访问。这样 git 就有权限访问部署目录。</p>
<h3 id="添加权限" tabindex="-1"> 添加权限</h3>
<p>创建 <code>~/.ssh/</code> 文件夹，生成 <code>authorized_keys</code> 文件，并设置其权限为 <code>600</code>。</p>
<div><pre><code><span>mkdir</span> -p ~/.ssh/

<span>touch</span> ~/.ssh/authorized_keys

<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>之后将需要赋予权限的用户公钥依次粘贴至该文件，这样相关用户即可以使用对应私钥，向服务器相关仓库推送代码。</p>
<h3 id="创建仓库" tabindex="-1"> 创建仓库</h3>
<p>回到 <code>/home/git/</code>，创建所需的文件夹:</p>
<div><pre><code><span>cd</span> ~
<span>mkdir</span> <span>&lt;</span>仓库名<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>进入文件夹，使用</p>
<div><pre><code><span>git</span> init --separate-git-dir<span>=</span>. <span>&lt;</span>部署位置<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这会将 git 库保持在 <code>/home/git/&lt;仓库名&gt;</code> 下，同时将工作区设置到部署文件夹中。</p>
<p>接下来执行:</p>
<div><pre><code><span>git</span> config receive.denyCurrentBranch ignore
<span>git</span> config --global --add safe.directory <span>&lt;</span>部署文件夹<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>注</p>
<p>Git 默认拒绝外部对当前分支的推送操作，因为这可能会覆盖或变更工作区文件。所以我们需要显式通知 Git 不要拒绝当前分支的推送操作。</p>
<p>另外在新版本 Git 中，考虑到安全因素，Git 会在检出时检测项目文件夹是否属于其他组成员，如果检测到会默认拒绝相关操作以防止其他用于获取到本不应该获取到的代码信息。因为部署文件夹的所有者通常不会是 git，所以我们需要标记对应的部署文件夹“安全”。</p>
</div>
<h2 id="github-actions" tabindex="-1"> GitHub Actions</h2>
<p>在 GitHub 一侧，我们需要通过 GitHub Action，在新代码推送时自动构建网站，并部署到 GitHub 的 gh-pages 分支。之后，GitHub Action 将该分支的变动推送服务器的对应仓库，完成网站的自动部署。</p>
<p>之后只需要使用 GitHub Action 通过 Git 推送到 <code>git@&lt;domain&gt;:&lt;部署目录&gt; gh-pages</code> 即可。</p>
<div><pre><code><span># 自动部署的名称</span>
<span>name</span><span>:</span> GitHub pages deploy

<span># 自动部署的条件</span>
<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span># 构建网站并部署到 GitHub Pages</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span># 运行环境</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest

    <span># 步骤</span>
    <span>steps</span><span>:</span>
      <span># 第一步: 下载源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span># action 配置详见 https://github.com/actions/checkout</span>
        <span>uses</span><span>:</span> actions/checkout@v3
        <span>with</span><span>:</span>
          <span># 如果本项目包含了子模块 (git submodules)，需要将此项设置为 true</span>
          <span># submodules: true</span>

          <span># 这是获取历史 commit 的深度，默认为 1，即只拉取最后一个 commit</span>
          <span># 这样可以加快拉取速度</span>
          <span>#</span>
          <span># 如果项目使用 VuePress，为了正确通过 Git 历史提交记录生成页面的最后更新时间</span>
          <span># 需要设置为 0 以拉取完整的 git 历史提交</span>
          <span># fetch-depth: 0</span>

          <span># 如果子模块包含私有仓库，需要设置 ssh key 或 token 以保证拥有拉取相应仓库的权限</span>
          <span># 您可以将 ssh-key 设置为 github 绑定公钥对应的私钥</span>
          <span># 也可以新建一个具有相关仓库访问权限的 github token</span>
          <span># token:</span>

      <span># 缓存 node_modules 以避免重复安装</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v3
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span># 需要缓存的路径</span>
          <span>path</span><span>:</span> node_modules/
          <span># 缓存的 key</span>
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span># 恢复 key</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>

      <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span># 只有没有命中缓存才会执行</span>
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span># 严格按照 yarn.lock 安装依赖</span>
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

      <span># 构建项目</span>
      <span>-</span> <span>name</span><span>:</span> Build
        <span># 项目的构建命令</span>
        <span>run</span><span>:</span> yarn run build

      <span># 第四步，部署</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># action 配置详见 https://github.com/JamesIves/github-pages-deploy-action</span>
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@v4
        <span>with</span><span>:</span>
          <span># 部署到的分支</span>
          <span>branch</span><span>:</span> gh<span>-</span>pages
          <span># 需要部署的文件夹</span>
          <span>folder</span><span>:</span> dist

  <span># 部署到服务器</span>
  <span>deploy-server</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span># 确保在部署到 GitHub Pages 之后执行</span>
    <span>needs</span><span>:</span> deploy<span>-</span>gh<span>-</span>pages
    <span>steps</span><span>:</span>
      <span># 检出网站代码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v3
        <span>with</span><span>:</span>
          <span># 检出 gh-pages 分支</span>
          <span>ref</span><span>:</span> gh<span>-</span>pages
          <span># 获取全部的历史提交</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>

      <span># 配置环境</span>
      <span>-</span> <span>name</span><span>:</span> Configuration environment
        <span># 写入私钥、配置 Git 用户名，写入服务器地址</span>
        <span># 您需要自行将服务器的私钥写入 secrets 的 SSH_PRIVATE_KEY</span>
        <span>run</span><span>:</span> <span>|</span><span>
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan &lt;your domain> >> ~/.ssh/known_hosts
          git config --global user.name 'Your Name'
          git config --global user.email 'You email'</span>

      <span># 部署到服务器</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># 使用 Git 将网站代码强制推送到远程的网站目录</span>
        <span># 并使用 SSH 连接服务器进入网站目录手动切换到最新提交</span>
        <span>run</span><span>:</span> <span>|</span><span>
          git push -f git@&lt;your domain>:&lt;deploy dir> gh-pages
          ssh git@&lt;your domain> "cd &lt;deploy dir> &amp;&amp; git reset --hard HEAD"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>GitHub 简介</title>
      <link>https://0808200.xyz/code/github/intro.html</link>
      <guid>https://0808200.xyz/code/github/intro.html</guid>
      <source url="https://0808200.xyz/rss.xml">GitHub 简介</source>
      <category>GitHub</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="gayhub-github-是世界上最大的-同性交友-代码托管网站" tabindex="-1"> <s>Gayhub</s> GitHub 是世界上最大的 <s>同性交友</s> 代码托管网站</h2>
<p>😋当然在上面交友也是极好的(这是重点，圈起来要考的😎)。</p>
<h2 id="基本概念" tabindex="-1"> 基本概念</h2>
<h3 id="repository" tabindex="-1"> Repository</h3>
<p>仓库。一个仓库即是一个项目。仓库是 GitHub 上的主要内容。每当您新建一个项目并想要在 GitHub。</p>
<h3 id="star" tabindex="-1"> Star</h3>
<p>收藏。在每一个仓库主页的上方可以看到 star 按钮。其上的数值为收藏该项目的人数。点击星星即可将当前仓库收藏到您的账号上。您可以收藏一些您比较喜欢，或者项目对您来说有很大价值的项目。同时，点击数字可以看到哪些人收藏了这个项目。</p>
<h3 id="fork" tabindex="-1"> Fork</h3>
<p>复刻。在每一个仓库主页的上方可以看到 Fork 按钮。点击该按钮的作用是将当前项目复刻一份到自己的仓库中，这样，您就可以在此仓库仓库上查看当前、历史的版本，切换分支、或者是随心所欲的进行修改。原项目的新的推送、对历史版本的修改、甚至原作者删除了他的 repo，都不会对您 fork 的项目产生任何影响。</p>
<h3 id="issue" tabindex="-1"> Issue</h3>
<p>议题。你可将这里理解为 Bug 汇报区与新功能提交区。</p>
<p>如果您在使用该项目的过程中遇到了问题，可以在相应项目的 Issue 板块按照项目的要求提出 Issue。在 Issue 中可以汇报一个 bug，或者是提出一个 Feature Request (功能请求)。项目的拥有者可以针对您汇报的情况对您做出回复。</p>
<p>同时，项目拥有者还可以:</p>
<ul>
<li>为此 issue 增加 label (标签)，以帮助项目成员或是项目的其他使用者更好的理解这个 issue 的分类</li>
<li>将此 issue assign (分派) 给特定的项目成员解决。</li>
<li>将此 issue 加入特定的 project (项目) 以安排处理日期与进度。</li>
</ul>
<div><p>提示</p>
<p>为了 GitHub 的友好交流环境，请在汇报 bug 时永远带上 bug 的一个简易的复现流程，可以直接建立一个简单的 reproduction repo 并把链接放置在您提出的 issue 中。</p>
</div>
<h3 id="pull-request" tabindex="-1"> Pull Request</h3>
<p>发起推送请求，简称 <strong>PR</strong>。如果是您自己的项目，您可以从一个分支向另一个分支发起推送请求。如果您想对别人的(您无权进行推送)项目进行代码的推送请求的化，需要先 fork 这个仓库。在自己 fork 的项目上进行修改，然后提交到自己的项目上，之后，建立一个从自己仓库到对方仓库的 PR。如果对方觉得您的新改动很不错，在经过测试或者 review 后就会接受它，这样原有项目就可拥有这些新的代码了.</p>
<h3 id="dicussion" tabindex="-1"> Dicussion</h3>
<p>GitHub 的讨论区，和 Issue 区主要用于 Bug 和 Feature Request 的追踪不同，通常情况下，你可以在讨论区开帖子询问使用中遇到的问题，以便其他人进行答复。你也可以在 Dicussion 区提供项目的看法与建议，比如对某个功能进行改进的方式以及相关理由。你也可以展示你自己使用项目的一些新的或是与项目相关的一些内容。</p>
<h3 id="watch" tabindex="-1"> Watch</h3>
<p>关注，在每一个仓库主页的上方可以看到 Watch 按钮。如果您关注了某个项目,那么这个项目有了变化的时候,您就会得到通知.在您点击关注后，您还可以点击下拉列表进一步设置关注级别。您可以选择接受 Release (新发布) 通知，也可以选择 Watching 来监听所有的通知。当您选择 Ignore 的话，即使有人在这个仓库中 metion (提到) 了您，您也不会得到通知。</p>
<h3 id="review" tabindex="-1"> Review</h3>
<p>审查。当项目收到 PR 时，项目的拥有成员可以对这份 PR 的代码改动进行审查，在 Review 的过程中，可以对代码的特定行或特定几行通过 comment(评论) 的方式来提出自己对代码改动的意见。</p>
<h2 id="主页" tabindex="-1"> 主页</h2>
<p><img src="@source/code/github/assets/mainPage.png" alt="个人主页"></p>
<p><a href="https://github.com" target="_blank" rel="noopener noreferrer">https://github.com</a></p>
<p>主页，在您登陆后，屏幕的左侧会展示您和您加入团队的项目，以及您的团队详情。中部会显示您关注的项目、人的动态，右侧会根据算法展示一些您可能会感兴趣的 repo。</p>
<h2 id="个人主页" tabindex="-1"> 个人主页</h2>
<p><img src="@source/code/github/assets/profile.png" alt="个人主页"></p>
<p><strong>地址:</strong> <code>https://github.com/&lt;您的用户名&gt;</code></p>
<p>个人主页会有几个主要面板:</p>
<h3 id="overview" tabindex="-1"> Overview</h3>
<p>个人概览，您可以在上方 pin(固定) 最多六个您想要展示给他人的仓库。</p>
<p>下方就是您过去一年里向 GitHub 的提交数量分布图，以及您在 GitHub 上的活动比例。</p>
<p>最下方是近几年您在 GitHub 上的活动记录。</p>
<h3 id="repositories" tabindex="-1"> Repositories</h3>
<p><img src="@source/code/github/assets/personalRepo.png" alt="个人仓库"></p>
<p>仓库列表，该面板会按照最后更新时间的倒序，展示该用户拥有的所有 reo，同时也会在面板上展示项目的 Descript(描述)、Star 数、Fork 数、语言、协议、标签，以及过去一年内项目的 commit 分布数量。这些都能够帮助浏览者在不进入具体仓库页面的情况下大致了解每一个仓库的内容、欢迎程度与维护情况。</p>
<h3 id="projects" tabindex="-1"> Projects</h3>
<p>个人拥有的项目，在管理自己与团队跨仓库的活动日程时很有用。可以设置涉及到的仓库，提出任务、代办、时间表等。</p>
<h3 id="packages" tabindex="-1"> Packages</h3>
<p>个人在 GitHub 上拥有的包。目前较少人在 GitHub 上发布相关的包。</p>
<h3 id="stars" tabindex="-1"> Stars</h3>
<p>和仓库列表完全相同，只不过展示该用户收藏的 repo。</p>
<h3 id="followers-following" tabindex="-1"> Followers / Following</h3>
<p>关注您的人 / 关注的人。在个人主页的左侧就有 follow 按钮，follow 一个人意味着这个人在 GitHub 的的活动会出现在 GitHub 主页的 Activity List 上。</p>
<h2 id="仓库主页" tabindex="-1"> 仓库主页</h2>
<p><img src="@source/code/github/assets/repo.png" alt="仓库主页"></p>
<p>仓库主页主要显示项目的信息。从左到右的面板依次是: Code(代码)，Issues (问题)、Pull Requests (提交请求)、Actions (自动流程)、 Projects (项目)、 Wiki (项目介绍)、 Security (项目安全)、 Insights (项目数据统计) 与 Settings (项目设置)。</p>
<p>在下方会展示代码文件以及项目说明 README.md 文件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Pages</title>
      <link>https://0808200.xyz/code/github/pages.html</link>
      <guid>https://0808200.xyz/code/github/pages.html</guid>
      <source url="https://0808200.xyz/rss.xml">GitHub Pages</source>
      <description>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。
您可以将站点托管在 GitHub 的 github.io 域名或您自己的自定义域名上。
</description>
      <category>GitHub</category>
      <pubDate>Sat, 20 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。</p>
<p>您可以将站点托管在 GitHub 的 <code>github.io</code> 域名或您自己的自定义域名上。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>GitHub Pages 站点共有三种类型: 项目，用户和组织。</p>
<p>项目站点连接到 GitHub 上托管的特定项目，而用户和组织站点已连接到特定的 GitHub 帐户。</p>
<ul>
<li>要发布用户站点，您必须创建一个名为的用户帐户拥有的存储库 <code>&lt;username&gt;.github.io</code>。</li>
<li>要发布组织站点，您必须创建一个名为的组织所拥有的存储库 <code>&lt;organization&gt;.github.io</code>。</li>
</ul>
<p>除非您使用自定义域名，否则用户站点和组织站点均位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p>
<p>项目站点的源文件与其项目存储在同一存储库中。除非您使用自定义域，否则项目站点可在 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 访问。</p>
<p>虽然您只能在 GitHub 上为每个帐户创建一个用户或组织站点。但无论是组织还是用户帐户拥有的项目站点都是无限的。</p>
<h2 id="发布源文件到-github-pages" tabindex="-1"> 发布源文件到 GitHub Pages</h2>
<div><p>警告</p>
<p>GitHub Pages 站点 默认在互联网上公开，即使站点的仓库是私有的。</p>
</div>
<p>如果您的存储库中存在默认发布源，则 GitHub Pages 将自动从该源发布网站。用户和组织站点的默认发布源是存储库的默认分支的根目录。项目站点的默认发布源是 gh-pages 分支的根目录。</p>
<p>您需要跳转到 Settings (设置) 选项卡，下来找到 GitHub Pages 的配置部分。</p>
<div><p>提示</p>
<p>您只能在根目录 (<code>/</code>) 和 文档目录 (<code>/docs</code>) 之间进行选择，而不能将仓库内的任意文件夹作为发布源。</p>
</div>
<h3 id="静态站点" tabindex="-1"> 静态站点</h3>
<p>GitHub Pages 发布您推送到存储库的所有静态文件，这意味它不支持服务器端语言，例如 PHP，Ruby 或 Python。也就是您只能通过 GitHub Pages 发布 “无后端” 的纯静态站点。</p>
<h3 id="限制" tabindex="-1"> 限制</h3>
<ul>
<li>
<p>GitHub Pages 网站不得超过 1 GB。</p>
</li>
<li>
<p>GitHub Pages 站点的带宽限制为每月 100GB。</p>
</li>
<li>
<p>GitHub Pages 站点限制为每小时最多构建 10 次。</p>
</li>
</ul>
<h3 id="子模块" tabindex="-1"> 子模块</h3>
<p>如果 GitHub Pages 站点的仓库包含子模块，则在构建站点时会自动拉取其内容。</p>
<p>只能使用指向公共仓库的子模块，因为 GitHub Pages 服务器无法访问私有仓库。</p>
<p>对子模块 (包括嵌套子模块) 使用 <code>https://</code> 只读 URL。 您可以在 .gitmodules 文件中进行此更改。</p>
<h2 id="取消发布" tabindex="-1"> 取消发布</h2>
<h3 id="取消发布项目站点" tabindex="-1"> 取消发布项目站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>如果仓库中存在 gh-pages 分支，请删除 gh-pages 分支。</li>
<li>在仓库名称下，单击 Settings (设置) 。</li>
<li>在“ GitHub Pages”下，使用 Source (源) 下拉菜单并选择 None (无) 。</li>
</ol>
<h3 id="取消发布用户或组织站点" tabindex="-1"> 取消发布用户或组织站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>删除用作发布源的分支，或删除整个仓库。</li>
</ol>
<h2 id="自定义域名" tabindex="-1"> 自定义域名</h2>
<p>您可以在对应仓库的 Settings (设置) 选项卡设置自定义域名，同时您需要将自定义域名的 CNAME 记录指向 <code>&lt;用户名&gt;.github.io</code>。</p>
<div><p>提示</p>
<p>自定义域名的控制是由发布源文件夹下的 CNAME 文件控制的，您可以直接创建这个文件写入链接。</p>
<p>同时，GitHub Pages 要求这个文件一直存在，否则自定义域名会失效。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Pull Request</title>
      <link>https://0808200.xyz/code/github/pr.html</link>
      <guid>https://0808200.xyz/code/github/pr.html</guid>
      <source url="https://0808200.xyz/rss.xml">Pull Request</source>
      <category>GitHub</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>对于一个用户的公开仓库，在默认情况下虽然其他用户可以拉取该库的代码，但是他们并不能够直接向这个库进行推送。</p>
<p>GitHub 是一个代码社区，这意味着鼓励大家互相提交与贡献代码。所以这就是 Fork 和 Pull Request 出现的意义。没有人会给一个陌生人添加访问自己仓库的权限，所以我们需要一种方式，能够让大家向仓库所有者发起贡献代码的请求。这就是 pull request 的由来。</p>
<h2 id="提交自己贡献的代码" tabindex="-1"> 提交自己贡献的代码</h2>
<p>对于代码贡献者来说，他需要用一种方法将自己贡献的代码推送到远程库上，以便发起请求，最好的办法就是 fork 原仓库。</p>
<p><img src="@source/code/github/assets/fork.png" alt="Fork 仓库"></p>
<div><p>相关信息</p>
<p>相关介绍，请见 <a href="/code/github/intro.html#fork">GitHub 简介 → fork</a></p>
</div>
<p>这样，贡献者在自己的账号上获得一个和原仓库完全相同的副本。</p>
<p>既然副本已经创建在自己的账号上，贡献者自然可以:</p>
<ol>
<li>克隆这个项目到本地</li>
<li>在这个项目上贡献自己的代码</li>
<li>将贡献的代码推送到这个副本上</li>
</ol>
<h2 id="发送请求" tabindex="-1"> 发送请求</h2>
<p>pull request 是请求仓库所有者拉取指定仓库分支代码的请求。</p>
<p>在贡献自己的代码并推送到自己的 fork 仓库后，贡献者即可到原仓库去选择自己仓库的对应分支发送这个拉取请求。仓库所有者随时可以批准这个更改，使其自动添加到自己的库中，或是拒绝这个请求。</p>
<p><img src="@source/code/github/assets/pull-request.png" alt="Pull request"></p>
<blockquote>
<p>这个仓库我已经删了所以显示 <code>unknown repository</code>，原为 <code>Mister-Hope:master</code></p>
</blockquote>
<p>这个页面允许所有人在主要对话线上交换自己的意见。</p>
<p>在 Pull request 里，一旦请求被创建，仓库所有者应该可以直观地看到哪些文件发生了怎样的改变。</p>
<p><img src="@source/code/github/assets/file-changes.png" alt="文件改动"></p>
<p>同时，他们也可以对贡献者的代码进行审查，对特定行或片段标注，并陈述自己的意见，同时将这个意见根据程度标注为“探讨”、“改进”或者“必须更改”，以便贡献者进行交流讨论与完善修改。</p>
<p><img src="@source/code/github/assets/pull-request-review.png" alt="代码审查"></p>
<p>同时，对于一个大型库来说，仓库所有者应该可以看到贡献的代码是否通过了所有测试。</p>
<p><img src="@source/code/github/assets/pull-request-check.png" alt="测试通过情况"></p>
<p>如果审查者认为没有问题，他可能就会通过这个拉取请求，拉取对应的代码到自己的仓库上。这样您就完成了对这个仓库的贡献。</p>
<h2 id="同步原仓库" tabindex="-1"> 同步原仓库</h2>
<p>需要注意的是，fork 创建的是一个时刻副本，也就是自己 fork 产生的仓库，会保持 fork 时的状态，原仓库的任何变动都不会自动同步到 fork 的仓库上。</p>
<p>有些时候，在自己 fork 原仓库、自己编写代码并提交的这段时间里，原仓库已经进行了很多提交。这时，我们就需要同步原仓库的更新到自己的副本上，以确保自己贡献的代码并未和新增代码发生冲突、可以正常工作。</p>
<p>这个时候只需反向拉取，在自己的仓库创建原仓库特定分支到自己仓库特定分支的 Pull request，并批准这个 pull request。这样即可很方便的将原仓库特定分支的更新同步到自己的副本上。</p>
<p>您当然可以在本地添加原仓库的远程库，将最新的更改直接 fetch 到本地，在本地测试通过并完成合并后，由本地推送至自己的 fork 仓库。</p>
]]></content:encoded>
    </item>
    <item>
      <title>语义化提交</title>
      <link>https://0808200.xyz/code/github/semantic.html</link>
      <guid>https://0808200.xyz/code/github/semantic.html</guid>
      <source url="https://0808200.xyz/rss.xml">语义化提交</source>
      <category>GitHub</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="semantic" tabindex="-1"> Semantic</h2>
<p>对于一个大型项目，几千个 commit 是很常见的，这些 commit 部分是项目维护者提交的 commit，部分是一些热心的开发者通过 PR 贡献的。</p>
<p>无论是对于项目维护者，还是想要贡献代码的热心开发者来说，一个简洁明了的 commit 描述都是必不可少的。也就是说我们需要用尽可能简短的备注信息，备注每一个 commit 的作用，以便大家查看。所以我们需要一种规范的，语义化的备注格式，很快由知名项目牵头，全球接收并统一了一种语义化的备注格式，这就是 semantic 规范的来源。</p>
<h2 id="优势" tabindex="-1"> 优势</h2>
<p>当一个仓库所有的 commit 信息都是用标准的 semantic 格式时，用户可以很方便的理解每一个 commit 的作用。</p>
<p>同时，senmantic 支持直接将某个提交或 PR 与特定 issue 链接，并自动关闭或引用这些 issue。</p>
<p>通过一些第三方工具，大家可以基于这些备注信息进行过滤查找，更新日志生成等操作。</p>
<h2 id="格式" tabindex="-1"> 格式</h2>
<div><pre><code>&lt;type>(&lt;scope>): &lt;subject>
&lt;body>

&lt;footer>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="header" tabindex="-1"> header</h3>
<p>第一行被称为 <code>header</code>，它必须只有一行，包括三个字段: <code>&lt;type&gt;</code>(必需)、<code>&lt;scope&gt;</code>(可选)和 <code>&lt;subject&gt;</code>(必需)</p>
<h3 id="type" tabindex="-1"> type</h3>
<p>commit 的类型。</p>
<p>规范中规定了如下类型:</p>
<ul>
<li><code>feat</code>: feature, 新增功能</li>
<li><code>fix</code> : bug fix, 修复 bug</li>
<li><code>docs</code>: documentation, 仅仅修改了文档，如 <code>README.md</code></li>
<li><code>style</code>: style, 仅仅是对格式进行修改，如逗号、缩进、空格等，不改变代码逻辑</li>
<li><code>refactor</code>: refactor, 代码重构，一般更改了源文件或测试文件，但没有新增功能或修复 bug</li>
<li><code>perf</code>: preformance, 优化相关，如提升性能、用户体验等</li>
<li><code>test</code>: test, 测试用例，包括单元测试，集成测试</li>
<li><code>chore</code>: chore, 对于库的其他内容的改变，一般不涉及到源文件或测试文件，比如更改 CI 设置，提升仓库以来等</li>
<li><code>revert</code>: 版本回滚</li>
</ul>
<h3 id="scope" tabindex="-1"> scope</h3>
<p>用于说明 commit 影响的范围，比如: <code>views</code> , <code>component</code>, <code>utils</code>, <code>test</code>。这个是由项目的内容与结构决定的。</p>
<h3 id="subject" tabindex="-1"> subject</h3>
<p>commit 目的的简短描述，最好小于 50 字符，一般不超过 65 个字符，最长不超过 80 字符。</p>
<p>当 subject 限制的字符数无法详细说明此 commit 的变动时，将 commit 的具体变动放置在 body 中</p>
<h3 id="body" tabindex="-1"> body</h3>
<p>对本次 commit 修改内容的具体描述，可以分为多行。<code>body</code> 是可选的，而且 <code>body</code> 可以有多行。</p>
<h3 id="footer" tabindex="-1"> footer</h3>
<p>可选的，前面有一空行。可以添加一些备注，一般放置 <code>BREAKING CHANGE</code>(一些破坏性的变动) 或修复的 bug(涉及的 issue)的链接。</p>
<h2 id="semantic-commit-与-changelog-生成" tabindex="-1"> Semantic commit 与 Changelog 生成</h2>
<p>不同语言环境都有很多种工具来帮助您创建一个 semantic commit 或者自动生成 changelog。</p>
<div><p>案例</p>
<p>Node.js 环境下可以使用:</p>
<ul>
<li>
<p><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noopener noreferrer"><code>cz-conventional-changelog</code></a> 提供 <code>git cz</code> 命令辅助创建 semantic commit。</p>
</li>
<li>
<p><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener noreferrer"><code>conventional-changelog-cli</code></a> 来快速生成更新日志，如 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">vuepress-theme-hope 的更改日志</a></p>
</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>加速 GitHub 克隆</title>
      <link>https://0808200.xyz/code/github/speedup.html</link>
      <guid>https://0808200.xyz/code/github/speedup.html</guid>
      <source url="https://0808200.xyz/rss.xml">加速 GitHub 克隆</source>
      <category>GitHub</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于天朝墙的存在，GitHub 的访问速度在大部分国内地区都很慢。如果需要克隆体积比较大的项目，可能需要很长时间，也很大概率会在中途因为网络波动、终端问题导致克隆失败。</p>
<p>本文介绍如何使用 Gitee 加快 GitHub 项目克隆。</p>
<h2 id="gitee" tabindex="-1"> Gitee</h2>
<p>Gitee 又称码云，是一个国内的代码托管商，国内访问 Gitee 的速度是十分 Amazing 的。</p>
<h3 id="注册" tabindex="-1"> 注册</h3>
<p>Gitee 账户可以很方便的通过 GitHub 账户 + 绑定手机号注册。</p>
<h3 id="添加公钥" tabindex="-1"> 添加公钥</h3>
<p>完成注册后，您需要上传本地公钥，以保证可以从 Gitee 上拉取或克隆，其步骤与 GitHub 大致相同。</p>
<h3 id="导入-github-仓库" tabindex="-1"> 导入 GitHub 仓库</h3>
<p>码云的企业专线访问 GitHub 的速度很快，而码云在新建仓库的时候提供了导入选项，这就给我们的加速提供了方式。</p>
<p>我们只需要在码云上新建仓库，选择导入，然后输入自己想要克隆的 GitHub 仓库地址，交给码云完成导入即可。</p>
<p>稍等片刻后，码云即会将 GitHub 的仓库同步到自己的服务器上，此时我们只需要克隆码云上的这个仓库地址，就可以高速克隆这个项目。</p>
<h3 id="远程库地址修改" tabindex="-1"> 远程库地址修改</h3>
<p>在克隆完毕后，本地的 origin 远程库会默认为 Gitee 的仓库，此时我们需要使用 <code>git remote rename origin gitee</code> 命令，将码云的远程仓库重命名为 <code>gitee</code>，并使用 <code>git remote add origin &lt;github url&gt;</code> 命令重新添加 GitHub 的远程仓库为 origin。</p>
<p>这样我们稍后在做出本地提交后，即可直接推送到 GitHub 仓库。</p>
<h3 id="同步仓库" tabindex="-1"> 同步仓库</h3>
<p>如果以导入的形式创建码云仓库。则可以随时点击仓库页面上的同步图标，让码云随时拉取最新的 gitee 代码，以便在本地通过 <code>git fetch gitee</code>，通过码云服务器高速拉取最新代码。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Token</title>
      <link>https://0808200.xyz/code/github/token.html</link>
      <guid>https://0808200.xyz/code/github/token.html</guid>
      <source url="https://0808200.xyz/rss.xml">GitHub Token</source>
      <description>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。
</description>
      <category>GitHub</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。</p>

<h2 id="创建个人访问令牌" tabindex="-1"> 创建个人访问令牌</h2>
<ol>
<li>
<p>访问 <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener noreferrer">新建 Token 页面</a> (当然您需要先登陆 GitHub)</p>
<blockquote>
<p>或者可以点击头像 → Settings → Developer settings → Personal access tokens → Generate new Token</p>
</blockquote>
</li>
<li>
<p>输入一个备注，选择您需要授权 Token 访问的内容，之后点击页面底部的 &quot;Generate Token&quot;</p>
</li>
<li>
<p>妥善保存该 Token (因为您无法再次查看它)</p>
</li>
</ol>
<p>详见 <a href="https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token" target="_blank" rel="noopener noreferrer">创建个人访问令牌</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>代码学习教程</title>
      <link>https://0808200.xyz/code/language/</link>
      <guid>https://0808200.xyz/code/language/</guid>
      <source url="https://0808200.xyz/rss.xml">代码学习教程</source>
      <category>教程</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li><a href="/code/language/learning.html">如何学习一门语言</a></li>
</ul>
<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/language/js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/python/">Python 教程</a> (编写中...)</p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener noreferrer">Java 教程</a>(廖雪峰的博客)</p>
</li>
<li>
<p><a href="/code/language/markdown/">Markdown 教程</a></p>
</li>
<li>
<p><a href="/code/language/yaml/">YAML 教程</a></p>
</li>
<li>
<p><a href="/code/language/json/">JSON 教程</a></p>
</li>
</ul>
<h2 id="linter" tabindex="-1"> Linter</h2>
<ul>
<li><a href="/code/language/linter/">Linter 介绍</a></li>
</ul>
<div><p>提示</p>
<p>C 、C++、Java、PHP 正在编写中...</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>如何学习一门计算机语言</title>
      <link>https://0808200.xyz/code/language/learning.html</link>
      <guid>https://0808200.xyz/code/language/learning.html</guid>
      <source url="https://0808200.xyz/rss.xml">如何学习一门计算机语言</source>
      <category>教程</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="如何学习一门计算机语言" tabindex="-1"> 如何学习一门计算机语言</h1>
<div><p>提示</p>
<p>学习一门语言的基本顺序是:</p>
<ul>
<li>了解数据结构</li>
<li>了解变量声明与赋值</li>
<li>了解判断和循环体结构</li>
<li>了解函数声明</li>
<li>了解输入输出</li>
</ul>
<p>本部分将以 JS 作为示例，展示什么是一门计算机语言，应该如何学习它们。</p>
</div>
<h2 id="基础" tabindex="-1"> 基础</h2>
<p>首先，任何语言都是由一些基本结构组成的，下面介绍几乎所有语言共有的一些概念:</p>
<h3 id="语句" tabindex="-1"> 语句</h3>
<p>语句可以简单理解为一个操作，它可以是赋值，也可以是执行，还可以是介于或者是可以归类到两者上的判断、声明、标记等。</p>
<p>请注意一条语句通常是一个计算机语言描述的最小操作。</p>
<p>比如:</p>
<div><pre><code><span>let</span> a <span>=</span> <span>1</span><span>;</span> <span>// 赋值</span>
<span>alert</span><span>(</span><span>"Hello word"</span><span>)</span><span>;</span> <span>// 调用函数 执行操作</span>
<span>if</span> <span>(</span>a <span>></span> <span>2</span><span>)</span> <span>{</span>
  <span>// 判断</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="代码块" tabindex="-1"> 代码块</h3>
<p>通常情况下，在有了语句概念后，我们就要使用不同的语句顺序，完成不同的操作，但是某些操作总是固定的。</p>
<p>比如回家，总是 “掏出钥匙”-“插入钥匙”-“转动钥匙”-“开启房门”-“拔出钥匙”-“进入”-“关闭房门” 。</p>
<p>这些步骤每一步都可以理解为一个语句，但是由于其顺序基本是固定的，我们就可以设计一个代码块，来约束它们。</p>
<div><pre><code>{
  “掏出钥匙”;
  “插入钥匙”;
  “转动钥匙”;
  “开启房门”;
  “拔出钥匙”;
  “进入”;
  “关闭房门”;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>大多数语言会使用 <code>{ }</code> 的形式，少数语言会使用统一的缩进进行表达。</p>
<h2 id="数据结构" tabindex="-1"> 数据结构</h2>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。</p>
<p>任何语言都是操作、计算(处理)、生成数据的。数据结构是一门语言存放数据的方式。不同的数据，需要定义不同的数据类型。了解了数据结构就了解了一门语言可以存储或处理何种数据。</p>
<p>大多数语言都包含了以下的一种或多种内容:</p>
<ul>
<li>
<p>数字:</p>
<p>不同语言对数字有不同的处理方式，少数语言可能只有数字这一种类型，一些语言可能会拆分成整数与浮点数。一些底层语言(涉及到内存)可能会魔鬼的将数字拆分为: 整型、浮点数、无符号整型、长整型、无符号长整形、长浮点数。(说的就是您，C 语言)</p>
</li>
<li>
<p>字符串:</p>
<p>一些语言只有字符串这个概念，一些语言分为字符和字符串这个概念。</p>
</li>
<li>
<p>布尔值:</p>
<p>几乎所有语言都有布尔值，布尔值只有真和假两种类型。大多数会表示为 <code>true</code> 和 <code>false</code>，少数会表示为 <code>True</code> 和 <code>False</code>。</p>
</li>
<li>
<p>数组:</p>
<p>大部分语言都有数组 (Array) 这个概念，它是一个有序的元素集合。很多底层语言就是靠数组实现的字符串 (因为字符串长度不固定)。在数组中，每个元素具有标号，从 0 开始依次递增。</p>
<p>一些语言还有 Set 这个概念，Set 表示的是无序元素集合，所有元素没有先后与标号的概念，自然 Set 也无法存入相同的元素。</p>
</li>
<li>
<p>对象:</p>
<p>大部分语言的对象 (Object) 都是由键值对组成的，它是一个由键标记的元素集合，可以使用特定的键名写入或读取其对应的值。</p>
<p>一些产生较晚的语言，将对象改为 Map，Map 表达一个映射，将对应的键映射到对应的值上。</p>
</li>
<li>
<p>类:</p>
<p>类 (Class) 是一个内容集合，它包含了自己的构造器、变量与方法。类在声明后，可以很轻松的使用构造器创建一个新的实例。每个实例可以用其内部的变量维护或表达一个状态，并可以使用它自身的方法来读取或是改变自己的状态。不同的类之间还可以进行继承。</p>
</li>
</ul>
<h2 id="变量" tabindex="-1"> 变量</h2>
<p>一个<strong>变量</strong>是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。</p>
<p>下面的语句创建(换句话说，<strong>声明</strong>或者<strong>定义</strong>)了一个名称为“message”的变量:</p>
<div><pre><code><span>let</span> message<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在有了变量之后，我们就可以将刚了解的数据结构赋值给变量，以变量来代替这些数据。</p>
<div><pre><code><span>let</span> user <span>=</span> <span>"John"</span><span>;</span>
<span>let</span> age <span>=</span> <span>25</span><span>;</span>
<span>let</span> message <span>=</span> <span>"Hello"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="条件" tabindex="-1"> 条件</h2>
<p>条件运算符用于判断，通过判断一个条件的真假，来执行不同的逻辑。这是每一门语言逻辑结构的基础。</p>
<div><pre><code><span>let</span> year <span>=</span> <span>2015</span><span>;</span>
<span>if</span> <span>(</span>year <span>&lt;</span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too early..."</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span>year <span>></span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too late"</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Exactly!"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="循环" tabindex="-1"> 循环</h2>
<p>循环运算符的作用，是在条件控制下，零次或多次执行特定代码块。它使得重复执行成为了可能。</p>
<div><pre><code><span>let</span> result <span>=</span> <span>0</span><span>;</span>
<span>let</span> i <span>=</span> <span>1</span><span>;</span>

<span>while</span> <span>(</span>i <span>&lt;=</span> <span>100</span><span>)</span> <span>{</span>
  <span>// 计算1+2+3+...+100的结果</span>
  i <span>=</span> i <span>+</span> <span>1</span><span>;</span>
  result <span>=</span> result <span>+</span> i<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>// 结果为 0、1、2</span>
  <span>alert</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="函数" tabindex="-1"> 函数</h2>
<p>函数是程序的主要“构建模块”，</p>
<p>创建函数时，需要声明函数内容，函数内容由一系列语句(代码块) 构成。在声明函数后，使用函数即可多次调用一段代码。</p>
<p>例如:</p>
<div><pre><code><span>function</span> <span>showMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Hello everyone!"</span><span>)</span><span>;</span>
<span>}</span> <span>// 声明一个函数</span>

<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 调用它</span>
<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 可以在任意时刻调用它</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同时函数可以通过接受参数的形式来根据情况返回不同的结果，比如这是一个简单的求和函数。</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>sum1<span>,</span> sum2</span><span>)</span> <span>{</span>
  <span>return</span> sum1 <span>+</span> sum2<span>;</span>
<span>}</span>

<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span> <span>// return 3</span>
<span>sum</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span> <span>// return 11</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>小程序</title>
      <link>https://0808200.xyz/code/mini-app/</link>
      <guid>https://0808200.xyz/code/mini-app/</guid>
      <source url="https://0808200.xyz/rss.xml">小程序</source>
      <description>提示
在开发小程序之前。应当掌握 HTML、CSS、JavaScript 基础 以及 ES6。

</description>
      <category>小程序</category>
      <pubDate>Mon, 25 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>提示</p>
<p>在开发小程序之前。应当掌握 <a href="/code/website/html/">HTML</a>、<a href="/code/website/css/">CSS</a>、<a href="/code/language/js/guide/">JavaScript 基础</a> 以及 <a href="/code/language/js/es6/">ES6</a>。</p>
</div>

<h2 id="小程序基础简介" tabindex="-1"> 小程序基础简介</h2>
<p>在微信小程序中主要有四种文件结构: <code>wxml</code>、<code>wxss</code>、<code>js</code> 和 <code>json</code>。其中 <code>wxml</code> 对应带有 vue.js 特征的 html5，<code>wxss</code> 对应 css3，<code>js</code> 对应 ES6 标准的的 javaScript。</p>
<p>对于 QQ 小程序，其文件结构为 <code>QML</code>、<code>qss</code>、<code>js</code> 和 <code>json</code>。</p>
<div><p>提示</p>
<p>QQ 小程序本质还是换汤不换药的，且 QQ 开发者工具兼容 <code>wxml</code> 与 <code>wss</code>)</p>
</div>
<p>小程序开发与网页开发极其相似。所以必须有适当的网页开发基础。零基础的人可能很难直接上手小程序开发。</p>
<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/mini-app/guide/file-structure.html">文件结构</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/env.html">运行环境</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/config/">小程序配置</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/config/app-config.html">全局配置</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/config/page-config.html">页面配置</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/config/sitemap-config.html">sitemap 配置</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/">小程序框架</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/frame/intro.html">框架介绍</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/scene.html">场景值</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/env.html">运行环境</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/mechanism.html">运行机制</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/frame/update.html">更新机制</a> <i>Content not supported</i></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/service/">逻辑层</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/service/lifetime.html">生命周期</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/route.html">路由</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/register.html">注册</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/app.html">App()</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/page.html">Page()</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/run.html">运行</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/module.html">模块化</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/service/api/">API</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/view/">视图层</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/view/wxml.html">WXML</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxss.html">WXSS</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxs.html">WXS</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/event.html">事件</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/component.html">基础组件</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/animation.html">动画</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxs.html">WXS</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/wxs-event.html">WXS 事件</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/model.html">建议双向绑定</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/selector.html">获取界面上的节点信息</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/selector.html">相应显示区域变化</a> <i>Content not supported</i></p>
</li>
<li>
<p><a href="/code/mini-app/guide/view/rendering-cache.html">初始渲染缓存</a> <i>Content not supported</i></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/">小程序能力</a></p>
<ul>
<li>
<p><a href="/code/mini-app/guide/ability/network.html">网络请求</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/storage.html">存储</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/file-system.html">文件系统</a></p>
</li>
<li>
<p><a href="/code/mini-app/guide/ability/debug.html">调试</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="开发者工具" tabindex="-1"> 开发者工具</h2>
<ul>
<li>
<p><a href="/code/mini-app/tools/interface.html">工具界面简介</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/debug.html">调试</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/npm.html">npm</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/audit.html">体验评分</a></p>
</li>
</ul>
<h2 id="官方教程" tabindex="-1"> 官方教程</h2>
<ul>
<li><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener noreferrer">点击前往</a></li>
</ul>
<h2 id="案例" tabindex="-1"> 案例</h2>
<ul>
<li><a href="https://github.com/Hope-Studio/wxminiappdemo" target="_blank" rel="noopener noreferrer">GitHub repository</a></li>
</ul>
<h2 id="mr-googxh-框架说明" tabindex="-1"> Mr.Googxh 框架说明</h2>
<ul>
<li>
<p><a href="/code/mini-app/framework/">小程序框架使用说明</a></p>
</li>
<li>
<p><a href="/code/mini-app/framework/tag-list.html">tag 值参数表</a></p>
</li>
<li>
<p><a href="/code/mini-app/framework/page.html">setPage 库使用说明</a></p>
</li>
<li>
<p><a href="/code/mini-app/framework/simple-debug.html">界面简单开发学习指南</a></p>
</li>
<li>
<p><a href="/code/mini-app/qr-code.html">分享相关</a></p>
</li>
</ul>
<h2 id="学习视频" tabindex="-1"> 学习视频</h2>
<ul>
<li>
<p><a href="https://www.bilibili.com/video/av22790583/" target="_blank" rel="noopener noreferrer">零基础开发小程序</a>(比较新的视频，强调总体思想)</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/av11938917" target="_blank" rel="noopener noreferrer">小程序-从入门到入土</a>(比较老的视频，针对每个组件或者 API 进行了针对的讲解与示范，但部分内容已经与最新官方文档不符)</p>
</li>
</ul>
<h2 id="示例代码" tabindex="-1"> 示例代码</h2>
<ul>
<li>
<p><a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener noreferrer">小程序实例源码</a></p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg" alt="小程序示例二维码"></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://q.qq.com/wiki/" target="_blank" rel="noopener noreferrer">QQ 小程序</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener noreferrer">微信小程序</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/question" target="_blank" rel="noopener noreferrer">微信小程序社区</a>
<ul>
<li><a href="https://developers.weixin.qq.com/community/develop/list/2?id=" target="_blank" rel="noopener noreferrer">官方公告</a></li>
</ul>
</li>
</ul>
<h3 id="qq-开发者工具" tabindex="-1"> QQ 开发者工具</h3>
<p>现在很多功能还处于缺失状态，bug 到没之前那么多了。</p>
<ul>
<li>
<p><a href="https://q.qq.com/wiki/" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
<li>
<p><a href="https://q.qq.com/wiki/tools/devtool/" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
</ul>
<h2 id="微信开发者工具" tabindex="-1"> 微信开发者工具</h2>
<p>微信开发者工具用来开发与调试微信小程序和微信相关网页的官方工具。小程序使用该开发工具进行开发。</p>
<ul>
<li>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="/code/mini-app/tools/">开发者工具教程</a></p>
</li>
<li>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html" target="_blank" rel="noopener noreferrer">官方使用指南</a></p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>小程序分享</title>
      <link>https://0808200.xyz/code/mini-app/qr-code.html</link>
      <guid>https://0808200.xyz/code/mini-app/qr-code.html</guid>
      <source url="https://0808200.xyz/rss.xml">小程序分享</source>
      <category>小程序</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="二维码生成" tabindex="-1"> 二维码生成</h2>
<p>目前小程序二维码生成选用的是<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener noreferrer">无限制生成二维码</a>。</p>
<p>我们使用 Postman 软件进行二维码的获取。</p>
<h3 id="调用凭据获取" tabindex="-1"> 调用凭据获取</h3>
<p>获取任何二维码都需要先获取 <code>access_token</code>，这是小程序全局唯一后台接口调用凭据。<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html" target="_blank" rel="noopener noreferrer">文档地址</a></p>
<p>请求方式为:</p>
<div><pre><code>GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET
</code></pre><div aria-hidden="true"><div></div></div></div><p>更多详情可以见文档。<code>AppSecret</code> 由于权限很大不在此文档中直接放置。</p>
<h3 id="无限制二维码生成" tabindex="-1"> 无限制二维码生成</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<p>在获取 <code>access_token</code> 之后就可以获取小程序二维码了。</p>
<div><pre><code>POST https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN
</code></pre><div aria-hidden="true"><div></div></div></div><p>请注意，在 Postman 软件中，首先要注意使用 <code>post</code> 方法。Body 使用 <code>raw</code>，格式选择 <code>Text</code>，需要将 <code>pretty</code> 化的 JSON 输入即可正常获取二维码。获取完二维码之后，需要在 <code>response</code> 中点击返回图片右上角的 <code>save as</code>，保存为 <code>jpg</code> 格式的文件即可保存二维码。</p>
<h2 id="小程序链接" tabindex="-1"> 小程序链接</h2>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Service_Center_messages.html" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<p>具体格式如下:</p>
<div><pre><code><span><span><span>&lt;</span>a</span>
  <span>href</span><span><span>=</span><span>"</span>不支持小程序时打开的网页<span>"</span></span>
  <span>data-miniprogram-appid</span><span><span>=</span><span>"</span>小程序的appid<span>"</span></span>
  <span>data-miniprogram-path</span><span><span>=</span><span>"</span>小程序路径<span>"</span></span>
  <span>></span></span>文本内容<span><span><span>&lt;/</span>a</span>
<span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://0808200.xyz/code/node-js/</link>
      <guid>https://0808200.xyz/code/node-js/</guid>
      <source url="https://0808200.xyz/rss.xml">Node.js</source>
      <description>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。
</description>
      <category>Node.js</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>

<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/node-js/intro.html">Node.js 介绍</a></p>
</li>
<li>
<p><a href="/code/node-js/install.html">Node.js 与 npm 安装</a></p>
</li>
<li>
<p><a href="/code/node-js/environment.html">Node.js 环境</a></p>
</li>
<li>
<p><a href="/code/node-js/program.html">编程</a></p>
</li>
<li>
<p><a href="/code/node-js/cjs.html">Node.js CJS 模块</a></p>
</li>
</ul>
<p>以上，就是 Node.js 的简易介绍，系统学习可以查看下方的详细教程。</p>
<h2 id="初学者教程" tabindex="-1"> 初学者教程</h2>
<ul>
<li>
<p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener noreferrer">Node.js 入门</a></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn/nodejs/" target="_blank" rel="noopener noreferrer">W3CSchool</a></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/" target="_blank" rel="noopener noreferrer">地址</a></li>
</ul>
<h2 id="yarn" tabindex="-1"> Yarn</h2>
<p>快速、可靠、安全的依赖管理工具。</p>
<ul>
<li>
<p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p>
</li>
<li>
<p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p>
</li>
<li>
<p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
</ul>
<h3 id="命令" tabindex="-1"> 命令</h3>
<ul>
<li>
<p><code>yarn install</code>: 执行安装</p>
</li>
<li>
<p><code>yarn upgrade</code>: 执行升级</p>
</li>
<li>
<p><code>yarn add &lt;package&gt;</code>: 添加一个包</p>
</li>
<li>
<p><code>yarn config set cache-folder &lt;path&gt;</code>: 更改缓存文件夹</p>
</li>
<li>
<p><code>yarn config set registry &lt;registry&gt;</code>: 更改源</p>
<div><p>提示</p>
<p>在国内，建议换成淘宝源 <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener noreferrer">https://registry.npm.taobao.org</a></p>
<p>即执行</p>
<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
</code></pre><div aria-hidden="true"><div></div></div></div></div>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>模块</title>
      <link>https://0808200.xyz/code/node-js/cjs.html</link>
      <guid>https://0808200.xyz/code/node-js/cjs.html</guid>
      <source url="https://0808200.xyz/rss.xml">模块</source>
      <description>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 .js 文件就称之为一个模块(module)。
使用模块有什么好处?
最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。
使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。
</description>
      <category>Node.js</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>
<p>使用模块有什么好处?</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>

<p>在上一节，我们编写了一个 hello.js 文件，这个 hello.js 文件就是一个模块，模块的名字就是文件名(去掉.js 后缀)，所以 hello.js 文件就是名为 hello 的模块。</p>
<p>我们把 hello.js 改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>", "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数 <code>greet()</code> 是我们在 hello 模块中定义的，您可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数 <code>greet</code> 作为模块的输出暴露出去，这样其他模块就可以使用 <code>greet</code> 函数了。</p>
<p>问题是其他模块怎么使用 hello 模块的这个 <code>greet</code> 函数呢? 我们再编写一个 <code>main.js</code> 文件，调用 <code>hello</code> 模块的 <code>greet</code> 函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>// 引入hello模块:</span>
<span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Michael"</span><span>;</span>

<span>greet</span><span>(</span>s<span>)</span><span>;</span> <span>// Hello, Michael!</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意到引入 <code>hello</code> 模块用 Node.js 提供的 <code>require</code> 函数:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>引入的模块作为变量保存在 <code>greet</code> 变量中，那 greet 变量到底是什么东西? 其实变量 <code>greet</code> 就是在 <code>hello.js</code> 中我们用 <code>module.exports = greet;</code> 输出的 <code>greet</code> 函数。所以，<code>main.js</code> 就成功地引用了 <code>hello.js</code> 模块中定义的 <code>greet()</code> 函数，接下来就可以直接使用它了。</p>
<p>在使用 <code>require()</code> 引入模块的时候，请注意模块的相对路径。因为 main.js 和 hello.js 位于同一个目录，所以我们用了当前目录.:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span> <span>// 不要忘了写相对目录!</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果只写模块名:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>则 Node.js 会依次在内置模块、全局模块和当前模块下查找 hello.js，您很可能会得到一个错误:</p>
<div><pre><code>module<span>.</span>js
    <span>throw</span> err<span>;</span>
          <span>^</span>
<span>Error</span><span>:</span> Cannot find module <span>'hello'</span>
    at Function<span>.</span>Module<span>.</span>_resolveFilename
    at Function<span>.</span>Module<span>.</span>_load
    <span>...</span>
    at Function<span>.</span>Module<span>.</span>_load
    at Function<span>.</span>Module<span>.</span>runMain
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>遇到这个错误，您要检查:</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h2 id="commonjs-规范" tabindex="-1"> CommonJS 规范</h2>
<p>这种模块加载机制被称为 <code>CommonJS</code> 规范。在这个规范下，每个 <code>.js</code> 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code> 和 <code>main.js</code> 都申明了全局变量 <code>const s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量(函数也是变量)，可以用 <code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用 <code>const ref = require('module_name');</code> 就拿到了引用模块的变量。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>要在模块中对外输出变量，用:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> variable<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用:</p>
<div><pre><code><span>const</span> foo <span>=</span> <span>require</span><span>(</span><span>"other_module"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h2 id="深入了解模块原理" tabindex="-1"> 深入了解模块原理</h2>
<p>如果您想详细地了解<strong>CommonJS</strong>的模块实现原理，请继续往下阅读。如果不想了解，请结束阅读。</p>
<p>当我们编写 JavaScript 代码时，我们可以申明全局变量:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"global"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在浏览器中，大量使用全局变量可不好。如果您在 <code>a.js</code> 中使用了全局变量 s，那么，在 <code>b.js</code> 中也使用全局变量 s，将造成冲突，<code>b.js</code> 中对 s 赋值会改变 <code>a.js</code> 的运行逻辑。</p>
<p>也就是说，JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那 Node.js 是如何实现这一点的?</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js 也并不会增加任何 JavaScript 语法。实现“模块”功能的奥妙就在于 JavaScript 是一种函数式编程语言，它支持闭包。如果我们把一段 JavaScript 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的 <code>hello.js</code> 代码是这样的:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
<span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>Node.js 加载了 hello.js 后，它可以把代码包装一下，变成这样执行:</p>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
  <span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>// hello.js代码结束</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样一来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。如果 Node.js 继续加载其他模块，这些模块中定义的“全局”变量 <code>s</code> 也互不干扰。</p>
<p>所以，Node.js 利用 JavaScript 的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出 <code>module.exports</code> 怎么实现?</p>
<p>这个也很容易实现，Node.js 可以先准备一个对象 <code>module</code>:</p>
<div><pre><code><span>// 准备module对象:</span>
<span>const</span> module <span>=</span> <span>{</span>
  <span>id</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
<span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>module</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>}</span>

  module<span>.</span>exports <span>=</span> greet<span>;</span>
  <span>// hello.js代码结束</span>
  <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>
<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>)</span><span>;</span>
<span>// 保存module:</span>
<span>save</span><span>(</span>module<span>,</span> exported<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，变量 module 是 Node.js 在加载 js 文件前准备的一个变量，并将其传入加载函数，我们在 <code>hello.js</code> 中可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>通过把参数 <code>module</code> 传递给 <code>load()</code> 函数，<code>hello.js</code> 就顺利地把一个变量传递给了 Node.js 执行环境，Node.js 会把 module 变量保存到某个地方。</p>
<p>由于 Node.js 保存了所有导入的 module，当我们用 <code>require()</code> 获取 module 时，Node.js 找到对应的 module，把这个 module 的 <code>exports</code> 变量返回，这样，另一个模块就顺利拿到了模块的输出:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>以上是 Node.js 实现 JavaScript 模块的一个简单的原理介绍。</p>
<h2 id="module-exports-vs-exports" tabindex="-1"> module.exports vs exports</h2>
<p>很多时候，您会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量:</p>
<p>方法一: 对 module.exports 赋值:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>hello</span><span>:</span> hello<span>,</span>
  <span>greet</span><span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>方法二: 直接使用 exports:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

exports<span>.</span>hello <span>=</span> hello<span>;</span>
exports<span>.</span>greet <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是您不可以直接对 exports 赋值:</p>
<div><pre><code><span>// 代码可以执行，但是模块并没有输出任何变量:</span>
exports <span>=</span> <span>{</span>
  <span>hello</span><span>:</span> hello<span>,</span>
  <span>greet</span><span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您对上面的写法感到十分困惑，不要着急，我们来分析 Node.js 的加载机制:</p>
<p>首先，Node.js 会把整个待加载的 hello.js 文件放入一个包装函数 load 中执行。在执行这个 load()函数前，Node.js 准备好了 module 变量:</p>
<div><pre><code><span>const</span> module <span>=</span> <span>{</span>
  <span>id</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>load()</code> 函数最终返回 <code>module.exports</code>:</p>
<div><pre><code><span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>exports<span>,</span> module</span><span>)</span> <span>{</span>
    <span>// hello.js的文件内容</span>
    <span>...</span>
    <span>// load函数返回:</span>
    <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>

<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>.</span>exports<span>,</span> module<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，默认情况下，Node.js 准备的 <code>exports</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code>，于是，我们可以写:</p>
<div><pre><code>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也可以写:</p>
<div><pre><code>module<span>.</span>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
module<span>.</span>exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>换句话说，Node.js 默认给您准备了一个空对象 <code>{}</code>，这样您可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>给 <code>exports</code> 赋值是无效的，因为赋值后，<code>module.exports</code> 仍然是空对象 <code>{}</code>。</p>
<h2 id="结论" tabindex="-1"> 结论</h2>
<p>如果要输出一个键值对象 <code>{}</code>，可以利用 <code>exports</code> 这个已存在的空对象 <code>{}</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对 <code>module.exports</code> 对象赋值。</p>
<p>所以我们可以得出结论: 直接对 <code>module.export</code>s 赋值，可以应对任何情况:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"foo"</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>或者:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>最终，我们强烈建议使用 <code>module.exports = xxx</code> 的方式来输出模块变量，这样，您只需要记忆一种方法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>搭建 Node 开发环境</title>
      <link>https://0808200.xyz/code/node-js/environment.html</link>
      <guid>https://0808200.xyz/code/node-js/environment.html</guid>
      <source url="https://0808200.xyz/rss.xml">搭建 Node 开发环境</source>
      <description>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Googxh 隆重向大家推荐 Node.js 集成开发环境: Visual Studio Code。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。
</description>
      <category>Node.js</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Googxh 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>

<div><p>相关信息</p>
<p>有关 VS Code 使用教程请<a href="/software/vscode/">访问这里</a></p>
</div>
<h2 id="运行和调试-javascript" tabindex="-1"> 运行和调试 JavaScript</h2>
<p>在 VS Code 中，我们可以非常方便地运行 JavaScript 文件。</p>
<p>VS Code 以文件夹作为工程目录 (Workspace Dir)，所有的 JavaScript 文件都存放在该目录下。此外，VS Code 在工程目录下还需要一个 <code>.vscode</code> 的配置目录，里面存放里 VS Code 需要的配置文件。</p>
<p>假设我们在 <code>C:\Work\</code> 目录下创建了一个 hello 目录作为工程目录，并编写了一个 <code>hello.js</code> 文件，则该工程目录的结构如下:</p>
<div><pre><code>hello/ &lt;-- workspace dir
|
├─ hello.js &lt;-- JavaScript file
|
└─ .vscode/ &lt;-- VS Code config
      |
      └ launch.json &lt;-- VS Code config file for JavaScript
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以用 VS Code 快速创建 <code>launch.json</code>，然后修改如下:</p>
<div><pre><code><span>{</span>
  <span>"version"</span><span>:</span> <span>"0.2.0"</span><span>,</span>
  <span>"configurations"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"name"</span><span>:</span> <span>"Run hello.js"</span><span>,</span>
      <span>"type"</span><span>:</span> <span>"node"</span><span>,</span>
      <span>"request"</span><span>:</span> <span>"launch"</span><span>,</span>
      <span>"program"</span><span>:</span> <span>"${workspaceRoot}/hello.js"</span><span>,</span>
      <span>"stopOnEntry"</span><span>:</span> <span>false</span><span>,</span>
      <span>"args"</span><span>:</span> <span>[</span><span>]</span><span>,</span>
      <span>"cwd"</span><span>:</span> <span>"${workspaceRoot}"</span><span>,</span>
      <span>"preLaunchTask"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeExecutable"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeArgs"</span><span>:</span> <span>[</span><span>"--nolazy"</span><span>]</span><span>,</span>
      <span>"env"</span><span>:</span> <span>{</span>
        <span>"NODE_ENV"</span><span>:</span> <span>"development"</span>
      <span>}</span><span>,</span>
      <span>"externalConsole"</span><span>:</span> <span>false</span><span>,</span>
      <span>"sourceMaps"</span><span>:</span> <span>false</span><span>,</span>
      <span>"outDir"</span><span>:</span> <span>null</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>有了配置文件，即可使用 VS Code 调试 JavaScript。</p>
<h2 id="视频演示" tabindex="-1"> 视频演示</h2>
<ul>
<li><a href="https://www.bilibili.com/video/av5827351/" target="_blank" rel="noopener noreferrer">视频演示</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装 Node.js</title>
      <link>https://0808200.xyz/code/node-js/install.html</link>
      <guid>https://0808200.xyz/code/node-js/install.html</guid>
      <source url="https://0808200.xyz/rss.xml">安装 Node.js</source>
      <description>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。
</description>
      <category>Node.js</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>

<h2 id="安装-node-js" tabindex="-1"> 安装 Node.js</h2>
<p>目前 Node.js 的 LTS 版本是 16.15.1。首先，从 Node.js 官网下载对应平台的安装程序。点击 LTS 版本的下载按钮。</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></li>
</ul>
<h3 id="安装过程" tabindex="-1"> 安装过程</h3>
<ul>
<li>
<p>在 Windows 上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>
<p>在安装过程中，无需勾选 &quot;Automatically install the necessary tools&quot;。选中此项会在电脑中安装 VS 等日常开发使用不到的软件。</p>
<p>安装完成后，在 Windows 环境下，请打开命令提示符，然后输入 <code>node -v</code> ，如果安装正常，您应该看到 <code>v16.15.1</code> 这样的输出:</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>IEUser<span>></span>node -v
v16.15.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>继续在命令提示符输入 node，此刻您将进入 Node.js 的交互环境。在交互环境下，您可以输入任意 JavaScript 语句，例如 <code>100 + 200</code>，回车后将得到输出结果。</p>
<p>要退出 Node.js 环境，连按两次 <code>Ctrl + C</code> 。</p>
</li>
<li>
<p>在 Mac 或 Linux 环境下，请打开终端，然后输入 <code>node -v</code>，您应该看到如下输出:</p>
<div><pre><code>$ <span>node</span> -v
v16.15.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
</ul>
<h2 id="npm" tabindex="-1"> npm</h2>
<p>npm 是 Node.js 的包管理工具(package manager)。</p>
<p>我们在 Node.js 上开发时，会用到很多别人写的 JavaScript 代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生: 大家都把自己开发的模块打包后放到 npm 官网上，如果要使用，直接通过 npm 安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块 A，而模块 A 又依赖于模块 B，模块 B 又依赖于模块 X 和模块 Y，npm 可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm 究竟在哪?</p>
<p>其实 npm 已经在 Node.js 安装的时候顺带装好了。我们在命令提示符或者终端输入 <code>npm -v</code>，应该看到类似的输出:</p>
<div><pre><code>C:<span>\</span><span>></span>npm -v
<span>8.12</span>.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>如果版本号太小，说明 npm 版本较低，请使用此命令升级到最新版本: <code>npm i -g npm</code>。</p>
</blockquote>
<p>如果直接输入 <code>npm</code>，您会看到类似下面的输出:</p>
<div><pre><code>C:<span>\</span><span>></span> <span>npm</span>
<span>npm</span> <span>&lt;</span>command<span>></span>

Usage:

<span>npm</span> <span>install</span>        <span>install</span> all the dependencies <span>in</span> your project
<span>npm</span> <span>install</span> <span>&lt;</span>foo<span>></span>  <span>add</span> the <span>&lt;</span>foo<span>></span> dependency to your project
    <span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的一大堆文字告诉您，npm 需要附带命令。现在我们不用关心这些命令，后面会一一讲到。目前，您只需要确保 npm 正确安装了，能运行就行。</p>
<h2 id="国内镜像站" tabindex="-1"> 国内镜像站</h2>
<p>大家都知道天朝是有墙的，有的时候，访问国外的 Node.js 服务器可能会十分缓慢以至于您想把它砸了。</p>
<p>所以贴心的马云爸爸提供了淘宝镜像源。你可以将 npm 的源配置为国内镜像源，以在每次安装依赖的时候从国内镜像站拉取镜像。这可以极大的提升安装速度。</p>
<div><p>注</p>
<p>如果官方源的速度还可以的话请尽可能使用官方源。</p>
<p>国内源毕竟是镜像站点，同步官方源的包会出现延迟，所以有时候你可能会遇到 <code>version xxx not found</code> 之类的错误，这是因为所需要的版本还没来得及被镜像站点同步所导致。</p>
<p>你可以通过访问 <code>npmmirror.com/sync/&lt;包名&gt;</code> 来手动同步一个包。</p>
</div>
<p>设置及国内源的命令如下:</p>
<div><pre><code><span>npm</span> config <span>set</span> registry https://registry.npmmirror.com/
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>注意</p>
<p><code>https://registry.npm.taobao.org/</code> 是老的淘宝源地址，现已停止维护，请不要使用!!!</p>
</div>
<h2 id="启用-corepack" tabindex="-1"> 启用 Corepack</h2>
<p>Node.js 自带的包管理工具 npm 并不是那么的强大，其安装速度也很慢，所以社区开发了一些其他的包管理工具如 <code>yarn</code> 和 <code>pnpm</code>，它们有自己的优势。</p>
<p>Mr.Googxh 推荐使用 pnpm 进行包管理，因为它使用硬链接索引包文件，安装速度更快而且节省磁盘空间。</p>
<p>从 v16 开始，Node.js 引入了 Corepack 工具，并在 package.json 支持了 <code>packageManager</code> 选项以支持第三方管理工具。</p>
<p>你需要通过下方命令启用 Corepack:</p>
<div><pre><code>corepack <span>enable</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样每个项目会自动应用根目录 package.json 中的 <code>packageManager</code> 选项。比如设置 <code>&quot;packageManager&quot;: &quot;pnpm@7.2.1&quot;</code> 的时候，会自动下载并使用 <code>pnpm@7.2.1</code>。</p>
<div><p>设置全局的 packageManager</p>
<p>你可以使用 <code>corepack prepare packageManager@semver</code> 来全局准备一个 packageManager 版本，并使用 <code>--activate</code> 选新娘 全局激活。</p>
<p>比如以下命令下载 <code>pnpm@7.2.1</code> 并将其作为默认的全局包管理器:</p>
<div><pre><code>corepack prepare pnpm@7.2.1 --activate
</code></pre><div aria-hidden="true"><div></div></div></div></div>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>请在本机安装 Node.js 环境，并确保 Node.js 和 npm 能正常运行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://0808200.xyz/code/node-js/intro.html</link>
      <guid>https://0808200.xyz/code/node-js/intro.html</guid>
      <source url="https://0808200.xyz/rss.xml">Node.js</source>
      <description>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。
Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。
</description>
      <category>Node.js</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>
<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>

<p>众所周知，在 Netscape 设计出 JavaScript 后的短短几个月，JavaScript 事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过 IE 击败了 Netscape 后一统桌面，结果几年时间，浏览器毫无进步。(2001 年推出的古老的 IE 6 到今天仍然有人在使用! )</p>
<p>没有竞争就没有发展。微软认为 IE6 浏览器已经非常完善，几乎没有可改进之处，然后解散了 IE6 开发团队! 而 Google 却认为支持现代 Web 应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行 JavaScript 的引擎性能还可提升 10 倍。</p>
<p>先是 Mozilla 借助已壮烈牺牲的 Netscape 遗产在 2002 年推出了 Firefox 浏览器，紧接着 Apple 于 2003 年在开源的 KHTML 浏览器的基础上推出了 WebKit 内核的 Safari 浏览器，不过仅限于 Mac 平台。</p>
<p>随后，Google 也开始创建自家的浏览器。他们也看中了 WebKit 内核，于是基于 WebKit 内核推出了 Chrome 浏览器。</p>
<p>Chrome 浏览器是跨 Windows 和 Mac 平台的，并且，Google 认为要运行现代 Web 应用，浏览器必须有一个性能非常强劲的 JavaScript 引擎，于是 Google 自己开发了一个高性能 JavaScript 引擎，名字叫 V8，以 BSD 许可证开源。</p>
<p>现代浏览器大战让微软的 IE 浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队! 回过头再追赶却发现，支持 HTML5 的 WebKit 已经成为手机端的标准了，IE 浏览器从此与主流移动端设备绝缘。</p>
<h2 id="浏览器大战和-node-js-的关系" tabindex="-1"> 浏览器大战和 Node.js 的关系</h2>
<p>话说有个叫 Ryan Dahl 的歪果仁，他的工作是用 C/C++写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发 Web 服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript 引擎。让 Google 投资去优化 V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在 2009 年，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。虽然名字很土，但是，Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</p>
<h2 id="在-node-js-上运行的-javascript-相比其他后端开发语言的优势" tabindex="-1"> 在 Node.js 上运行的 JavaScript 相比其他后端开发语言的优势</h2>
<p>最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</p>
<p>其次，JavaScript 语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉 JavaScript 就是个“玩具语言”。但是，在 Node.js 环境下，通过模块化的 JavaScript 代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的 ECMAScript 6 标准，可以完全满足工程上的需求。</p>
<blockquote>
<p>我还听说过 io.js，这又是什么鬼?</p>
</blockquote>
<p>因为 Node.js 是开源项目，虽然由社区推动，但幕后一直由 Joyent 公司资助。由于一群开发者对 Joyent 公司的策略不满，于 2014 年从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</p>
<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent 公司表示要和解，于是，io.js 项目又决定回归 Node.js。</p>
<p>具体做法是将来 io.js 将首先添加新的特性，如果大家测试用得爽，就把新特性加入 Node.js。Io.js 是“尝鲜版”，而 Node.js 是线上稳定版，相当于 Fedora Linux 和 RHEL 的关系。</p>
<p>本章教程的所有代码都在 Node.js 上调试通过。如果您要尝试 io.js 也是可以的，不过两者如果遇到一些区别请自行查看 io.js 的文档。</p>
<h2 id="node-js-相关链接" tabindex="-1"> Node.js 相关链接</h2>
<ul>
<li>
<p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></p>
</li>
<li>
<p><a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener noreferrer">Node.js 最新文档</a></p>
</li>
<li>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/" target="_blank" rel="noopener noreferrer">Node.js 最新 API 文档</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>第一个 Node 程序</title>
      <link>https://0808200.xyz/code/node-js/program.html</link>
      <guid>https://0808200.xyz/code/node-js/program.html</guid>
      <source url="https://0808200.xyz/rss.xml">第一个 Node 程序</source>
      <description>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。
从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。
</description>
      <category>Node.js</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>

<p>那么问题来了: 文本编辑器到底哪家强?</p>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="/code/windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>如果您的电脑上已经安装了<strong>Sublime Text</strong>，或者<strong>Notepad++</strong>，也可以用来编写 JavaScript 代码，注意用 UTF-8 格式保存。</p>
<p>最方便的，当然是 Mr.Googxh 强力安利的 VS Code 了。</p>
<p>输入以下代码:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>"Hello, world."</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>第一行总是写上 <code>'use strict';</code> 是因为我们总是以严格模式运行 JavaScript 代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如 <code>C:\Workspace</code>，把文件保存为 <code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到 hello.js 所在目录，然后输入以下命令运行这个程序了:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
Hello, world.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>也可以保存为别的名字，比如 <code>first.js</code>，但是必须要以 <code>.js</code> 结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有 <code>hello.js</code> 这个文件，运行 <code>node hello.js</code> 就会报错:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
module.js:338
    throw err<span>;</span>
          ^
Error: Cannot <span>find</span> module <span>'C:\Workspace\hello.js'</span>
    at Function.Module._resolveFilename
    at Function.Module._load
    at Function.Module.runMain
    at startup
    at node.js
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>报错的意思就是，没有找到 <code>hello.js</code> 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h2 id="命令行模式和-node-js-交互模式" tabindex="-1"> 命令行模式和 Node.js 交互模式</h2>
<p>请注意区分命令行模式和 Node.js 交互模式。</p>
<p>看到类似 <code>C:\&gt;</code> 是在 Windows 提供的命令行模式:</p>
<p><img src="@source/code/node-js/assets/run-node-hello.png" alt="run-node-hello"></p>
<p>在命令行模式下，可以执行 Node.js 进入 Node.js 交互式环境，也可以执行 Node.js <code>hello.js</code> 运行一个 <code>.js</code> 文件。</p>
<p>看到<code>&gt;</code> 是在 Node.js 交互式环境下:</p>
<p><img src="@source/code/node-js/assets/node-interactive-env.png" alt="node-interactive-env"></p>
<p>在 Node.js 交互式环境下，我们可以输入 JavaScript 代码并立刻执行。</p>
<p>此外，在命令行模式运行.js 文件和在 Node.js 交互式环境下直接运行 JavaScript 代码有所不同。Node.js 交互式环境会把每一行 JavaScript 代码的结果自动打印出来，但是，直接运行 JavaScript 文件却不会。</p>
<p>例如，在 Node.js 交互式环境下，输入:</p>
<div><pre><code><span>></span> <span>100</span> + <span>200</span> + <span>300</span><span>;</span>
<span>600</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>直接可以看到结果 600。</p>
<p>但是，写一个 <code>calc.js</code> 的文件，内容如下:</p>
<div><pre><code><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后在命令行模式下执行:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
</code></pre><div aria-hidden="true"><div></div></div></div><p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用 <code>console.log()</code> 打印出来。把 <code>calc.js</code> 改造一下:</p>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>再执行，就可以看到结果:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
<span>600</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="使用严格模式" tabindex="-1"> 使用严格模式</h2>
<p>如果在 JavaScript 文件开头写上 <code>'use strict';</code>，那么 Node.js 在执行该 JavaScript 时将使用严格模式。但是，在服务器环境下，如果有很多 JavaScript 文件，每个文件都写上 <code>'use strict';</code> 很麻烦。我们可以给 Node.js 传递一个参数，让 Node.js 直接为所有 js 文件开启严格模式:</p>
<div><pre><code><span>node</span> --use_strict calc.js
</code></pre><div aria-hidden="true"><div></div></div></div><p>后续代码，如无特殊说明，我们都会直接给 Node.js 传递 <code>--use_strict</code> 参数来开启严格模式。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>用文本编辑器写 JavaScript 程序，然后保存为后缀为 <code>.js</code> 的文件，就可以用 Node.js 直接运行这个程序了。</p>
<p>Node.js 的交互模式和直接运行 <code>.js</code> 文件有什么区别呢?</p>
<p>直接输入 Node.js 进入交互模式，相当于启动了 Node.js 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行 <code>node hello.js</code> 文件相当于启动了 Node.js 解释器，然后一次性把 <code>hello.js</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>
<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node.js 交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27 寸的超大显示器!</p>
]]></content:encoded>
    </item>
    <item>
      <title>React</title>
      <link>https://0808200.xyz/code/react/</link>
      <guid>https://0808200.xyz/code/react/</guid>
      <source url="https://0808200.xyz/rss.xml">React</source>
      <category>前端</category>
      <pubDate>Fri, 08 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="创建-react-项目" tabindex="-1"> 创建 React 项目</h2>
<p>使用 <code>create-react-app</code> 工具。</p>
<p>创建普通模板:</p>
<div><pre><code>npx create-react-app xxx
</code></pre><div aria-hidden="true"><div></div></div></div><p>创建 TS 模板:</p>
<div><pre><code>npx create-react-app xxx --template typescript
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="react-文档" tabindex="-1"> React 文档</h2>
<ul>
<li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://react.docschina.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">中文文档</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js</title>
      <link>https://0808200.xyz/code/vue/</link>
      <guid>https://0808200.xyz/code/vue/</guid>
      <source url="https://0808200.xyz/rss.xml">Vue.js</source>
      <category>基础</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue.js 是世界上主流的前端框架。</p>
<p>官方介绍为：渐近式 JavaScript 框架。一款用于构建 Web 界面，易学易用，性能出色且功能丰富的框架。</p>
<h2 id="vue-js-教程目录" tabindex="-1"> Vue.js 教程目录</h2>
<ul>
<li>
<p><a href="/code/vue/install.html">开发环境安装</a></p>
</li>
<li>
<p><a href="/code/vue/get-started.html">起步上手</a></p>
</li>
<li>
<p><a href="/code/vue/vue.html">Vue 单文件组件说明</a></p>
</li>
</ul>
<h2 id="vue-生态" tabindex="-1"> Vue 生态</h2>
<h3 id="vue-router" tabindex="-1"> Vue Router</h3>
<ul>
<li>
<p><a href="/code/vue/router/">Vue Router 讲解</a></p>
</li>
<li>
<p><a href="/code/vue/router/demo.html">Vue Router Demo</a></p>
</li>
</ul>
<h3 id="vuex" tabindex="-1"> Vuex</h3>
<ul>
<li>
<p><a href="/code/vue/vuex/">Vuex 讲解</a></p>
</li>
<li>
<p><a href="/code/vue/vuex/demo.html">Vuex Demo</a></p>
</li>
</ul>
<h3 id="vue-cli" tabindex="-1"> Vue Cli</h3>
<ul>
<li>
<p><a href="/code/vue/cli/intro.html">Vue Cli 介绍</a></p>
</li>
<li>
<p><a href="/code/vue/cli/quick-dev.html">使用 Vue Cli 进行快速开发</a></p>
</li>
<li>
<p><a href="/code/vue/cli/file.html">Vue Cli 文件处理</a></p>
</li>
</ul>
<h3 id="其他-vue-生态" tabindex="-1"> 其他 Vue 生态</h3>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/basic/vuepress/" target="_blank" rel="noopener noreferrer">VuePress</a>: 静态站点生成器；</li>
<li><a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener noreferrer">Ant Design Vue</a>: 阿里的一套 UI 组件库；</li>
<li><a href="https://bootstrap-vue.js.org/" target="_blank" rel="noopener noreferrer">BootstrapVue</a></li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue.js 介绍</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer">Vue.js API</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://cli.vuejs.org/zh/guide/cli-service.html" target="_blank" rel="noopener noreferrer">Vue CLI 3 介绍</a></p>
</li>
<li>
<p><a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener noreferrer">Vue CLI 3 配置</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="noopener noreferrer">Vue Router 介绍</a></p>
</li>
<li>
<p><a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener noreferrer">Vue Router 配置</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">Vuex 介绍</a></p>
</li>
<li>
<p><a href="https://vuex.vuejs.org/zh/api/" target="_blank" rel="noopener noreferrer">Vuex 配置</a></p>
</li>
</ul>
<h2 id="其他文档" tabindex="-1"> 其他文档</h2>
<ul>
<li>
<p><a href="/code/vue/component.html">各组件使用说明</a></p>
</li>
<li>
<p><a href="/code/vue/compare.html">Vue 与小程序的异同</a></p>
</li>
<li>
<p>VueConf 视频</p>
<ul>
<li>
<p><a href="https://www.yuque.com/vueconf/2019/qg1yms" target="_blank" rel="noopener noreferrer">Vue Beyond Vue Loader</a></p>
</li>
<li>
<p><a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener noreferrer">尤雨溪演讲视频</a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/VueConf2019SH_Evan.pdf" target="_blank" rel="noopener noreferrer">尤雨溪演讲 PPT</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/intro-to-vuepres-1.x.pdf" target="_blank" rel="noopener noreferrer">VuePress 介绍</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.pdf" target="_blank" rel="noopener noreferrer">Vue 单元测试</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/%E4%BD%BF%E7%94%A8Vue%E5%AE%9E%E7%8E%B00%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92-winter.pdf" target="_blank" rel="noopener noreferrer">使用 Vue 实现 0 代码交互</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%20%E5%BC%80%E5%8F%91%20ECharts%20%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener noreferrer">Echart 与 Vue</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%20Beyond%20Vue%20Loader.pdf" target="_blank" rel="noopener noreferrer">Vue Loader</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Mars%E6%A1%86%E6%9E%B6%E5%88%86%E4%BA%AB-vueconf.pdf" target="_blank" rel="noopener noreferrer">基于 Vue 的多端框架</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 与小程序的异同</title>
      <link>https://0808200.xyz/code/vue/compare.html</link>
      <guid>https://0808200.xyz/code/vue/compare.html</guid>
      <source url="https://0808200.xyz/rss.xml">Vue 与小程序的异同</source>
      <description>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。
</description>
      <category>Vue</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。</p>

<h2 id="优缺点比较" tabindex="-1"> 优缺点比较</h2>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>小程序</td>
<td>小程序底层由微信框架驱动，每个界面是单独的 JS 文件，页面切换以及全局生命周期丰富完善。小程序具有相当完备的 API。</td>
<td>小程序是由 JSCore 驱动逻辑层，视图层采用 Webview，故没有 DOM 节点的概念，只有渲染出的虚拟节点，所以无法动态删除或添加节点，无法使用一切 DOM 相关 API。小程序组件生命周期不够强大。小程序的 Webview 渲染存在一定的性能问题。小程序视图层与逻辑层通过 Jsbridge 连接，数据传输及渲染有延时。</td>
</tr>
<tr>
<td>vue</td>
<td>Vue 的实质是动态监测并托管 DOM 节点。由于 Vue 是网页开发，拥有 DOM 树，可以使用 DOM 相关 API。Vue 组件拥有更全面的生命周期，同时可以动态渲染组件。Vue 的组件传递数据方式默认为单向绑定</td>
<td>由于 Vue 的组件本质是监测 DOM 树，故其组件只能有一个根节点。同时 Vue 的界面路由依赖于 History API，其界面切换周期与逻辑不够强大。</td>
</tr>
</tbody>
</table>
<h2 id="代码区别" tabindex="-1"> 代码区别</h2>
<p>小程序与 Vue 在代码写法上极其相似，但稍有不同。</p>
<h3 id="数据绑定" tabindex="-1"> 数据绑定</h3>
<h4 id="小程序数据绑定" tabindex="-1"> 小程序数据绑定</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span>class</span><span><span>=</span><span>"</span>text1 {{a}} {{b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span>}}<span>"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div>
<p>小程序在所有内容上都使用 Muscle 语法 (<code>{{Javascript表达式}}</code>) 的写法。</p>
</div>
<h4 id="vue-数据绑定" tabindex="-1"> Vue 数据绑定</h4>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>text1<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>a+<span>'</span> <span>'</span>+ b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span><span>"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>Vue 在标签名属性用 <code>v-bind:prop=&quot;Javascript表达式&quot;</code> 的写法、其简写为 <code>:prop=&quot;&quot;</code>，在标签内容处使用 Muscle 语法。</p>
</div>
<h3 id="条件渲染" tabindex="-1"> 条件渲染</h3>
<h4 id="小程序条件渲染" tabindex="-1"> 小程序条件渲染</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>if</span><span><span>=</span><span>"</span>{{condition1}}<span>"</span></span><span>></span></span>板块只有 condition1 为 true 时才会渲染<span><span><span>&lt;/</span>view</span><span>></span></span>


<span><span><span>&lt;</span>block</span> <span><span>wx:</span>if</span><span><span>=</span><span>"</span>{{condition2}}<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>内容1<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>内容2<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>
    <span><span><span>&lt;</span>view</span><span>></span></span>内容3<span><span><span>&lt;/</span>view</span><span>></span></span>
    <span><span><span>&lt;</span>view</span><span>></span></span>内容4<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>
    这是一个拥有很多兄弟标签的代码块.
    虚拟标签 block 会把其当作一个整体用作条件渲染。
  <span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;/</span>block</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html" target="_blank" rel="noopener noreferrer">小程序条件渲染文档</a></p>
</div>
<h4 id="vue-条件渲染" tabindex="-1"> Vue 条件渲染</h4>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>condition<span>"</span></span><span>></span></span>板块只有 condition 为 true 时才会渲染<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>{{condition2}}<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>内容1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>内容2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>内容3<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>内容4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    Vue 没有相关虚拟标签，且只能监听一个标签。所以只能建立一个没有样式的 div
    标签将多个并列标签抱起来。这样 Vue 就会因监听最外层 div
    会把其当作一个整体用作条件渲染。
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 条件渲染文档</a></p>
</div>
<h3 id="循环渲染" tabindex="-1"> 循环渲染</h3>
<h4 id="小程序循环渲染" tabindex="-1"> 小程序循环渲染</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>for</span><span><span>=</span><span>"</span>{{array}}<span>"</span></span> <span><span>wx:</span>for-item</span><span><span>=</span><span>"</span>element<span>"</span></span> <span><span>wx:</span>for-index</span><span><span>=</span><span>"</span>index<span>"</span></span><span>></span></span>
  {{index}} is {{element}}
<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>实际渲染结果为:</p>
<div><pre><code><span><span><span>&lt;</span>view</span><span>></span></span>1<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>2<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>3<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>4<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>5<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html" target="_blank" rel="noopener noreferrer">小程序循环渲染文档</a></p>
</div>
<h4 id="vue-循环渲染" tabindex="-1"> Vue 循环渲染</h4>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>v-for</span><span><span>=</span><span>"</span>(element,index) in array<span>"</span></span><span>></span></span>
       {{index}} is {{ element }}
    <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 循环渲染文档</a></p>
</div>
<h2 id="生命周期" tabindex="-1"> 生命周期</h2>
<h3 id="页面生命周期" tabindex="-1"> 页面生命周期</h3>
<h4 id="小程序生命周期" tabindex="-1"> 小程序生命周期</h4>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" alt="小程序页面生命周期"></p>
<h4 id="vue-页面生命周期" tabindex="-1"> Vue 页面生命周期</h4>
<p><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">Vue 页面生命周期</a></p>
<h3 id="组件生命周期" tabindex="-1"> 组件生命周期</h3>
<h4 id="小程序组件生命周期" tabindex="-1"> 小程序组件生命周期</h4>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html" target="_blank" rel="noopener noreferrer">小程序组件生命周期</a></p>
<h4 id="vue-组件生命周期" tabindex="-1"> Vue 组件生命周期</h4>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue组件生命周期"></p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" type="image/png"/>
    </item>
    <item>
      <title>组件使用说明</title>
      <link>https://0808200.xyz/code/vue/component.html</link>
      <guid>https://0808200.xyz/code/vue/component.html</guid>
      <source url="https://0808200.xyz/rss.xml">组件使用说明</source>
      <description>Mr.Googxh 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。
</description>
      <category>Vue</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>Mr.Googxh 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。</p>

<h2 id="常规组件" tabindex="-1"> 常规组件</h2>
<div><p>提示</p>
<p>所有以 <code>Base</code> 开头的组件都包含如下属性:</p>
<p>| 属性 | 必填 |       类型       | 内容      |
| ---- | :--: | :--------------: | --------- | --- |
| myId |  是  | Number 或 String | 组件的 ID |     |</p>
</div>
<p>以下是项目中中常用的组件。</p>
<h3 id="basehead" tabindex="-1"> BaseHead</h3>
<p>页面标题文字</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>页面选项卡文字</td>
</tr>
</tbody>
</table>
<h3 id="basetitle" tabindex="-1"> BaseTitle</h3>
<p>段落间大标题</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>标题文字</td>
<td></td>
</tr>
<tr>
<td>myStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
</tbody>
</table>
<h3 id="basep" tabindex="-1"> BaseP</h3>
<p>段落文字(可带图)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>段落的文字</td>
<td>可以识别连续的空格，使用 <code>\n</code> 表示回车，也可直接使用 <code>&lt;br /&gt;</code> 换行</td>
</tr>
<tr>
<td>head</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>段落的标题</td>
<td></td>
</tr>
<tr>
<td>headStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
<tr>
<td>myStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td>会在段落后渲染一张图片</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的描述文字</td>
<td>会自动在文字前加 <code>▲</code></td>
</tr>
</tbody>
</table>
<h3 id="baseimg" tabindex="-1"> BaseImg</h3>
<p>图片</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的描述文字</td>
<td>会自动在文字前加 ▲</td>
</tr>
</tbody>
</table>
<h3 id="baselist" tabindex="-1"> BaseList</h3>
<p>列表</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>列表内容</td>
<td></td>
</tr>
<tr>
<td>head</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Boolean</td>
<td>列表的标题</td>
<td>默认为 <code>''</code>，设置 <code>false</code> 取消显示列表标题，否则即使不设置也会显示一个空标题</td>
</tr>
<tr>
<td>foot</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>列表的页脚文字</td>
<td>默认为 <code>''</code>,不显示页脚</td>
</tr>
</tbody>
</table>
<h3 id="basegrid" tabindex="-1"> BaseGrid</h3>
<p>九宫格</p>
<p>| 属性    | 必填 |       类型        | 内容             |
| ------- | :--: | :---------------: | ---------------- | ------------------------------------------------------------------------------ |
| content |  是  |    GirdItem[]     | 九宫格单元内容   |
| head    |  否  | String 或 Boolean | 九宫格的标题     | 默认为 <code>''</code>，设置 <code>false</code> 取消显示九宫格标题，否则即使不设置也会显示一个空标题 |
| foot    |  否  |      String       | 九宫格的页脚文字 | 默认为 <code>''</code>,不显示页脚                                                         |</p>
<ul>
<li><strong>GirdItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>icon</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图标地址</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>文字</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>跳转链接</td>
</tr>
</tbody>
</table>
<h3 id="basefoot" tabindex="-1"> BaseFoot</h3>
<p>页脚</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>页脚额外描述文字</td>
<td></td>
</tr>
<tr>
<td>author</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>作者</td>
<td>默认为 <code>Mr.Googxh</code>，如需取消请传入 <code>''</code></td>
</tr>
<tr>
<td>time</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>最后编辑时间</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basecarousel" tabindex="-1"> BaseCarousel</h3>
<p>轮播图</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center">CarouselItem[]</td>
<td>轮播图组件内容</td>
<td></td>
</tr>
<tr>
<td>vertical</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否竖直显示</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>autoplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否支持自动播放</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>autoplaySpeed</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Number</td>
<td>自动播放时间间隔</td>
<td>默认为 <code>3000</code></td>
</tr>
<tr>
<td>speed</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Number</td>
<td>切换速度</td>
<td>默认为 <code>500</code></td>
</tr>
<tr>
<td>dotDisplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否显示指示点</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>arrowDisplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否显示切换箭头</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>easing</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>切换动画</td>
<td>默认为 <code>easeInOutQuart</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>CarouselItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>caption</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>轮播图的主标题</td>
<td>请填入核心内容</td>
</tr>
<tr>
<td>subCaption</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>轮播图的副标题</td>
<td>主标题的进一步解释</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td>所有轮播图图片长宽比例应该相同，推荐值 <code>16: 9</code></td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>轮播图点击时的跳转路径</td>
<td>支持相对路径绝对路径以及 http、https 链接</td>
</tr>
<tr>
<td>enSubhead</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>轮播图的英文副标题</td>
<td></td>
</tr>
<tr>
<td>alt</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片失效时的显示文字</td>
<td>不填会默认初始化为文字 <code>轮播图背景</code></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>页面右下角补充说明</td>
<td>仅在 large 及以上屏幕上显示</td>
</tr>
<tr>
<td>black</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否采用黑色文字</td>
<td>默认文字色为白色</td>
</tr>
</tbody>
</table>
<h3 id="basephone" tabindex="-1"> BasePhone</h3>
<p>生成拨打电话提示，该组件仅为兼容小程序。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>number</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String 或 Number</td>
<td>电话号码</td>
</tr>
</tbody>
</table>
<h2 id="以下是以便复用的不常用组件" tabindex="-1"> 以下是以便复用的不常用组件</h2>
<h3 id="nav-组件" tabindex="-1"> Nav 组件</h3>
<p>网页导航栏</p>
<h3 id="slide-组件" tabindex="-1"> Slide 组件</h3>
<p>网页侧边栏</p>
<h3 id="footer-组件" tabindex="-1"> Footer 组件</h3>
<p>网页页脚</p>
<h3 id="basemenu-组件" tabindex="-1"> BaseMenu 组件</h3>
<p>生成竖直菜单</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td style="text-align:center">是</td>
<td style="text-align:center">MenuItem[]</td>
<td>菜单内容</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>MenuItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>菜单项的标识符</td>
<td>不可重复</td>
</tr>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>菜单的文字</td>
<td></td>
</tr>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Boolean</td>
<td>菜单的图标</td>
<td>填入 <code>true</code> 不显示图标但是图标区留空</td>
</tr>
<tr>
<td>children</td>
<td style="text-align:center">否</td>
<td style="text-align:center">MenuItem[]</td>
<td>子菜单</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basepage-组件" tabindex="-1"> BasePage 组件</h3>
<p>用于渲染小程序 json 生成页面</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>pagedata</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>小程序页面 json 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="docview-组件" tabindex="-1"> DocView 组件</h3>
<p>用于自动渲染转码的 HTML</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>docContent</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>Markdown 转 HTML 内容</td>
</tr>
</tbody>
</table>
<h3 id="basecard-组件" tabindex="-1"> BaseCard 组件</h3>
<p>卡片样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>卡片的标题</td>
<td></td>
</tr>
<tr>
<td>price</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Number</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Array</td>
<td>卡片详情</td>
<td>数组的每一项是卡片详情的每一项内容，支持 rawHtml</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>卡片跳转的地址</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basetimeaxis-组件" tabindex="-1"> BaseTimeAxis 组件</h3>
<p>生成时间轴</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeList</td>
<td style="text-align:center">是</td>
<td style="text-align:center">TimeListItem[]</td>
<td>Markdown 转 HTML 内容</td>
</tr>
</tbody>
</table>
<div><p>注意</p>
<p>※ 必须将该组件直接放置在 <code>div.container</code> 中! 否则会造成显示错乱。</p>
</div>
<ul>
<li><strong>TimeListItem</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>时间线的标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>时间线的段落文字</td>
<td>可输入 rawhtml，支持 <code>\n</code> 与连续空格</td>
</tr>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>时间线的图标</td>
<td>可输入 rawhtml</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>点击当前选项卡跳转的地址</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="mydoc-组件" tabindex="-1"> MyDoc 组件</h3>
<p>用于自动生成 HTML 页面</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>baselength</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Number</td>
<td>MarkDown 基准路径字符数</td>
</tr>
</tbody>
</table>
<h3 id="backtop-组件" tabindex="-1"> BackTop 组件</h3>
<p>一个返回顶部按钮，当滚动距离超过 300px 时显示会显示在右下角</p>
<h3 id="loadingicon" tabindex="-1"> LoadingIcon</h3>
<p>一个自定义的齿轮加载图标</p>
<h3 id="passwordmodal" tabindex="-1"> PasswordModal</h3>
<p>密码弹出框</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>验证地址</td>
<td>填入绝对路径，不需要填写 php 文件后缀名</td>
</tr>
<tr>
<td>userNameKey</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>用户名的自动填充键值</td>
<td>填写后会提示输入用户名，默认不输入</td>
</tr>
<tr>
<td>passwordKey</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>密码的自动填充键值</td>
<td>默认为 <code>password</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>快速上手 Vue.js</title>
      <link>https://0808200.xyz/code/vue/get-started.html</link>
      <guid>https://0808200.xyz/code/vue/get-started.html</guid>
      <source url="https://0808200.xyz/rss.xml">快速上手 Vue.js</source>
      <category>Vue</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="vue-js-是什么" tabindex="-1"> Vue.js 是什么</h2>
<p><a href="https://learning.dcloud.io/#/?vid=0" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<h2 id="起步" tabindex="-1"> 起步</h2>
<p><a href="https://learning.dcloud.io/#/?vid=1" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<div><p>提示</p>
<p>您应当已了解关于 HTML、CSS 和 JavaScript 的中级知识。</p>
</div>
<p><a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener noreferrer">安装</a></p>
<p>尝试 Vue.js 最简单的方法是使用 <a href="https://jsfiddle.net/chrisvfritz/50wL7mdz/" target="_blank" rel="noopener noreferrer">JSFiddle 上的 Hello World 例子</a>。您可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者您也可以创建一个 <code>.html</code> 文件，然后通过如下方式引入 Vue:</p>
<div><pre><code><span>&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>或者:</p>
<div><pre><code><span>&lt;!-- 生产环境版本，优化了尺寸和速度 --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/npm/vue<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>注意</p>
<p>请注意 Mr.Googxh <strong>不推荐</strong> 新手直接使用 <code>vue-cli</code>，尤其是在您还不熟悉基于 Node.js 的构建工具时。</p>
</div>
<h2 id="声明式渲染" tabindex="-1"> 声明式渲染</h2>
<p><a href="https://learning.dcloud.io/#/?vid=3" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue!"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们已经成功创建了第一个 Vue 应用! 现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式的</strong>。也就是说如果 <code>data</code> 中的 <code>message</code> 值被改变，那么视图层中的 <code>message</code> 马上会更新。</p>
<p>除了文本插值，我们还可以像这样来绑定元素特性:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-2<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>span</span> <span><span>v-bind:</span>title</span><span><span>=</span><span>"</span>message<span>"</span></span><span>></span></span>
    鼠标悬停几秒钟查看此处动态绑定的提示信息!
  <span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app2 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-2"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"页面加载于 "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们遇到了一点新东西。您看到的 <code>v-bind</code> 特性被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue 提供的特殊特性。可能您已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是: “将这个元素节点的 <code>title</code> 特性和 Vue 实例的 <code>message</code> 属性保持一致”。</p>
<h2 id="条件与循环" tabindex="-1"> 条件与循环</h2>
<p><a href="https://learning.dcloud.io/#/?vid=8" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>控制切换一个元素是否显示也相当简单:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-3<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-if</span><span><span>=</span><span>"</span>seen<span>"</span></span><span>></span></span>现在您看到我了<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app3 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-3"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>seen</span><span>:</span> <span>true</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您改变 <code>seen</code> 的值，文字的显示与否(也就是 <code>&lt;p&gt;</code> 标签的存在与否)也会进行切换。</p>
<p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM <strong>结构</strong>。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener noreferrer">过渡效果</a>。</p>
<p>还有其它很多指令，每个都有特殊的功能。例如，<code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-4<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ol</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>todo in todos<span>"</span></span><span>></span></span>{{ todo.text }}<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app4 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-4"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>todos</span><span>:</span> <span>[</span>
      <span>{</span> <span>text</span><span>:</span> <span>"学习 JavaScript"</span> <span>}</span><span>,</span>
      <span>{</span> <span>text</span><span>:</span> <span>"学习 Vue"</span> <span>}</span><span>,</span>
      <span>{</span> <span>text</span><span>:</span> <span>"整个牛项目"</span> <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="处理用户输入" tabindex="-1"> 处理用户输入</h2>
<p><a href="https://learning.dcloud.io/#/?vid=11" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>为了让用户和您的应用进行交互，我们可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-5<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>reverseMessage<span>"</span></span><span>></span></span>反转消息<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app5 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-5"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue.js!"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>reverseMessage</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>message <span>=</span> <span>this</span><span>.</span>message<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意在 <code>reverseMessage</code> 方法中，每次点击按钮的时候，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，您编写的代码只需要关注逻辑层面即可。</p>
<p>Vue 还提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-6<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>v-model</span><span><span>=</span><span>"</span>message<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app6 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-6"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue!"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，在输入框做出的更改会同步到 js 的数据中。</p>
<h2 id="组件化应用构建" tabindex="-1"> 组件化应用构建</h2>
<p><a href="https://learning.dcloud.io/#/?vid=12" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树:</p>
<p><img src="@source/code/vue/assets/components.png" alt="Component Tree"></p>
<p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单:</p>
<div><pre><code><span>// 定义名为 todo-item 的新组件</span>
Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>template</span><span>:</span> <span>"&lt;li>这是个待办项&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>现在您可以用它构建另一个组件模板:</p>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span>&lt;!-- 创建一个 todo-item 组件的实例 --></span>
  <span><span><span>&lt;</span>todo-ite</span> <span>/></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener noreferrer">prop</a>:</p>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>// todo-item 组件现在接受一个</span>
  <span>// "prop"，类似于一个自定义特性。</span>
  <span>// 这个 prop 名为 todo。</span>
  <span>props</span><span>:</span> <span>[</span><span>"todo"</span><span>]</span><span>,</span>
  <span>template</span><span>:</span> <span>"&lt;li>{{ todo.text }}&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-7<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ol</span><span>></span></span>
    <span>&lt;!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    --></span>
    <span><span><span>&lt;</span>todo-item</span>
      <span>v-for</span><span><span>=</span><span>"</span>item in groceryList<span>"</span></span>
      <span><span>v-bind:</span>todo</span><span><span>=</span><span>"</span>item<span>"</span></span>
      <span><span>v-bind:</span>key</span><span><span>=</span><span>"</span>item.id<span>"</span></span>
    <span>/></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>props</span><span>:</span> <span>[</span><span>"todo"</span><span>]</span><span>,</span>
  <span>template</span><span>:</span> <span>"&lt;li>{{ todo.text }}&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> app7 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-7"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>groceryList</span><span>:</span> <span>[</span>
      <span>{</span> <span>id</span><span>:</span> <span>0</span><span>,</span> <span>text</span><span>:</span> <span>"蔬菜"</span> <span>}</span><span>,</span>
      <span>{</span> <span>id</span><span>:</span> <span>1</span><span>,</span> <span>text</span><span>:</span> <span>"奶酪"</span> <span>}</span><span>,</span>
      <span>{</span> <span>id</span><span>:</span> <span>2</span><span>,</span> <span>text</span><span>:</span> <span>"随便其它什么人吃的东西"</span> <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。</p>
<p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">后续教程</a>中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>app-nav</span> <span>/></span></span>
  <span><span><span>&lt;</span>app-view</span><span>></span></span>
    <span><span><span>&lt;</span>app-sidebar</span> <span>/></span></span>
    <span><span><span>&lt;</span>app-content</span> <span>/></span></span>
  <span><span><span>&lt;/</span>app-view</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="与自定义元素的关系" tabindex="-1"> 与自定义元素的关系</h3>
<p>您可能已经注意到 Vue 组件非常类似于<strong>自定义元素</strong>——它是 <a href="https://www.w3.org/wiki/WebComponents/" target="_blank" rel="noopener noreferrer">Web 组件规范</a>的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener noreferrer">Slot API</a> 与 <code>is</code> 特性。但是，还是有几个关键差别:</p>
<ol>
<li>
<p>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</p>
</li>
<li>
<p>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</p>
</li>
</ol>
<p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，<a href="https://custom-elements-everywhere.com/#vue" target="_blank" rel="noopener noreferrer">依然有很好的互操作性</a>。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p>
<h2 id="创建一个-vue-实例" tabindex="-1"> 创建一个 Vue 实例</h2>
<p><a href="https://learning.dcloud.io/#/?vid=2" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的:</p>
<div><pre><code><span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>// 选项</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener noreferrer">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<p>当创建一个 Vue 实例时，您可以传入一个<strong>选项对象</strong>。这篇教程主要描述的就是如何使用这些选项来创建您想要的行为。作为参考，您也可以在 <a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer">API 文档</a> 中浏览完整的选项列表。</p>
<p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的:</p>
<div><pre><code>根实例
└─ TodoList
├─ TodoItem
│ ├─ DeleteTodoButton
│ └─ EditTodoButton
└─ TodoListFooter
├─ ClearTodosButton
└─ TodoListStatistics
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们会在稍后的<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">组件系统</a>章节具体展开。不过现在，您只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。</p>
<h2 id="数据与方法" tabindex="-1"> 数据与方法</h2>
<p><a href="https://learning.dcloud.io/#/?vid=3" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的属性加入到 Vue 的<strong>响应式系统</strong>中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<div><pre><code><span>// 我们的数据对象</span>
<span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>

<span>// 该对象被加入到一个 Vue 实例中</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> data<span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>// 获得这个实例上的属性</span>
<span>// 返回源数据中对应的字段</span>
vm<span>.</span>a <span>==</span> data<span>.</span>a<span>;</span> <span>// => true</span>

<span>// 设置属性也会影响到原始数据</span>
vm<span>.</span>a <span>=</span> <span>2</span><span>;</span>
data<span>.</span>a<span>;</span> <span>// => 2</span>

<span>// ……反之亦然</span>
data<span>.</span>a <span>=</span> <span>3</span><span>;</span>
vm<span>.</span>a<span>;</span> <span>// => 3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的属性才是<strong>响应式</strong>的。也就是说如果您添加一个新的属性，比如:</p>
<div><pre><code>vm<span>.</span>b <span>=</span> <span>"hi"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果您知道您会在晚些时候需要一个属性，但是一开始它为空或不存在，那么您仅需要设置一些初始值。比如:</p>
<div><pre><code><span>data</span><span>:</span> <span>{</span>
  <span>newTodoText</span><span>:</span> <span>''</span><span>,</span>
  <span>visitCount</span><span>:</span> <span>0</span><span>,</span>
  <span>hideCompletedTodos</span><span>:</span> <span>false</span><span>,</span>
  <span>todos</span><span>:</span> <span>[</span><span>]</span><span>,</span>
  <span>error</span><span>:</span> <span>null</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的属性，也意味着响应系统无法再<em>追踪</em>变化。</p>
<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>"bar"</span><span>,</span>
<span>}</span><span>;</span>

Object<span>.</span><span>freeze</span><span>(</span>obj<span>)</span><span>;</span>

<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> obj<span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ foo }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span>&lt;!-- 这里的 `foo` 不会更新!  --></span>
  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>foo = <span>'</span>baz<span>'</span><span>"</span></span><span>></span></span>Change it<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 <code>$</code>，以便与用户定义的属性区分开来。例如:</p>
<div><pre><code><span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#example"</span><span>,</span>
  <span>data</span><span>:</span> data<span>,</span>
<span>}</span><span>)</span><span>;</span>

vm<span>.</span>$data <span>===</span> data<span>;</span> <span>// => true</span>
vm<span>.</span>$el <span>===</span> document<span>.</span><span>getElementById</span><span>(</span><span>"example"</span><span>)</span><span>;</span> <span>// => true</span>

<span>// $watch 是一个实例方法</span>
vm<span>.</span><span>$watch</span><span>(</span><span>"a"</span><span>,</span> <span>function</span> <span>(</span><span>newValue<span>,</span> oldValue</span><span>)</span> <span>{</span>
  <span>// 这个回调将在 `vm.a` 改变后调用</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以后您可以在 <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener noreferrer">API 参考</a>中查阅到完整的实例属性和方法的列表。</p>
<h2 id="实例生命周期钩子" tabindex="-1"> 实例生命周期钩子</h2>
<p><a href="https://learning.dcloud.io/#/?vid=4" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 <a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener noreferrer"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码:</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>a</span><span>:</span> <span>1</span><span>,</span>
  <span>}</span><span>,</span>
  <span>created</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// `this` 指向 vm 实例</span>
    console<span>.</span><span>log</span><span>(</span><span>"a is: "</span> <span>+</span> <span>this</span><span>.</span>a<span>)</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
<span>// => "a is: 1"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted" target="_blank" rel="noopener noreferrer"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated" target="_blank" rel="noopener noreferrer"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed" target="_blank" rel="noopener noreferrer"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<div><p>提示</p>
<p>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener noreferrer">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
</div>
<h2 id="生命周期图示" tabindex="-1"> 生命周期图示</h2>
<p>下图展示了实例的生命周期。您不需要立马弄明白所有的东西，不过随着您的不断学习和使用，它的参考价值会越来越高。</p>
<p><img src="@source/code/vue/assets/lifecycle.png" alt="Vue 实例生命周期"></p>
]]></content:encoded>
    </item>
    <item>
      <title>开发环境安装</title>
      <link>https://0808200.xyz/code/vue/install.html</link>
      <guid>https://0808200.xyz/code/vue/install.html</guid>
      <source url="https://0808200.xyz/rss.xml">开发环境安装</source>
      <category>Vue</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="环境准备" tabindex="-1"> 环境准备</h2>
<h3 id="vs-code-安装" tabindex="-1"> VS Code 安装</h3>
<ul>
<li><a href="/software/vscode/install.html">安装 VS Code</a></li>
</ul>
<h4 id="开发指南" tabindex="-1"> 开发指南</h4>
<ol>
<li>
<p>使用 VS Code 打开项目文件夹。</p>
<div><p>提示</p>
<p>请打开 VS Code 选择菜单栏中的 “文件-打开文件夹”，或在文件夹上 “右键——使用 VS Code 打开” 或在文件夹内部空白处 “右键——使用 VS Code 打开”。</p>
</div>
</li>
<li>
<p>打开终端(快捷键 <code>Ctrl + `</code> )。</p>
</li>
<li>
<p>在终端中输入相关指令即可执行相关功能。</p>
</li>
</ol>
<h3 id="git-安装" tabindex="-1"> Git 安装</h3>
<ul>
<li><a href="/software/git/install.html">安装 Git</a></li>
</ul>
<h3 id="node-js-环境安装" tabindex="-1"> Node.js 环境安装</h3>
<p>请先安装 Node.js 并将 npm 与 Node.js 添加至 path。</p>
<ul>
<li>
<p><a href="/code/node-js/install.html">安装 Node.js</a></p>
</li>
<li>
<p><a href="/code/windows/add-path.html">添加到 path</a></p>
</li>
</ul>
<h2 id="初始化版本库、下载网页代码并安装-npm-模块" tabindex="-1"> 初始化版本库、下载网页代码并安装 npm 模块</h2>
<ol>
<li>
<p>打开文件管理器窗口找到合适位置，并在地址栏输入 cmd，以在当前界面打开终端。</p>
</li>
<li>
<p>使用 <code>git clone git@github.com:Mister-Hope/vue-template.git</code> 克隆模板。</p>
</li>
<li>
<p>使用 VS Code 打开刚刚克隆出来的文件夹，按下 <code>Ctrl + `</code> 打开终端。</p>
</li>
<li>
<p>使用 <code>npm install</code> 命令安装模块。</p>
</li>
</ol>
<div><p>提示</p>
<p>npm 模块介绍</p>
<p>此处待补充。</p>
</div>
<h2 id="开发工具安装" tabindex="-1"> 开发工具安装</h2>
<p>Vue 官方提供的浏览器插件 VueTools 可以更好的帮助开发。</p>
<p>使用 VPN 用 Chrome 打开<a href="https://chrome.google.com/webstore/detail/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener noreferrer">安装网址</a>，安装 VueTools 开发工具</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 单文件组件</title>
      <link>https://0808200.xyz/code/vue/vue.html</link>
      <guid>https://0808200.xyz/code/vue/vue.html</guid>
      <source url="https://0808200.xyz/rss.xml">Vue 单文件组件</source>
      <category>Vue</category>
      <pubDate>Mon, 27 Jun 2022 09:33:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍" tabindex="-1"> 介绍</h2>
<p>Vue 的单文件组件 (即 <code>*.vue</code> 文件，简称 <strong>SFC</strong>) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>greeting</span><span>:</span> <span>"Hello World!"</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>greeting<span>"</span></span><span>></span></span>{{ greeting }}<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.greeting</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如你所见，Vue 的单文件组件是 HTML、CSS 和 JavaScript 三种元素的自然延伸。<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 三个块在同一个文件中封装、组合了组件的视图、逻辑和样式。</p>
<h2 id="总览" tabindex="-1"> 总览</h2>
<h2 id="总览-overview" tabindex="-1"> 总览 {#overview}</h2>
<p>一个 Vue 单文件组件 (SFC)，通常使用 <code>*.vue</code> 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。</p>
<p>每一个 <code>*.vue</code> 文件都由三种顶层语块构成：<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>，以及一些其他的自定义块：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>example<span>"</span></span><span>></span></span>{{ msg }}<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>msg</span><span>:</span> <span>"Hello world!"</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.example</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;</span>custom1</span><span>></span></span>
  This could be e.g. documentation for the component.
<span><span><span>&lt;/</span>custom1</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="相应语言块-language-blocks" tabindex="-1"> 相应语言块 {#language-blocks}</h2>
<h3 id="template-template" tabindex="-1"> <code>&lt;template&gt;</code> {#template}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个顶层 <code>&lt;template&gt;</code> 块。</p>
</li>
<li>
<p>语块包裹的内容将会被提取、传递给 <code>@vue/compiler-dom</code>，预编译为 JavaScript 渲染函数，并附在导出的组件上作为其 <code>render</code> 选项。</p>
</li>
</ul>
<h3 id="script-script" tabindex="-1"> <code>&lt;script&gt;</code> {#script}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script&gt;</code> 块。(使用 <a href="/api/sfc-script-setup.html"><code>&lt;script setup&gt;</code></a> 的情况除外)</p>
</li>
<li>
<p>这个脚本代码块将作为 ES 模块执行。</p>
</li>
<li>
<p><strong>默认导出</strong>应该是 Vue 的组件选项对象，可以是一个对象字面量或是 <a href="/api/general.html#definecomponent">defineComponent</a> 函数的返回值。</p>
</li>
</ul>
<h3 id="script-setup-script-setup" tabindex="-1"> <code>&lt;script setup&gt;</code> {#script-setup}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script setup&gt;</code>。(不包括一般的 <code>&lt;script&gt;</code>)</p>
</li>
<li>
<p>这个脚本块将被预处理为组件的 <code>setup()</code> 函数，这意味着它将<strong>为每一个组件实例</strong>都执行。<code>&lt;script setup&gt;</code> 中的顶层绑定都将自动暴露给模板。要了解更多细节，请看 <a href="/api/sfc-script-setup"><code>&lt;script setup&gt;</code> 的专门文档</a>。</p>
</li>
</ul>
<h3 id="style-style" tabindex="-1"> <code>&lt;style&gt;</code> {#style}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件可以包含多个 <code>&lt;style&gt;</code> 标签。</p>
</li>
<li>
<p>一个 <code>&lt;style&gt;</code> 标签可以使用 <code>scoped</code> 或 <code>module</code> attribute (查看 <a href="/api/sfc-css-features">SFC 样式功能</a>了解更多细节) 来帮助封装当前组件的样式。使用了不同封装模式的多个 <code>&lt;style&gt;</code> 标签可以被混合入同一个组件。</p>
</li>
</ul>
<h3 id="自定义块-custom-blocks" tabindex="-1"> 自定义块 {#custom-blocks}</h3>
<p>在一个 <code>*.vue</code> 文件中可以为任何项目特定需求使用额外的自定义块。举个例子，一个用作写文档的 <code>&lt;docs&gt;</code> 块。这里是一些自定义块的真实用例：</p>
<ul>
<li><a href="https://gridsome.org/docs/querying-data/" target="_blank" rel="noopener noreferrer">Gridsome：<code>&lt;page-query&gt;</code></a></li>
<li><a href="https://github.com/wheatjs/vite-plugin-vue-gql" target="_blank" rel="noopener noreferrer">vite-plugin-vue-gql：<code>&lt;gql&gt;</code></a></li>
<li><a href="https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block" target="_blank" rel="noopener noreferrer">vue-i18n：<code>&lt;i18n&gt;</code></a></li>
</ul>
<p>自定义块的处理需要依赖工具链。如果你想要在构建中集成你的自定义语块，请参见<a href="/guide/scaling-up/tooling.html#sfc-custom-block-integrations">相关工具链指南</a>获取更多细节。</p>
<h2 id="自动名称推导-automatic-name-inference" tabindex="-1"> 自动名称推导 {#automatic-name-inference}</h2>
<p>SFC 在以下场景中会根据<strong>文件名</strong>自动推导其组件名：</p>
<ul>
<li>开发警告信息格式</li>
<li>DevTools 审阅</li>
<li>递归组件自引用。例如一个名为 <code>FooBar.vue</code> 的组件可以在模板中通过 <code>&lt;FooBar/&gt;</code> 引用自己。(同名情况下) 这比明确注册/导入的组件优先级低。</li>
</ul>
<h2 id="预处理器-pre-processors" tabindex="-1"> 预处理器 {#pre-processors}</h2>
<p>代码块可以使用 <code>lang</code> 这个 attribute 来声明预处理器语言，最常见的用例就是对 <code>&lt;script&gt;</code> 块使用 TypeScript：</p>
<div><pre><code>&lt;script lang=&quot;ts&quot;&gt;
  // use TypeScript
&lt;/script&gt;
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>lang</code> 在任意块上都能使用，比如我们可以在 <code>&lt;style&gt;</code> 标签上使用 <a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">SASS</a> 或是 <code>&lt;template&gt;</code> 上使用 <a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="noopener noreferrer">Pug</a>：</p>
<div><pre><code>&lt;template lang=&quot;pug&quot;&gt;
p {{ msg }}
&lt;/template&gt;

&lt;style lang=&quot;scss&quot;&gt;
  $primary-color: #333;
  body {
    color: $primary-color;
  }
&lt;/style&gt;
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意对各种不同的预处理的集成会导致工具链的不同，你应该查看相应的工具链文档了解细节：</p>
<ul>
<li><a href="https://vitejs.dev/guide/features.html#css-pre-processors" target="_blank" rel="noopener noreferrer">Vite</a></li>
<li><a href="https://cli.vuejs.org/guide/css.html#pre-processors" target="_blank" rel="noopener noreferrer">Vue CLI</a></li>
<li><a href="https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors" target="_blank" rel="noopener noreferrer">webpack + vue-loader</a></li>
</ul>
<h2 id="src-导入-src-imports" tabindex="-1"> Src 导入 {#src-imports}</h2>
<p>如果你更喜欢将 <code>*.vue</code> 组件分散到多个文件中，可以为一个语块使用 <code>src</code> 这个 attribute 来导入一个外部文件：</p>
<div><pre><code><span><span><span>&lt;</span>template</span> <span>src</span><span><span>=</span><span>"</span>./template.html<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>style</span> <span>src</span><span><span>=</span><span>"</span>./style.css<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./script.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>请注意 <code>src</code> 导入和 Webpack 的模块请求遵循相同的路径解析规则，这意味着：</p>
<ul>
<li>相对路径需要以 <code>./</code> 开头</li>
<li>你也可以从 npm 依赖中导入资源</li>
</ul>
<div><pre><code><span>&lt;!-- 从所安装的 "todomvc-app-css" npm 包中导入一个文件 --></span>
<span><span><span>&lt;</span>style</span> <span>src</span><span><span>=</span><span>"</span>todomvc-app-css/index.css<span>"</span></span> <span>/></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>src</code> 导入对自定义语块也同样适用：</p>
<div><pre><code><span><span><span>&lt;</span>unit-test</span> <span>src</span><span><span>=</span><span>"</span>./unit-test.js<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>unit-test</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="注释-comments" tabindex="-1"> 注释 {#comments}</h2>
<p>在每一个语块中你都可以按照相应语言 (HTML、CSS、JavaScript 和 Pug 等等) 的语法书写注释。对于顶层注释，请使用 HTML 的注释语法 <code>&lt;!-- comment contents here --&gt;</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>网页入门</title>
      <link>https://0808200.xyz/code/website/</link>
      <guid>https://0808200.xyz/code/website/</guid>
      <source url="https://0808200.xyz/rss.xml">网页入门</source>
      <description>网页需要三件套: HTML、CSS 和 JavaScript。

HTML 定义了网页的内容
CSS 描述了网页的样式
JavaScript 编写网页的行为

</description>
      <category>前端</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>

<div><p>提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>
</div>
<div><p>网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2 id="html" tabindex="-1"> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="/code/website/html/">HTML 教程</a></li>
</ul>
<h2 id="css" tabindex="-1"> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="/code/website/css/">CSS 教程</a></li>
</ul>
<h2 id="emmet" tabindex="-1"> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="/code/website/emmet/">Emmet 用法介绍</a></li>
</ul>
<h2 id="javascript" tabindex="-1"> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="/code/website/js.html">JS 教程</a></li>
</ul>
<h3 id="typescript" tabindex="-1"> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="/code/language/typescript/">TypeScript 教程</a></li>
</ul>
<h2 id="node-js" tabindex="-1"> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="/code/node-js/">Node.js 教程</a></li>
</ul>
<h2 id="历史前端框架" tabindex="-1"> 历史前端框架</h2>
<h3 id="jquery" tabindex="-1"> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 MVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="/code/website/jQuery/">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="bootstrap4" tabindex="-1"> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2 id="现代前端框架" tabindex="-1"> 现代前端框架</h2>
<h3 id="vue" tabindex="-1"> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 与 React、Angular 一起合称前端三大框架。</p>
<ul>
<li>
<p><a href="/code/vue/">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3 id="react" tabindex="-1"> React</h3>
<ul>
<li><a href="/code/react/">React 教程</a></li>
</ul>
<h3 id="angular" tabindex="-1"> Angular</h3>
<ul>
<li><a href="/code/Angular/">Angular 教程</a></li>
</ul>
<h2 id="其他文档" tabindex="-1"> 其他文档</h2>
<ul>
<li><a href="/code/website/https.html">HTTPS 介绍</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Http 与 Https 介绍</title>
      <link>https://0808200.xyz/code/website/https.html</link>
      <guid>https://0808200.xyz/code/website/https.html</guid>
      <source url="https://0808200.xyz/rss.xml">Http 与 Https 介绍</source>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是-http-协议" tabindex="-1"> 什么是 HTTP 协议</h2>
<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>
<p><img src="@source/code/website/assets/http1.jpg" alt="Http 漫画"></p>
<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>
<p><img src="@source/code/website/assets/http2.jpg" alt="Http 漫画"></p>
<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>
<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>
<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>
<p><img src="@source/code/website/assets/http3.jpg" alt="Http 漫画"></p>
<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>
<p><img src="@source/code/website/assets/http4.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http5.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http6.jpg" alt="Http 漫画"></p>
<p>如何进行加密呢?</p>
<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p><img src="@source/code/website/assets/http7.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http8.jpg" alt="Http 漫画"></p>
<p>这样做是不是就绝对安全了呢? 并不是。</p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<p><img src="@source/code/website/assets/http9.jpg" alt="Http 漫画"></p>
<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>
<p><img src="@source/code/website/assets/http10.jpg" alt="Http 漫画"></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>
<p><img src="@source/code/website/assets/http11.jpg" alt="Http 漫画"></p>
<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>
<p><img src="@source/code/website/assets/http12.jpg" alt="Http 漫画"></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>
<p><img src="@source/code/website/assets/http13.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http14.jpg" alt="Http 漫画"></p>
<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>
<p><img src="@source/code/website/assets/http15.jpg" alt="Http 漫画"></p>
<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>
<p><img src="@source/code/website/assets/http16.jpg" alt="Http 漫画"></p>
<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>
<p><img src="@source/code/website/assets/http17.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http18.jpg" alt="Http 漫画"></p>
<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>
<p>到底什么是证书呢? 证书包含如下信息:</p>
<p><img src="@source/code/website/assets/http19.jpg" alt="Http 漫画"></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下:</p>
<ol>
<li>
<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>
<p><img src="@source/code/website/assets/http20.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>
<p><img src="@source/code/website/assets/http21.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p><img src="@source/code/website/assets/http22.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>
<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>
<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>
<p><img src="@source/code/website/assets/http23.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>
<p><img src="@source/code/website/assets/http24.jpg" alt="Http 漫画"></p>
</li>
<li>
<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>
<p><img src="@source/code/website/assets/http25.jpg" alt="Http 漫画"></p>
</li>
</ol>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>
<p><img src="@source/code/website/assets/http26.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http27.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http28.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http29.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http30.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http31.jpg" alt="Http 漫画"></p>
<p><img src="@source/code/website/assets/http32.jpg" alt="Http 漫画"></p>
<div><p>相关信息</p>
<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 教程</title>
      <link>https://0808200.xyz/code/website/js.html</link>
      <guid>https://0808200.xyz/code/website/js.html</guid>
      <source url="https://0808200.xyz/rss.xml">JavaScript 教程</source>
      <category>JavaScript</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="初学者教程" tabindex="-1"> 初学者教程</h2>
<ul>
<li><a href="/code/language/js/guide/">快速上手</a></li>
</ul>
<h3 id="javascript-手册" tabindex="-1"> JavaScript 手册</h3>
<ul>
<li><a href="/code/language/js/">JavaScript 学习教程</a></li>
</ul>
<h3 id="在线教程" tabindex="-1"> 在线教程</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="es6" tabindex="-1"> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="/code/language/js/es6/">ES6 教程</a></li>
</ul>
<div><p>提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="/code/language/js/guide/">JS 快速入门章节</a> 了解 JavaScript，或 <a href="/code/language/js/">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>基础知识</title>
      <link>https://0808200.xyz/code/windows/</link>
      <guid>https://0808200.xyz/code/windows/</guid>
      <source url="https://0808200.xyz/rss.xml">基础知识</source>
      <description>以下是有关于 Windows 10 系统的一些基础知识。
</description>
      <category>基础</category>
      <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是有关于 Windows 10 系统的一些基础知识。</p>

<ul>
<li>
<p><a href="/code/windows/add-path.html">添加到 path</a></p>
</li>
<li>
<p><a href="/code/windows/shortcut-key.html">Windows 快捷键</a></p>
</li>
<li>
<p><a href="/code/windows/hidden-file.html">显示文件后缀名与隐藏文件</a></p>
</li>
<li>
<p><a href="/code/windows/cmd.html">快速打开 CMD</a></p>
</li>
<li>
<p><a href="/code/windows/notepad.html">记事本的遗留问题</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>环境变量的添加</title>
      <link>https://0808200.xyz/code/windows/add-path.html</link>
      <guid>https://0808200.xyz/code/windows/add-path.html</guid>
      <source url="https://0808200.xyz/rss.xml">环境变量的添加</source>
      <category>基础</category>
      <pubDate>Sun, 08 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>以 Windows 10 系统为例，直接在左下角搜索栏中输入“系统变量”</p>
<p><img src="@source/code/windows/assets/pathSearch.png" alt="搜索"></p>
<p>在弹出的框中点击环境变量</p>
<p><img src="@source/code/windows/assets/path.png" alt="系统变量"></p>
<p>在弹出的新窗口中找到 path，选中并点击编辑</p>
<p><img src="@source/code/windows/assets/pathDetail.png" alt="系统变量"></p>
<p>点击添加输入想要添加到 path 的路径或者执行文件名即可</p>
<p><img src="@source/code/windows/assets/pathAdd.png" alt="系统变量"></p>
]]></content:encoded>
    </item>
    <item>
      <title>打开命令行</title>
      <link>https://0808200.xyz/code/windows/cmd.html</link>
      <guid>https://0808200.xyz/code/windows/cmd.html</guid>
      <source url="https://0808200.xyz/rss.xml">打开命令行</source>
      <description>打开命令行 (命令提示符) 有多种方式。

运行 - cmd: Win + R 打开运行，然后敲入 cmd 后回车。
搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。
开始菜单 - Windows 系统 - 命令提示符。

如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 cmd 并回车。
</description>
      <category>基础</category>
      <pubDate>Sun, 08 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>打开命令行 (命令提示符) 有多种方式。</p>
<ol>
<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>
<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>
<li>开始菜单 - Windows 系统 - 命令提示符。</li>
</ol>
<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>

<p><img src="@source/code/windows/assets/cmd.png" alt="示意图"></p>
<p>这样就会快速打开一个路径为当前文件夹的命令提示符窗口。</p>
]]></content:encoded>
    </item>
    <item>
      <title>显示文件后缀名与隐藏文件</title>
      <link>https://0808200.xyz/code/windows/hidden-file.html</link>
      <guid>https://0808200.xyz/code/windows/hidden-file.html</guid>
      <source url="https://0808200.xyz/rss.xml">显示文件后缀名与隐藏文件</source>
      <category>基础</category>
      <pubDate>Tue, 15 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>显示文件后缀名与隐藏文件</p>
<p><img src="@source/code/windows/assets/hidden-file.png" alt="如何显示隐藏的文件与文件夹"></p>
]]></content:encoded>
    </item>
    <item>
      <title>记事本的遗留问题</title>
      <link>https://0808200.xyz/code/windows/notepad.html</link>
      <guid>https://0808200.xyz/code/windows/notepad.html</guid>
      <source url="https://0808200.xyz/rss.xml">记事本的遗留问题</source>
      <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>在编写代码的时候，临时的软件选择需要注意。</p>
<p>请注意，绝对不能用 Word 和写字板。Word 和写字板保存的不是纯文本文件。</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<p>原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了几个特殊字符(UTF-8 BOM，即 0xefbbbf)，您会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。</p>
<p>这个弱智行为从 Windows XP 影响到 Windows 10，在最新的 Windows 10 版本(20H2) 中，才得到解决。</p>
<div><p>提示</p>
<p>如果实在是临时急用，需要用记事本替代改一下代码，也要一定注意，保存文件时使用 ANSI 编码，并且暂时不要输入(包含)中文。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>常用快捷键</title>
      <link>https://0808200.xyz/code/windows/shortcut-key.html</link>
      <guid>https://0808200.xyz/code/windows/shortcut-key.html</guid>
      <source url="https://0808200.xyz/rss.xml">常用快捷键</source>
      <description>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。
</description>
      <category>基础</category>
      <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>

<h2 id="最常用且最有用的" tabindex="-1"> 最常用且最有用的</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="通用键" tabindex="-1"> 通用键</h2>
<ul>
<li><code>F1</code>: 显示帮助；</li>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>F11</code>: 全屏；</li>
<li><code>Shift</code> + <code>F10</code>: 打开当前活动项目的快捷菜单(相当于鼠标右键)；</li>
<li><code>ALT</code> 激活当前程序的菜单栏(使用对应字母选择)；</li>
<li><code>Backspace</code>: 退格——删除前一个字符、文件视图下——返回上一级；</li>
<li><code>Enter</code>: 执行或进入；</li>
<li><code>Win</code> 或 <code>CTRL</code> + <code>ESC</code>: 打开开始菜单；</li>
<li><code>DELETE</code>: 删除被选中的项目，如果是文件，将被放入回收站；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
</ul>
<h2 id="程序窗口" tabindex="-1"> 程序窗口</h2>
<ul>
<li><code>Win</code> + <code>Tab</code>: 最近任务和多桌面视图；</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>Alt</code> + <code>加下划线的字母</code> 执行与该字母匹配的命令(或选择选项)；</li>
<li><code>Win</code> + <code>↑</code>: 显示最小化的窗口 → 最大化窗口；</li>
<li><code>Win</code> + <code>←</code>: 将窗口最大化到屏幕的左侧；</li>
<li><code>Win</code> + <code>→</code>: 将窗口最大化到屏幕的右侧；</li>
<li><code>Win</code> + <code>↓</code>: 缩小窗口 → 最小化窗口；</li>
<li><code>Win</code> + <code>Home</code>: 最小化除活动窗口之外的所有窗口；</li>
<li><code>ALT</code> + <code>SPACEBAR</code>: 打开程序最左上角的菜单；</li>
<li><code>Win</code> + <code>Shift</code> + <code>↑</code>: 将窗口拉伸到屏幕的顶部和底部；</li>
<li><code>Win</code> + <code>Shift</code> + <code>←</code> 或 <code>Win</code> + <code>Shift</code> + <code>→</code>: 将窗口从一个监视器移动到另一个监视器；</li>
</ul>
<h2 id="文件浏览" tabindex="-1"> 文件浏览</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>Shift</code> + <code>DELETE</code>: 删除被选中的项目，如果是文件，将被直接删除而不是放入回收站；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="编辑模式" tabindex="-1"> 编辑模式</h2>
<ul>
<li><code>CTRL</code> + <code>O</code>: 打开文件；</li>
<li><code>CTRL</code> + <code>S</code>: 保存；</li>
<li><code>CTRL</code> + <code>方向键</code>: 滚动屏幕；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Z</code>: 撤销；</li>
<li><code>CTRL</code> + <code>Y</code>: 重做；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>E</code>: 搜索/助理；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>P</code>: 打印；</li>
</ul>
<div><p>提示</p>
<p>单击鼠标左键选择光标位置，按住 <code>Shift</code> 再次在另一处单击鼠标左键，即可选中两光标间的所有文字。鼠标左键单击拖动选中内容即可移动选中内容在文档中的位置。</p>
</div>
<h2 id="系统" tabindex="-1"> 系统</h2>
<ul>
<li><code>CTRL</code> + <code>Shift</code> + <code>ESC</code>: 打开任务管理器;</li>
<li><code>CTRL</code> + <code>ALT</code> + <code>DELETE</code>: 进入安全选项；</li>
<li><code>Win</code> + <code>D</code>: 显示桌面；</li>
<li><code>Win</code> + <code>E</code>: 打开资源管理器；</li>
<li><code>Win</code> + <code>L</code>: 锁定计算机或切换用户；</li>
<li><code>Win</code> + <code>M</code>: 最小化所有窗口(和显示桌面不同，自行感受)；</li>
<li><code>Win</code> + <code>Shift</code> + <code>M</code>: 将最小化的窗口还原到桌面；</li>
<li><code>Win</code> + <code>R</code>: 打开“运行”对话框；</li>
<li><code>Win</code> + <code>A</code>: 打开通知中心；</li>
<li><code>Win</code> + <code>I</code>: 打开系统设置；</li>
<li><code>Win</code> + <code>X</code>: 打开 Windows 主选项菜单；</li>
<li><code>Win</code> + <code>P</code>: 选择投影模式；</li>
<li><code>Win</code> + <code>数字</code>: 启动任务栏上快捷启动项数字位置处的程序；</li>
<li><code>Win</code> + <code>B</code> 选中桌面右下方工具栏；</li>
<li><code>Win</code> + <code>BREAK</code>: 打开“系统属性”对话框</li>
<li><code>Win</code> + <code>T</code>: 循环切换任务栏上的程序；</li>
<li><code>Shift</code> + <code>Win</code> + <code>数字</code>: 打开任务栏上快捷启动项数字位置处程序的新实例；</li>
<li><code>Alt</code> + <code>Win</code> + <code>数字</code>: 显示任务栏上快捷启动项数字位置处程序的跳转列表；</li>
<li><code>ALT</code> + <code>ESC</code>: 保留程序的显示状态切换当前程序(最小化状态将被保留)(加 Shift 反向)；</li>
</ul>
<h2 id="输入法" tabindex="-1"> 输入法</h2>
<ul>
<li><code>CTRL</code> + <code>Space</code>: 切换中英文输入法；</li>
<li><code>Win</code> + <code>Space</code>: 切换输入法；</li>
</ul>
<h2 id="屏幕截图" tabindex="-1"> 屏幕截图</h2>
<ul>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Win</code> + <code>PRINT SCREEN</code>: 将当前屏幕截图保存在图片文件夹中；</li>
<li><code>ALT</code> + <code>PRINT SCREEN</code>: 将当前活动程序窗口以图像方式拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>设计文章</title>
      <link>https://0808200.xyz/design/articles/</link>
      <guid>https://0808200.xyz/design/articles/</guid>
      <source url="https://0808200.xyz/rss.xml">设计文章</source>
      <category>设计</category>
      <pubDate>Sat, 26 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="文章列表" tabindex="-1"> 文章列表</h2>
<ul>
<li>
<p><a href="/design/articles/gestalt-principle.html">格式塔原则</a></p>
</li>
<li>
<p><a href="/design/articles/left-or-right.html">布局中的左和右</a></p>
</li>
<li>
<p><a href="/design/articles/infomation-flow.html">信息流介绍</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>格式塔原则</title>
      <link>https://0808200.xyz/design/articles/gestalt-principle.html</link>
      <guid>https://0808200.xyz/design/articles/gestalt-principle.html</guid>
      <source url="https://0808200.xyz/rss.xml">格式塔原则</source>
      <category>设计</category>
      <pubDate>Sat, 26 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>好的设计师理解心理学在视觉感知中的强大作用。当别人的目光与您的设计创作相遇时，会发生什么? 他们对您分享的信息有什么反应?</p>
<h2 id="格式塔原理概述" tabindex="-1"> 格式塔原理概述</h2>
<h3 id="前言" tabindex="-1"> 前言</h3>
<p>举一个场景化的栗子，大家平时逛街的时候能记住哪些广告呢? 我们虽然每天看到那么多的信息，但是真正记住的却不多。还有当我们看到复杂的事物的时候，心里会涌现不舒服的奇怪感受，有时候这种感受没有办法用语言来描述。那么为什么会有这些感受呢?</p>
<p><img src="@source/design/articles/assets/gestalt-principle1.jpg" alt="图片1"></p>
<p>其实道理很简单，我们做的东西是给人用的。人是动物不是一台机器，人的认知和记忆能力是有限的。视觉设计和心理是相互联系的，并且可以相互影响。格式塔原则可以帮助我们理解和控制这些联系。</p>
<p>今天就给大家科普下格式塔原则到底是什么? 在设计中如何运用? 是如何影响到我们的生活学习的? 本文会结合大量案例分析讲解，无论您是平面设计师，UI 设计师，插画师，设计小白还是路人，一篇文章让格式塔帮您做出更好的设计!</p>
<h3 id="什么是格式塔原理" tabindex="-1"> 什么是格式塔原理</h3>
<p>格式塔学习理论可谓是现代认知主义学习理论的先驱，自 1912 年由韦特海墨(Ｍ，Wetheimer)提出后，在德国得到迅速发展。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-history.jpg" alt="格式塔原理发展历史"></p>
<p>1910，这位心理学家乘坐火车度假旅行。当火车经过一个铁路道口的时候，他发现道口闪烁的灯竟然像马戏团表演时剧院帐篷上环绕的灯光，令他产生了光在运动的错觉。(而我们坐火车永远就只会遇到熊孩子和熊孩子)然后他赶紧下火车买了一个西洋镜，来测试自己的想法。</p>
<p>他将一张图片放在西洋镜内部并通过狭缝观看时，一系列静止图像看起来像是动图。接着他用简单的抽象线条制作不同的画条，通过改变这些元素来研究导致错觉的原因。似动(Apparent Movement)实验成为格式塔心理学的起点。</p>
<h3 id="解决什么问题" tabindex="-1"> 解决什么问题</h3>
<p>他们认为思维是整体的、有意义的知觉，而不是联结起来的表象的简单集合；主张学习是在于构成一种完形，是改变一个完形为另一完形。我们的视觉系统自动对视觉输入构建结构，并在神经系统层面上感知形状、图形和物体，而不是只看到互不相连的边、线和区域。所谓格式塔，是德语 Gestalt 的译音，意即「完形」或「形状」；他们认为学习的过程不是试尝错误的过程，而是顿悟的过程，即结合当前整个情境对问题的突然解决。再通俗一点就是人是怎样认知和记忆所看到的事物。</p>
<h2 id="格式塔实验研究" tabindex="-1"> 格式塔实验研究</h2>
<p>主要包括以下三方面的实验研究:</p>
<h3 id="_1-似动现象" tabindex="-1"> 1. 似动现象</h3>
<p>似动现象是形成格式塔心理学的基础。是指两个相距不远、相继出现的视觉刺激物，呈现的时间间隔如果在 1/10 秒到 1/30 秒之间，那么我们看到的不是两个物体，而是一个物体在移动。</p>
<p>例如，我们看到灯光从一处向另一处移动，事实上是这只灯熄了，那只灯同时亮了。这种现象正是不能把整体分解成部分的证据。这种现象的组成部分是一些独立的灯在一开一关，但组成一个整体后，给人造成这些灯在动的假象。</p>
<p>后来，格式塔心理学把重点放在整体系统上，在这个系统中，各个部分是以一种能动的方式相互联系在一起的，也就是说，仅根据各分离的部分，无法推断出这个整体。所以人们把它称为「格式塔或完形心理学」。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-move.jpg" alt="似动现象"></p>
<ul>
<li>
<p>A: 这张螺旋图是静态还是动态的? 盯着漩涡看一会，您就会感觉到它在转动。</p>
</li>
<li>
<p>B: 您数数看有几个黑点? 当您的眼睛离开那个白点时，就出现白的负象，即黑。当您重新把视点 集中在原来的白点上时，它又变成白色的了。因此，当您的眼睛不断地 在移动的时候，那些黑白点 (正负像) 也就在不断地变化。</p>
</li>
<li>
<p>C: 您看是水平线还是不规则的斜线? 事实上所有的横线都是水平的，不信您拿尺子比一下。</p>
</li>
</ul>
<h3 id="_2-整体与部分" tabindex="-1"> 2. 整体与部分</h3>
<p>看起来格式塔心理学是把重点放在整体上，但这并不意味着他们不承认分离性。事实上，格式塔也可以是指一个分离的整体。</p>
<p>研究认为，一个人的知觉场始终被分成图形与背景两部分。「图形」是一个格式塔，是突出的实体，是我们知觉到的事物；「背景」则是尚未分化的、衬托图形的东西。知觉帮助我们把图形从背景中分离出来。图形与背景的对比越大，图形的轮廓越明显，则图形越容易被发觉。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-shape.jpg" alt="整体与部分"></p>
<ul>
<li>
<p>A: 这幅美食节广告中，酒瓶是被战略性地放置，以创造一个叉子的错觉。黑色酒瓶是图形，白色叉子是背景；在另一种情况下，黑色酒瓶是背景，白色叉子是图形。</p>
</li>
<li>
<p>B: 一黑一白两只天鹅，白天鹅和黑天鹅可以互充图形与背景的关系。</p>
</li>
<li>
<p>C: 这幅海报中，小女孩和气球是被战略性的放置，以创造一个字母「R」的错觉。这两个角色同样可以在图形和背景中互换。</p>
</li>
</ul>
<p><img src="@source/design/articles/assets/gestalt-principle-shape2.jpg" alt="整体与部分"></p>
<h3 id="_3-顿悟实验" tabindex="-1"> 3. 顿悟实验</h3>
<p>W·科勒在一次实验中用绳子把一只香蕉悬挂在笼子的顶棚上。笼子里只有惟一的一只木箱可以使用。6 只黑猩猩看到香蕉时跳跃起来竭力想抓住香蕉，但是徒劳。有一只名叫苏尔坦的黑猩猩马上停止了这些白费力气的努力，开始从各个方向打量箱子。忽然它停在箱子前面，抓起它并径直朝目标走去。它把木箱迅速放到地上，爬上箱子，从木箱上面使劲跳起，终于抓住了香蕉。</p>
<p>W·科勒还对这组黑猩猩使用其他工具进行了观察，如利用木棍去获取放在笼子外面的水果。这些黑猩猩甚至能够将两根短棍连接起来做成一根长棍。同样，它们还能把两三个箱子叠放在一起，再爬到放在最上面的箱子顶上，借助一根木棍去获取香蕉。</p>
<p>苛勒通过对黑猩猩进行的许多实验，提出了顿悟理论。他认为问题的解决不是由于尝试错误，而是由于顿悟。所谓顿悟，就是内在地把握情境的关系性，并依此改变整个情境。</p>
<p>或许正如一些批评家所指出的那样，顿悟不是一种独立的学习过程或学习形式，而是学习达到一定程度的表现或者结果。一定的经验积累，是产生顿悟的前提。</p>
<h2 id="影响记忆的三个因素" tabindex="-1"> 影响记忆的三个因素</h2>
<p>沃尔夫实验时要求实验体观看样本图形并记住它们，然后在不同的时间里根据记忆把它们画出来。结果发现实验体在不同的间隔时间画出来的图像都有不同。有时再现的图画比原来的图画更简单更有规则，有时原来图画中显著的细节在再现时被更加突出了。还有的比原来的图像更像某些别的我们都很熟悉的图案了。沃尔夫把这三种记忆规律称之为格式塔三大记忆律: 「水平化」、「尖锐化」、「常态化」。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-logo.jpg" alt="这两个品牌logo哪个才是正确的? "></p>
<h3 id="水平化-leveling" tabindex="-1"> 水平化 leveling</h3>
<p>水平化是指在记忆中我们趋向于减少知觉图形小的不规则部分使其对称；或趋向于减少知觉图形中的具体细节。</p>
<h3 id="尖锐化-sharpening" tabindex="-1"> 尖锐化 sharpening</h3>
<p>尖锐化是在记忆中与水平化过程伴随而行的。尖锐化是指在记忆中，人们往往强调知觉图形的某些特征而忽视其它具体细节的过程。在有些心理学家看来，人类记忆的特征之一，就是客体中最明显的特征在再现过程中往往被夸大了。</p>
<h3 id="常态化-normalizing" tabindex="-1"> 常态化 normalizing</h3>
<p>常态化是指人们在记忆中，往往根据自己已有的记忆痕迹对知觉图形加以修改，即一般会趋向于按照自己认为它似乎应该是什么样子来加以修改的。</p>
<h2 id="格式塔原理在设计中的应用" tabindex="-1"> 格式塔原理在设计中的应用</h2>
<p>格式塔的七个基本原则:</p>
<ul>
<li>接近性原则</li>
<li>相似性原则</li>
<li>连续性原则</li>
<li>闭合性原则</li>
<li>主体/背景原则</li>
<li>简单对称性原则</li>
<li>共同命运原则</li>
</ul>
<div><p>格式塔原理的核心</p>
<p><strong>整体决定部分的性质并且部分依从与整体</strong></p>
</div>
<h3 id="接近性原则-law-of-proximity" tabindex="-1"> 接近性原则 law of proximity</h3>
<p>人们对知觉场中客体的知觉，是根据它们各部分彼此接近或邻近的程度而组合在一起的。两个元素越是接近，组合在一起的可能性就越大。说明它们之间关系更强。但是接近也是有对比的，在复杂的设计中，我们要一边考虑它们之间内部的逻辑关系一边来排版。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-proximity.jpg" alt="接近性原则"></p>
<blockquote>
<p>同样都是 12 个圆形，您会把左图的 12 个圆形当成一个整体；右边那幅图，上面 4 个圆和下面 8 个圆距离较远，所以您会把上面 4 个圆当成一个整体，下面 8 个圆当成另外一个整体。</p>
</blockquote>
<p>需要注意的是，接近性比重较大，把上图的圆形改变形状，甚至添加颜色，人们也会把相近的一组当成一个整体:</p>
<p><img src="@source/design/articles/assets/gestalt-principle-proximity2.jpg" alt="接近性原则"></p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-proximity-app-store.jpg" alt="App Store"></p>
<p>板块之间的大间距把页面信息分割成各种不同栏目，距离更近的信息暗示了他们有内在的逻辑关系</p>
<p><img src="@source/design/articles/assets/gestalt-principle-proximity-zhanku.jpg" alt="站酷"></p>
<p>设计师模块，每个设计师信息组之间有足够大的留白，即使去掉分割线，用户也会清晰分清每一组的边界</p>
</div>
<div><p>提示</p>
<p>在界面设计中常用的设计方法就是划分固定的位置区域，比如导航栏，内容区，操作栏。还有就是通过距离远近来进行信息归类，同类信息接近，不同信息远离。</p>
</div>
<div><p>相关信息</p>
<p>属性相同、场景相似的信息应该放到一起，降低阅读成本，提高用户感知效率;不相关的信息尽量区分开，不要放到一起模糊不清引起不必要的误解。</p>
</div>
<h3 id="相似性原则-law-of-similarity" tabindex="-1"> 相似性原则 law of similarity</h3>
<p>人们在感知时，会对那些相似的项目，只要不被接近因素干扰，会倾向于把它们联合在一起。换言之，相似的部分在知觉中会形成若干组。</p>
<p>例如，我们在小组辩论中，往往几个人争着发言，但我们仍然能从嘈杂的声音中听出某个人的讲话，这是因为这个人讲话的音质始终有相似性的缘故。如果他讲话的音质经常在变化，那就很难从噪音声中分辨出他的话来。</p>
<p>人们会把那些明显具有共同特性(如形状、大小、共同运动、方向、颜色等)的事物当成一个整体。与不具有相似视觉特征的元素相比，具有相似视觉特征的元素被认为更加相关。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-similarity.jpg" alt="相似性原则"></p>
<p>举个例子相似性原则在实际产品中的应用:</p>
<p><img src="@source/design/articles/assets/gestalt-principle-similarity-bilibili.jpg" alt="bilibili"></p>
<blockquote>
<p>上图全部频道页面，我们在浏览时，会从心理上默认，把频道头像、介绍和订阅按钮自动归为一类。类似外形的单元会被我们人脑默认为同一属类</p>
</blockquote>
<div><p>相关信息</p>
<p>看起来跟亲密性非常类似，但是他们确实不同的两个概念。亲密性强调位置，相似性则强调内容。通常把有明显特征的事物(形状、颜色、大小)组合在一起。多用于表单和导航。</p>
</div>
<h3 id="连续性原则-law-of-continuity" tabindex="-1"> 连续性原则 law of continuity</h3>
<p>在知觉过程中人们往往倾向于使知觉对象的直线继续成为直线，使曲线继续成为曲线，也就是视觉的惯性。利用连续律我们可以让用户操作界面时不经过思考就点击一个固定的位置。</p>
<p>我们倾向于完整地连接一个图形，而不是观察残缺的线条或形状。这种知觉上的结束，称之为闭合。如果局部形象过于陌生或者简略，则不会产生整体闭合联想。</p>
<p>人的视觉有追随一个方向的延续，以便把元素联接在一起，使它们看来是连续向着特定的方向。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-continuity.jpg" alt="连续性原则"></p>
<p>△ 左图我们不会认为是两个残缺的圆，而是两个相交的圆；中间的 IBM 商标我们之所以能看出来是 IBM，就是因为我们在视觉上看到的不是离散的线条，而是连续的图形；右图我们会看到是向两个方向连续的曲线。</p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-continuity-stock.jpg" alt="股市"></p>
<p>每天的股市数据构成走势图，视觉上会跟随曲线方向知道由左向右去看走势</p>
</div>
<div><p>相关信息</p>
<p>视觉倾向于感知连续的形式而不是分散的碎片通过找到非常微小的共性，将多个不同的信息结成一个整体，是界面设计和 logo 设计常用的原则之一</p>
</div>
<h3 id="闭合性原则-law-of-closure" tabindex="-1"> 闭合性原则 law of closure</h3>
<p>人们在观察熟悉的视觉形象时，会把不完整的局部形象当作一个整体的形象来感知，这种知觉上的结束，称之为闭合。如果局部形象过于陌生或者简略，则不会产生整体闭合联想。</p>
<p>闭合是一种完成某种图形(完形)的行动。就算没有外形的约束，我们也会自动把图形脑补完全。比如半个形状或者有缺口的形状我们不会认为是一条线或各种零碎的图形，而是一个完整的形状。闭合是指一种完形的认知规律。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-closure.jpg" alt="闭合性原则"></p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-closure-apple-music.jpg" alt="Apple Music"></p>
<p>我们常见的页面横滑组件就运用了闭合律原则，通常在界面右侧露出一半(或少部分)内容，来提示用户右边还隐藏着更多内容</p>
</div>
<div><p>相关信息</p>
<p>人们的视觉系统会自动将不相干的图形元素封闭起来感知为完整的个体为不实单独的碎片</p>
<p>表现手法有:正负形、封闭边界、不完全闭合</p>
</div>
<h3 id="主体-背景原则" tabindex="-1"> 主体/背景原则</h3>
<p>主体指的是在界面当中占据我们主要注意力的所有元素，其余的元素在此时均成为背景。当主体与背景重叠时，人的视觉更加倾向于将小的物体视为主体，大的物体视为背景，所以我们可以通过大小与图的关系，将我们希望传递的不同层次的内容进行展示。</p>
<p>当小图形重叠大图形之上，我们的视觉会倾向于将小图形归为主体，大色块为背景，这就是格式塔中的主体与背景原则。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-main.jpg" alt="主体/背景原则"></p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-main-doubanFM.jpg" alt="豆瓣 FM"></p>
<p>在白色背景上有非常突出的主体: 歌曲封面、歌名、进度条、播放/暂停、收藏等，歌曲播放时，进度条有非常明显的进度变化，切换歌曲时，封面的前后错层，这些都与背景有非常鲜明的对比</p>
</div>
<div><p>相关信息</p>
<p>在界面设计中，主体背景是弹窗常常运用到的表现手法利用空间感给用户带来视觉引导，让用户快速感知重要的信息内容，和可忽略的信息内容</p>
</div>
<h3 id="简单对称性原则-simple-principle" tabindex="-1"> 简单对称性原则 Simple principle</h3>
<p>在观察事物过程中，我们第一印象更倾向于简单而且对称的图形，这就是格式塔的简化对称性原则。</p>
<p>具有对称、规则、平滑的简单图形特征的各部分趋于组成整体。对称的元素往往被认为是归属在一起的，而不管它们之间的距离，都给我们一种牢固和有序的感觉。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-simple.jpg" alt="简单对称性原则"></p>
<p>人的眼睛喜欢在复杂的形状中找到简单而有序的对象，当我们在一个设计中看到复杂的物体时，眼睛更愿意将它们转换为单一统一形状，并尝试从这些形状中移除无关的细节来简化这些物体。</p>
<p>对称的构图是令人满意的，但它们也会变得有点沉闷。在对称的设计中加入不对称的元素可以在给人留下印象的同时吸引注意力。</p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-simple-pinterest.jpg" alt="Pinterest"></p>
<p>左右布局的瀑布流就是格式塔的简化对称性的体现，用户在浏览的的过程中有效减轻了阅读压力。特别适合这种以图片流为主的产品，能大大提高浏览效率。</p>
</div>
<div><p>相关信息</p>
<p>对称元素简单、和谐，但往往容易单调，一般来说加入不对称的样式会更容易让人印象深刻，在平面设计中对称的使用趣味性更加广泛</p>
</div>
<h3 id="共同命运原则-common-destiny" tabindex="-1"> 共同命运原则 Common destiny</h3>
<p>无论元素之间的距离有多远，或者它们看起来有多不同，如果它们一起运动或变化，它们都被认为是相关的。这里的共同命运针对的是运动的物体。与接近性原理和相似性原理相像，都与我们的视觉系统会有着给对象进行分组来感知事物的倾向相关，但是一起运动的物体会被感知为属于同一组或是彼此相关这样的一种视觉现象，这就是格式塔中的共同命运原则。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-common-destiny.jpg" alt="共同命运原则"></p>
<p>向同一方向移动的元素，我们在处理的过程当中，会默认把它们归为一类。</p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-common-destiny-iOS.jpg" alt="ios 桌面"></p>
<p>iPhone 删除应用时候，所有图标都一起晃动起来(意思瑟瑟发抖，不要删我不要删我! )，左上角都有一个删除的按钮，要么删除，要么保留，这就是共同命运原则。</p>
</div>
<div><p>相关信息</p>
<p>共同命运强调的是方向，当元素的运动、方向具有共同运动形式或者某种规律使，我们会将其视为为彼此相关的一个群组或整体</p>
</div>
<h3 id="更多" tabindex="-1"> 更多</h3>
<p>事实上，以上 7 条原则只是格式塔心理学中的一小部分而已，比如还有:</p>
<h4 id="成员特性律" tabindex="-1"> 成员特性律</h4>
<p>一个整体中的个别部分并不具有固定的特性，个别部分的特性是从它与其他部分的关系中显现出来的。</p>
<p><img src="@source/design/articles/assets/gestalt-principle-special.jpg" alt="成员特性律"></p>
<p>如果我们有很多同样的按钮，如何让某个更重要的按钮突出但是仍然让用户感知还是按钮呢? 那就要用到成员特性律了。成员特性律赋予了集体中某一个元素特殊的一些刺激元素从而突出它。</p>
<p>独特的外形暗示了它与别的元素有不同的功能</p>
<div><p>案例</p>
<p><img src="@source/design/articles/assets/gestalt-principle-special-taobao.jpg" alt="淘宝"></p>
<p>商品详情页有两个重要的操作按钮: 加入购物车、立即购买。为了促使用户尽快购买，给「立即购买」更重的红色以突出它的独特性</p>
</div>
<h2 id="格式塔学习理论的基本观点" tabindex="-1"> 格式塔学习理论的基本观点</h2>
<h3 id="认知重组" tabindex="-1"> 认知重组</h3>
<p>格式塔心理学认为，通过学习，会在头脑中留下记忆痕迹，这些痕迹不是孤立的要素，而是一个有组织的整体，即完形。因此，学习主要不是加进新痕迹或减去旧痕迹的问题，而是要使一种完形改变成另一种完形。一个人学习的过程，通常是从一种混沌的模糊状态，转变成一种有意义的、有结构的状态，这就是知觉重组的过程。</p>
<h3 id="顿悟学习" tabindex="-1"> 顿悟学习</h3>
<p>顿悟学习可以避免多余的试误，同时又有助于迁移。格式塔心理学家认为，通过对问题情境的内在性质有所顿悟的方式来解决问题，就可以避免与这一问题情境不相干的大量随机的、盲目的行动，而且有利于把学习所得迁移到新的问题情境中去。顿悟学习的核心是要把握事物的本质，而不是无关紧要的细节。</p>
<h3 id="遗忘曲线" tabindex="-1"> 遗忘曲线</h3>
<p>真正的学习是不会遗忘的。通过顿悟习得的内容，一旦掌握后，永远也不会遗忘。顿悟将成为我们知识技能中永久的部分。用现代认知信息加工心理学的术语来说，顿悟的内容是进入了长时记忆将永远保留在学习者的头脑中。</p>
<div><p>提示</p>
<p>有人在一项实验中，把 149162536496481 写在一张卡片上，要一组被试看 15 秒钟，然后试图回忆它。这是一项相当困难的任务。在一般情况下，除了记住其中少数几个数字外，没有人能全部记住。但在给另一组被试看这张卡片之前，告诉他们在试图记住它以前，先想一下这些数字为什么这样排列，是否有规律可循。结果不少被试都觉察到，这些数原是用 1 到 9 的平方排列起来的。这样一来，回忆这些数字就毫无困难，哪怕是在几周或几个月之后也能轻易做到。</p>
</div>
<h3 id="学习奖励" tabindex="-1"> 学习奖励</h3>
<p>格式塔心理学家认为，真正的学习常常会伴随着一种兴奋感。例如，一些人对智力拼图、字迷填空玩得津津有味。也因此有人抨击滥用各种外部奖励，诸如使用糖果、好分数、五角星或金钱之类的东西来驱动学习。对于教育工作者来说，不加区分地使用奖励物，可能会使学生分心，不把心思用在学习上，而只关心能得到什么奖励上，从而不可能达到对问题情境有顿悟的理解。</p>
<h3 id="顿悟说对错误说的批判" tabindex="-1"> 顿悟说对错误说的批判</h3>
<p>还记得第二部分对猩猩的实验吗，实验表明猩猩在行动之前，已经领会到了自己的动作为什么进行，怎样去进行以及最终的结果为何，在苛勒看来，猩猩对问题的解决并非是一种盲目尝试错误的过程，而是处于对问题产生了顿悟。</p>
<p>在格式塔心理学家看来，学习是一种智慧行为，是一种顿悟过程，需要有理解、领会与思维等认识活动的参与，并且它是一种突现、速变、飞跃的过程。顿悟学习特点可归纳如下: 问题解决前尚有一个困惑或沉静的时期，表现得迟疑不决，有长时间停顿；从问题解决前到问题解决之间的过渡不是一种渐变的过程，而是一种突发性的质变过程；在问题解决阶段，行为操作是一个顺利的不间断的过程，形成一个连续的完整体，很少有错误的行为；由顿悟获得的问题解决方法能在记忆中保持较长的时间；由顿悟而掌握的学习原则有利于适应新的情境，解决新的问题。</p>
<h3 id="创造性思维" tabindex="-1"> 创造性思维</h3>
<p>韦特默认为要想创造性地解决问题必须让整体支配部分。即使在必要的关注问题的细节时，也决不能忽视问题的整体。必须把细节放在问题的整体中，把它们与整体结构联系起来加以考虑。这是一种自上而下、由整体到部分的思维。他认为要使人们顺利地解决问题，必须把问题的整个情境呈现出来，使之能对问题有个完全概观，决不能像桑代克那样，有意地把解决问题的方法和途径藏起来，迫使被试不得不去盲目试误。学习贵在打破旧有知识和模式的束缚，争取在对问题领域的基础上产生顿悟，掌据解决问题的原则，做到触类旁通、举一反三，促进智力水平的提高。</p>
<h2 id="格式塔学习理论的分支" tabindex="-1"> 格式塔学习理论的分支</h2>
<h3 id="勒温的基本观点" tabindex="-1"> 勒温的基本观点</h3>
<p>传统的格式塔心理学在探讨学习的问题时，认为学习者「渴望达到某些目的」是理所当然的，因而他们关注的是通过知觉重组达到目的的途径；而勒温则把注意力集中在「渴望」和「目的」本身上，并把它们与个性联系起来研究。勒温由此而形成的理论体系，主要不是一种学习理论，而是一种描述系统。</p>
<h3 id="勒温论学习" tabindex="-1"> 勒温论学习</h3>
<p>勒温的基本观点是社会心理学方面的，尤其是关于个体的动机。从某种角度来看，这弥补了格式塔学习理论的不足。勒温认为，用场论来研究学习的问题，需要注意以下几个方面:</p>
<p>要使用构成法(Constructive method)，而不是用分类法或分析法。这就是说，要用心理学中最基本的几个构成来探讨学习的问题。这些基本构成就是生活空间，心理环境、诱发力和约束力等。</p>
<p>要对行为作动态分析，要了解作为行为之基础的各种力(forces)。他把行为变化看作是各种心理力量的结果。</p>
<p>要从心理的角度来分析学习者当时的生活空间和心理世界，而不能像行为主义者那样用客观的物理主义者的术语来界定刺激。</p>
<p>要从整体情境分析入手，而不能只是从刺激情境中抽取一两个孤立的要素。因为不从整体上考虑问题，是不可能作出正确判断的。</p>
<p>行为是行为发生时场的函数。勒温认为行为取决于有机体以往的经验和强化史，这是形而上学的。因为过去的事情现在并不存在，所以不可能直接影响现在的行为。虽说过去的心理场是现在的心理场的来源，但影响现在行为的，毕竟是现在的心理场。</p>
<p>在研究学习时，至少必须区别这样四种变化: 第一，作为认知结构(即知识)变化的学习；第二，作为动机变化的学习；第三，作为群体属性和意识形态变化的学习；第四，作为身体肌肉随意控制发生变化的学习。在勒温看来，学习理论要探讨的，主要是学习者认知结构和动机的变化。</p>
<h3 id="评论" tabindex="-1"> 评论</h3>
<p>勒温在格式塔心理学的框架结构内引进「场」、「生活空间」、「拓扑学」和「向量」等概念，另辟蹊径，从而丰富和发展了传统的格塔理论。尽管他研究的重心放在社会心理学方面，但他对行为、问题和动机等方面探讨，在当时是很有新意的。</p>
<h2 id="格式塔原理的贡献与局限性" tabindex="-1"> 格式塔原理的贡献与局限性</h2>
<h3 id="_1-贡献" tabindex="-1"> 1. 贡献</h3>
<h4 id="对元素主义的反击具有进步意义" tabindex="-1"> 对元素主义的反击具有进步意义</h4>
<p>格式塔学派用大量的事实证明了冯特元素主义理论的漏洞百出，并大胆地冲破了元素主义的束缚，积极而有成效地进行了大量的探索，并取得了一系列引人注目的成果，这对促进心理学事业的繁荣和发展是大有脾益的。</p>
<h4 id="格式塔学派引发了知觉心理学的革新" tabindex="-1"> 格式塔学派引发了知觉心理学的革新</h4>
<p>由于格式塔学派在知觉领域做了大量有目共睹的研究，使得经验论、联想论、官能主义的传统方法逐渐让位于先验论、整体论和突创论。知觉心理学也由感觉心理学的附庸变成一个独立的分支，并在短时期内就取得了一系列突破。</p>
<h4 id="格式塔学派的学习理论独具特色" tabindex="-1"> 格式塔学派的学习理论独具特色</h4>
<p>格式塔学派的顿悟说及对迁移、创造性思维的研究，冲击了联结主义和行为主义的框框，不论在理论创建还是在教育实践中都具有独到的价值和意义。顿悟说也成为西方学习理论中最重要的理论之一。</p>
<h4 id="对人本主义心理学影响较大" tabindex="-1"> 对人本主义心理学影响较大</h4>
<p>人本主义心理学的创建人马斯洛(就是提出人生 7 个层次的需求理论的那位)曾在他老师的惠特海默指导下，研究整体论，从而积累下了研究人的经验；同时期的对人的心理事件或整体研究。主张存在分析的心理学，这些都表明了格式塔学派的潜在影响。</p>
<h4 id="对现代认知心理学的产生起了推动作用" tabindex="-1"> 对现代认知心理学的产生起了推动作用</h4>
<p>格式塔学派研究的那些认知过程及心理过程成了现代认知心理学的基本观点，正如罗伯特逊指出，认知心理学实际上是一种新格式塔现象。</p>
<h3 id="_2-局限性" tabindex="-1"> 2. 局限性</h3>
<p>过分强调顿悟，而全面否定尝试错误，犯了以偏概全的偏激性错误。</p>
<p>顿悟似乎是一个神秘的概念，它的心理活动机制没有揭示清楚。还不能说是一个完善的理论解释。</p>
<p>顿悟说还缺乏对其他与学习有关问题的研究。而且研究的主要是动物的经验学习，还不能很好地解释人类的所有直接经验学习，如技能的习得等。</p>
<p>其理论观点和术语含糊不清。格式塔学派不加分析地采用了一些物理学的概念和数理术语，观点模棱两可，概念不确切，给人的感觉是理论主张过于晦涩深奥，神秘莫测。</p>
<p>对其他学派的批评过于苛刻，他们只批评其他学派的缺陷，却没有提出更好的改进措施，且自身的理论建设和主张又并不明确和高明多少。原来每个行业都有一条鄙视链的存在啊。</p>
<p>格式塔学派的实验不够严谨，过分依赖现象学的方法，缺乏信度和效度，就水平而言，并不比他们所批评的其他学派好多少。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>我们把原理归类、总结的目的有两个: 一个是自我检查，我们在构思设计的过程中往往会多于专注视觉效果的创作而忽略最基本的原理，比如在设计之前进行完整的设计构思；设计过程中检查自己的设计作品，避免低级错误导致反复改稿，比如信息不对齐，布局杂乱等；再就是设计完成之后对需求方有理有据的陈述。第二个是在深入理解的前提下做设计时能够举一反三。</p>
<p>用户界面设计并不全是关于漂亮的像素和完美的图形。它主要是关于沟通、性能和便利性。格式塔原则总是帮助我们实现这些目标，为用户创造愉快的体验，为企业创造巨大的成功。</p>
<p>通过例子可以发现，这 7 项法则并不是独立存在的，它们之间具有高度的关联性，是相辅相成的关系，我们需要跟进不同的需求类型和用户场景，运用这些基本法则打出组合拳，使您的设计方案更有依据。在做产品或者设计的时候一定要考虑人的认知与记忆的因素，这是与生俱来的天性，人们的审美对简单与和谐具有基本的要求。我们只有更好的利用视觉空间设计作品，减少设计的复杂性，尽量保持格式塔原则的完整，用户才能更好更容易地理解使用我们的产品。</p>
<blockquote>
<p>参考文献:</p>
<ul>
<li>《格式塔心理学理论》MBA 智库</li>
<li>《格式塔心理学原理》库尔特.考夫卡</li>
<li>《视觉设计中的格式塔艺术心理学》</li>
<li>《格式塔心理学 5 项法则的学习与思考》Tencent CDC</li>
<li>《设计中的格式塔原则》Souche Blog</li>
<li>维基百科及其他</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>信息流介绍</title>
      <link>https://0808200.xyz/design/articles/infomation-flow.html</link>
      <guid>https://0808200.xyz/design/articles/infomation-flow.html</guid>
      <source url="https://0808200.xyz/rss.xml">信息流介绍</source>
      <category>设计</category>
      <pubDate>Sat, 26 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>今日头条的出现颠覆了传统新闻产品(如网易、新浪和搜狐新闻)。</p>
<p>传统新闻依靠着编辑人员的推荐，将新闻触达给用户，而今日头条则依靠着新闻算法，抛弃传统人工分发的思路，使分发效率数以万计的提升，其迅速崛起，成为头部新闻资讯产品。</p>
<p>今日头条作为新闻信息流的头部产品，里面的设计细节和设计逻辑值得我们思考和分析。</p>
<h2 id="信息流样式" tabindex="-1"> 信息流样式</h2>
<p>什么是信息流? 信息流由两部分组成，信息流=信息+流。</p>
<p>信息指的是内容，这些内容可以是新闻、视频、图片等，所呈现的样式多为列表或卡片。</p>
<p>流指的是瀑布流，可以无限滑动浏览。</p>
<p>所以信息流就是可以无限滑动浏览内容信息。</p>
<p>信息流的样式的好坏，会直接影响到信息的展现效率和点击率，从而影响到用户获取信息的效率和整体阅读时长。</p>
<p>下图为今日头条首页推荐频道的信息流:</p>
<p><img src="@source/design/articles/assets/infomation-flow1.jpg" alt="信息流"></p>
<p>将信息流样式进行简单分类，使用最多的四种样式为纯文、左文右图、短内容、大图视频。如下图所示:</p>
<p><img src="@source/design/articles/assets/infomation-flow2.jpg" alt="信息流"></p>
<p>纯文样式用于新闻中没有图片的情况，当文章中没有图片时，这时候采用改样式。列表含有: 标题、来源、评论数、发布时间。</p>
<p>对于含有图片时候，采用左文右图样式。目前新闻对于含有图片的列表样式，一般有 3 种分别为: 左文右图、左图右文和三图。</p>
<p>左图右文的样式，强化图片，弱化标题。对于新闻资讯来说，图片无法准确的表达其新闻资讯的内容，所以这种样式目前没什么产品使用。</p>
<p>目前市面上绝大部分产品都采用左文右图，例如今日头条、网易新闻、腾讯新闻、新浪新闻等。只有是搜狐新闻采用左图右文。</p>
<p><img src="@source/design/articles/assets/infomation-flow3.jpg" alt="信息流"></p>
<p>三图则通过图片吸引用户点击查看，更加通过图片引导用户点击，好处是可以提升点击率，但是整个信息流显得乱，影响用户阅读。</p>
<p><img src="@source/design/articles/assets/infomation-flow4.jpg" alt="信息流"></p>
<p>和网易相比，头条信息流阅读起来更加舒服，视觉压力减少，这是基于今日头条三图样式占比很少，如下图所示，网易新闻信息流插入三图样式导致整个信息流杂乱。</p>
<p><img src="@source/design/articles/assets/infomation-flow5.jpg" alt="信息流"></p>
<p>对比下网易新闻和今日头条信息流样式，如下图所示:</p>
<p>纯文，今日头条的标题颜色更深，网易的相对而言淡一些。头条的列表高度比网易的高，这意味着，头条的屏幕展示条数比网易新闻的少，但是整体的空间感和留白呼吸感更舒服。同时今日头条含有发布时间，使得用户观看新闻资讯时，能够感知新闻的实时性。</p>
<p><img src="@source/design/articles/assets/infomation-flow6.jpg" alt="信息流"></p>
<p>左文右图，头条的列表比网易的要高一些，对比来看，头条的标题更加明显，图片含有圆角半径，使得头条整体看上去更舒服。</p>
<p><img src="@source/design/articles/assets/infomation-flow7.jpg" alt="信息流"></p>
<p>大图视频，两者的区别不大，依然是标题文字颜色、封面圆角和发布时间的差异性。</p>
<p><img src="@source/design/articles/assets/infomation-flow8.jpg" alt="信息流"></p>
<h3 id="小结" tabindex="-1"> 小结</h3>
<p>头条流整体的空间感、留白，标题颜色对比做的比较好。</p>
<p>留白相对于网易更多一些，相同的屏幕空间，展示的内容信息会少一点，屏幕展示效率会低一些。但用户在阅读过程中舒适度更强，同样的情况下用户的阅读时长会变长。</p>
<h2 id="信息流分发" tabindex="-1"> 信息流分发</h2>
<p>什么是信息流分发? 通过一定的设计策略，将用户的流量合理的分配到其他各个地方，从而达到产品的设计目标，促进流量利用最大化。提升流量最大限度的转化，获得更大的商业化价值。</p>
<p>今日头条的信息流主要包含 5 个模块: 置顶模块、资讯列表、广告模块、短内容、其他功能模块的卡片入口。如下图所示:</p>
<p><img src="@source/design/articles/assets/infomation-flow9.jpg" alt="信息流"></p>
<p>推荐流顶部的置顶内容，最多置顶两条，这里是因为相关政策原因。</p>
<p>在正常信息流第一条之后，插入广告，为平台做商业化营收。之后就会根据用户的阅读习惯，给用户推荐信息内容，并时不时的插入广告等。</p>
<p>今日头条没有编辑运营，所以几乎所有的新闻都来自于机器算法。少了编辑人员的人工运营，使得今日头条有巨量的内容按照不同用户的阅读习惯推荐用户不同的内容。</p>
<h2 id="搜索栏" tabindex="-1"> 搜索栏</h2>
<p>在新闻信息流产品里，搜索栏所承接的使用场景主要有两个。一个是提供搜索新闻功能，通过关键词对当前或过去的新闻进行搜索。</p>
<p>另一个是在搜索模块提供热搜新闻，提供用户阅读。</p>
<p>那么如何提升搜索栏的点击次数。今日头条将热搜新闻以提示语的形式展示在搜索栏滚动，吸引用户。同时为了更大限度的展示新闻条数，采用一排两个的设计，保证最大程度的提升点击率。</p>
<p><img src="@source/design/articles/assets/infomation-flow10.jpg" alt="信息流"></p>
<p>用户点击搜索框之后，搜索框里面内置第一条热搜关键词。用户可通过键盘上的搜索，进行搜索。也可以点击搜索栏下方的两个热搜新闻进行搜索查看。</p>
<h2 id="短视频" tabindex="-1"> 短视频</h2>
<p>视频标题内置于播放器中，这样的好处可以减少卡片高度，让视频曝光量提升，缺点是用户如果想看视频标题介绍时，则需要点击下播放器，标题才能再次出现。</p>
<p><img src="@source/design/articles/assets/infomation-flow11.jpg" alt="信息流"></p>
<p>标题置于播放器里面，头条可以展示 2.5 条，而好看视频将标题置于外面只能展示 2 条，如下图所示:</p>
<p><img src="@source/design/articles/assets/infomation-flow12.jpg" alt="信息流"></p>
<p>对于广告业务来说，收入的一个重要指标则是广告曝光量，为了提升广告的收入，则必须降低视频高度，使得广告曝光效率得到提升，以此提升收入，所以头条将标题放置于播放器里面符合商业目标，但是不符合用户目标。</p>
<h2 id="小视频" tabindex="-1"> 小视频</h2>
<p>小视频的布局设计大致有两种，一种是抖音式布局，采用头像和操作项位于右侧。这样的好处是，视频的互动量很明显的展示出来，可引导用户互动。但对视频的内容有一定遮挡影响。</p>
<p>另一种是好看视频式布局，将头像昵称、操作项放在底部，弱化视频的互动数据。让用户专注于视频内容。</p>
<p><img src="@source/design/articles/assets/infomation-flow13.jpg" alt="信息流"></p>
<p>今日头条的小视频采用和抖音一样的布局。头像和操作项放于右侧。但是为了引导用户评论，在界面底部加入了输入框，引导用户评论，为了让用户更加方便的看评论。上滑手势变成了调起起评论。</p>
<p><img src="@source/design/articles/assets/infomation-flow14.jpg" alt="信息流"></p>
<h2 id="短内容流" tabindex="-1"> 短内容流</h2>
<p>推荐流里面的短内容(微头条)，点击进入短内容 feed 流。而非短内容详情页。用户如果想看详情，那么需要用户再次点击。</p>
<p><img src="@source/design/articles/assets/infomation-flow15.jpg" alt="信息流"></p>
<p>这种设计明显体验不好，估计产品为其他短内容导流。这样的交互设计，可以使得整体的短内容流的曝光量提升好几倍。</p>
<p>这种做法牺牲了体验，用户如果需要看详情，则需要连续点击两次。这是为了业务指标作出牺牲的设计。</p>
]]></content:encoded>
    </item>
    <item>
      <title>布局中的左和右</title>
      <link>https://0808200.xyz/design/articles/left-or-right.html</link>
      <guid>https://0808200.xyz/design/articles/left-or-right.html</guid>
      <source url="https://0808200.xyz/rss.xml">布局中的左和右</source>
      <category>设计</category>
      <pubDate>Sat, 26 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="左右横跳的泳道" tabindex="-1"> 左右横跳的泳道</h2>
<p>最近经常在人人视频上看电视剧，发现人人视频在设计上有个很有意思的点。</p>
<p>它的电影页中有很多推荐电影片单，每个片单里有 5-12 部电影；碍于手机尺寸，用户只能看到 3 部电影；如果您对这个片单里的电影比较感兴趣，可以滑动查看更多的电影——这种横向滑动的设计又被称之为“泳道”。</p>
<p><img src="@source/design/articles/assets/left-or-right-renren.jpg" alt="泳道"></p>
<p>那么问题来了，究竟向哪个方向滑动呢?</p>
<p>或许您会觉得这是一个送分题，肯定是左滑啊；没错，您去查看 100 个 APP，这种水平横滑的泳道，99 个都是左滑的；但是人人视频就是那唯一的特例，它是左滑和右滑相互组合的。</p>
<p><img src="@source/design/articles/assets/left-or-right-renren.gif" alt="人人交互"></p>
<p>前一个片单是左滑，后一个就是右滑；反之，前一个片单是右滑，后一个就是左滑。</p>
<p>第一次碰到这种设计，我很奇怪: 为什么要做出这种挑战用户固有认知的调整? 后来思考了一下，开始理解他们的做法。</p>
<p>当用户左滑查看电影时，浏览完最后一部电影，用户的视线是停留在在屏幕右侧；如果下一个片单依然采用左滑，那么用户的视线需要先移动到屏幕左侧，再移动到右侧——这个路线就是 Z 型浏览模式；而人人视频紧接着的是右滑，第一个视频直接从右侧开始，避免了用户视线的转移。</p>
<p><img src="@source/design/articles/assets/left-or-right-sight.jpg" alt="视线路径"></p>
<p>人人视频的这种方案，让我想起夸克浏览器——用户在夸克浏览器里观看视频，如果点击屏幕的位置靠左，那么菜单就会出现在左边；如果点击的位置靠右，菜单就会出现在右边；这样的处理方式，可以缩短用户手指的移动距离。</p>
<p><img src="@source/design/articles/assets/left-or-right-quark.gif" alt="夸克菜单"></p>
<p>一个是缩短视线移动距离，一个是缩短手指移动距离。</p>
<h2 id="左还是右" tabindex="-1"> 左还是右</h2>
<p>设计中有很多这样“左、右”的争论。最经典的就是: 对话框的确定按钮到底是在左边还是右边? 这个话题被讨论了无数次。</p>
<p>那么不管是左还是右，我们到底在争论什么? 左和右代表了什么?</p>
<p>我们习惯的浏览方向是由左至右，那么左代表了用户视线的起点。</p>
<p>我们经常说用户的浏览模式是 Z 型的，但是在移动端界面中，左边为信息区，右边为操作区。</p>
<p>用户在快速浏览页面的模式下，根据左边的信息区判断自己是否对这条内容感兴趣，如果感兴趣才进行操作；所以更多的情况下，用户的浏览模式不是 Z 型，而是 L 型的。</p>
<p><img src="@source/design/articles/assets/left-or-right-L.jpg" alt="视线移动"></p>
<p>iOS 11 与 iOS 10 相比，我们可以发现页面标题、搜索框文案和内容都是改成放在左边。</p>
<p><img src="@source/design/articles/assets/left-or-right-app-store.jpg" alt="iOS页面对比"></p>
<p>整体的视觉动线由中间改成了左边，用户在快速浏览过程中视线不需要发生偏移。</p>
<p><img src="@source/design/articles/assets/left-or-right-app-store2.jpg" alt="iOS 页面对比"></p>
<p>右代表着更好的易用性。因为在移动端，用户更习惯单手握持手机进行操作；而我们大部分人都是右撇子。</p>
<p>谷歌的 MD 设计中的浮动按钮，是位于界面右侧；微信的浮窗也是位于界面右侧，就是为了方便用户操作。</p>
<p><img src="@source/design/articles/assets/left-or-right-float.jpg" alt="浮动按钮"></p>
<p>看到这里或许您会理解为什么“对话框的确定按钮在左边还是右边? ”这个话题经久不衰了吧。</p>
<p>因为左边和右边背后都有理论支撑——左代表着离您的眼睛更近，右代表着离您的手更近。</p>
<p>我们再来设想一个场景，针对左撇子用户，界面设计应该怎么调整；用户的惯用手是左手，那是不是要做镜面反转，把操作区移动到左边呢? 读者中肯定有左撇子用户，您们会喜欢这种布局吗?</p>
<p><img src="@source/design/articles/assets/left-or-right-direction.jpg" alt="文字方向"></p>
<h2 id="流量分发" tabindex="-1"> 流量分发</h2>
<p>当然也会有一些设计方案在“左/右”的选择上没这么纠结，例如在微博、抖音这类社交产品中，其主页的“推荐”栏目永远在“关注”栏目的左边。</p>
<p><img src="@source/design/articles/assets/left-or-right-flow.jpg" alt="流量分发"></p>
<p>以微博为例，“关注”和“推荐”在信息架构上是类似的，下面都有一些细分类目: “关注”里有不同的分组，“推荐”里也有不同内容类别，例如热门、同城、榜单等。</p>
<p>但是“关注”用户需要点击下拉框才能筛选，而“推荐”里用户直接右滑就可以切换不同的内容类别；如果把“关注”里的分组也改成滑动切换的样式，那么必然会降低“推荐”栏目的流量。</p>
<p><img src="@source/design/articles/assets/left-or-right-flow2.jpg" alt="流量分发"></p>
<p>抖音也是类似的道理，因为用户左滑可以查看作者的主页，如果把推荐栏目放在左边，那么用户左滑就会进入关注栏目。</p>
<p>引导用户进入已经关注的作者主页，相对来说意义不是很大；抖音的想法是——用户在刷推荐视频的时候，觉得这个视频很好玩，对这个视频的作者产生兴趣；用户可以直接滑动进入作者的主页，而不是需要点击头像才能进入主页。</p>
<p><img src="@source/design/articles/assets/left-or-right-flow3.jpg" alt="流量分发"></p>
<p>微博和抖音的“左关注，右推荐”的模式都是为了往推荐栏目引流。</p>
<p>社交产品追求的是用户可以在这个产品里建立更多关系链，关系链是社交产品的护城河；既然这个人您已经关注了，说明关系链已经形成，那就没有必要引流了。</p>
<p>从这里我们也能看出，在考虑方案的时候，不仅仅要考虑交互易用性，更要着眼于流量分配——哪个方案的流量分配更符合您的诉求，哪个就是好的方案。</p>
<p>甚至在很多时候，当交互易用性跟流量分配相冲突时，交互易用性是被牺牲的一方，因为流量代表了产品经理的 KPI。</p>
<p><img src="@source/design/articles/assets/left-or-right-flow4.jpg" alt="流量分发"></p>
<p>最典型的例子就是知乎为了给答案底部的广告引流把左右滑动切换答案改成了上下滑动；当然，我们也不能批判知乎的这种行为。</p>
<p>还是回到对话框的话题，“确定按钮到底在左边还是右边? ”，最好的办法就是 A/B 测试；如果是一个引导用户安装 APP 的对话框，您就看“确定”按钮放在哪边可以带来更多的转化率。</p>
<p>这个 A/B 测试，搜狗输入法曾经做过，结果显示: 确定按钮放在左边转化率更高，误操作率更低，操作平均时长也更短；那么我们是否可以说，以后“确定”按钮就放在左边了?</p>
<p>当然不可以，因为这个测试是在安卓 4.0 时期进行的；安卓 4.0 之前的系统对话框的确定按钮是在左边的，4.0 才改成右边——用户之前的操作习惯会影响测试结果。</p>
<p>还有一个因素就是设备尺寸，手机尺寸现在越来越大，用户需要双手握持手机；那么在双手操作的模式下，手指可以全覆盖屏幕，那么右边的易用性就没那么高了。</p>
<p>总之，同一个交互问题，在不同的设备，系统，时间和场景下，会有不同的答案。</p>
]]></content:encoded>
    </item>
    <item>
      <title>图标</title>
      <link>https://0808200.xyz/design/icon/</link>
      <guid>https://0808200.xyz/design/icon/</guid>
      <source url="https://0808200.xyz/rss.xml">图标</source>
      <description>本文介绍了 UI 设计中图标的相关介绍与技巧。
</description>
      <category>设计</category>
      <pubDate>Sun, 13 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文介绍了 UI 设计中图标的相关介绍与技巧。</p>

<h2 id="图标网站" tabindex="-1"> 图标网站</h2>
<ul>
<li>
<p><a href="https://www.iconfont.cn/" target="_blank" rel="noopener noreferrer">iconfont</a></p>
<p>阿里妈妈 MUX 倾力打造的矢量图标管理、交流平台。</p>
<p>设计师将图标上传到 Iconfont 平台，用户可以自定义下载多种格式的 icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。</p>
<p>强大的图标在线编辑与自定义下载</p>
<p>图标项目的项目管理、协同、分享</p>
</li>
</ul>
<h2 id="相关文档" tabindex="-1"> 相关文档</h2>
<p>图标是 UI 的设计体系最重要的组成部分之一，是任何 UI 界面中都不可或缺的视觉元素。了解图标相关的概念，以及正确绘制的方法，是入门 UI 设计的必备条件。</p>
<ul>
<li>
<p><a href="/design/icon/intro.html">图标介绍</a></p>
</li>
<li>
<p><a href="/design/icon/type.html">图标种类</a></p>
</li>
<li>
<p><a href="/design/icon/guide.html">图标设计指南</a></p>
</li>
<li>
<p><a href="/design/icon/software.html">图标设计软件</a></p>
</li>
<li>
<p><a href="/design/icon/draw.html">图标绘制流程</a></p>
</li>
<li>
<p><a href="/design/icon/rule.html">图标设计准则</a></p>
</li>
<li>
<p><a href="/design/icon/line.html">线性图标设计演示</a></p>
</li>
<li>
<p><a href="/design/icon/flour.html">面性图标设计指南</a></p>
</li>
<li>
<p><a href="/design/icon/decorative.html">装饰性图标设计指南</a></p>
</li>
<li>
<p><a href="/design/icon/start.html">启动图标设计指南</a></p>
</li>
<li>
<p><a href="/design/icon/skill.html">图标设计技巧</a></p>
</li>
<li>
<p><a href="/design/icon/apply.html">图标实践注意事项</a></p>
</li>
</ul>
<h2 id="相关要求" tabindex="-1"> 相关要求</h2>
<ul>
<li>
<p>了解图标的常见设计准则</p>
<ul>
<li>
<p>能够对一个图标的好坏做出评判。</p>
</li>
<li>
<p>了解不同的图标风格</p>
</li>
<li>
<p>能够从现有图表库中中选取合适的图标应用到项目中。</p>
</li>
</ul>
</li>
<li>
<p>简单了解图标的制作软件与制作方式</p>
<ul>
<li>
<p>能够制作简单的图标</p>
</li>
<li>
<p>在项目拥有一套完善图标风格，但部分图标存在缺失时能够自制图标补全。</p>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>图标应用</title>
      <link>https://0808200.xyz/design/icon/apply.html</link>
      <guid>https://0808200.xyz/design/icon/apply.html</guid>
      <source url="https://0808200.xyz/rss.xml">图标应用</source>
      <description>在 UI 设计中，图标不是孤立存在的。我们学习图标的设计，不是为了画一组套图，然后上传到设计平台中分享或求赞，而是要在真实的项目中发挥作用。如果不了解图标应用到项目中的知识点，那么真实的图标设计水平就会在项目设计过程中被损耗。
所以，本章讲述工具图标在项目中应用的方法。
</description>
      <category>设计</category>
      <pubDate>Mon, 14 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>在 UI 设计中，图标不是孤立存在的。我们学习图标的设计，不是为了画一组套图，然后上传到设计平台中分享或求赞，而是要在真实的项目中发挥作用。如果不了解图标应用到项目中的知识点，那么真实的图标设计水平就会在项目设计过程中被损耗。</p>
<p>所以，本章讲述工具图标在项目中应用的方法。</p>

<h2 id="一套应用中的图标规格" tabindex="-1"> 一套应用中的图标规格</h2>
<p>图标是一个应用不可或缺的组成元素，在应用的界面中随处可见。也因为图标的常见性，我们往往需要在一个应用中应用多套图标，这和崇尚简约的第一印象是有背离的。</p>
<p>很多新手，都以为我们只要设计一套大而全的图标，在项目中对应提取即可。但有很多场景，如果只使用一种图标类型，那么效果会非常差劲。比如，我们看看下面的淘宝设置页，前后包含了 6 种以上的图标。是太复杂了没错，但如果我们把图标都替换成同一套呢?</p>
<p><img src="@source/design/icon/assets/place-same.jpg" alt="替换淘宝图标"></p>
<p>可以看见，右侧替换后的案例，效果非常的不理想，缺乏对比和趣味性。交互规则中说: 如无必要，勿增实体，但对于图标的使用来说，这就是必要。</p>
<hr>
<p>应用内的图标规格不同，可以用两个属性来划分，大小和风格。</p>
<h3 id="图标的尺寸" tabindex="-1"> 图标的尺寸</h3>
<p>大小就是图标的尺寸规格，有些界面的元素权重低，图标的尺寸就小，有些权重高的则反之。比如在 Apple Music 的播放界面，播放快进等按钮，作为页面最重要的按钮，尺寸非常大，其它可以点击的图标次之，而表示音量的两个按钮则最小。</p>
<p><img src="@source/design/icon/assets/icon-size.jpg" alt="图标尺寸"></p>
<p>确定图标尺寸，是我们在项目中进行图标设计的第一件事。但尺寸的确定，不是我们凭空制定出来的，我们要先构建出实际的「场景」进行分析，即先完成了界面的高保真原型或交互原型。</p>
<p>下方是一个原型演示，在构建了这样的页面以后可以在原型中检查，总共用了多少种图标的尺寸，它们分别会应用在哪些场景中，然后整理出来。如果出现了一些觉得没有必要的，可以将它们进行调整合并成一种尺寸。</p>
<p><img src="@source/design/icon/assets/icon-template.jpg" alt="图标模板"></p>
<p>所以，在这个案例中，我整理出了 4 种图标的尺寸:</p>
<ul>
<li>48pt: 分类、快速入口大图标</li>
<li>32pt: 底部 TabBar 图标</li>
<li>24pt: 常规工具图标</li>
<li>16pt: 小型提示图标</li>
</ul>
<p>定好了这 4 种规格，我们在后续的设计上才有明确的设计方向。再复习一遍，为什么我们需要先定尺寸再设计，而不是统一设计一套很大的图标进行缩小。</p>
<p>因为图标要尽可能满足像素对齐的要求，通过缩小的图标往往在细节上会发生错位、模糊、丢失等问题。且在大画布上设计图标和一开始就在小画布中设计，两者在过程中得到的视觉反馈是完全不一样的，先在大画布画完，再缩小到 16pt、12pt 的规格时往往会显得太复杂，或描边太粗。</p>
<h3 id="图标的风格" tabindex="-1"> 图标的风格</h3>
<p>图标尺寸确认完以后，下面就是确认图标的风格了，和尺寸一样，我们要应用什么风格的图标，是需要在已经具备视觉雏形的页面中对比确定的，而不能提前开始设计。</p>
<p>在正常的设计流程中，通常会将图标放在项目的最后再开始设计，原因就是图标的视觉样式风格是取决于所处位置和环境的，是「先有界面样式，再有图标风格」的。</p>
<p>在常规情况下，如果一个应用中有多套图标，那么普通的中小尺寸图标使用一般的线性或面性风格即可。而在分类、快速入口这些具备装饰性、大尺寸的类型中，就应该使用一些更激进的设计风格。比如下图是 58 同城客户端应用图标案例:</p>
<p><img src="@source/design/icon/assets/58icon.jpg" alt="58 同城图标"></p>
<p>通常，一种风格会应用在一种「类别」的图标中。上方案例属于比较理想的状态，一种类别的图标对应一种尺寸，但是在一些更复杂的环境中，往往同一种尺寸下还会包括不同类别的图标。</p>
<h2 id="图标的不同状态" tabindex="-1"> 图标的不同状态</h2>
<p>图标在一个产品中，除了充当装饰以外，往往也可以作为按钮来使用。每个应用中都有大量的图标可以进行点击和交互，比如底部导航栏，头部的消息图标、发布图标等等。</p>
<p>当一个图标能被操作后，那么我们就要注意到它的状态变化。从导航栏图标举例，常规的选中状态是更换色彩，但也有越来越多的应用会在选中状态采取不同的设计风格，通过更丰富的样式表现来提升可看性。比如淘宝、QQ 的底部导航栏。</p>
<p><img src="@source/design/icon/assets/icon-change.jpg" alt="改变图标状态"></p>
<p>还有，一些包含在控件内的图标，也会跟随控件状态的变更发生变更。例如在账号输入框中，如果选中了输入框，那么图标的色彩也得到改变。如果输入框目前处于不可输入状态，那么图标也会对应置灰。</p>
<p><img src="@source/design/icon/assets/icon-change2.jpg" alt="改变图标状态"></p>
<p>合格的 UI 设计师会充分考虑到图标所变换的各种状态，并在提交给开发的过程中会进行详细的说明、归类。以及，充分运用 Sketch 等软件中的组件功能，提升项目的效率和最后的产出成果。</p>
<p><img src="@source/design/icon/assets/sketch.jpg" alt="提升效率"></p>
<h2 id="图标的标注和切图" tabindex="-1"> 图标的标注和切图</h2>
<p>在我们完成了界面和图标的设计以后，要提交我们的设计给开发人员。其中，包含我们的标注和切图。抛开其它设计元素不谈，我们就讲讲图标的切图需要遵循哪些规范，它和字体都是在这个过程中最容易出错的地方。</p>
<p>应用图标的导出我们已经在上一章提到过，所以下面还是以工具图标的说明为主。</p>
<h3 id="图标的边界" tabindex="-1"> 图标的边界</h3>
<p>我们要回到第二章工具图标的规范中，当我们确定出图标的尺寸时，不是要把图形设计得正好撑满这个尺寸，而是利用格线系统来定义它们的大小。</p>
<p>很多新人会在这个过程中产生疑惑，那么在标注的过程中，我们标注的到底是图形到其它元素的距离，还是图标外轮廓到别的图形的距离。</p>
<p>其实，图标的距离是根据外部轮廓进行计算的。虽然这个轮廓我们肉眼不可见，但它包含的内在规律可以帮助我们忽略一些不必要的小问题。</p>
<p><img src="@source/design/icon/assets/border.jpg" alt="图标的边界"></p>
<p>所以，要让标注有效，就一定不要偷懒只把图标置入画布中，而没有透明矩形背景。</p>
<h3 id="图标的画布" tabindex="-1"> 图标的画布</h3>
<p>现在有很多帮助我们进行标注和切图的协作工具，比如蓝湖、Zeplin 等。我们只要将设计稿上传，程序员可以自行获取图标对应的切图。</p>
<p>在裁切一些特定元素时很好用，但通过线上页面导出图标的方法，是非常不牢靠的。我们说过，一个应用中可能出现多种规格的图标，所以合理的图标切图，要根据不同的规格进行导出和整理，而不是让程序员自己在线上工具中下载，这样不仅操作起来困难，而且图标间不同的状态难以被轻易获取。</p>
<p>所以，要在项目设计过程中，创建不同规格的画布(Symbol)并将它们分类排列，不仅利于我们对以后图标的调用，也方便在最后批量导出切图到对应文件夹中。</p>
<h3 id="图标的命名" tabindex="-1"> 图标的命名</h3>
<p>下面我们简单讲讲图标的命名规则。有很多新手和刚入职场的 UI 设计师会不明就里的强调图标一定要用英文命名，并且各种收集常见的英文命名词汇，我首先要指出这种做法是错误的。</p>
<p>因为涉及到整个应用的图标系统时，会出现大量寓意「抽象」的图标。比如在我上方案例中，有一个启动图标的中文名是「中二」，那么这个词应该如何翻译? 即使不受制于英文水平的发挥，但是您写的英文不代表开发人员能看得懂，而大量抽象词汇的堆积最后导致命名无法成为有效的索引条件，因为没人看得懂，开发需要查找一个图标的时候依旧是通过缩略图而不是命名。</p>
<p>所以，在内部没有具体的命名规范，亦或是程序员没有特殊要求的情况下，更建议使用中文命名系统，因为国内多数程序员的习惯会将获取的图标进行二次命名。</p>
<p>命名的格式可以分成 3 级，格式大致为: 「模块_名称_状态@1x」，比如下面的案例:</p>
<ul>
<li>设置_钱包_高亮@1x.png</li>
<li>动态_评论_默认@1x.png</li>
<li>登录_按钮_点击@2x.png</li>
</ul>
<p>当然，这不是唯一准确的命名方式，可以根据实际场景自由调整，但大家要牢记，图标的命名是为了方便查找、检索。</p>
<p>最后，图标 Symbol 的命名，要和图标的命名保持一致，这样才能起到事半功倍的效果。</p>
<p><img src="@source/design/icon/assets/name-example.jpg" alt="命名示例"></p>
<h3 id="图标的格式" tabindex="-1"> 图标的格式</h3>
<p>上一章启动图标的导出格式，会根据不同设备、场景导出不同的尺寸，并且使用 PNG 的格式。不要担心，工具图标虽然也面临设备不同的问题，但不需要导出这么多的规格。下面讲讲两种图标的导出类型。</p>
<h4 id="位图格式" tabindex="-1"> 位图格式</h4>
<p>最常用的导出格式就是位图 PNG 格式，因为显示器显示倍率的不同，所以我们要导出 1x、2x、3x 三种倍率规格的图片，即设计了 16pt 的图标的话，我们需要导出 16pt、32pt、48pt 三种尺寸。并在导出的文件名后缀上标有 @1x、@2x、@3x 的标注。</p>
<p><img src="@source/design/icon/assets/png-export.jpg" alt="位图导出"></p>
<p>这个规格对于 iOS 还是 Android 都是通用的，虽然还有 3x 以上的设备，但是那些设备只要调用 3x 的规格即可。</p>
<p>虽然后面会提图标可以使用矢量格式导出，但对于使用了渐变、投影或者拟物风格的图标，必须使用位图的格式，否则无法完整记录图形的细节元素。</p>
<h4 id="矢量格式" tabindex="-1"> 矢量格式</h4>
<p>导出 3 种规格的图标很麻烦，而且位图占用的空间往往较大。所以，iOS 和 Android 为了优化这个问题，在之前的系统更新中都默认支持了矢量格式的切图文件:</p>
<ul>
<li>iOS 使用 PDF 的 1x 切图</li>
<li>Android 使用 SVG 的 1x 切图</li>
</ul>
<p>当然，如果使用矢量格式导出，那么切记在分类文件夹的时候，要将 iOS 和 Android 分开保存，而不是混合在一起。</p>
]]></content:encoded>
    </item>
    <item>
      <title>装饰性图标设计</title>
      <link>https://0808200.xyz/design/icon/decorative.html</link>
      <guid>https://0808200.xyz/design/icon/decorative.html</guid>
      <source url="https://0808200.xyz/rss.xml">装饰性图标设计</source>
      <description>装饰图标最主要的应用区域，集中在首页的快速入口上，也是今天多数应用中会使用的组件。下面，我们会讲解国内主流应用中的几种装饰图标的设计。
</description>
      <category>设计</category>
      <pubDate>Mon, 14 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>装饰图标最主要的应用区域，集中在首页的快速入口上，也是今天多数应用中会使用的组件。下面，我们会讲解国内主流应用中的几种装饰图标的设计。</p>

<p><img src="@source/design/icon/assets/decorate-type.jpg" alt="装饰图标分类"></p>
<h2 id="扁平插画风格" tabindex="-1"> 扁平插画风格</h2>
<p>装饰图标的主要作用是丰富视觉体验，对于识别性的要求较低，所以我们可以在这里应用更复杂的图形和添加更多的细节。在这里的扁平插画风格设计更具象，而不是像工具图标一样的抽象化，所以完整的采用扁平插画的设计是没问题的。</p>
<p>例如在肯德基客户端首页的服务分类中，使用的图标就是依据扁平插画的形式设计的，有较多的色彩和完整的细节。</p>
<p><img src="@source/design/icon/assets/KFC.jpg" alt="肯德基设计图"></p>
<p>这类图标的设计并不困难，只要具备了工具图标的设计基础，就可以很快学会并运用。它的设计特征是这样的，先通过绘制具体的图形轮廓，然后为这个轮廓内添加细节，并对不同的面填充不同的色彩进行区分。</p>
<p>下面，我们通过讲解几个图标的设计过程，帮助大家学习这种设计风格。</p>
<ol>
<li>
<p>优惠券图标</p>
<p>先通过模拟现实世界的优惠券样式，确定出基本的线性轮廓。</p>
<p><img src="@source/design/icon/assets/KFC-ticket1.jpg" alt="优惠券1"></p>
<p>但作为装饰图标来说，这样的设计目前有些简陋，左侧空出了大量的留白，所以我们要考虑如何增加细节来丰富这个区域。于是，使用 % 号就可以比较好的标示折扣。</p>
<p><img src="@source/design/icon/assets/KFC-ticket2.jpg" alt="优惠券2"></p>
<p>最后，开始为图标填色。因为在这套图标中，红色是主要基调，所以我们不能大面积的使用其它颜色，于是就将其中一侧进行留白处理，只修改了它描边的色彩。并且还在票据两侧的连接处添加了一个用来标示阴影的竖线。</p>
<p><img src="@source/design/icon/assets/KFC-ticket3.jpg" alt="优惠券3"></p>
</li>
<li>
<p>店铺图标</p>
<p><img src="@source/design/icon/assets/shop.jpg" alt="店铺图标"></p>
</li>
<li>
<p>我的卡包图标</p>
<p><img src="@source/design/icon/assets/wallet.jpg" alt="我的卡包"></p>
</li>
</ol>
<h2 id="渐变几何背景" tabindex="-1"> 渐变几何背景</h2>
<p>和其它风格比较，在快速入口中，线上案例应用得最多的风格其实是渐变几何背景的设计方案，即在一个应用渐变色的背景上贴了一个线性或面性的图标。</p>
<p><img src="@source/design/icon/assets/gradient-background.jpg" alt="渐变几何背景"></p>
<p>这种风格的设计，主要在于背景渐变色的应用，通常，在一组彩色快速入口的图标中，要让它们的渐变色看起来自然和谐，是需要技巧的。</p>
<p>例如有四个图标，首先要定义出不同的色相，然后再对它们应用相同的渐变模式。例如，使用相同的渐变角度，然后在渐变的起始色使用该色相，在结尾使用不同明度、饱和度的色彩。</p>
<p><img src="@source/design/icon/assets/gradient-background2.jpg" alt="渐变几何背景1"></p>
<p>之后，再在上方置入图标的图形，并为它们添加适当的阴影即可。</p>
<p><img src="@source/design/icon/assets/gradient-background3.jpg" alt="渐变几何背景2"></p>
<p>如果在这个基础上，还想再添加细节，那么就可以在上方的图形中添加一些折叠的阴影效果，强化立体感。</p>
<p><img src="@source/design/icon/assets/gradient-background4.jpg" alt="渐变几何背景3"></p>
<h2 id="炫彩渐变风格" tabindex="-1"> 炫彩渐变风格</h2>
<p>这是一个比较奇特的设计风格，在过去只存在于飞机稿中，是一种单纯为了追求视觉表现力的设计形式，通过高饱和的渐变、撞色，抓取浏览者的眼球。</p>
<p><img src="@source/design/icon/assets/shine.jpg" alt="炫彩渐变风格"></p>
<p>这类风格的设计，在确定了图形以后，就是为它们填充高饱和度的渐变色。和扁平插画比较不同的是，色彩的填充不是用来描绘物体的颜色，而仅仅是视觉表现的一种方法，所以颜色的添加追求的不是「合理」，而是纯粹的「好看」。</p>
<p>并且，通常这类图标还会使用前两年开始流行的彩色投影，增加界面本身的层次感。下面，我们也通过 3 个案例，为大家演示一下这类图标设计的过程。</p>
<p>案例 1:</p>
<p><img src="@source/design/icon/assets/shine1.jpg" alt="炫彩渐变风格1"></p>
<p>案例 2:</p>
<p><img src="@source/design/icon/assets/shine2.jpg" alt="炫彩渐变风格2"></p>
<p>案例 3:</p>
<p><img src="@source/design/icon/assets/shine3.jpg" alt="炫彩渐变风格3"></p>
<h2 id="实物贴图风格" tabindex="-1"> 实物贴图风格</h2>
<p>最后，讲讲实物贴图的图标风格。这种图标出现在涉及到实物产品的应用中，例如电商应用，智能硬件控制应用等等。</p>
<p><img src="@source/design/icon/assets/good.jpg" alt="实物贴图风格"></p>
<p>这类设计看起来很简单，只要画出一个几何的背景，并建立蒙版将实物图置入进去即可，但还是有不少新手会犯错误，下面我们主要说说常见的问题有哪些。</p>
<ol>
<li>
<p>物体的透视</p>
<p>和工具图标一样，我们要尽可能的保证整组图标中图形的形状和透视可以统一，如果实物图采用的透视不一致，那么空间的对立感就更强，也容易被用户觉察到违和感。</p>
<p><img src="@source/design/icon/assets/good1.jpg" alt="实物贴图风格1"></p>
</li>
<li>
<p>形体和比例</p>
<p>当我们采用实物照片时，我们往往不能控制该物体完整的形状，但需要切记的是，不是物体本身是什么形状我们都要完整的置入进去。</p>
<p>比如入口中有口红和香水两种，口红是细长的而香水是圆形，那么我们可以做的就是放大口红，最终只展示它的局部，否则它们的对比会完全失衡。</p>
<p><img src="@source/design/icon/assets/good2.jpg" alt="实物贴图风格2"></p>
</li>
<li>
<p>图形的质感</p>
<p>实物的图形，还有一个非常重要的细节，就是它们的质感。这种质感指的不是物体本身的材质，而是摄影、后期产生的质感。如下图的对比，同一件商品，手机直出的图，和经过商品精修的图，展现出来的质感是完全不一样的。</p>
<p><img src="@source/design/icon/assets/good3.jpg" alt="实物贴图风格3"></p>
<p>如果强行将有精修痕迹和普通照片抠出来的商品放到一起，也只能给用户产生巨大的违和感。所以，如果提供给我们的素材本身质感不同，那么我们就要在 PS 中对它们进行调试，尽可能保证它们的一致。</p>
</li>
<li>
<p>前后对比</p>
<p>因为是摄影图，所以图形本身包含的细节会非常丰富，而且色彩也可能比较多。在采用了几何背景时，就要保证它能更好地衬托主体物。如果使用较强的颜色，或是太多细节，就会导致前后元素的分离度不足，无法凸显物体本身。所以，多数采用这种风格的设计案例中，背景用色都使用饱和度偏低的配色。</p>
<p><img src="@source/design/icon/assets/good4.jpg" alt="实物贴图风格4"></p>
</li>
</ol>
<p>只要不犯上面 4 种错误，那么设计这类图标时，就能保证最终的效果不会太差。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>掌握以上这种风格的画法，已经可以应对绝大多数的需求和场景了。但这并不是终点，应用对于视觉风格的追求愈发的重要，想要尝试更多的设计风格，那么就需要掌握更多种装饰类图标的设计方法。需要大家在之后的时间里努力积累相关的技巧和思路。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>