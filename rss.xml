<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://0808200.xyz/rss.xml" rel="self" type="application/rss+xml"/>
    <title>𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ</title>
    <link>https://0808200.xyz/</link>
    <description>𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ blog.</description>
    <language>zh-CN</language>
    <pubDate>Wed, 22 Feb 2023 05:34:11 GMT</pubDate>
    <lastBuildDate>Wed, 22 Feb 2023 05:34:11 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Interview</category>
    <category>google-v8</category>
    <category>设计模式</category>
    <category>浏览器</category>
    <category>内存</category>
    <item>
      <title>H5面试题汇总</title>
      <link>https://0808200.xyz/Interview/h5/</link>
      <guid>https://0808200.xyz/Interview/h5/</guid>
      <source url="https://0808200.xyz/rss.xml">H5面试题汇总</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><h1><a id="_5"></a>面试必考高频面试题：</h1>
<h2><a id="CSS_7"></a>CSS：</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/2232798" target="_blank">盒模型</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/738538" target="_blank">BFC容器</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/571117" target="_blank">居中方式</a><br><a href="https://juejin.cn/post/6844903586841755655#heading-5" target="_blank">flex布局</a></p>
<br>
<h2><a id="JS_15"></a>JS</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/544424" target="_blank"><strong>eventloop机制</strong></a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/937078" target="_blank">类型转换</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/484623" target="_blank">原型链</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/896332" target="_blank">继承</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/921104" target="_blank">函数执行栈</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/484622" target="_blank">闭包</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/482371" target="_blank">this</a></p>
<br>
<h2><a id="_26"></a>浏览器</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/788455" target="_blank">从HTML到完整页面展示全流程</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/941705" target="_blank">GC机制</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/943046" target="_blank">缓存：强缓存与协商缓存完整过程</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/482368#JSONP_335" target="_blank">跨域</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/568039" target="_blank">回流/重绘/合成</a></p>
<br>
<h2><a id="_35"></a>网络</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/951685" target="_blank">五层协议</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/1042708" target="_blank"><strong>https原理</strong></a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/482398" target="_blank">DNS解析流程</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/482397" target="_blank">CDN原理</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/951686" target="_blank">TCP</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/951687" target="_blank">UDP</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/951686" target="_blank">三次握手四次挥手过程</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/951689" target="_blank">HTTP1.1/2区别</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/1042707" target="_blank">各状态码表达含义</a></p>
<br>
<h2><a id="Vue_48"></a>Vue</h2>
<p><strong>实现原理</strong><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381629" target="_blank"><strong>virtual dom结构</strong></a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381630" target="_blank">computed原理</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381631" target="_blank">数组绑定原理</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381633" target="_blank">nextTick原理</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381634" target="_blank">keep-alive原理</a><br>
vue3新特性</p>
<br>
<h2><a id="React_59"></a>React</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381636" target="_blank">fiber原理</a><br>
hooks原理<br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2381635" target="_blank">diff算法原理</a></p>
<br>
<h2><a id="_66"></a>性能优化：</h2>
<p>常见性能瓶颈<br><a href="https://www.kancloud.cn/surahe/front-end-notebook/578627" target="_blank">优化手段</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/578719" target="_blank">如何检测首屏时间并提升首屏速度</a></p>
<br>
<h2><a id="JS_74"></a>手写JS代码：</h2>
<p><a href="https://github.com/surahe/handCode" target="_blank">https://github.com/surahe/handCode</a></p>
<br>
<h2><a id="node_79"></a>node：</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/1030655" target="_blank">express/koa中间件原理</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/2350396" target="_blank">SSR原理</a></p>
<br>
<h2><a id="web_86"></a>web安全</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/482387" target="_blank">xss</a><br><a href="https://www.kancloud.cn/surahe/front-end-notebook/482388" target="_blank">csrf</a></p>
<br>
<h2><a id="_92"></a>前端工程化</h2>
<p><a href="https://www.kancloud.cn/surahe/front-end-notebook/1108198" target="_blank">webpack优化策略</a><br><a href="https://juejin.cn/post/6928175048163491848" target="_blank">vite优点</a></p>
<br>
<h2><a id="_101"></a>其它</h2>
<p>TS<br>
移动端适配<br>
flutter/RN/weex等native开发方式</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>JS 编程题</title>
      <link>https://0808200.xyz/Interview/h5/bianchen.html</link>
      <guid>https://0808200.xyz/Interview/h5/bianchen.html</guid>
      <source url="https://0808200.xyz/rss.xml">JS 编程题</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-写出下面这段代码的输出结果是" tabindex="-1"> 1. 写出下面这段代码的输出结果是？</h2>
<div><pre><code><span>var</span> out <span>=</span> <span>25</span><span>,</span>
    inner <span>=</span> <span>{</span>
        <span>out</span> <span>:</span> <span>20</span><span>,</span>
        <span>func</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>var</span> out <span>=</span> <span>30</span><span>;</span>
            <span>return</span> <span>this</span><span>.</span>out<span>;</span>
        <span>}</span>
    <span>}</span>
console<span>.</span><span>log</span><span>(</span><span>(</span>inner<span>.</span>func<span>,</span> inner<span>.</span>func<span>)</span><span>(</span><span>)</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>inner<span>.</span><span>func</span><span>(</span><span>)</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>(</span>inner<span>.</span>func<span>)</span><span>(</span><span>)</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>(</span>inner<span>.</span>func <span>=</span> inner<span>.</span>func<span>)</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>//输出结果 :</span>

<span>25</span>
<span>20</span>
<span>20</span>
<span>25</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解析：</p>
<p>本题考点两个： 1， 作用域；2. 运算符（赋值运算符，逗号运算符）</p>
<p>第一个考的就是逗号运算符，逗号运算符就是运算前面的，返回最后一个；</p>
<p>例如：var i= 1；j = 2; k = 5; console.log((i++, j++, k)),最后输出的是5；</p>
<p>回到题目，逗号运算符会返回inner.func，而inner.func是一个匿名函数，而这个匿名函数是属于window的，所以里面的this指向的是window，输出25；</p>
<p>第二，第三个输出都是20，因为this指向的是inner</p>
<p>最后一个考的是等号运算符，inner.func = inner.func其实返回的是运算的结果，也就是返回的是匿名函数，所以this也是指向window，输出的是25</p>
<h2 id="_2-以下代码片段-输出的结果是-简要解释一下" tabindex="-1"> 2. 以下代码片段，输出的结果是？简要解释一下</h2>
<div><pre><code><span>var</span> name <span>=</span> <span>'1'</span><span>;</span>
<span>var</span> object <span>=</span> <span>{</span>
    <span>name</span><span>:</span> <span>'2'</span><span>,</span>
    <span>getNameFunc</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>name<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>object<span>.</span><span>getNameFunc</span><span>(</span><span>)</span><span>(</span><span>)</span><span>)</span>

<span>//输出结果： 1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解释：</p>
<p>object.getNameFunc()执行完后，返回的是一个匿名函数，所以里面的this指向的就是window，最终结果输出的是1；</p>
<h2 id="_3-下面代码的输出是什么" tabindex="-1"> 3. 下面代码的输出是什么？</h2>
<div><pre><code><span>function</span> <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>name<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>age<span>)</span><span>;</span>
    <span>var</span> name <span>=</span> <span>'张三'</span>；
    <span>let</span> age <span>=</span> <span>21</span><span>;</span>
<span>}</span>
<span>sayHi</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>答案： undefined 和 ReferenceError</p>
<p>在函数中，我们首先使用var关键字声明了name变量。</p>
<p>这意味着变量在创建阶段会被提升（JavaScript会在创建变量创建阶段为其分配内存空间），默认值为undefined，直到我们实际执行到使用该变量的行。</p>
<p>我们还没有为name变量赋值，所以它仍然保持undefined的值。</p>
<p>使用let关键字（和const）声明的变量也会存在变量提升，但与var不同，初始化没有被提升。</p>
<p>在我们声明（初始化）它们之前，它们是不可访问的。 这被称为“暂时死区”。</p>
<p>当我们在声明变量之前尝试访问变量时，JavaScript会抛出一个ReferenceError。</p>
<h2 id="_4-下面代码输出是什么" tabindex="-1"> 4. 下面代码输出是什么？</h2>
<div><pre><code><span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>i<span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>i<span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>答案：3 3 3 and 0 1 2</p>
<p>由于JavaScript中的事件执行机制，setTimeout函数真正被执行时，循环已经走完。</p>
<p>由于第一个循环中的变量i是使用var关键字声明的，因此该值是全局的。</p>
<p>在循环期间，我们每次使用一元运算符++都会将i的值增加1。</p>
<p>因此在第一个例子中，当调用setTimeout函数时，i已经被赋值为3。</p>
<p>在第二个循环中，使用let关键字声明变量i：使用let（和const）关键字声明的变量是具有块作用域的（块是{}之间的任何东西）。</p>
<p>在每次迭代期间，i将被创建为一个新值，并且每个值都会存在于循环内的块级作用域。</p>
<h2 id="_5-下面代码的输出是什么" tabindex="-1"> 5. 下面代码的输出是什么?</h2>
<div><pre><code><span>const</span> shape <span>=</span> <span>{</span>
  <span>radius</span><span>:</span> <span>10</span><span>,</span>
  <span>diameter</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>radius <span>*</span><span>2</span><span>;</span>
  <span>}</span><span>,</span>
<span>perimeter</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>2</span><span>*</span> Math<span>.</span><span>PI</span> <span>*</span> <span>this</span><span>.</span>radius
<span>}</span><span>;</span>

shape<span>.</span><span>diameter</span><span>(</span><span>)</span><span>;</span>
shape<span>.</span><span>perimeter</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>答案： 20 and NaN</p>
<p>请注意，diameter是普通函数，而perimeter是箭头函数。</p>
<p>对于箭头函数，this关键字指向是它所在上下文（定义时的位置）的环境，与普通函数不同！</p>
<p>这意味着当我们调用perimeter时，它不是指向shape对象，而是指其定义时的环境（window）。</p>
<p>没有值radius属性，返回undefined。</p>
<h2 id="_6-下面代码的输出是什么" tabindex="-1"> 6. 下面代码的输出是什么?</h2>
<div><pre><code><span>+</span><span>true</span><span>;</span>
<span>!</span><span>"张三"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>答案：1 and false</p>
<p>一元加号会尝试将boolean类型转换为数字类型。 true被转换为1，false被转换为0。</p>
<p>字符串'Lydia'是一个真值。 我们实际上要问的是“这个真值是假的吗？”。 这会返回false。</p>
<h2 id="_7、如何判断一个对象是否为数组" tabindex="-1"> 7、如何判断一个对象是否为数组</h2>
<div><pre><code><span>function</span> <span>isArray</span><span>(</span><span>arg</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>typeof</span> arg <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
        <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>arg<span>)</span> <span>===</span> <span>'[object Array]'</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_8、冒泡排序" tabindex="-1"> 8、冒泡排序</h2>
<p>每次比较相邻的两个数，如果后一个比前一个小，换位置</p>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>3</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>2</span><span>]</span><span>;</span>

<span>function</span> <span>bubbleSort</span><span>(</span><span>arr</span><span>)</span> <span>{</span>
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span><span>(</span><span>var</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>arr<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>&lt;</span> arr<span>[</span>j<span>]</span><span>)</span> <span>{</span>
            <span>var</span> temp<span>;</span>
            temp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
            arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
            arr<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>=</span> temp<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
<span>return</span> arr<span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>bubbleSort</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_9、快速排序-二分法" tabindex="-1"> 9、快速排序（二分法）</h2>
<p>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</p>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>3</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>2</span><span>]</span><span>;</span>

<span>function</span> <span>quickSort</span><span>(</span><span>arr</span><span>)</span> <span>{</span>
    <span>if</span><span>(</span>arr<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>[</span><span>]</span><span>;</span>    <span>// 返回空数组</span>
    <span>}</span>

    <span>var</span> cIndex <span>=</span> Math<span>.</span><span>floor</span><span>(</span>arr<span>.</span>length <span>/</span> <span>2</span><span>)</span><span>;</span>
    <span>var</span> c <span>=</span> arr<span>.</span><span>splice</span><span>(</span>cIndex<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>var</span> l <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>var</span> r <span>=</span> <span>[</span><span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>arr<span>[</span>i<span>]</span> <span>&lt;</span> c<span>)</span> <span>{</span>
            l<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            r<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>quickSort</span><span>(</span>l<span>)</span><span>.</span><span>concat</span><span>(</span>c<span>,</span> <span>quickSort</span><span>(</span>r<span>)</span><span>)</span><span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>quickSort</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_10-下面的代码输出什么" tabindex="-1"> 10. 下面的代码输出什么？</h2>
<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>resolve</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span>
<span>}</span><span>)</span>

promise<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>}</span><span>)</span>

console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span><span>;</span>

<span>// 答案</span>
<span>1</span>
<span>2</span>
<span>4</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解析</p>
<p>首先 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then() 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。</p>
<h2 id="_11-下面的代码输出什么" tabindex="-1"> 11. 下面的代码输出什么？</h2>
<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    <span>resolve</span><span>(</span><span>'success1'</span><span>)</span><span>;</span>
    <span>reject</span><span>(</span><span>'error'</span><span>)</span><span>;</span>
    <span>resolve</span><span>(</span><span>'success2'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

promise<span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'then:'</span><span>,</span> res<span>)</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'catch:'</span><span>,</span> err<span>)</span><span>;</span>
<span>}</span><span>)</span>

<span>// 答案</span>
<span>then</span><span>:</span> success1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解析</p>
<p>resolve 函数将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p>reject 函数将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>而一旦状态改变，就不会再变。 所以 代码中的reject('error'); 不会有作用。</p>
<p>Promise 只能 resolve 一次，剩下的调用都会被忽略。 所以 第二次的 resolve('success2'); 也不会有作用。</p>
<h2 id="_12-下面代码输出什么" tabindex="-1"> 12. 下面代码输出什么？</h2>
<div><pre><code>Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>2</span><span>)</span>
  <span>.</span><span>then</span><span>(</span>Promise<span>.</span><span>resolve</span><span>(</span><span>3</span><span>)</span><span>)</span>
  <span>.</span><span>then</span><span>(</span>console<span>.</span>log<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>解析</p>
<p>Promise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。</p>
<p>then 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。</p>
<div><pre><code>Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>null</span><span>)</span> <span>// 穿透</span>
  <span>.</span><span>then</span><span>(</span><span>null</span><span>)</span> <span>// 穿透</span>
  <span>.</span><span>then</span><span>(</span>console<span>.</span>log<span>)</span>

<span>// 答案</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_13-实现需求" tabindex="-1"> 13. 实现需求</h2>
<p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在：</p>
<div><pre><code><span>function</span> <span>red</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'red'</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>green</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'green'</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>yellow</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'yellow'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解析</p>
<p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。</p>
<p>答案</p>
<div><pre><code><span>function</span> <span>red</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'red'</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>green</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'green'</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>yellow</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'yellow'</span><span>)</span><span>;</span>
<span>}</span>

<span>var</span> <span>light</span> <span>=</span> <span>function</span> <span>(</span><span>timmer<span>,</span> cb</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
        <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>cb</span><span>(</span><span>)</span><span>;</span>
            <span>resolve</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>,</span> timmer<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>var</span> <span>step</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>light</span><span>(</span><span>3000</span><span>,</span> red<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>light</span><span>(</span><span>2000</span><span>,</span> green<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>light</span><span>(</span><span>1000</span><span>,</span> yellow<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>step</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>step</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_14-以下代码最后输出什么" tabindex="-1"> 14. 以下代码最后输出什么？</h2>
<div><pre><code><span>const</span> <span>first</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>let</span> p <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>7</span><span>)</span><span>;</span>
        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>5</span><span>)</span><span>;</span>
            <span>resolve</span><span>(</span><span>6</span><span>)</span><span>;</span>
        <span>}</span><span>,</span> <span>0</span><span>)</span>
        <span>resolve</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>resolve</span><span>(</span><span>2</span><span>)</span><span>;</span>
    p<span>.</span><span>then</span><span>(</span><span>(</span><span>arg</span><span>)</span> <span>=></span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>arg<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

<span>}</span><span>)</span><span>)</span><span>;</span>

<span>first</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>arg</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>arg<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span><span>;</span>

<span>// 答案</span>
<span>3</span>
<span>7</span>
<span>4</span>
<span>1</span>
<span>2</span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解析</p>
<p>这道题就其实和 Promise 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题。</p>
<p><strong>第一轮事件循环</strong></p>
<p>先执行宏任务，主script ，new Promise立即执行，输出【3】，</p>
<p>执行 p 这个new Promise 操作，输出【7】，</p>
<p>发现 setTimeout，将回调放入下一轮任务队列（Event Queue），</p>
<p>p 的 then，姑且叫做 then1，放入微任务队列，</p>
<p>发现 first 的 then，叫 then2，放入微任务队列。</p>
<p>执行console.log(4)，输出【4】，宏任务执行结束。</p>
<p>再执行微任务，执行 then1，输出【1】，</p>
<p>执行 then2，输出【2】。</p>
<p>到此为止，第一轮事件循环结束。开始执行第二轮。</p>
<p><strong>第二轮事件循环</strong></p>
<p>先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。 resolve(6) 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。</p>
<h2 id="_15、js-统计一个字符串出现频率最高的字母-数字" tabindex="-1"> 15、js 统计一个字符串出现频率最高的字母/数字</h2>
<div><pre><code><span>let</span> str <span>=</span> <span>'asdfghjklaqwertyuiopiaia'</span><span>;</span>
<span>const</span> <span>strChar</span> <span>=</span> <span>str</span> <span>=></span> <span>{</span>
    <span>let</span> string <span>=</span> <span>[</span><span>...</span>str<span>]</span><span>,</span>
        maxValue <span>=</span> <span>''</span><span>,</span>
        obj <span>=</span> <span>{</span><span>}</span><span>,</span>
        max <span>=</span> <span>0</span><span>;</span>
    string<span>.</span><span>forEach</span><span>(</span><span>value</span> <span>=></span> <span>{</span>
        obj<span>[</span>value<span>]</span> <span>=</span> obj<span>[</span>value<span>]</span> <span>==</span> <span>undefined</span> <span>?</span> <span>1</span> <span>:</span> obj<span>[</span>value<span>]</span> <span>+</span> <span>1</span>
        <span>if</span> <span>(</span>obj<span>[</span>value<span>]</span> <span>></span> max<span>)</span> <span>{</span>
            max <span>=</span> obj<span>[</span>value<span>]</span>
            maxValue <span>=</span> value
        <span>}</span>
    <span>}</span><span>)</span>
<span>return</span> maxValue<span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>strChar</span><span>(</span>str<span>)</span><span>)</span>    <span>// a</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_16、不借助临时变量-进行两个整数的交换" tabindex="-1"> 16、不借助临时变量，进行两个整数的交换</h2>
<div><pre><code><span>let</span> a <span>=</span> <span>2</span><span>,</span>
    b <span>=</span> <span>3</span><span>;</span>
    <span>[</span>b<span>,</span>a<span>]</span> <span>=</span> <span>[</span>a<span>,</span>b<span>]</span>
    console<span>.</span><span>log</span><span>(</span>a<span>,</span>b<span>)</span>   <span>// 3 2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="下面代码输出什么结果" tabindex="-1"> 下面代码输出什么结果？</h2>
<div><pre><code><span>function</span> <span>*</span><span>printLog</span><span>(</span><span>array</span><span>)</span> <span>{</span>
    <span>let</span> nextIndex <span>=</span> <span>0</span><span>;</span>
    <span>while</span><span>(</span>nextIndex <span>&lt;</span> array<span>.</span>length<span>)</span> <span>{</span>
        <span>yield</span> array<span>[</span>nextIndex<span>++</span><span>]</span>
    <span>}</span>
    <span>return</span> <span>5</span><span>;</span>
<span>}</span>

<span>let</span> gen <span>=</span> <span>printLog</span><span>(</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>gen<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>gen<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>gen<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>gen<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>

<span>//答案：</span>
<span>{</span><span>value</span><span>:</span> <span>3</span><span>,</span> <span>done</span><span>:</span> <span>false</span><span>}</span>
<span>{</span><span>value</span><span>:</span> <span>4</span><span>,</span> <span>done</span><span>:</span> <span>false</span><span>}</span>
<span>{</span><span>value</span><span>:</span> <span>5</span><span>,</span> <span>done</span><span>:</span> <span>true</span><span>}</span>
<span>{</span><span>value</span><span>:</span> <span>undefined</span><span>,</span> <span>done</span><span>:</span> <span>true</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="下面代码中什么情况下会打印1" tabindex="-1"> 下面代码中什么情况下会打印1？</h2>
<div><pre><code><span>var</span> a <span>=</span> <span>?</span>
<span>if</span> <span>(</span>a <span>==</span> <span>1</span> <span>&amp;&amp;</span> a <span>==</span> <span>2</span> <span>&amp;&amp;</span> a<span>==</span> <span>3</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>
<span>}</span>
<span>var</span> a <span>=</span> <span>{</span>
    <span>i</span><span>:</span><span>1</span><span>,</span>
    <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> a<span>.</span>i<span>++</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="下面代码运行的结果" tabindex="-1"> 下面代码运行的结果？</h2>
<div><pre><code><span>async</span> <span>function</span> <span>async1</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'async1 start'</span><span>)</span>
    <span>await</span> <span>async2</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>'async1 end'</span><span>)</span>
<span>}</span>

<span>async</span> <span>function</span> <span>async2</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'async2'</span><span>)</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>'script start'</span><span>)</span>
<span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span>
<span>}</span><span>,</span> <span>0</span><span>)</span>

<span>async1</span><span>(</span><span>)</span><span>;</span>
<span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'promise1'</span><span>)</span>
    <span>resolve</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'promise2'</span><span>)</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>'script end'</span><span>)</span>

<span>//答案：</span>
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="实现一个sleep函数" tabindex="-1"> 实现一个sleep函数</h2>
<p>比如sleep(1000)意味着等待1000毫秒</p>
<div><pre><code><span>const</span> <span>sleep</span> <span>=</span> <span>time</span> <span>=></span> <span>{</span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
        <span>setTimeout</span><span>(</span>resolve<span>,</span> time<span>)</span>
    <span>}</span><span>)</span>
<span>}</span>
<span>sleep</span><span>(</span><span>1000</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="如何把一个字符串的大小写取反-大写变小写-小写变大写-例如-abc-变成-abc" tabindex="-1"> 如何把一个字符串的大小写取反（大写变小写，小写变大写），例如'AbC' 变成 'aBc'?</h2>
<div><pre><code><span>let</span> str <span>=</span> <span>'aBc'</span><span>;</span>
str <span>=</span> str<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>[a-zA-Z]</span><span>/</span><span>g</span></span><span>,</span> <span>content</span> <span>=></span> <span>{</span>
    <span>return</span> content<span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>===</span> content <span>?</span> content<span>.</span><span>toLowerCase</span><span>(</span><span>)</span> <span>:</span> content<span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="请自定义一个函数-实现字符串的反转" tabindex="-1"> 请自定义一个函数，实现字符串的反转</h2>
<div><pre><code><span>function</span> <span>reverse</span><span>(</span><span>str</span><span>)</span> <span>{</span>
    <span>return</span> str<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>''</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="请写出三种对象合并的方法" tabindex="-1"> 请写出三种对象合并的方法</h2>
<div><pre><code><span>let</span> arr1 <span>=</span> <span>{</span>
    <span>a</span><span>:</span><span>1</span><span>,</span>
    <span>b</span><span>:</span><span>2</span><span>,</span>
    <span>c</span><span>:</span><span>3</span>
<span>}</span><span>;</span>
<span>let</span> arr2 <span>=</span> <span>{</span>
    <span>d</span><span>:</span><span>4</span><span>,</span>
    <span>e</span><span>:</span><span>5</span><span>,</span>
    <span>a</span><span>:</span><span>6</span>
<span>}</span><span>;</span>
<span>//方法一拓展运算符，后面相同的属性覆盖前一个</span>
<span>let</span> arr3<span>=</span><span>{</span><span>...</span>arr1<span>,</span><span>...</span>arr2<span>}</span><span>;</span>

<span>//方法二Object.assign()，后面相同的属性覆盖前一个</span>
<span>let</span> arr3<span>=</span>Object<span>.</span><span>assign</span><span>(</span>arr1<span>,</span>arr2<span>)</span><span>;</span>

<span>//方法三Object.keys()，相同的属性只取第一个</span>
Object<span>.</span><span>keys</span><span>(</span>arr1<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
    arr2<span>[</span>key<span>]</span> <span>=</span> arr1<span>[</span>key<span>]</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="数组去重的方法" tabindex="-1"> 数组去重的方法</h2>
<p>1.ES6 的 Set</p>
<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span>
<span>let</span> arr2 <span>=</span> <span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>arr<span>)</span><span>]</span> <span>// 两种写法均可：Array.from(new Set(arr))</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>2.reduce()</p>
<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span>
<span>let</span> arr2 <span>=</span> arr<span>.</span><span>reduce</span><span>(</span><span>function</span><span>(</span><span>ar<span>,</span>cur</span><span>)</span> <span>{</span>
  <span>if</span><span>(</span><span>!</span>ar<span>.</span><span>includes</span><span>(</span>cur<span>)</span><span>)</span> <span>{</span>
    ar<span>.</span><span>push</span><span>(</span>cur<span>)</span>
  <span>}</span>

  <span>return</span> ar
<span>}</span><span>,</span><span>[</span><span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>3.filter()</p>
<div><pre><code><span>// 这种方法会有一个问题：[1,'1']会被当做相同元素，最终输入[1]</span>
<span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span>
<span>let</span> arr2 <span>=</span> arr<span>.</span><span>filter</span><span>(</span><span>function</span><span>(</span><span>item<span>,</span>index</span><span>)</span> <span>{</span>
  <span>// indexOf() 方法可返回某个指定的 字符串值 在字符串中首次出现的位置</span>
  <span>return</span> arr<span>.</span><span>indexOf</span><span>(</span>item<span>)</span> <span>===</span> index
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="手写一个递归方法求斐波那契数列的第n项的值" tabindex="-1"> 手写一个递归方法求斐波那契数列的第N项的值</h2>
<div><pre><code><span>function</span> <span>fn</span><span>(</span><span>n</span><span>)</span><span>{</span>
    <span>if</span><span>(</span>n<span>==</span><span>1</span> <span>||</span> n<span>==</span><span>2</span><span>)</span><span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span><span>else</span> <span>{</span>
        <span>return</span> <span>fn</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>+</span><span>fn</span><span>(</span>n<span>-</span><span>2</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="将数组扁平化并去除其中重复数据-最终得到一个升序且不重复的数组" tabindex="-1"> 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</h2>
<div><pre><code>Array<span>.</span><span>from</span><span>(</span><span>new</span> <span>Set</span><span>(</span>arr<span>.</span><span>flat</span><span>(</span><span>Infinity</span><span>)</span><span>)</span><span>)</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span>b</span><span>)</span><span>=></span><span>{</span> <span>return</span> a<span>-</span>b<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="实现-add-1-2-3" tabindex="-1"> 实现 add(1)(2)(3)</h2>
<p>考点：函数柯里化</p>
<div><pre><code><span>function</span> <span>add</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>//求和</span>
    <span>return</span> args<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>)</span>
<span>}</span>

<span>function</span> <span>currying</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>let</span> args <span>=</span> <span>[</span><span>]</span>
    <span>return</span> <span>function</span> <span>temp</span> <span>(</span><span><span>...</span>newArgs</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>newArgs<span>.</span>length<span>)</span> <span>{</span>
            args <span>=</span> <span>[</span>
                <span>...</span>args<span>,</span>
                <span>...</span>newArgs
            <span>]</span>
            <span>return</span> temp
        <span>}</span> <span>else</span> <span>{</span>
            <span>let</span> val <span>=</span> <span>fn</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
            args <span>=</span> <span>[</span><span>]</span> <span>//保证再次调用时清空</span>
            <span>return</span> val
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>let</span> addCurry <span>=</span> <span>currying</span><span>(</span>add<span>)</span>
console<span>.</span><span>log</span><span>(</span><span>addCurry</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>)</span><span>(</span><span>4</span><span>,</span> <span>5</span><span>)</span><span>(</span><span>)</span><span>)</span>  <span>//15</span>
console<span>.</span><span>log</span><span>(</span><span>addCurry</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>)</span><span>(</span><span>)</span><span>)</span>  <span>//15</span>
console<span>.</span><span>log</span><span>(</span><span>addCurry</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>)</span><span>(</span><span>)</span><span>)</span>  <span>//15</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>HTML&amp;CSS</title>
      <link>https://0808200.xyz/Interview/h5/html-css.html</link>
      <guid>https://0808200.xyz/Interview/h5/html-css.html</guid>
      <source url="https://0808200.xyz/rss.xml">HTML&amp;CSS</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="掌握-行内元素和块级元素都有哪一些" tabindex="-1"> （掌握）行内元素和块级元素都有哪一些？</h2>
<p>1）行内元素</p>
<div><pre><code><span>&lt;</span>span<span>></span>、<span>&lt;</span>a<span>></span>、<span>&lt;</span>b<span>></span>、<span>&lt;</span>strong<span>></span>、<span>&lt;</span>img<span>></span>、<span>&lt;</span>input<span>></span>、<span>&lt;</span>textarea<span>></span>、<span>&lt;</span>select<span>></span>、、<span>&lt;</span>em<span>></span>、<span>&lt;</span>del<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>2）块级元素</p>
<div><pre><code><span>&lt;</span>address<span>></span>、<span>&lt;</span>center<span>></span>、<span>&lt;</span>h1<span>></span><span>~</span><span>&lt;</span>h6<span>></span>、<span>&lt;</span>p<span>></span>、<span>&lt;</span>pre<span>></span>、<span>&lt;</span>ul<span>></span>、<span>&lt;</span>ol<span>></span>、<span>&lt;</span>dl<span>></span>、<span>&lt;</span>table<span>></span>、<span>&lt;</span>div<span>></span>、<span>&lt;</span>form<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="掌握-bfc" tabindex="-1"> （掌握）BFC</h2>
<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。</p>
<p>流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；</p>
<p>BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>
<h2 id="掌握-什么是弹性布局" tabindex="-1"> （掌握）什么是弹性布局？</h2>
<p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。</p>
<p>设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!</p>
<p>display:flex; 属性align-self 定义子元素的位置。</p>
<h2 id="掌握-html5有哪些新特性" tabindex="-1"> （掌握）html5有哪些新特性？</h2>
<p>(1)Canvas绘图</p>
<p>(2)SVG绘图</p>
<p>(3)地理定位</p>
<p>(4)Web Worker</p>
<ul>
<li>
<p>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。
(5)Web Storage</p>
</li>
<li>
<p>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）</p>
</li>
<li>
<p>2.（兼容性差,数据8MB,操作简单）sessionStorage</p>
</li>
<li>
<p>3.localStorage</p>
</li>
</ul>
<p>(6)Web Socket</p>
<ul>
<li>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</li>
</ul>
<h2 id="掌握-position有哪些属性" tabindex="-1"> （掌握）position有哪些属性？</h2>
<ol>
<li>
<p>position: relative;相对定位</p>
</li>
<li>
<p>position: absolute;绝对定位</p>
</li>
<li>
<p>position: fixed;固定定位</p>
</li>
<li>
<p>position:static：默认值</p>
</li>
<li>
<p>position: sticky 粘性定位</p>
</li>
<li>
<p>position: inherit 规定应该从父元素继承 position 属性的值</p>
</li>
<li>
<p>position: initial 设置该属性为默认值</p>
</li>
</ol>
<h2 id="掌握-请说出1px-1rem-1vh-1em各自代表的含义" tabindex="-1"> （掌握）请说出1px，1rem，1vh，1em各自代表的含义？</h2>
<p><code>rem</code></p>
<p><code>rem</code>是全部的长度都相对于根元素<code>&lt;html&gt;</code>元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为<code>rem</code>。</p>
<p>em 元素用em的话是相对于该元素的font-size</p>
<p><code>vw/vh</code></p>
<p>全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 <code>vh</code> 单位更好。</p>
<p><code>px</code></p>
<p>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p>
<p>一般电脑的分辨率有{1920 <em>1024}等不同的分辨率，1920</em> 1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素</p>
<h2 id="掌握-什么是spa" tabindex="-1"> （掌握）什么是SPA？</h2>
<p>单页面Web应用（single page web application,SPA）：SPA是一种特殊的web应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面。</p>
<p>它将所有活动局限于一个web页面中，仅在该web页面初始化时加载相应的HTML、JavaScript、css。</p>
<p>一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或者跳转，而是利用JavaScript动态的变换HTML（采用的是div切换显示和隐藏），从而实现UI与用户的交互。</p>
<p>在SPA应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region(区域)中的视图切换来展示内容。</p>
<p>**优点：**用户体验好 、良好的前后端分离。</p>
<p>缺点：</p>
<ol>
<li>不利于SEO。</li>
<li>初次加载耗时相对增多。</li>
<li>导航不可用，如果一定要导航需要自行实现前进、后退。</li>
</ol>
<h2 id="掌握-简述优雅降级与渐进增强" tabindex="-1"> （掌握）简述优雅降级与渐进增强</h2>
<p>1、渐进增强（progressive enhancement）</p>
<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>2、优雅降级（graceful degradation）</p>
<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>3、区别：</p>
<p>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给；渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。</p>
<p>b. 渐进增强观点认为应该关注于内容本身，这使得渐进增强成为一种更为合理的设计范例；优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。</p>
<h2 id="掌握-重绘与重排" tabindex="-1"> （掌握）重绘与重排</h2>
<p>1、重绘</p>
<p>重绘是一个元素外观的改变所触发的浏览器行为（例如改变visibility，outline，background等属性），浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>2、重排</p>
<p>重排时更明显的一种改变，可以理解为渲染树需要重新计算。常见的触发重排的操作：</p>
<p>DOM元素的几何属性变化</p>
<p>DOM树的结构变化（例如节点的增减、移动）</p>
<p>获取某些属性（例如offsetTop，offsetLeft，offsetHeight，offsetWidth，clientWidth，clientHeight等）</p>
<p>改变元素的一些样式（例如调整浏览器窗口大小）</p>
<p>3、两者的区别</p>
<p>重绘不会带来重新布局，并不一定伴随着重排。</p>
<p>在实践中，应该尽量减少重排次数和缩小重排的影响范围。有以下几种方法：</p>
<p>[ ] 将多次改变样式属性的操作合并成一次操作</p>
<p>[ ] 将需要多次重排的元素，position属性设为absolute或fixed，使其脱离文档流，这样它的变化就不会影响到其他元素</p>
<p>[ ] 在内存中多次操作节点，完成后再添加到文档中去</p>
<p>[ ] 如果要对一个元素进行复杂的操作，可以将其display属性设置为none使其隐藏，待操作完成后再显示</p>
<p>[ ] 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量</p>
<h2 id="掌握-解释下浮动和它的工作原理-清除浮动的方法" tabindex="-1"> （掌握）解释下浮动和它的工作原理？清除浮动的方法</h2>
<p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p>1、使用空标签清除浮动</p>
<p>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p>
<p>2、使用after伪对象清除浮动</p>
<p>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<div><pre><code><span>#parent::after</span><span>{</span>
  <span>content</span><span>:</span><span>""</span><span>;</span>
  <span>height</span><span>:</span>0<span>;</span>
  <span>visibility</span><span>:</span>hidden<span>;</span>
  <span>display</span><span>:</span>block<span>;</span>
  <span>clear</span><span>:</span>both<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>3、溢出隐藏</p>
<div><pre><code><span>overflow</span><span>:</span> hidden<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>4.浮动外部元素</p>
<h2 id="掌握-如何让一个盒子在页面垂直水平居中" tabindex="-1"> （掌握）如何让一个盒子在页面垂直水平居中</h2>
<p>方法一：已知宽高</p>
<div><pre><code><span>div</span><span>{</span>
  <span>position</span><span>:</span> absolute<span>;</span>
  <span>left</span><span>:</span> 0<span>;</span>
  <span>right</span><span>:</span> 0<span>;</span>
  <span>bottom</span><span>:</span> 0<span>;</span>
  <span>top</span><span>:</span> 0<span>;</span>
  <span>margin</span><span>:</span> auto<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>方法二：未知宽高</p>
<div><pre><code><span>div</span><span>{</span>
 <span>position</span><span>:</span> absolute<span>;</span>
  <span>left</span><span>:</span> 50%<span>;</span>
  <span>top</span><span>:</span> 50%<span>;</span>
  <span>transform</span><span>:</span> <span>translate</span><span>(</span>-50%<span>,</span>-50%<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-前端性能优化方案" tabindex="-1"> （掌握）前端性能优化方案</h2>
<p>1、减少DOM操作</p>
<p>2、部署前，图片压缩，代码压缩</p>
<p>3、优化js代码结构，减少冗余代码</p>
<p>4、减少http请求，合理设置HTTP缓存</p>
<p>5、使用内容分发cdn加速</p>
<p>6、静态资源缓存</p>
<p>7、图片延迟加载</p>
<h2 id="掌握-css选择器优先级顺序" tabindex="-1"> （掌握）css选择器优先级顺序</h2>
<ul>
<li>ID 选择器， 如 #id{}</li>
<li>类选择器， 如 .class{}</li>
<li>属性选择器， 如 a[href=&quot;segmentfault.com&quot;]{}</li>
<li>伪类选择器， 如 :hover{}</li>
<li>伪元素选择器， 如 ::before{}</li>
<li>标签选择器， 如 span{}</li>
<li>通配选择器， 如 *{}</li>
</ul>
<h2 id="掌握-css3有哪些新特性" tabindex="-1"> （掌握）CSS3有哪些新特性</h2>
<ul>
<li>border-radius   圆角</li>
<li>box-shadow   阴影</li>
<li>text-shadow   文字阴影</li>
<li>gradient   线性渐变</li>
<li>transform  旋转、缩放、移动或倾斜</li>
<li>scale  缩放</li>
<li>translate   位移</li>
<li>媒体查询   多栏布局   多背景</li>
</ul>
<h2 id="掌握-什么是空元素" tabindex="-1"> （掌握）什么是空元素？</h2>
<p>即没有内容的HTML元素，例如：br、meta、hr、link、input、img</p>
<h2 id="掌握-如何实现浏览器内多个标签页之间的通讯" tabindex="-1"> （掌握）如何实现浏览器内多个标签页之间的通讯</h2>
<ol>
<li>定时器setInterval + cookie</li>
</ol>
<p>在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。</p>
<p>由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。</p>
<p>这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优雅。</p>
<p><strong>2. 使用localstorage</strong></p>
<p>localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，每个标签页都是单独的）。</p>
<p>直接在window对象上添加监听即可：</p>
<div><pre><code>window<span>.</span><span>onstorage</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>}</span>
<span>// 或者这样</span>
window<span>.</span><span>addEventListener</span><span>(</span><span>'storage'</span><span>,</span> <span>(</span><span>e</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。</p>
<p>然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行：localStorage.setItem('a', 'b')代码，同样是不会触发监听函数的。</p>
<h2 id="掌握-为什么要初始化css样式" tabindex="-1"> （掌握）为什么要初始化css样式</h2>
<p>1.浏览器差异</p>
<p>不同浏览器对有些标签的默认值是不同的，如果没对css初始化会出现浏览器之间的页面显示差异</p>
<p>2.提高编码质量</p>
<p>如果不初始化，整个页面做完会很糟糕，重复的css样式很多</p>
<h2 id="掌握-css3新增的伪类有哪些" tabindex="-1"> （掌握）CSS3新增的伪类有哪些？</h2>
<p>p:first-of-type 选择属于其父元素的首个元素</p>
<p>p:last-of-type 选择属于其父元素的最后元素</p>
<p>p:only-of-type 选择属于其父元素唯一的元素</p>
<p>p:only-child 选择属于其父元素的唯一子元素</p>
<p>p:nth-child(2) 选择属于其父元素的第二个子元素</p>
<h2 id="掌握-说说对canvas-svg-webgl的理解" tabindex="-1"> （掌握）说说对canvas，svg，webgl的理解</h2>
<p>Canvas 是HTML5新增的一个元素对象，名副其实就是一个画布，浏览器 js 配有相应的操作api，可以不再依赖其他的API或组件而直接绘图，相当于2D的API。</p>
<p>Canvas 适用于位图，高数据量高绘制频率（帧率）的场景，如动画、游戏；</p>
<p>SVG 是给数据就可以绘制点、线、图形的，基于 XML 的标记语言；</p>
<p>SVG 适用于矢量图，低数据量低绘制频率的场景，如图形、图表；</p>
<p>WebGL（全写Web Graphics Library）是一种3D绘图标准，通俗说WebGL是canvas绘图中的3D版本。</p>
<p>因为原生的WebGL很复杂，我们经常会使用一些三方的库，如three.js等，WebGL 主要用来做 3D 展示、动画、游戏。</p>
<h2 id="掌握-浏览器是如何渲染ui的" tabindex="-1"> （掌握）浏览器是如何渲染UI的？</h2>
<ul>
<li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree</li>
<li>与此同时，进行CSS解析，生成Style Rules</li>
<li>接着将DOM Tree与Style Rules合成为 Render Tree</li>
<li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li>
<li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来</li>
</ul>
<h2 id="掌握-em、rem的区别" tabindex="-1"> （掌握）em、<code>rem</code>的区别</h2>
<p>em是相对长度单位，相对于当前对象内文本的字体尺寸。</p>
<p>如当前对行内文本的字体尺寸未被人为设置，则相对浏览器的默认字体尺寸。</p>
<p>它会继承父级元素的字体大小，因此并不是一个固定的值。</p>
<p><code>rem</code>是CSS3新增的一个相对单位(root em,根em),使用<code>rem</code>为元素设定字体大小事，仍然是相对大小但相对的只是HTML根元素。</p>
<h2 id="掌握-解释csssprites-如何使用" tabindex="-1"> （掌握）解释csssprites，如何使用</h2>
<p>Css精灵把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量。</p>
<h2 id="掌握-伪类和伪元素的区别" tabindex="-1"> （掌握）伪类和伪元素的区别</h2>
<p>1）伪类(pseudo-classes)</p>
<p>其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。</p>
<p>⽐如:hover :active :visited :link :visited :first-child :focus :lang等</p>
<p>由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。</p>
<p>由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。</p>
<p>2）伪元素(Pseudo-elements)</p>
<p>DOM树没有定义的虚拟元素</p>
<p>核⼼就是需要创建通常不存在于⽂档中的元素，</p>
<p>⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。</p>
<p>伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器</p>
<p>2）伪类与伪元素的区别</p>
<p>表示⽅法</p>
<ul>
<li>CSS2 中伪类、伪元素都是以单冒号:表示,</li>
<li>CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，</li>
<li>浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。</li>
<li>CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。</li>
<li>CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头</li>
</ul>
<p>定义不同</p>
<ul>
<li>伪类即假的类，可以添加类来达到效果</li>
<li>伪元素即假元素，需要通过添加元素才能达到效果</li>
</ul>
<p>总结:</p>
<ul>
<li>伪类和伪元素都是⽤来表示⽂档树以外的&quot;元素&quot;。</li>
<li>伪类和伪元素分别⽤单冒号:和双冒号::来表示。</li>
<li>伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，</li>
<li>是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。</li>
</ul>
<p>4）相同之处：</p>
<ul>
<li>伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。 不同之处：</li>
<li>伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。</li>
<li>伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。</li>
</ul>
<h2 id="掌握-浏览器工作原理" tabindex="-1"> （掌握） 浏览器工作原理</h2>
<ol>
<li>用户界面</li>
<li>网络</li>
<li>UI后端</li>
<li>数据存储</li>
<li>浏览器引擎</li>
<li>渲染引擎</li>
<li>js解释器</li>
</ol>
<h2 id="掌握-介绍一下你对浏览器内核的理解" tabindex="-1"> （掌握）介绍一下你对浏览器内核的理解？</h2>
<p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</p>
<p>渲染引擎：</p>
<p>负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。</p>
<p>浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。</p>
<p>所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p>JS引擎则：</p>
<p>解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h2 id="掌握-常见的浏览器内核有哪些" tabindex="-1"> （掌握）常见的浏览器内核有哪些？</h2>
<ul>
<li>Trident内核：IE,360，傲游，搜狗，世界之窗，腾讯等。[又称MSHTML]</li>
<li>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>
<li>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]</li>
<li>Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]</li>
</ul>
<h2 id="掌握-一个页面上有大量的图片-加载很慢-你有哪些方法优化这些图片的加载-给用户更好的体验" tabindex="-1"> （掌握）一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h2>
<p>（1）图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p>
<p>（2）如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</p>
<p>（3）如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p>
<p>（4）如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p>
<h2 id="掌握-如何进行seo优化" tabindex="-1"> （掌握）如何进行seo优化？</h2>
<p>1、合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。</p>
<p>2、语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</p>
<p>3、重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取</p>
<p>4、重要内容不要用js输出：爬虫不会执行js获取内容</p>
<p>5、少用iframe：搜索引擎不会抓取iframe中的内容</p>
<p>6、非装饰性图片必须加alt属性</p>
<p>7、提高网站速度：网站速度是搜索引擎排序的一个重要指标。</p>
<h2 id="掌握-如何实现0-5px边框" tabindex="-1"> （掌握）如何实现0.5px边框</h2>
<p>1、border+border-image+linear-gradient的方式</p>
<div><pre><code>  <span>&lt;</span>div <span>class</span><span>=</span><span>"border"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>
  <span>.</span>border<span>{</span>
        <span>width</span><span>:</span>200px<span>;</span>
        <span>height</span><span>:</span> 200px<span>;</span>
        background<span>-</span>color<span>:</span> red<span>;</span>
        <span>margin</span><span>:</span> <span>0</span> auto <span>;</span>
        border<span>-</span>bottom<span>:</span>  1px solid blue<span>;</span>
        border<span>-</span>image<span>:</span> linear<span>-</span><span>gradient</span><span>(</span> to bottom<span>,</span>transparent  <span>50</span><span>%</span><span>,</span>Green <span>50</span><span>%</span><span>)</span> <span>0</span> <span>0</span> <span>100</span><span>%</span> <span>0</span> <span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>2、伪元素+background-image的方式</p>
<div><pre><code> <span>&lt;</span>div <span>class</span><span>=</span><span>"border"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>
 <span>.</span>border <span>{</span>
        <span>width</span><span>:</span> 200px<span>;</span>
        <span>height</span><span>:</span> 200px<span>;</span>
        background<span>-</span>color<span>:</span> red<span>;</span>
        <span>margin</span><span>:</span> <span>0</span> auto<span>;</span>
        <span>position</span><span>:</span> relative<span>;</span>
    <span>}</span>

    <span>.</span>border<span>:</span>before <span>{</span>
        <span>content</span><span>:</span> <span>" "</span><span>;</span>
        <span>position</span><span>:</span> absolute<span>;</span>
        <span>left</span><span>:</span> <span>0</span><span>;</span>
        <span>bottom</span><span>:</span> <span>0</span><span>;</span>
        <span>width</span><span>:</span> 100px<span>;</span>
        <span>height</span><span>:</span> 1px<span>;</span>
        background<span>-</span>color<span>:</span> blue<span>;</span>
        background<span>-</span>image<span>:</span> linear<span>-</span><span>gradient</span><span>(</span>to bottom transparent <span>50</span><span>%</span><span>,</span> blue <span>50</span><span>%</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>3、定位+伪元素+transfrom缩放(scale)的方式</p>
<div><pre><code> <span>&lt;</span>div <span>class</span><span>=</span><span>"border"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>

 <span>.</span>border <span>{</span>
        <span>width</span><span>:</span> 200px<span>;</span>
        <span>height</span><span>:</span> 200px<span>;</span>
        background<span>-</span>color<span>:</span> red<span>;</span>
        <span>margin</span><span>:</span> <span>0</span> auto<span>;</span>
        <span>position</span><span>:</span> relative<span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-less和sass的区别" tabindex="-1"> （掌握）less和sass的区别</h2>
<p>Less是基于JavaScript，是在客户端处理的；Sass是基于Ruby的，是在服务器端处理的。</p>
<p>关于变量在Less和Sass中的唯一区别就是<code>Less用@</code>，<code>Sass用$</code>。</p>
<p>输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。</p>
<p>Sass支持条件语句，可以使用if{}else{},for{}循环等等，而Less不支持。</p>
<h2 id="了解-xhtml和html有什么区别" tabindex="-1"> （了解）xhtml和html有什么区别</h2>
<p>HTML与XHTML之间的差别，主要分为功能上的差别和书写习惯的差别两方面。</p>
<p>关于功能上的差别，主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页。</p>
<p>由于XHTML的语法较为严谨，所以如果你是习惯松散结构的HTML编写者，那需要注意XHTML的规则。</p>
<p>下面列出了几条容易犯的错误，供理解。</p>
<p>所有标签都必须小写</p>
<p>在XHTML中，所有的标签都必须小写，不能大小写穿插其中，也不能全部都是大写。</p>
<p>标签必须成双成对</p>
<p>像是<code>&lt;p&gt;...&lt;/p&gt;、&lt;a&gt;...&lt;/a&gt;、&lt;div&gt;...&lt;/div&gt;</code>标签等，当出现一个标签时，必须要有对应的结束标签，缺一不可，就像在任何程序语言中的括号一样</p>
<p>标签顺序必须正确</p>
<p>标签由外到内，一层层包覆着，所以假设你先写div后写h1，结尾就要先写h1后写div。只要记住一个原则“先进后出”，先弹出的标签要后结尾。</p>
<p>所有属性都必须使用双引号</p>
<p>在XHTML 1.0中规定连单引号也不能使用，所以全程都得用双引号。</p>
<p>不允许使用<code>target=&quot;_blank&quot;</code></p>
<p>从XHTML 1.1开始全面禁止target属性，如果想要有开新窗口的功能，就必须改写为<code>rel=&quot;external&quot;</code>，并搭配JavaScript实现此效果。</p>
<h2 id="了解-img标签上title与alt属性的区别是什么" tabindex="-1"> （了解）img标签上title与alt属性的区别是什么?</h2>
<p>alt：当图片不显示是用文字代表</p>
<p>title：为该属性提供信息</p>
<h2 id="了解-a标签中-active-hover-link-visited-正确的设置顺序是什么" tabindex="-1"> （了解）a标签中 active hover link visited 正确的设置顺序是什么?</h2>
<p>按照 lvha 顺序排列 a:link a:visited a:hover a:active</p>
<p>而引用CSS文件的<code>@import</code>就是造成这个问题的罪魁祸首。</p>
<p>IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</p>
<p>解决方法：只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素就可以了。</p>
<h2 id="了解-如何处理html5新标签的浏览器兼容性问题" tabindex="-1"> （了解）如何处理HTML5新标签的浏览器兼容性问题</h2>
<p>方法一 :</p>
<p>1、使用静态资源的html5shiv包</p>
<div><pre><code><span>&lt;</span><span>!</span><span>--</span><span>[</span><span>if</span> lt <span>IE9</span><span>]</span><span>></span>
<span>&lt;</span>script src<span>=</span><span>"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
<span>&lt;</span><span>!</span><span>[</span>endif<span>]</span><span>--</span><span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>2、载入后，初始化新标签的css</p>
<div><pre><code><span>header, section, footer, aside, nav, main, article, figure</span> <span>{</span> <span>display</span><span>:</span> block<span>;</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>方法二：</p>
<p>IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签</p>
<h2 id="了解-html5的离线储存怎么使用-工作原理能不能解析一下" tabindex="-1"> （了解）HTML5的离线储存怎么使用，工作原理能不能解析一下？</h2>
<p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p>原理：</p>
<p>HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。</p>
<p>之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>更新缓存：一旦应用被缓存，它就会保持缓存直到发生下列情况：</p>
<ul>
<li>用户清空浏览器缓存</li>
<li>manifest 文件被修改</li>
<li>由程序来更新应用缓存</li>
</ul>
<p>如何使用：</p>
<p>1、页面头部像下面一样加入一个manifest的属性；</p>
<p>2、在cache.manifest文件的编写离线存储的资源；</p>
<p>3、在离线状态时，操作window.applicationCache进行需求实现。</p>
<h2 id="了解-页面导入样式时-使用link和-import有什么区别" tabindex="-1"> （了解）页面导入样式时，使用link和@import有什么区别</h2>
<p>1、<code>link</code>属于XHTML标签，除了加载CSS外，还能用于定义RSS（简易信息聚合，是一种基于XML标准，在互联网上被广泛采用的内容包装和投递协议），rel连接属性等作用；<code>@import</code>是CSS提供的，只能用于加载CSS；</p>
<p>2、页面被加载时，<code>link</code>会同时被加载；而<code>@import</code>引用的CSS会等到页面被加载完成后再加载；</p>
<p>3、<code>link</code>是XHTML标签，没有兼容问题；而<code>@import</code>只有在IE5以上才能被识别；</p>
<p>4、<code>link</code>支持使用JavaScript控制DOM修改样式；而<code>@import</code>不支持。</p>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript</title>
      <link>https://0808200.xyz/Interview/h5/js.html</link>
      <guid>https://0808200.xyz/Interview/h5/js.html</guid>
      <source url="https://0808200.xyz/rss.xml">JavaScript</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="掌握-什么是-use-strict-好处和坏处" tabindex="-1"> （掌握）什么是“use strict”,好处和坏处</h2>
<p>use ‘strict’： &quot;严格模式&quot;是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。</p>
<p>优点：</p>
<p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
<p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>
<p>提高编译器效率，增加运行速度；</p>
<p>为未来新版本的Javascript做好铺垫。</p>
<p>缺点：</p>
<p>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。</p>
<p>这时这些本来是严格模式的文件，被 merge 后，这个字符串(&quot;use strict&quot;)就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h2 id="掌握-console-log-0-1-0-2" tabindex="-1"> （掌握）console.log(0.1 + 0.2)</h2>
<p>0.1+0.2的结果不是0.3，而是0.3000000000000000004，JS中两个数字相加时是以二进制形式进行的，当十进制小数的二进制表示的有限数字超过52位时，在JS里是不能精确储存的，这个时候就存在舍入误差。</p>
<h2 id="掌握-数组pop-push-unshift-shift-的区别" tabindex="-1"> （掌握）数组pop(), push(), unshift(), shift()的区别</h2>
<ul>
<li>push()方法可以在数组的末属添加一个或多个元素</li>
<li>shift()方法把数组中的第一个元素删除</li>
<li>unshift()方法可以在数组的前端添加一个或多个元素</li>
<li>pop()方法把数组中的最后一个元素删除</li>
</ul>
<h2 id="掌握-和" tabindex="-1"> （掌握）==和===</h2>
<ul>
<li>==：只是比较值</li>
<li>===：既要比较数据类型还要比较值</li>
</ul>
<h2 id="掌握-事件冒泡和事件捕获到底有何区别" tabindex="-1"> （掌握）事件冒泡和事件捕获到底有何区别？</h2>
<p>事件冒泡：</p>
<p>从下至上。</p>
<p>当给父子元素的同一事件绑定方法的时候，触发子元素身上的事件，执行完毕之后，也会触发父级元素相同的事件。</p>
<p>注意： addEventListener中有三个属性，第三个属性是布尔值。false为事件冒泡，true为事件捕获</p>
<p>事件捕获：</p>
<p>从上至下到指定元素。</p>
<p>当触发子元素身上的事件时，先触发父元素，然后在传递给子元素</p>
<h2 id="掌握-js数据类型" tabindex="-1"> （掌握）JS数据类型</h2>
<p>在ES5的时候，我们认知的数据类型确实是 6种：Number、String、Boolean、undefined、object、Null。</p>
<p>ES6 中新增了一种 Symbol 。这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。</p>
<h2 id="掌握-什么是typescript" tabindex="-1"> （掌握）什么是typescript</h2>
<ol>
<li>它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</li>
<li>TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。</li>
</ol>
<h2 id="掌握-什么是模块化编程" tabindex="-1"> （掌握）什么是模块化编程？</h2>
<p>每个模块内部，module变量代表当前模块。</p>
<p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<h2 id="掌握-简述javascript原型、原型链-有什么特点" tabindex="-1"> （掌握）简述javascript原型、原型链？有什么特点</h2>
<p>原型：每一个构造函数都有一个prototype属性指向一个对象，这个对象就是构造函数实例的原型</p>
<p>原型链：每一个实例都有一个__proto__属性执行原型对象，来获取原型对象上的属性和方法,原型对象也有一个__proto</p>
<p>属性指向另外一个原型对象,以此类推,直到原型链的最终端null为止，这个串成链的过程就是原型链</p>
<p>特点：实现继承 一个对象可以拿到另一个对象上的属性和方法</p>
<p>构造函数都有一个prototype属性指向原型对象</p>
<p>原型对象都有一个consttuctor属性指向构造函数</p>
<p>构造函数new实例化实例对象</p>
<p>实例对象上有__proto属性指向原型</p>
<h2 id="掌握-解释javascript中的作用域和变量声明提升" tabindex="-1"> （掌握）解释javascript中的作用域和变量声明提升</h2>
<p>作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>变量声明提升：</p>
<div><pre><code>foo<span>;</span>  <span>// undefined</span>
<span>var</span> <span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'foo1'</span><span>)</span><span>;</span>
<span>}</span>
 
<span>foo</span><span>(</span><span>)</span><span>;</span>  <span>// foo1，foo赋值</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以想象成：所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端。</p>
<h2 id="掌握-谈谈this对象的理解-call-和apply-的区别" tabindex="-1"> （掌握）谈谈this对象的理解，call()和apply()的区别</h2>
<p>call和apply的区别在于传入参数的不同； 第一个参数都是，指定函数体内this的指向；</p>
<p>第二个参数开始不同，apply是传入带下标的集合，数组或者类数组，apply把它传给函数作为参数，call从第二个开始传入的参数是不固定的，都会传给函数作为参数。</p>
<p>call比apply的性能要好，平常可以多用call。call传入参数的格式正是内部所需要的格式。</p>
<h2 id="掌握-js-的typeof返回有哪些数据类型" tabindex="-1"> （掌握）js 的typeof返回有哪些数据类型？</h2>
<p>string，number，Boolean，undefined，object，function, symbol(es6)</p>
<h2 id="掌握-什么是闭包-为什么要用它" tabindex="-1"> （掌握）什么是闭包？为什么要用它？</h2>
<p>1）什么是闭包</p>
<p>函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。</p>
<p>可以在内部函数访问到外部函数作用域。</p>
<p>使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。</p>
<p>而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。</p>
<p>当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。</p>
<p><strong>2）闭包原理</strong></p>
<p>函数执行分成两个阶段(预编译阶段和执行阶段)。</p>
<p>在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。</p>
<p>执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量</p>
<p>利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。</p>
<p><strong>3）优点</strong></p>
<ul>
<li>
<p>可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</p>
</li>
<li>
<p>避免变量污染全局</p>
</li>
<li>
<p>把变量存到独立的作用域，作为私有成员存在
<strong>4）缺点</strong></p>
</li>
<li>
<p>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏</p>
</li>
<li>
<p>对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</p>
</li>
<li>
<p>可能获取到意外的值(captured value)</p>
</li>
</ul>
<p><strong>4）应用场景</strong></p>
<p>应用场景一： 典型应用是模块封装，在各模块规范（ES6）出现之前，都是用这样的方式防止变量污染全局。</p>
<div><pre><code><span>var</span> Yideng <span>=</span> <span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 这样声明为模块私有变量，外界无法直接访问</span>
    <span>var</span> foo <span>=</span> <span>0</span><span>;</span>

    <span>function</span> <span>Yideng</span><span>(</span><span>)</span> <span>{</span><span>}</span>
    <span>Yideng</span><span>.</span>prototype<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> foo<span>;</span>
    <span>}</span><span>;</span>
    <span>return</span> Yideng<span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>应用场景二： 在循环中创建闭包，防止取到意外的值。</p>
<p>如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3</p>
<div><pre><code><span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    document<span>.</span><span>getElementById</span><span>(</span><span>'id'</span> <span>+</span> i<span>)</span><span>.</span><span>onfocus</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      <span>alert</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span><span>;</span>
<span>}</span>
<span>//可用闭包解决</span>
<span>function</span> <span>makeCallback</span><span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span>num<span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span>
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    document<span>.</span><span>getElementById</span><span>(</span><span>'id'</span> <span>+</span> i<span>)</span><span>.</span>onfocus <span>=</span> <span>makeCallback</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-简述js继承的方式" tabindex="-1"> （掌握）简述js继承的方式</h2>
<ul>
<li>混入式继承：把父类的所有方法都拷贝到子类上</li>
<li>原型式继承：只继承父类原型上的属性和方法</li>
<li>原型链继承：继承父类构造函数里边的属性和方法，也继承父类原型上的属性和方法 缺点--不能向父类传参数</li>
<li>借用构造函数继承：可以父类传递参数 缺点--继承不了父类原型对象的方法</li>
<li>组合继承：借用构造函数继承+原型链继承</li>
</ul>
<h2 id="掌握-给string添加一个trim-方法-去除开头和结尾的空格符号" tabindex="-1"> （掌握）给String添加一个trim()方法，去除开头和结尾的空格符号</h2>
<div><pre><code><span>String</span><span>.</span>prototype<span>.</span><span>trim</span> <span>=</span> <span>function</span> <span>(</span><span>str</span><span>)</span> <span>{</span>
  <span>return</span> str<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>(^\s*)|(\s*$)</span><span>/</span><span>g</span></span><span>,</span> <span>''</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="掌握-深拷贝和浅拷贝的区别" tabindex="-1"> （掌握）深拷贝和浅拷贝的区别</h2>
<p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存.</p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p>
<h2 id="掌握-如何实现深拷贝" tabindex="-1"> （掌握）如何实现深拷贝</h2>
<p>常用：使用JSON.parse(JSON.stringify(obj))</p>
<p>原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象</p>
<p>缺点是: 会忽略undefined、symbol、funciton</p>
<p>实现：递归+判断类型</p>
<p>一个简单的代码</p>
<div><pre><code><span>// 数字 字符串 function是不需要拷贝的</span>
<span>function</span> <span>deepClone</span><span>(</span><span>value</span><span>)</span> <span>{</span>  
    <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>return</span> value<span>;</span>  
    <span>if</span> <span>(</span><span>typeof</span> value <span>!==</span> <span>'object'</span><span>)</span> <span>return</span> value<span>;</span>
    <span>if</span> <span>(</span>value <span>instanceof</span> <span>RegExp</span><span>)</span> <span>return</span> <span>new</span> <span>RegExp</span><span>(</span>value<span>)</span><span>;</span>  
    <span>if</span> <span>(</span>value <span>instanceof</span> <span>Date</span><span>)</span> <span>return</span> <span>new</span> <span>Date</span><span>(</span>value<span>)</span><span>;</span>  
    <span>// 我要判断 value 是对象还是数组 如果是对象 就产生对象 是数组就产生数组  </span>
    <span>let</span> obj <span>=</span> <span>new</span> <span>value<span>.</span>constructor</span><span>;</span>  
    <span>for</span><span>(</span><span>let</span> key <span>in</span> value<span>)</span><span>{</span>    
        obj<span>[</span>key<span>]</span> <span>=</span> <span>deepClone</span><span>(</span>value<span>[</span>key<span>]</span><span>)</span><span>;</span> <span>// 看一看当前的值是不是一个对象  </span>
    <span>}</span>  
    <span>return</span> obj<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-javascript-的垃圾回收机制讲一下" tabindex="-1"> （掌握）javascript 的垃圾回收机制讲一下</h2>
<p>定义：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。</p>
<p>JavaScript 在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存，这个过程称为垃圾收集。</p>
<p>内存生命周期中的每一个阶段:</p>
<p>分配内存 —  内存是由操作系统分配的，它允许您的程序使用它。在低级语言(例如 C 语言)中，这是一个开发人员需要自己处理的显式执行的操作。然而，在高级语言中，系统会自动为你分配内在。</p>
<p>使用内存 — 这是程序实际使用之前分配的内存，在代码中使用分配的变量时，就会发生读和写操作。</p>
<p>释放内存 — 释放所有不再使用的内存,使之成为自由内存,并可以被重利用。与分配内存操作一样,这一操作在低级语言中也是需要显式地执行。</p>
<p>四种常见的内存泄漏：全局变量，未清除的定时器，闭包，以及 dom 的引用</p>
<ul>
<li>全局变量 不用 var 声明的变量，相当于挂载到 window 对象上。如：b=1; 解决：使用严格模式</li>
<li>被遗忘的定时器和回调函数</li>
<li>闭包</li>
<li>没有清理的 DOM 元素引用</li>
</ul>
<h2 id="掌握-介绍下-promise-的特性、优缺点" tabindex="-1"> （掌握）介绍下 promise 的特性、优缺点</h2>
<p>Promise基本特性</p>
<p>1、Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)</p>
<p>2、Promise对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调resolve和失败时的回调reject；另外resolve的参数除了正常值以外， 还可能是一个Promise对象的实例；reject的参数通常是一个Error对象的实例。</p>
<p>3、then方法返回一个新的Promise实例，并接收两个参数onResolved(fulfilled状态的回调)；onRejected(rejected状态的回调，该参数可选)</p>
<p>4、catch方法返回一个新的Promise实例</p>
<p>5、finally方法不管Promise状态如何都会执行，该方法的回调函数不接受任何参数</p>
<p>6、Promise.all()方法</p>
<ul>
<li>将多个多个Promise实例，包装成一个新的Promise实例，</li>
<li>该方法接受一个由Promise对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例)，</li>
<li>注意参数中只要有一个实例触发catch方法，都会触发Promise.all()方法返回的新的实例的catch方法，</li>
<li>如果参数中的某个实例本身调用了catch方法，将不会触发Promise.all()方法返回的新实例的catch方法</li>
</ul>
<p>7、Promise.race()方法</p>
<ul>
<li>参数与Promise.all方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给Promise.race()方法，并将返回值作为Promise.race()方法产生的Promise实例的返回值</li>
</ul>
<p>8、Promise.resolve()</p>
<ul>
<li>将现有对象转为Promise对象，如果该方法的参数为一个Promise对象，Promise.resolve()将不做任何处理；</li>
<li>如果参数thenable对象(即具有then方法)，Promise.resolve()将该对象转为Promise对象并立即执行then方法；</li>
<li>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为fulfilled，其参数将会作为then方法中onResolved回调函数的参数，</li>
<li>如果Promise.resolve方法不带参数，会直接返回一个fulfilled状态的 Promise 对象。</li>
<li>需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li>
</ul>
<p>9、Promise.reject()</p>
<ul>
<li>同样返回一个新的Promise对象，状态为rejected，无论传入任何参数都将作为reject()的参数</li>
</ul>
<p>2）Promise优点</p>
<p>①统一异步 API</p>
<p>Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。</p>
<p>②Promise 与事件对比</p>
<p>和事件相比较， Promise 更适合处理一次性的结果。</p>
<p>在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。</p>
<p>Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。</p>
<p>链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。</p>
<p>③Promise 与回调对比</p>
<p>解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。</p>
<p>④Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。</p>
<p>3）Promise缺点</p>
<p>1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。</p>
<p>2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p>
<p>3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。</p>
<h2 id="掌握-请介绍一下xmlhttprequest对象" tabindex="-1"> （掌握）请介绍一下XMLhttprequest对象</h2>
<p>Ajax的核心是JavaScript对象XmlHttpRequest。</p>
<p>该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。</p>
<p>简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。</p>
<p>通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。</p>
<h2 id="掌握-请描述一下-cookies-sessionstorage-和-localstorage-的区别" tabindex="-1"> （掌握）请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2>
<p>cookie是浏览器自动携带在请求里发送给服务端去验证的</p>
<p>sessionStorage和localStorage不会自动携带</p>
<p>cookie体积相对sessionStorage localStorage小</p>
<p>后端可以设置cookie之后,前端修改不了的;</p>
<p>cookie可以设置过期时间</p>
<p>cookie是用来做状态保持的，因为http请求时无状态的</p>
<p>cookie是用户第一次访问服务器服务器颁发给浏览器的,第二次请求就会携带</p>
<p>sessionStorage 存储在内存中 关闭浏览器数据会消失</p>
<p>localStorage 关闭浏览器数据不会消失 需要手动去清除</p>
<h2 id="掌握-浏览器缓存策略" tabindex="-1"> （掌握）浏览器缓存策略</h2>
<p>1）浏览器缓存策略</p>
<p>浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。</p>
<p>如果缓存有效，则使 用本地缓存；否则，则向服务器发起请求并携带缓存标识。</p>
<p>根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分： 强制缓存和协商缓存，强缓优先于协商缓存。</p>
<p>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p>
<p>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<p>HTTP缓存都是从第二次请求开始的：</p>
<ul>
<li>第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；</li>
<li>第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个</li>
</ul>
<p>2）强缓存</p>
<ul>
<li>强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk</li>
<li>控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）</li>
<li>Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。</li>
<li>Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求</li>
<li>Cache-Control的优先级比Expires的优先级高。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。 如果同时存在则使用Cache-control。</li>
</ul>
<p>3）强缓存-expires</p>
<p>该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。</p>
<p>Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。</p>
<p>在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。</p>
<p>由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。</p>
<p>此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。</p>
<p>优势特点</p>
<ol>
<li>HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。</li>
<li>以时刻标识失效时间。</li>
</ol>
<p>劣势问题</p>
<ol>
<li>时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。</li>
<li>存在版本问题，到期之前的修改客户端是不可知的。</li>
</ol>
<p>4）强缓存-cache-control</p>
<p>已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。</p>
<p>这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些 Cache-control 字段常用的值：(完整的列表可以查看MDN)</p>
<ul>
<li>max-age：即最大有效时间。</li>
<li>must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。</li>
<li>no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜。</li>
<li>no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。</li>
<li>public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)</li>
<li>private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li>
<li>Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。</li>
</ul>
<p>该字段可以在请求头或者响应头设置，可组合使用多种指令：</p>
<p>可缓存性：</p>
<ul>
<li>public：浏览器和缓存服务器都可以缓存页面信息</li>
<li>private：default，代理服务器不可缓存，只能被单个用户缓存</li>
<li>no-cache：浏览器器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private， 过期时间设置为过去时间。</li>
<li>only-if-cache：客户端只接受已缓存的响应</li>
</ul>
<p>到期</p>
<ul>
<li>max-age=：缓存存储的最大周期，超过这个周期被认为过期。</li>
<li>s-maxage=：设置共享缓存，比如can。会覆盖max-age和expires。</li>
<li>max-stale[=]：客户端愿意接收一个已经过期的资源</li>
<li>min-fresh=：客户端希望在指定的时间内获取最新的响应</li>
<li>stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应 的时间长度。</li>
<li>stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。</li>
</ul>
<p>重新验证和重新加载</p>
<ul>
<li>must-revalidate：如页面过期，则去服务器进行获取。</li>
<li>proxy-revalidate：用于共享缓存。</li>
<li>immutable：响应正文不随时间改变。</li>
</ul>
<p>其他</p>
<ul>
<li>no-store：绝对禁止缓存</li>
<li>no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。</li>
</ul>
<p>优势特点</p>
<ol>
<li>HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。</li>
<li>比Expires多了很多选项设置。</li>
</ol>
<p>劣势问题</p>
<ol>
<li>存在版本问题，到期之前的修改客户端是不可知的。</li>
</ol>
<p>5）协商缓存</p>
<p>协商缓存的状态码由服务器决策返回200或者304</p>
<p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p>
<p>对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。</p>
<p>协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）</p>
<p>Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标 识，只要资源变化，Etag就会重新生成。</p>
<p>Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。</p>
<p>6）协商缓存-协商缓存-Last-Modified/If-Modified-since</p>
<ol>
<li>服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如 Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT</li>
<li>浏览器将这个值和内容一起记录在缓存数据库中。</li>
<li>下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段</li>
<li>服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</li>
</ol>
<p>优势特点</p>
<ol>
<li>不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。</li>
</ol>
<p>劣势问题
2. 只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。
3. 以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
4. 某些服务器不能精确的得到文件的最后修改时间。
5. 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</p>
<p>7）协商缓存-Etag/If-None-match</p>
<p>为了解决上述问题，出现了一组新的字段 Etag 和 If-None-Match</p>
<p>Etag 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。之后的流程和 Last-Modified 一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 hash，把 If-Modified-Since 变成了 If-None-Match。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。</p>
<p>浏览器在发起请求时，服务器返回在Response header中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的Etag值赋值给If-No-Matched并添加在Request Header中。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。</p>
<p>Etag 的优先级高于 Last-Modified。</p>
<p>优势特点</p>
<ol>
<li>可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。</li>
<li>不存在版本问题，每次请求都回去服务器进行校验。</li>
</ol>
<p>劣势问题</p>
<ol>
<li>计算ETag值需要性能损耗。</li>
<li>分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETag不匹配的情况。</li>
</ol>
<h2 id="掌握-简述同源策略与跨域" tabindex="-1"> （掌握）简述同源策略与跨域</h2>
<p>同源策略是一种约定，它是浏览器最核心的也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。</p>
<p>当协议，主机，和端口号有一个不同时，就是跨域。</p>
<h2 id="掌握-跨域解决方案" tabindex="-1"> （掌握）跨域解决方案</h2>
<p>1、（后端）服务器配置CORS(跨域资源共享)</p>
<p>2） （后端）node.js或nginx,反向代理，把跨域改造成同域</p>
<p>3）（前端）将JSON升级成JSONP,在JSON的基础上，利用script 标签可以跨域的特性，加上头设置</p>
<h2 id="掌握-从浏览器地址栏输入url到显示页面的步骤" tabindex="-1"> （掌握）从浏览器地址栏输入URL到显示页面的步骤</h2>
<ol>
<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（html，js，css，图像等）;</li>
<li>浏览器对加载到的资源（html，js，css等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）;</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ol>
<h2 id="掌握-javascript-中的作用域-scope-是指什么" tabindex="-1"> （掌握）JavaScript 中的作用域（scope）是指什么？</h2>
<p>在 JavaScript 中，每个函数都有自己的作用域。作用域基本上是变量以及如何通过名称访问这些变量的规则的集合。只有函数中的代码才能访问函数作用域内的变量。</p>
<p>同一个作用域中的变量名必须是唯一的。一个作用域可以嵌套在另一个作用域内。如果一个作用域嵌套在另一个作用域内，最内部作用域内的代码可以访问另一个作用域的变量。</p>
<h2 id="掌握-解释-javascript-中的-null-和-undefined" tabindex="-1"> （掌握）解释 JavaScript 中的 null 和 undefined</h2>
<div><pre><code><span>null</span>                <span>// 表示一个空的对象,什么也没有</span>
<span>undefined</span>           <span>// 表示声明为赋值，undefined是从null派生出来的</span>
<span>null</span> <span>==</span> <span>undefined</span>   <span>// true</span>
<span>null</span> <span>===</span> <span>undefined</span>  <span>// false</span>
<span>typeof</span> <span>null</span>         <span>// 'object'</span>
<span>typeof</span> <span>undefined</span>    <span>// 'undefined'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-浏览器的事件循环" tabindex="-1"> （掌握）浏览器的事件循环</h2>
<p><strong>1）为什么会有Event Loop</strong></p>
<p>JavaScript的任务分为两种同步和异步，它们的处理方式也各自不同，同步任务是直接放在主线程上排队依次执行，异步任务会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到调用栈然后主线程执行调用栈的任务。</p>
<p>调用栈：调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。</p>
<p>JavaScript是单线程的，单线程是指 js引擎中解析和执行js代码的线程只有一个（主线程），每次只能做一件事情，然而ajax请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。</p>
<p>综上所述，检查调用栈是否为空以及讲某个任务添加到调用栈中的个过程就是event loop，这就是JavaScript实现异步的核心。</p>
<p>2）浏览器中的 Event Loop</p>
<p>Micro-Task 与 Macro-Task</p>
<p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。</p>
<p>常见的 macro-task：setTimeout、setInterval、script（整体代码）、I/O 操作、UI 渲染等。</p>
<p>常见的 micro-task: new Promise().then(回调)、MutationObserve等。</p>
<p>requestAnimationFrame</p>
<p>requestAnimationFrame也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务。按照MDN中的定义：</p>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>
<p>requestAnimationFrame是GUI渲染之前执行，但在Micro-Task之后，不过requestAnimationFrame不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行。</p>
<p>event loop过程</p>
<ul>
<li>检查macrotask队列是否为空，非空则到2，为空则到3</li>
<li>执行macrotask中的一个任务</li>
<li>继续检查microtask队列是否为空，若有则到4，否则到5</li>
<li>取出microtask中的任务执行，执行完成返回到步骤3</li>
<li>执行视图更新</li>
<li>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</li>
</ul>
<h2 id="掌握-解释事件冒泡以及如何阻止它" tabindex="-1"> （掌握）解释事件冒泡以及如何阻止它？</h2>
<p>事件冒泡是指嵌套最深的元素触发一个事件，然后这个事件顺着嵌套顺序在父元素上触发。</p>
<p>防止事件冒泡的一种方法是使用 event.cancelBubble 或 event.stopPropagation()（低于 IE 9）。</p>
<h2 id="掌握-什么是防抖和节流-有什么区别-如何实现" tabindex="-1"> （掌握）什么是防抖和节流？有什么区别？如何实现？</h2>
<div><pre><code><span>/** 防抖:
 * 应用场景：当用户进行了某个行为(例如点击)之后。不希望每次行为都会触发方法，而是行为做出后,一段时间内没有再次重复行为，
 * 才给用户响应
 * 实现原理 : 每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。（每次触发事件时都取消之前的延时调用方法）
 *  <span>@params</span> fun 传入的防抖函数(callback) delay 等待时间
 *  */</span>
<span>const</span> <span>debounce</span> <span>=</span> <span>(</span><span>fun<span>,</span> delay <span>=</span> <span>500</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>let</span> timer <span>=</span> <span>null</span> <span>//设定一个定时器</span>
    <span>return</span> <span>function</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
        <span>clearTimeout</span><span>(</span>timer<span>)</span><span>;</span>
        timer <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>fun</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
        <span>}</span><span>,</span> delay<span>)</span>
    <span>}</span>
<span>}</span>
<span>/** 节流
 *  应用场景:用户进行高频事件触发(滚动)，但在限制在n秒内只会执行一次。
 *  实现原理: 每次触发时间的时候，判断当前是否存在等待执行的延时函数
 * <span>@params</span> fun 传入的防抖函数(callback) delay 等待时间
 * */</span>

<span>const</span> <span>throttle</span> <span>=</span> <span>(</span><span>fun<span>,</span> delay <span>=</span> <span>1000</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>let</span> flag <span>=</span> <span>true</span><span>;</span>
    <span>return</span> <span>function</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>flag<span>)</span> <span>return</span><span>;</span>
        flag <span>=</span> <span>false</span>
        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>fun</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
            flag <span>=</span> <span>true</span>
        <span>}</span><span>,</span> delay<span>)</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>区别:节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数</p>
<h2 id="掌握-jsonp-的原理是什么" tabindex="-1"> （掌握）JSONP 的原理是什么？</h2>
<p>尽管浏览器有同源策略，但是 script 标签的 src 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求。</p>
<p>Step1: 创建 callback 方法</p>
<p>Step2: 插入 script 标签</p>
<p>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</p>
<p>Step4: 前端执行服务端返回的方法调用</p>
<h2 id="掌握-异步加载js的方式有哪些" tabindex="-1"> （掌握）异步加载JS的方式有哪些？</h2>
<p>defer，只支持IE</p>
<p>async：</p>
<p>创建script，插入到DOM中，加载完毕后callBack</p>
<p>defer并行加载js文件，会按照页面上script标签的顺序执行</p>
<p>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p>
<h2 id="掌握-常见web安全及防护原理" tabindex="-1"> （掌握）常见web安全及防护原理</h2>
<h3 id="_1-xss-跨站脚本攻击" tabindex="-1"> 1）XSS：跨站脚本攻击</h3>
<p>就是攻击者想尽一切办法将可以执行的代码注入到网页中。</p>
<h4 id="存储型-server端" tabindex="-1"> 存储型（server端）</h4>
<p>场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<p>攻击步骤：</p>
<p>i）攻击者将恶意代码提交到目标网站的数据库中</p>
<p>ii）用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器</p>
<p>iii）用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行</p>
<p>iv）恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作</p>
<h4 id="反射型-server端" tabindex="-1"> 反射型（Server端）</h4>
<p>与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上</p>
<p>场景：通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<p>攻击步骤：</p>
<p>i）攻击者构造出特殊的 URL，其中包含恶意代码。</p>
<p>ii）用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</p>
<p>iii）用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</p>
<p>iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p>
<h4 id="dom-型-浏览器端" tabindex="-1"> Dom 型(浏览器端）</h4>
<p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<p>场景：通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<p>攻击步骤：</p>
<p>i）攻击者构造出特殊的 URL，其中包含恶意代码。</p>
<p>ii）用户打开带有恶意代码的 URL。</p>
<p>iii）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</p>
<p>iv）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p>
<h4 id="预防方案-防止攻击者提交恶意代码-防止浏览器执行恶意代码" tabindex="-1"> 预防方案：（防止攻击者提交恶意代码，防止浏览器执行恶意代码）</h4>
<p>i）对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等</p>
<ul>
<li>避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML</li>
</ul>
<p>ii）CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection</p>
<ul>
<li>增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)</li>
<li>Content-Security-Policy: default-src 'self'-所有内容均来自站点的同一个源（不包括其子域名）</li>
<li>Content-Security-Policy: default-src 'self' *.trusted.com-允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)</li>
<li>Content-Security-Policy: default-src <a href="https://yideng.xn--com-HTTPSyideng-5y5xfa6n090cd1gh8vlz5bs4c231du6gl81xt8anz4e0ec.xn--com-t33er8omxyu5cdqcvx8l4jva" target="_blank" rel="noopener noreferrer">https://yideng.com-该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档</a></li>
</ul>
<p>iii）输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断</p>
<p>iv）开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</p>
<p>v）验证码</p>
<h3 id="_2-csrf-跨站请求伪造" tabindex="-1"> 2）CSRF：跨站请求伪造</h3>
<p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<h4 id="攻击流程举例" tabindex="-1"> 攻击流程举例</h4>
<p>i）受害者登录 a.com，并保留了登录凭证（Cookie）</p>
<p>ii）攻击者引诱受害者访问了b.com</p>
<p>iii）b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie</p>
<p>iv）a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</p>
<p>v）a.com以受害者的名义执行了act=xx</p>
<p>vi）攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</p>
<h4 id="攻击类型" tabindex="-1"> 攻击类型</h4>
<p>i）GET型：如在页面的某个 img 中发起一个 get 请求</p>
<p>ii）POST型：通过自动提交表单到恶意网站</p>
<p>iii）链接型：需要诱导用户点击链接</p>
<h4 id="预防方案" tabindex="-1"> 预防方案</h4>
<p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。）</p>
<p>i）同源检测：通过Header中的Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证</p>
<p>ii）CSRF Token 校验：将CSRF Token输出到页面中（通常保存在Session中），页面提交的请求携带这个Token，服务器验证Token是否 正确</p>
<p>iii）双重cookie验证：</p>
<p>流程：</p>
<ul>
<li>步骤1：在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）</li>
<li>步骤2：在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST <a href="https://www.a.com/comment?csrfcookie=v8g9e4ksfhw" target="_blank" rel="noopener noreferrer">https://www.a.com/comment?csrfcookie=v8g9e4ksfhw</a>）</li>
<li>步骤3：后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。</li>
</ul>
<p>优点：</p>
<ul>
<li>无需使用Session，适用面更广，易于实施。</li>
<li>Token储存于客户端中，不会给服务器带来压力。</li>
<li>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</li>
</ul>
<p>缺点：</p>
<ul>
<li>Cookie中增加了额外的字段。</li>
<li>如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。</li>
<li>难以做到子域名的隔离。</li>
<li>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</li>
</ul>
<p>iv）Samesite Cookie属性：Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie , 但必须是Get请求</p>
<h3 id="_3-iframe-安全" tabindex="-1"> 3）iframe 安全</h3>
<h4 id="说明" tabindex="-1"> 说明</h4>
<p>i）嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题</p>
<p>ii）点击劫持</p>
<ul>
<li>攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。</li>
</ul>
<p>iii）禁止自己的 iframe 中的链接外部网站的JS</p>
<h4 id="预防方案-1" tabindex="-1"> 预防方案</h4>
<p>i）为 iframe 设置 sandbox 属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则</p>
<p>ii）服务端设置 X-Frame-Options Header头，拒绝页面被嵌套，X-Frame-Options 是HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入</p>
<p>iii）设置 CSP 即 Content-Security-Policy 请求头</p>
<p>iv）减少对 iframe 的使用</p>
<h3 id="_4-错误的内容推断" tabindex="-1"> 4）错误的内容推断</h3>
<h4 id="说明-1" tabindex="-1"> 说明</h4>
<p>文件上传类型校验失败后，导致恶意的JS文件上传后，浏览器 Content-Type Header 的默认解析为可执行的 JS 文件</p>
<h4 id="预防方案-2" tabindex="-1"> 预防方案</h4>
<p>设置 X-Content-Type-Options 头</p>
<h3 id="_5-第三方依赖包" tabindex="-1"> 5）第三方依赖包</h3>
<p>减少对第三方依赖包的使用，如之前 npm 的包如：event-stream 被爆出恶意攻击数字货币；</p>
<h3 id="_6-https" tabindex="-1"> 6）HTTPS</h3>
<h4 id="描述" tabindex="-1"> 描述</h4>
<p>黑客可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。</p>
<h4 id="预防方案-3" tabindex="-1"> 预防方案</h4>
<p>使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信。</p>
<p>这里的“强制性”表现为浏览器无论在何种情况下都直接向务器端发起HTTPS请求，而不再像以往那样从HTTP跳转到HTTPS。</p>
<p>另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再 用户选择是否继续进行不安全的通信。</p>
<h3 id="_7-本地存储数据" tabindex="-1"> 7）本地存储数据</h3>
<p>避免重要的用户信息存在浏览器缓存中</p>
<h3 id="_8-静态资源完整性校验" tabindex="-1"> 8）静态资源完整性校验</h3>
<h4 id="描述-1" tabindex="-1"> 描述</h4>
<p>使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。</p>
<p>然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。</p>
<h4 id="预防方案-4" tabindex="-1"> 预防方案</h4>
<p>将使用 base64 编码过后的文件哈希值写入你所引用的 script 标签的 integrity 属性值中即可启用子资源完整性能。</p>
<h3 id="_9-网络劫持" tabindex="-1"> 9）网络劫持</h3>
<h4 id="描述-2" tabindex="-1"> 描述</h4>
<p>DNS劫持（涉嫌违法）：修改运行商的 DNS 记录，重定向到其他网站。</p>
<ul>
<li>DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持</li>
</ul>
<p>HTTP劫持：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）。</p>
<h4 id="预防方案-5" tabindex="-1"> 预防方案</h4>
<p>全站 HTTPS</p>
<h3 id="_10-中间人攻击" tabindex="-1"> 10）中间人攻击</h3>
<p>中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。</p>
<p>没有进行严格的证书校验是中间人攻击着手点。</p>
<p>目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。</p>
<p>如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p>
<p>攻击场景如用户在一个未加密的 WiFi下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。</p>
<h4 id="场景" tabindex="-1"> 场景</h4>
<p>i）在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络</p>
<p>ii）Fiddler / Charles （花瓶）代理工具</p>
<p>iii）12306 之前的自己证书</p>
<h4 id="过程" tabindex="-1"> 过程</h4>
<p>i）客户端发送请求到服务端，请求被中间人截获</p>
<p>ii）服务器向客户端发送公钥</p>
<p>iii）中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端</p>
<p>iv）客户端收到伪造的公钥后，生成加密hash值发给服务器</p>
<p>v）中间人获得加密hash值，用自己的私钥解密获得真秘钥,同时生成假的加密hash值，发给服务器</p>
<p>vi）服务器用私钥解密获得假密钥,然后加密数据传输给客户端</p>
<h4 id="使用抓包工具fiddle来进行举例说明" tabindex="-1"> 使用抓包工具fiddle来进行举例说明</h4>
<ul>
<li>首先通过一些途径在客户端安装证书</li>
<li>然后客户端发送连接请求，fiddle在中间截取请求，并返回自己伪造的证书</li>
<li>客户端已经安装了攻击者的根证书，所以验证通过</li>
<li>客户端就会正常和fiddle进行通信，把fiddle当作正确的服务器</li>
<li>同时fiddle会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥</li>
</ul>
<h4 id="常见攻击方式" tabindex="-1"> 常见攻击方式</h4>
<ul>
<li>嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具</li>
<li>数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。</li>
<li>会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。</li>
<li>SSL剥离：HTTPS是通过SSL/TLS进行加密过的，在SSL剥离攻击中，会使SSL/TLS连接断开，让受保护的HTTPS，变成不受 保护的HTTP（这对于网站非常致命）</li>
<li>DNS欺骗，攻击者往往通过入侵到DNS服务器，或者篡改用户本地hosts文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器</li>
<li>ARP欺骗，ARP(address resolution protocol)地址解析协议，攻击者利用APR的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的MAC地址，客户端无从得到真正的主机的MAC地址，所以，他会把这个地址当作真正 的主机来进行通信，将MAC存入ARP缓存表。</li>
<li>代理服务器</li>
</ul>
<h4 id="预防方案-6" tabindex="-1"> 预防方案</h4>
<p>i）用可信的第三方CA厂商</p>
<p>ii）不下载未知来源的证书，不要去下载一些不安全的文件</p>
<p>iii）确认你访问的URL是HTTPS的，确保网站使用了SSL，确保禁用一些不安全的SSL，只开启：TLS1.1，TLS1.2</p>
<p>iv）不要使用公用网络发送一些敏感的信息</p>
<p>v）不要去点击一些不安全的连接或者恶意链接或邮件信息</p>
<h3 id="_11-sql-注入" tabindex="-1"> 11）sql 注入</h3>
<h4 id="描述-3" tabindex="-1"> 描述</h4>
<p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗数据库服务器执行恶意的SQL命令,从而达到和服务器 进行直接的交互</p>
<h4 id="预防方案-7" tabindex="-1"> 预防方案</h4>
<p>i）后台进行输入验证，对敏感字符过滤。</p>
<p>ii）使用参数化查询，能避免拼接SQL，就不要拼接SQL语句。</p>
<h3 id="_12-前端数据安全" tabindex="-1"> 12）前端数据安全</h3>
<h4 id="描述-4" tabindex="-1"> 描述</h4>
<p>反爬虫。如猫眼电影、天眼查等等，以数据内容为核心资产的企业</p>
<h4 id="预防方案-8" tabindex="-1"> 预防方案</h4>
<p>i）font-face拼接方式：猫眼电影、天眼查</p>
<p>ii）background 拼接：美团</p>
<p>iii）伪元素隐藏：汽车之家</p>
<p>iv）元素定位覆盖式：去哪儿</p>
<p>v）iframe 异步加载：网易云音乐</p>
<h3 id="_13-其他建议" tabindex="-1"> 13）其他建议</h3>
<p>i）定期请第三方机构做安全性测试，漏洞扫描</p>
<p>ii）使用第三方开源库做上线前的安全测试，可以考虑融合到CI中</p>
<p>iii）code review 保证代码质量</p>
<p>iv）默认项目中设置对应的 Header 请求头，如 X-XSS-Protection、 X-Content-Type-Options 、X-Frame-Options Header、Content-Security-Policy 等等</p>
<p>v）对第三方包和库做检测：NSP(Node Security Platform)，Snyk</p>
<h2 id="掌握-那些操作会造成内存泄漏" tabindex="-1"> （掌握）那些操作会造成内存泄漏？</h2>
<p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</p>
<p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</p>
<p>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>
<h2 id="掌握-事件传播的三个阶段是什么" tabindex="-1"> （掌握）事件传播的三个阶段是什么</h2>
<p>捕获 &gt; 目标 &gt; 冒泡；在捕获阶段，事件通过父元素向下传递到目标元素。 然后它到达目标元素，冒泡开始。</p>
<h2 id="掌握-同步和异步的区别" tabindex="-1"> （掌握）同步和异步的区别?</h2>
<p>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</p>
<p>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</p>
<h2 id="掌握-前端如何压缩图片" tabindex="-1"> （掌握）前端如何压缩图片</h2>
<p>首先介绍下压缩的大概流程</p>
<ul>
<li>通过原生的input标签拿到要上传的图片文件</li>
<li>将图片文件转化成img元素标签</li>
<li>在canvas上压缩绘制该HTMLImageElement</li>
</ul>
<p>核心步骤：</p>
<ul>
<li>拿到转化后的img元素后，先取出该元素的宽高度，这个宽高度就是实际图片文件的宽高度。</li>
<li>然后定义一个最大限度的宽高度，如果超过这个限制宽高度，则进行等比例的缩放。</li>
<li>计算好将要压缩的尺寸后，创建canvas实例，设置canvas的宽高度为压缩计算后的尺寸，并将img绘制到上面</li>
</ul>
<div><pre><code><span>// 创建画布</span>
<span>const</span> canvas <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'canvas'</span><span>)</span>
<span>const</span> context <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'2d'</span><span>)</span>
 
<span>// 设置宽高度为等同于要压缩图片的尺寸</span>
 canvas<span>.</span>width <span>=</span> targetWidth
 canvas<span>.</span>height <span>=</span> targetHeight
 context<span>.</span><span>clearRect</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> targetWidth<span>,</span> targetHeight<span>)</span>
 <span>//将img绘制到画布上</span>
 context<span>.</span><span>drawImage</span><span>(</span>img<span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> targetWidth<span>,</span> targetHeight<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="了解-websocket和http的区别" tabindex="-1"> （了解）WebSocket和HTTP的区别</h2>
<p>http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。</p>
<p>http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p>
<p>WebSocket他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。</p>
<p>建立了WenSocket之后服务器不必在浏览器发送request请求之后才能发送信息到浏览器。这时的服务器已有主动权想什么时候发就可以发送信息到服务器。</p>
<h2 id="了解-怎么禁止js访问cookie" tabindex="-1"> （了解）怎么禁止js访问cookie？</h2>
<p>设置HttpOnly</p>
<p>如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，</p>
<h2 id="了解-谈谈你对amd、cmd的理解" tabindex="-1"> （了解）谈谈你对AMD、CMD的理解</h2>
<p>AMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。</p>
<h2 id="了解-new操作符到底干了什么" tabindex="-1"> （了解）new操作符到底干了什么？</h2>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name</span><span>)</span><span>{</span> 
    <span>//--------------------伪代码----------------------- </span>
    <span>var</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span> <span>//创建了空对象 </span>
    <span>this</span> <span>=</span> obj <span>//obj赋值给this </span>
    <span>this</span><span>.</span>proto <span>=</span> <span>Person</span><span>.</span>prototype <span>//实例对象的原型就是构造函数的原型 </span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span><span>//定义实例属性和方法 </span>
    <span>return</span> <span>this</span><span>;</span> <span>//返回this </span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="了解-xml和json的区别" tabindex="-1"> （了解）xml和json的区别</h2>
<p>面积：XML体积比JSON体积大</p>
<p>传输速度：JSON比XML执行速度快</p>
<p>结构清晰: JSON在结构上比XML清晰</p>
<p>交互：JSON数据和js有很好的交互性</p>
]]></content:encoded>
    </item>
    <item>
      <title>Nodejs</title>
      <link>https://0808200.xyz/Interview/h5/nodejs.html</link>
      <guid>https://0808200.xyz/Interview/h5/nodejs.html</guid>
      <source url="https://0808200.xyz/rss.xml">Nodejs</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="掌握-http和https的区别" tabindex="-1"> （掌握）Http和Https的区别？</h2>
<p>http协议和https协议的区别：传输信息安全性不同、连接方式不同、端口不同、证书申请方式不同</p>
<p>一、传输信息安全性不同</p>
<p>1、http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</p>
<p>2、https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。</p>
<p>二、连接方式不同</p>
<p>1、http协议：http的连接很简单，是无状态的。</p>
<p>2、https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。 三、端口不同</p>
<p>1、http协议：使用的端口是80。</p>
<p>2、https协议：使用的端口是443．</p>
<p>四、证书申请方式不同</p>
<p>1、http协议：免费申请。</p>
<p>2、https协议：需要到ca申请证书，一般免费证书很少，需要交费。</p>
<h2 id="掌握-http与tcp的关系-介绍一下tcp的三次握手-能否为两次握手-为什么-四次挥手" tabindex="-1"> （掌握）HTTP与TCP的关系，介绍一下TCP的三次握手，能否为两次握手，为什么？四次挥手</h2>
<p>HTTP是基于TCP协议的，所以每次都是客户端发送请求，服务器应答，但是TCP还可以给其他应用层提供服务，即可能A、B在建立链接之后，谁都可能先开始通信。</p>
<p>要知道TCP是全双工的，即客户端在给服务器端发送信息的同时，服务器端也可以给客户端发送信息。而半双工的意思是A可以给B发，B也可以给A发，但是A在给B发的时候，B不能给A发，即不同时，为半双工。 单工为只能A给B发，B不能给A发； 或者是只能B给A发，不能A给B发。</p>
<p>TCP三次握手：</p>
<p>第一次握手：客户端发送一个TCP的SYN（同步，代表开始会话请求）标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里</p>
<p>第二次握手 ：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p>
<p>第三次握手：客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p>
<p>如果两次，那么服务器无法确定服务器的信息客户端是否能收到，所以如果服务器先发送数据，可能后面的客户端都收不到，会出现问题 。</p>
<p>TCP四次挥手：</p>
<p>第一次挥手：首先客户端想要释放连接，向服务器发送一段报文（FIN：结束会话）；</p>
<p>第二次挥手：服务器接收到客户端发送过来的报文，确定了客户端要释放连接；随后服务器进入CLOSE-WAIT阶段（半关闭状态）并返回一段报文给客户端（ASK：应答）；</p>
<p>第三次挥手：服务器自从发送了ASK（应答）后，经过CLOSE-WAIT阶段（在这个阶段把没有发送完的数据先完成发送），做好了释放服务器端到客户端方向上的连接，再次向客户端发送报文（FIN：结束会话）</p>
<p>第四次挥手：客户端接收到服务器端发送的释放连接的报文，确定服务器做好释放连接的准备，最后客户端再次向服务器发送一段报文（ASK：应答）</p>
<h2 id="掌握-http-method" tabindex="-1"> （掌握）HTTP method</h2>
<p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。</p>
<p>GET是最常用的方法，通常用于请求服务器发送某个资源。</p>
<p>HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。</p>
<p>PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。</p>
<p>POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</p>
<p>TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</p>
<p>OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</p>
<p>DELETE 请求服务器删除请求 URL 指定的资源。</p>
<h2 id="掌握-http状态码及其含义" tabindex="-1"> （掌握）HTTP状态码及其含义</h2>
<p>举例状态码类型:</p>
<div><pre><code>状态码 类别 原因短语
1XX Information（信息性状态码） 接收的请求正在处理
2XX Success（成功状态码） 请求正常处理完毕
3XX Redirection（重定向状态码） 需要进行附加的操作以完成请求
4XX Client Error（客户端错误状态码） 服务器无法处理请求
5XX Server Error（服务端错误状态码） 服务器处理请求出错
204  服务器成功处理，但未返回内容。
304 Not Modified 未修改。 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
400 Bad Request 客户端请求的语法错误，服务器无法理解
403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求
404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-为什么javascript是单线程" tabindex="-1"> （掌握）为什么JavaScript是单线程？</h2>
<p>防止DOM渲染冲突的问题；</p>
<p>Html5中的Web Worker可以实现多线程</p>
<h2 id="掌握-同步和异步任务" tabindex="-1"> （掌握）同步和异步任务</h2>
<p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<p>异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<h2 id="掌握-什么是事件循环-eventloop" tabindex="-1"> （掌握）什么是事件循环（EventLoop）？</h2>
<p>node中的 Event Loop</p>
<p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现</p>
<p>img(opens new window)</p>
<p>根据上图node的运行机制如下</p>
<ul>
<li>8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>ibuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>8引擎再将结果返回给用户。</li>
</ul>
<p>六大阶段</p>
<p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p>img(opens new window)</p>
<ul>
<li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调，并且是由 poll 阶段控制的。</li>
<li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li>
<li>idle, prepare 阶段：仅node内部使用</li>
<li>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li>
<li>check 阶段：执行 setImmediate() 的回调</li>
<li>close callbacks 阶段：执行 socket 的 close 事件回调</li>
</ul>
<p>poll阶段</p>
<p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p>
<p>1.回到 timer 阶段执行回调</p>
<p>2.执行 I/O 回调</p>
<p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果 poll 队列为空时，会有两件事发生
<ul>
<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>
<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li>
<li>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</li>
</ul>
</li>
</ul>
<p>Micro-Task 与 Macro-Task</p>
<p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p>
<p>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、I/O 操作等。</p>
<p>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</p>
<p>setTimeout 和 setImmediate</p>
<p>二者非常相似，区别主要在于调用时机不同。</p>
<p>setImmediate 设计在poll阶段完成时执行，即check阶段；</p>
<p>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</p>
<div><pre><code><span>setTimeout</span><span>(</span><span>function</span> <span>timeout</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'timeout'</span><span>)</span><span>;</span>
<span>}</span><span>,</span><span>0</span><span>)</span><span>;</span>
<span>setImmediate</span><span>(</span><span>function</span> <span>immediate</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'immediate'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</p>
<p>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</p>
<p>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了 process.nextTick</p>
<p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行</p>
<p>4）Node与浏览器的 Event Loop 差异</p>
<p>img(opens new window)</p>
<p>Node端，microtask 在事件循环的各个阶段之间执行</p>
<p>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</p>
<h2 id="掌握-什么是内存泄漏-以及常见内存泄漏的原因-和排查的方法" tabindex="-1"> （掌握）什么是内存泄漏，以及常见内存泄漏的原因，和排查的方法</h2>
<p>1、概念</p>
<p>内存泄漏(Memory Leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢。</p>
<p>2、原因</p>
<p>严重的情况下导致内存达到某个极限(可能是进程的上限，如 v8 的上限;也可能是系统可提供的内存上限)会使得应用程序崩溃。常见内存泄漏的原因内存泄漏的几种情况:</p>
<p><strong>#全局变量</strong>
全局变量直接挂在 root 对象上，不会被清除掉。</p>
<p><strong>#闭包</strong>
闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。</p>
<p><strong>#事件监听</strong>
Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除(removeListener)，将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现。</p>
<p>3、排查方法</p>
<p>想要定位内存泄漏，通常会有两种情况：</p>
<ul>
<li>对于只要正常使用就可以重现的内存泄漏，这是很简单的情况只要在测试环境模拟就可以排查了。</li>
<li>对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。</li>
</ul>
<p>需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。快照工具推荐使用 heapdump 用来保存内存快照，使用 devtool 来查看内存快照。</p>
<p>使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰(如果使用 node-inspector 的话，快照中会有前端的变量干扰)。</p>
<h2 id="掌握-简述ajax原理和xmlhttprequest对象" tabindex="-1"> （掌握）简述ajax原理和XmlHttpRequest对象</h2>
<p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</p>
<p>这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。</p>
<p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。</p>
<p>简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p>
<h2 id="掌握-简述jwt-json-web-token-鉴权的原理" tabindex="-1"> （掌握）简述JWT（JSON Web Token）鉴权的原理</h2>
<h2 id="了解-一个tcp接连能发几个http请求" tabindex="-1"> （了解）一个tcp接连能发几个http请求？</h2>
<p>http 1.0 默认一次tcp连接进行一次http请求之后就会断开（由于资源浪费，有些服务器支持通过配置支持多次）</p>
<p>http 1.1 请求头配置：Connection:keep-alive = true，只要tcp连接不断开（默认2小时），一直可以进行http请求，但是一个tcp连接同一时间只支持一个http请求 Connection:keep-alive = false，只能发一次http请求</p>
<p>http 2.0：多路复用技术Multiplexing，一个tcp可以并发多个http请求（理论无上限，但是一般浏览器会有tcp并发数的限制）‘</p>
<h2 id="了解-nodejs中间件原理" tabindex="-1"> （了解）NodeJs中间件原理</h2>
<p>中间件其实就是一个函数</p>
<p>function(req,res,next){ req:请求对象 res：响应对象 next：下一个中间件 }
简单描述</p>
<p>洋葱圈模型，就是说中间件执行就像洋葱一样，最早use的中间件，就放在最外层。</p>
<p>处理顺序从左到右，左边接收一个request，右边输出返回response</p>
<p>一般的中间件都会执行两次，调用next之前为第一次，调用next时把控制传递给下游的下一个中间件。</p>
<p>当下游不再有中间件或者没有执行next函数时，就将依次恢复上游中间件的行为，让上游中间件执行next之后的代码</p>
<p>(洋葱圈模型，了解一下)</p>
<h2 id="了解-nodejs的中间件" tabindex="-1"> （了解）nodejs的中间件?</h2>
<p>在NodeJS中，中间件主要是指封装所有Http请求细节处理的方法。</p>
<p>一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p>
<p>中间件的行为比较类似Java中过滤器的工作原理，就是在进入具体的业务处理之前，先让过滤器处理。</p>
<h2 id="了解-cookies机制和session机制的区别" tabindex="-1"> （了解）cookies机制和session机制的区别</h2>
<p>1、cookies数据保存在客户端。session数据保存在服务端</p>
<p>2、cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗</p>
<p>3、session安全一点，但是占用服务器资源。</p>
<h2 id="了解-你知道哪些http头部" tabindex="-1"> （了解）你知道哪些http头部？</h2>
<p>HTTP Request Header 请求头</p>
<p>**Accept：**指定客户端能够接收的内容类型。</p>
<p>**Accept-Charset：**浏览器可以接受的字符编码集。</p>
<p>**Accept-Encoding：**指定浏览器可以支持的web服务器返回内容压缩编码类型。</p>
<p>**Accept-Language：**浏览器可接受的语言。</p>
<p>**Cache-Control：**指定请求和响应遵循的缓存机制。</p>
<p>**Connection：**表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</p>
<p>**CookieHTTP：**请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p>
<p>**Content-Length：**请求的内容长度。</p>
<p>**Content-Type：**请求的与实体对应的MIME信息。</p>
<p>**Date：**请求发送的日期和时间。</p>
<p>**From：**发出请求的用户的Email。</p>
<p>**Host：**指定请求的服务器的域名和端口号。</p>
<p>**Referer：**先前网页的地址，当前请求网页紧随其后,即来路。</p>
<p>**User-Agent：**的内容包含发出请求的用户信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>项目综合</title>
      <link>https://0808200.xyz/Interview/h5/project_integrated.html</link>
      <guid>https://0808200.xyz/Interview/h5/project_integrated.html</guid>
      <source url="https://0808200.xyz/rss.xml">项目综合</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="不同分辨率的布局适配" tabindex="-1"> 不同分辨率的布局适配</h2>
<p>媒体查询，百分比， 主要内容居中布局， rem</p>
<h2 id="项目应用了哪些相应的技术" tabindex="-1"> 项目应用了哪些相应的技术</h2>
<p>回答方向：组件复用，vuex具体场景使用，路由相关技术的使用，其他第三方库的使用，axios相关的处理</p>
<h2 id="axios网络请求封装" tabindex="-1"> axios网络请求封装</h2>
<p>回答方向：拦截器的具体使用，结合项目具体来说</p>
<h2 id="axios请求响应中的错误处理涉及哪些错误代号" tabindex="-1"> axios请求响应中的错误处理涉及哪些错误代号</h2>
<p>回答方向：token过期，token无效，特殊的code值需要的不同提示</p>
<h2 id="路由的动态渲染" tabindex="-1"> 路由的动态渲染</h2>
<p>addRoute</p>
]]></content:encoded>
    </item>
    <item>
      <title>React</title>
      <link>https://0808200.xyz/Interview/h5/react.html</link>
      <guid>https://0808200.xyz/Interview/h5/react.html</guid>
      <source url="https://0808200.xyz/rss.xml">React</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一、简述virtualdom及其工作原理" tabindex="-1"> 一、简述VirtualDOM及其工作原理</h2>
<p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。</p>
<p>React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p>
<p>Virtual DOM 工作过程有三个简单的步骤。</p>
<p>1、每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</p>
<p>2、然后计算之前 DOM 表示与新表示的之间的差异。</p>
<p>3、完成计算后，将只用实际更改的内容更新 real DOM。</p>
<h2 id="二、为什么浏览器无法读取jsx" tabindex="-1"> 二、为什么浏览器无法读取JSX？</h2>
<p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。</p>
<p>所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p>
<h2 id="三、解释-react-中-render-的目的" tabindex="-1"> 三、解释 React 中 render() 的目的</h2>
<p>每个React组件强制要求必须有一个 render()。</p>
<p>它返回一个 React 元素，是原生 DOM 组件的表示。</p>
<p>如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <code>&lt;form&gt;、 &lt;group&gt; 、 &lt;div&gt;</code> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</p>
<h2 id="四、详细解释-react-组件的生命周期方法" tabindex="-1"> 四、详细解释 React 组件的生命周期方法</h2>
<p>componentWillMount() – 在渲染之前执行，在客户端和服务器端都会执行。</p>
<p>componentDidMount() – 仅在第一次渲染后在客户端执行。</p>
<p>componentWillReceiveProps() – 当从父类接收到 props 并且在调用另一个渲染器之前调用。</p>
<p>shouldComponentUpdate() – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。</p>
<p>componentWillUpdate() – 在 DOM 中进行渲染之前调用。</p>
<p>componentDidUpdate() – 在渲染发生后立即调用。</p>
<p>componentWillUnmount() – 从 DOM 卸载组件后调用。用于清理内存空间。</p>
<h2 id="五、你对-react-的-refs-有什么了解" tabindex="-1"> 五、你对 React 的 refs 有什么了解？</h2>
<p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。</p>
<p>用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</p>
<h2 id="六、react-的工作原理" tabindex="-1"> 六、React 的工作原理</h2>
<p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 &quot;diffing&quot; 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。</p>
<h2 id="七、什么是高阶组件-hoc-它可以做什么" tabindex="-1"> 七、什么是高阶组件（HOC）？它可以做什么？</h2>
<p>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。</p>
<p>HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</p>
<p>HOC可用于许多任务，例如：</p>
<ul>
<li>代码重用，逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>状态抽象和控制</li>
<li>Props 控制</li>
</ul>
<h2 id="八、redux遵循的三个原则是什么" tabindex="-1"> 八、Redux遵循的三个原则是什么？</h2>
<ul>
<li>单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。</li>
<li>状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。</li>
<li>使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</li>
</ul>
<h2 id="九、你对-单一事实来源-有什么理解" tabindex="-1"> 九、你对“单一事实来源”有什么理解？</h2>
<p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p>
<h2 id="十、为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象" tabindex="-1"> 十、为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h2>
<p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>
]]></content:encoded>
    </item>
    <item>
      <title>小程序</title>
      <link>https://0808200.xyz/Interview/h5/small_program.html</link>
      <guid>https://0808200.xyz/Interview/h5/small_program.html</guid>
      <source url="https://0808200.xyz/rss.xml">小程序</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="掌握-小程序登录流程" tabindex="-1"> （掌握）小程序登录流程</h2>
<ul>
<li>wx.login获取临时登录凭证code</li>
<li>发送code给后端，后端通过code，appid，appsecret调用微信接口，返回openid和session-key；</li>
<li>后端通过openid和session-key生成token返回给前端</li>
<li>前端把后端返回的token缓存起来</li>
</ul>
<h2 id="掌握-微信小程序双向绑定和vue的异同" tabindex="-1"> （掌握）微信小程序双向绑定和vue的异同？</h2>
<p>大体相同，但小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData()方法。</p>
<h2 id="掌握-小程序应用的生命周期" tabindex="-1"> （掌握）小程序应用的生命周期</h2>
<ul>
<li>onLaunch() 用户首次打开小程序触发（全局只触发一次）</li>
<li>onShow() 小程序初始化完成后触发，小程序从后台进入前台也会触发</li>
<li>onHide() 小程序从前台进入后台触发</li>
<li>onError() 小程序发生脚本错误或者API调用失败时触发</li>
</ul>
<h2 id="掌握-小程序页面的生命周期函数" tabindex="-1"> （掌握）小程序页面的生命周期函数？</h2>
<ul>
<li>onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。</li>
<li>onShow() 页面显示/切入前台时触发，一般用来发送数据请求；</li>
<li>onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。</li>
<li>onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。</li>
<li>onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。</li>
</ul>
<h2 id="掌握-应用与页面生命周期触发的顺序" tabindex="-1"> （掌握）应用与页面生命周期触发的顺序</h2>
<p>首次进入小程序会触发应用生命周期</p>
<p>应用（app）onLaunch -&gt; 应用（app）onShow -&gt; 页面（page）-&gt; onLoad -&gt; 页面（page）onShow -&gt; 页面（page）onReady</p>
<h2 id="掌握-简述微信小程序原理" tabindex="-1"> （掌握）简述微信小程序原理</h2>
<p>小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；</p>
<p>它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现；</p>
<p>它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发；</p>
<p>功能可分为webview和appService两个部分；</p>
<p>webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；</p>
<p>两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。</p>
<h2 id="掌握-小程序导入外联样式的方法" tabindex="-1"> （掌握）小程序导入外联样式的方法？</h2>
<p>使用 <code>@import</code> 标识符来导入外联样式。<code>@import</code> 后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束</p>
<div><pre><code>@<span>import</span> <span>'./base.wxss'</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="掌握-哪些方法可以用来提高微信小程序的应用速度" tabindex="-1"> （掌握）哪些方法可以用来提高微信小程序的应用速度</h2>
<p>1、提高页面加载速度</p>
<p>2、用户行为预测</p>
<p>3、减少默认 data 的大小</p>
<p>4、组件化方案</p>
<h2 id="掌握-webview中的页面怎么跳回小程序中" tabindex="-1"> （掌握）webview中的页面怎么跳回小程序中？</h2>
<p>首先要引入最新版的jweixin-1.3.2.js，然后：</p>
<div><pre><code>wx<span>.</span>miniProgram<span>.</span><span>navigateTo</span><span>(</span><span>{</span>
  <span>url</span><span>:</span> <span>'/pages/login/login'</span><span>+</span><span>'$params'</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="掌握-如何实现下拉刷新" tabindex="-1"> （掌握）如何实现下拉刷新？</h2>
<p>首先在全局 config 中的 window配置 enablePullDownRefresh ，在 Page 中定义onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法 请求返回后，调用wx.stopPullDownRefresh停止下拉刷新。</p>
<h2 id="掌握-小程序的事件" tabindex="-1"> （掌握）小程序的事件</h2>
<p>1、事件分类</p>
<p>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</p>
<p>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</p>
<p>2、事件的绑定</p>
<p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<p>key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。</p>
<p>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</p>
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>
<p>3、如何实现下拉刷新</p>
<p>监听用户下拉刷新事件。</p>
<p>需要在app.json的window (opens new window)选项中或页面配置中开启enablePullDownRefresh。</p>
<p>可以通过wx.startPullDownRefresh (opens new window)触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。</p>
<p>当处理完数据刷新后，wx.stopPullDownRefresh (opens new window)可以停止当前页面的下拉刷新。</p>
<h2 id="掌握-小程序的路由方式" tabindex="-1"> （掌握）小程序的路由方式</h2>
<p>**打开新页面：**调用 API wx.navigateTo</p>
<p>**页面重定向：**调用 API wx.redirectTo</p>
<p>**页面返回：**调用 API wx.navigateBack</p>
<p>**Tab 切换：**调用 API wx.switchTab</p>
<p>**重启动：**调用 API wx.reLaunch</p>
<h2 id="掌握-小程序页面间有哪些传递数据的方法" tabindex="-1"> （掌握）小程序页面间有哪些传递数据的方法</h2>
<p>全局变量之中传递参数数据 微信小程序初始化时，首先会加载app.json全局样式配置文件和全局变量文件，例如下面的globalData变量。</p>
<p>在app.js定义全局变量后，可以在各页面间直接加载全局变量，小程序提供了getApp()方法，可以直接获取到App({...})这个全局实例对象。</p>
<p>使用本地缓存的方法保存全局变量,本地缓存是有存储限制的，所以建议手动删除不再需要的缓存数据。wx.setStorage</p>
<p>通过在跳转、重定向等转变页面时候，可以直接通过url来传送数据。</p>
<p><code>wx.navigateTo({ url: 'test?id=1' })</code> 在要接收上一页面传递过来的数据的页面通过onLoad事件的options参数里面包含了上一页面所有传递过来的参数数据 <code>onLoad:function(options){}</code></p>
<h2 id="了解-用过云开发吗-简述其功能" tabindex="-1"> （了解）用过云开发吗？简述其功能</h2>
<p>云开发有三个基础能力：</p>
<ul>
<li>云函数：运行在微信服务器上的函数，处理微信相关操作有天然优势，如获得用户信息异常方便（以前服务端解析很麻烦）</li>
<li>云数据库：一个小程序可以直接操作的JSON数据库，可以直接操作数据库，不在需要服务端了。</li>
<li>云存储：用来存储文件和图片</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Typescript</title>
      <link>https://0808200.xyz/Interview/h5/typescript.html</link>
      <guid>https://0808200.xyz/Interview/h5/typescript.html</guid>
      <source url="https://0808200.xyz/rss.xml">Typescript</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是typescript" tabindex="-1"> 什么是TypeScript？</h2>
<p>Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</p>
<h2 id="为什么要使用-typescript-typescript-相对于-javascript-的优势是什么" tabindex="-1"> 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</h2>
<p>增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。</p>
<p>优势:</p>
<ul>
<li>杜绝手误导致的变量名写错;</li>
<li>类型可以一定程度上充当文档;</li>
<li>IDE自动填充，自动联想;</li>
</ul>
<p>TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</p>
<p>const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。</p>
<p>枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>
<p>接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p>
<h2 id="typescript中内置类型" tabindex="-1"> typescript中内置类型</h2>
<div><pre><code><span>let</span> <span>str</span><span>:</span> string <span>=</span> <span>"jimmy"</span><span>;</span>
<span>let</span> <span>num</span><span>:</span> number <span>=</span> <span>24</span><span>;</span>
<span>let</span> <span>bool</span><span>:</span> boolean <span>=</span> <span>false</span><span>;</span>
<span>let</span> <span>u</span><span>:</span> <span>undefined</span> <span>=</span> <span>undefined</span><span>;</span>
<span>let</span> <span>n</span><span>:</span> <span>null</span> <span>=</span> <span>null</span><span>;</span>
<span>let</span> <span>obj</span><span>:</span> object <span>=</span> <span>{</span><span>x</span><span>:</span> <span>1</span><span>}</span><span>;</span>
<span>let</span> <span>big</span><span>:</span> bigint <span>=</span> <span>100n</span><span>;</span>
<span>let</span> <span>sym</span><span>:</span> symbol <span>=</span> <span>Symbol</span><span>(</span><span>"me"</span><span>)</span><span>;</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="null和undefined的区别" tabindex="-1"> null和undefined的区别</h2>
<p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给其他类型。</p>
<h2 id="number和bigint" tabindex="-1"> number和bigint</h2>
<p>虽然number和bigint都表示数字，但是这两个类型不兼容。</p>
<h2 id="any和unknown" tabindex="-1"> any和unknown</h2>
<p>any 类型，则允许被赋值为任意类型。</p>
<p>使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。</p>
<p>如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。</p>
<p>请记住，any 是魔鬼！尽量不要用any。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。</p>
<p>unknown与any的最大区别是： 任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何型。</p>
<p>unknown 任何类型的值都可以赋值给它，但它只能赋值给unknown和any。</p>
<p>这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用typeof、类型断言等方式来缩小未知范围</p>
<h2 id="object、object-和" tabindex="-1"> object、Object 和 {}</h2>
<p>另外，object（首字母小写，以下称“小 object”）、Object（首字母大写，以下称“大 Object”）和 {}（以下称“空对象”）</p>
<p>小 object 代表的是所有非原始类型，也就是说我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，null 和 undefined 类型也不能赋给 object。</p>
<p>JavaScript 中以下类型被视为原始类型：string、boolean、number、bigint、symbol、null 和 undefined。</p>
<p>大Object 代表所有拥有 toString、hasOwnProperty 方法的类型，所以所有原始类型、非原始类型都可以赋给 Object。同样，在严格模式下，null 和 undefined 类型也不能赋给 Object。</p>
<p>大 Object 包含原始类型，小 object 仅包含非原始类型，所以大 Object 似乎是小 object 的父类型。实际上，大 Object 不仅是小 object 的父类型，同时也是小 object 的子类型。</p>
<p>{}空对象类型和大 Object 一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，null 和 undefined 也不能赋给 {}</p>
<p>结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</p>
<h2 id="void" tabindex="-1"> void</h2>
<p>void表示没有任何类型，和其他类型是平等关系，不能直接赋值:</p>
<div><pre><code><span>let</span> <span>a</span><span>:</span> <span>void</span><span>;</span> 
<span>let</span> <span>b</span><span>:</span> number <span>=</span> a<span>;</span> <span>// Error</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>你只能为它赋予null和undefined（在strictNullChecks未指定为true时）。声明一个void类型的变量没有什么大用，我们一般也只有在函数没有返回值时去声明。</p>
<p>值得注意的是，方法没有返回值将得到undefined，但是我们需要定义成void类型，而不是undefined类型。否则将报错:</p>
<div><pre><code><span>function</span> <span>fun</span><span>(</span><span>)</span><span>:</span> <span>undefined</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"this is TypeScript"</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>fun</span><span>(</span><span>)</span><span>;</span> <span>// Error</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="函数重载" tabindex="-1"> 函数重载</h2>
<p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。 要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p>
<div><pre><code>type Types <span>=</span> number <span>|</span> string
<span>function</span> <span>add</span><span>(</span><span><span>a</span><span>:</span>number<span>,</span><span>b</span><span>:</span>number</span><span>)</span><span>:</span>number<span>;</span>
<span>function</span> <span>add</span><span>(</span><span><span>a</span><span>:</span> string<span>,</span> <span>b</span><span>:</span> string</span><span>)</span><span>:</span> string<span>;</span>
<span>function</span> <span>add</span><span>(</span><span><span>a</span><span>:</span> string<span>,</span> <span>b</span><span>:</span> number</span><span>)</span><span>:</span> string<span>;</span>
<span>function</span> <span>add</span><span>(</span><span><span>a</span><span>:</span> number<span>,</span> <span>b</span><span>:</span> string</span><span>)</span><span>:</span> string<span>;</span>
<span>function</span> <span>add</span><span>(</span><span><span>a</span><span>:</span>Types<span>,</span> <span>b</span><span>:</span>Types</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> a <span>===</span> <span>'string'</span> <span>||</span> <span>typeof</span> b <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
    <span>return</span> a<span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span> b<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> a <span>+</span> b<span>;</span>
<span>}</span>
<span>const</span> result <span>=</span> <span>add</span><span>(</span><span>'Semlinker'</span><span>,</span> <span>' Kakuqo'</span><span>)</span><span>;</span>
result<span>.</span><span>split</span><span>(</span><span>' '</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="array" tabindex="-1"> Array</h2>
<p>对数组类型的定义有两种方式：</p>
<div><pre><code><span>let</span> <span>arr</span><span>:</span>string<span>[</span><span>]</span> <span>=</span> <span>[</span><span>"1"</span><span>,</span><span>"2"</span><span>]</span><span>;</span>
<span>let</span> <span>arr2</span><span>:</span>Array<span>&lt;</span>string<span>></span> <span>=</span> <span>[</span><span>"1"</span><span>,</span><span>"2"</span><span>]</span>；
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>定义联合类型数组</p>
<div><pre><code><span>let</span> <span>arr</span><span>:</span><span>(</span>number <span>|</span> string<span>)</span><span>[</span><span>]</span><span>;</span>
arr3 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>'b'</span><span>,</span> <span>2</span><span>,</span> <span>'c'</span><span>]</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>定义指定对象成员的数组：</p>
<div><pre><code><span>interface</span> <span>Arrobj</span><span>{</span>
    <span>name</span><span>:</span>string<span>,</span>
    <span>age</span><span>:</span>number
<span>}</span>
<span>let</span> <span>arr3</span><span>:</span>Arrobj<span>[</span><span>]</span><span>=</span><span>[</span><span>{</span><span>name</span><span>:</span><span>'jimmy'</span><span>,</span><span>age</span><span>:</span><span>22</span><span>}</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="never类型" tabindex="-1"> never类型</h2>
<p>never类型表示的是那些永不存在的值的类型。</p>
<p>值会永不存在的两种情况：</p>
<ul>
<li>如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；</li>
<li>函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回</li>
</ul>
<h2 id="接口和类型别名type有什么区别" tabindex="-1"> 接口和类型别名type有什么区别</h2>
<p>接口可以继承,还可以重复申明,当有多个命名一样的接口是他们被定义的类型会发生合并,不支持联合/交叉类型</p>
<p>类型别名不可以继承,也不可以重复定义,支持使用联合类型和交叉类型</p>
<h2 id="类型收窄" tabindex="-1"> 类型收窄</h2>
<p>TypeScript 类型收窄就是从宽类型转换成窄类型的过程，其常用于处理联合类型变量的场景。</p>
<p>在TypeScript中，有许多方法可以收窄变量的类型：</p>
<ul>
<li>类型断言</li>
<li>类型守卫</li>
<li>双重断言</li>
</ul>
<h2 id="类型断言" tabindex="-1"> 类型断言</h2>
<p>类型断言可以明确地告诉 TypeScript 值的详细类型。</p>
<p>当在某些场景下，我们非常确认某个值的类型，即使与 TypeScript 推断出来的类型不一致，这时我们就可以使用类型断言，其语法如下：</p>
<div><pre><code>值 <span>as</span> 类型
<span>// or</span>
<span>&lt;</span>类型<span>></span>值
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。同时，因为 &lt;&gt; 容易跟泛型语法起冲突，所以建议大家在使用类型断言时，统一使用 值 as 类型 这样的语法。
当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法。</p>
<div><pre><code><span>interface</span> <span>Cat</span> <span>{</span>
 <span>name</span><span>:</span> stirng<span>;</span>
  <span>run</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Fish</span> <span>{</span>
  <span>name</span><span>:</span> string<span>;</span>
  <span>swim</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>function</span> <span>getName</span><span>(</span><span><span>animal</span><span>:</span> Cat <span>|</span> Fish</span><span>)</span> <span>{</span>
  <span>return</span> animal<span>.</span>name
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，如：</p>
<div><pre><code><span>interface</span> <span>Cat</span> <span>{</span>
 <span>name</span><span>:</span> stirng<span>;</span>
  <span>run</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Fish</span> <span>{</span>
  <span>name</span><span>:</span> string<span>;</span>
  <span>swim</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>function</span> <span>isFish</span><span>(</span><span><span>animal</span><span>:</span> Cat <span>|</span> Fish</span><span>)</span> <span>{</span>
  <span>if</span><span>(</span><span>typeof</span> animal<span>.</span>swim <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，获取 animal.swim 的时候会报错。此时可以使用类型断言，将 animal 断言成 Fish 类型，就可以解决访问 animal.swim 时报错的问题：</p>
<div><pre><code><span>interface</span> <span>Cat</span> <span>{</span>
 <span>name</span><span>:</span> stirng<span>;</span>
  <span>run</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Fish</span> <span>{</span>
  <span>name</span><span>:</span> string<span>;</span>
  <span>swim</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>function</span> <span>isFish</span><span>(</span><span><span>animal</span><span>:</span> Cat <span>|</span> Fish</span><span>)</span> <span>{</span>
  <span>if</span><span>(</span><span>typeof</span> <span>(</span>animal <span>as</span> Fish<span>)</span><span>.</span>swim <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>
<div><pre><code><span>interface</span> <span>Cat</span> <span>{</span>
 <span>name</span><span>:</span> stirng<span>;</span>
  <span>run</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Fish</span> <span>{</span>
  <span>name</span><span>:</span> string<span>;</span>
  <span>swim</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
<span>function</span> <span>swim</span><span>(</span><span><span>animal</span><span>:</span> Cat <span>|</span> Fish</span><span>)</span> <span>{</span>
  <span>(</span>animal <span>as</span> Fish<span>)</span><span>.</span><span>swim</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>tom</span><span>:</span> Cat <span>=</span> <span>{</span>
  <span>name</span><span>:</span> <span>"Tom"</span><span>,</span>
  <span>run</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"run"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>swim</span><span>(</span>tom<span>)</span><span>;</span> <span>// Uncaught TypeError: animal.swim is not a function</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>TypeScript 编译器信任了我们的断言，故在调用 swim() 时没有编译错误，但由于 Cat 上并没有 swim 方法，就会导致在运行时发生错误。</p>
<p>使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p>
<h2 id="类型保护的方式有哪些" tabindex="-1"> 类型保护的方式有哪些</h2>
<p>联合类型
当某些特定类型有共有属性的时候,可以使用联合类型结合if/else判断语句,来保护类型指定类型才能调用指定的方法</p>
<div><pre><code><span>interface</span> <span>Brid</span> <span>{</span>
    <span>fly</span><span>:</span> boolean
    <span>sing</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span>
<span>}</span>

<span>interface</span> <span>Dog</span> <span>{</span>
    <span>fly</span><span>:</span> boolean
    <span>bark</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span>
<span>}</span>

<span>// 联合类型仅提示共有属性</span>
<span>function</span> <span>tranAnial</span><span>(</span><span><span>animal</span><span>:</span> Brid <span>|</span> Dog</span><span>)</span> <span>{</span>
    <span>// 类型断言 实现类型保护</span>
    <span>if</span> <span>(</span>animal<span>.</span>fly<span>)</span> <span>{</span>
        <span>(</span>animal <span>as</span> Brid<span>)</span><span>.</span><span>sing</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>(</span>animal <span>as</span> Dog<span>)</span><span>.</span><span>bark</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>in 语法</p>
<p>当类型区别于其他方法有特定的属性是可以用in语法来保护类型启用对应的类型方法和属性等</p>
<div><pre><code><span>interface</span> <span>Brid</span> <span>{</span>
    <span>fly</span><span>:</span> boolean
    <span>sing</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span>
<span>}</span>

<span>interface</span> <span>Dog</span> <span>{</span>
    <span>fly</span><span>:</span> boolean
    <span>bark</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span>
<span>}</span>

<span>function</span> <span>tranAnialSecond</span><span>(</span><span><span>animal</span><span>:</span> Brid <span>|</span> Dog</span><span>)</span> <span>{</span>
    <span>// in 语法实现类型保护</span>
    <span>if</span> <span>(</span><span>'sing'</span> <span>in</span> animal<span>)</span> <span>{</span>
        animal<span>.</span><span>sing</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        animal<span>.</span><span>bark</span><span>(</span><span>)</span>
    <span>}</span>

<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>typeof</p>
<p>当某数据类型是指定的某原始类型,可以用typeof结合===运算符进行类型保护</p>
<div><pre><code><span>function</span> <span>add</span><span>(</span><span><span>first</span><span>:</span> string <span>|</span> number<span>,</span> <span>second</span><span>:</span> string <span>|</span> number</span><span>)</span> <span>{</span>
    <span>// typeof 语法实现类型保护</span>
    <span>if</span> <span>(</span><span>typeof</span> first <span>===</span> <span>'string'</span> <span>||</span> <span>typeof</span> second <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
        <span>return</span> <span><span>`</span><span><span>${</span>first<span>}</span></span><span><span>${</span>second<span>}</span></span><span>`</span></span>
    <span>}</span>
    <span>return</span> first <span>+</span> second
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用instanceof语法</p>
<p>判断某对象类型数据是否来自于对应的构造函数(instanceof用于检查构造函数的prototype属性是否存在于某实例里)</p>
<div><pre><code><span>// 使用 instanceof 语法做类型保护</span>
<span>class</span> <span>NumberObj</span> <span>{</span>
    <span>// 声明变量</span>
    <span>count</span><span>:</span> number
    <span>// 创建构造函数</span>
    <span>constructor</span><span>(</span><span><span>count</span><span>:</span> number</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>count <span>=</span> count
    <span>}</span>
<span>}</span>
<span>function</span> <span>addSecond</span><span>(</span><span><span>first</span><span>:</span> object <span>|</span> NumberObj<span>,</span> <span>second</span><span>:</span> object <span>|</span> NumberObj</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>first <span>instanceof</span> <span>NumberObj</span> <span>&amp;&amp;</span> second <span>instanceof</span> <span>NumberObj</span><span>)</span> <span>{</span>
        <span>return</span> first<span>.</span>count <span>+</span> second<span>.</span>count
    <span>}</span>
    <span>return</span> <span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="元祖越界问题" tabindex="-1"> 元祖越界问题</h2>
<div><pre><code><span>let</span> <span>aaa</span><span>:</span> <span>[</span>string<span>,</span> number<span>]</span> <span>=</span> <span>[</span><span>'aaa'</span><span>,</span> <span>5</span><span>]</span><span>;</span>
<span>// 添加时不会报错</span>
aaa<span>.</span><span>push</span><span>(</span><span>6</span><span>)</span><span>;</span>
<span>// 打印整个元祖不会报错</span>
console<span>.</span><span>log</span><span>(</span>aaa<span>)</span><span>;</span> <span>// ['aaa',5,6];</span>
<span>// 打印添加的元素时会报错</span>
console<span>.</span><span>log</span><span>(</span>aaa<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span> <span>// error</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="常量枚举与普通枚举的区别" tabindex="-1"> 常量枚举与普通枚举的区别</h2>
<ul>
<li>常量枚举会在编译阶段被删除</li>
<li>枚举成员只能是常量成员</li>
</ul>
<div><pre><code><span>const</span> <span>enum</span> Colors <span>{</span>
    Red<span>,</span>
    Yellow<span>,</span>
    Blue
<span>}</span>
<span>// 常量枚举会在编译阶段被删除</span>
<span>let</span> myColors <span>=</span> <span>[</span>Colors<span>.</span>Red<span>,</span> Colors<span>.</span>Yellow<span>,</span> Colors<span>.</span>Blue<span>]</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>编译成 JS</p>
<div><pre><code><span>"use strict"</span><span>;</span>
<span>var</span> myColors <span>=</span> <span>[</span><span>0</span> <span>/* Red */</span><span>,</span> <span>1</span> <span>/* Yellow */</span><span>,</span> <span>2</span> <span>/* Blue */</span><span>]</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>常量枚举<em><strong>不能包含计算成员，如果</strong></em>包含了计算成员，则会在编译阶段报错</p>
<div><pre><code><span>// 报错</span>
<span>const</span> <span>enum</span> Color <span>{</span>Red<span>,</span> Yellow<span>,</span> Blue <span>=</span> <span>"blue"</span><span>.</span>length<span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>Colors<span>.</span><span>RED</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="什么是函数类型接口" tabindex="-1"> 什么是函数类型接口</h2>
<p>对方法传入的参数和返回值进行约束</p>
<div><pre><code><span>// 注意区别</span>

<span>// 普通的接口</span>
<span>interface</span> <span>discount1</span><span>{</span>
  <span>getNum</span> <span>:</span> <span>(</span><span><span>price</span><span>:</span>number</span><span>)</span> <span>=></span> number
<span>}</span>

<span>// 函数类型接口</span>
<span>interface</span> <span>discount2</span><span>{</span>
  <span>// 注意:</span>
  <span>// “:” 前面的是函数的签名，用来约束函数的参数</span>
  <span>// ":" 后面的用来约束函数的返回值</span>
  <span>(</span>price<span>:</span>number<span>)</span><span>:</span>number
<span>}</span>
<span>let</span> <span>cost</span><span>:</span><span>discount2</span> <span>=</span> <span>function</span><span>(</span><span><span>price</span><span>:</span>number</span><span>)</span><span>:</span>number<span>{</span>
   <span>return</span> price <span>*</span> <span>.8</span><span>;</span>
<span>}</span>

<span>// 也可以使用类型别名</span>
type <span>Add</span> <span>=</span> <span>(</span><span><span>x</span><span>:</span> number<span>,</span> <span>y</span><span>:</span> number</span><span>)</span> <span>=></span> number
<span>let</span> <span>add</span><span>:</span> <span>Add</span> <span>=</span> <span>(</span><span><span>a</span><span>:</span> number<span>,</span> <span>b</span><span>:</span> number</span><span>)</span> <span>=></span> a <span>+</span> b
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="继承-vs-多态" tabindex="-1"> 继承 vs 多态</h2>
<ul>
<li>继承：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应</li>
</ul>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
    <span>speak</span><span>(</span>word<span>:</span> string<span>)</span><span>:</span> string <span>{</span>
        <span>return</span> <span>'Animal: '</span> <span>+</span> word<span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
    <span>speak</span><span>(</span>word<span>:</span> string<span>)</span><span>:</span> string <span>{</span>
        <span>return</span> <span>'Cat:'</span> <span>+</span> word<span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> <span>{</span>
    <span>speak</span><span>(</span>word<span>:</span> string<span>)</span><span>:</span> string <span>{</span>
        <span>return</span> <span>'Dog:'</span> <span>+</span> word<span>;</span>
    <span>}</span>
<span>}</span>

<span>let</span> cat <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>cat<span>.</span><span>speak</span><span>(</span><span>'hello'</span><span>)</span><span>)</span><span>;</span>
<span>let</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>dog<span>.</span><span>speak</span><span>(</span><span>'hello'</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="什么是泛型" tabindex="-1"> 什么是泛型</h2>
<p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。</p>
<p>可以把泛型理解为代表类型的参数</p>
<h2 id="非空断言符的使用" tabindex="-1"> 非空断言符的使用</h2>
<p>TS 3.7版本正式支持使用</p>
<div><pre><code><span>let</span> <span>root</span><span>:</span> any <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>;</span>
root<span>.</span>style<span>.</span>color <span>=</span> <span>'red'</span><span>;</span>

<span>let</span> <span>root2</span><span>:</span> <span>(</span>HTMLElement <span>|</span> <span>null</span><span>)</span> <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>;</span>
<span>// 非空断言操作符--> 这样写只是为了骗过编译器，防止编译的时候报错，打包后的代码可能还是会报错</span>
root2<span>!</span><span>.</span>style<span>.</span>color <span>=</span> <span>'red'</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="typescript-中-、-、-、-、-、-等符号的含义" tabindex="-1"> TypeScript 中 ?.、??、!、!.、_、* 等符号的含义？*</h2>
<p><code>?. 可选链</code> 遇到 null 和 undefined 可以立即停止表达式的运行。</p>
<p><code>?? 空值合并运算符</code> 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。</p>
<p><code>! 非空断言运算符</code> x! 将从 x 值域中排除 null 和 undefined <code>!.</code> 在变量名后添加，可以断言排除undefined和null类型</p>
<p><code>_ 数字分割符</code> 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324。</p>
<p><code>**求幂</code></p>
<h2 id="declare-declare-global是什么" tabindex="-1"> declare，declare global是什么？</h2>
<p>declare 是用来定义全局变量、全局函数、全局命名空间、js modules、class等 declare global 为全局对象 window 增加新的属性</p>
<div><pre><code>declare global <span>{</span> 
   <span>interface</span> <span>Window</span> <span>{</span> 
        <span>csrf</span><span>:</span> string<span>;</span> 
   <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="对-typescript-类中成员的-public、private、protected、readonly-修饰符的理解" tabindex="-1"> 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？</h2>
<ul>
<li>public: 成员都默认为public，被此限定符修饰的成员是可以被外部访问；</li>
<li>private: 被此限定符修饰的成员是只可以被类的内部访问；</li>
<li>protected: 被此限定符修饰的成员是只可以被类的内部以及类的子类访问;</li>
<li>readonly: 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</li>
</ul>
<h2 id="keyof-和-typeof-关键字的作用" tabindex="-1"> keyof 和 typeof 关键字的作用？</h2>
<p>keyof 索引类型查询操作符 获取索引类型的属性名，构成联合类型。 typeof 获取一个变量或对象的类型。</p>
<p>简述工具类型 Exclude、Omit、Merge、Intersection、Overwrite的作用。</p>
<div><pre><code>Exclude&lt;T, U> 从 T 中排除出可分配给 U的元素。 
Omit&lt;T, K> 的作用是忽略T中的某些属性。 
Merge&lt;O1, O2> 是将两个对象的属性合并。 
Compute&lt;A &amp; B> 是将交叉类型合并 
Intersection&lt;T, U>的作用是取T的属性,此属性同样也存在与U。 
Overwrite&lt;T, U> 是用U的属性覆盖T的相同属性。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Vue</title>
      <link>https://0808200.xyz/Interview/h5/vue.html</link>
      <guid>https://0808200.xyz/Interview/h5/vue.html</guid>
      <source url="https://0808200.xyz/rss.xml">Vue</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="掌握-用vue实现样式绑定-可以用class或者内联样式-最少写出2个" tabindex="-1"> （掌握）用Vue实现样式绑定，可以用class或者内联样式，最少写出2个？</h2>
<div><pre><code><span>&lt;!-- 第一种绑定class --></span>
<span><span><span>&lt;</span>div</span> <span>:class</span><span><span>=</span><span>"</span>[<span>'</span>classA<span>'</span>, <span>'</span>classB<span>'</span>]<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>&lt;!-- 第二种绑定class --></span>
<span><span><span>&lt;</span>div</span> <span>:class</span><span><span>=</span><span>"</span>{<span>'</span>classA<span>'</span>: true, <span>'</span>classB<span>'</span> : false}<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>&lt;!-- 第一种绑定style --></span>
<span><span><span>&lt;</span>div</span> <span>:style</span><span><span>=</span><span>"</span>{fontSize: <span>'</span>16px<span>'</span>, color: <span>'</span>red<span>'</span>}<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>&lt;!-- 第二种绑定style --></span>
<span><span><span>&lt;</span>div</span> <span>:style</span><span><span>=</span><span>"</span>[{fontSize: <span>'</span>16px<span>'</span>, color: <span>'</span>red<span>'</span>}]<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-能说下-vue-router-中常用的路由模式实现原理吗" tabindex="-1"> （掌握）能说下 vue-router 中常用的路由模式实现原理吗</h2>
<p>hash 模式</p>
<p>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
可以为 hash 的改变添加监听事件</p>
<div><pre><code>window<span>.</span><span>addEventListener</span><span>(</span><span>"hashchange"</span><span>,</span> funcRef<span>,</span> <span>false</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p>
<p>特点：兼容性好但是不美观</p>
<p>history 模式</p>
<p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p>
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p>
<p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p>
<h2 id="掌握-vue-router-有几种导航钩子" tabindex="-1"> （掌握）vue-router 有几种导航钩子？</h2>
<p>1、全局守卫： router.beforeEach</p>
<p>2、全局解析守卫： router.beforeResolve</p>
<p>3、全局后置钩子： router.afterEach</p>
<p>4、路由独享的守卫： beforeEnter</p>
<p>5、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave</p>
<h2 id="掌握-前端路由和后端路由的区别" tabindex="-1"> （掌握）前端路由和后端路由的区别</h2>
<p><strong>什么是路由</strong></p>
<p>路由是根据不同的 url 地址展示不同的内容或页面；</p>
<p>前端路由</p>
<p>很重要的一点是页面不刷新，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，每跳转到不同的URL都是使用前端的锚点路由.</p>
<p>随着（SPA）单页应用的不断普及，前后端开发分离，目前项目基本都使用前端路由，在项目使用期间页面不会重新加载。</p>
<p>优点:</p>
<ol>
<li>用户体验好，和后台网速没有关系，不需要每次都从服务器全部获取，快速展现给用户</li>
<li>可以再浏览器中输入指定想要访问的url路径地址</li>
<li>实现了前后端的分离，方便开发。有很多框架都带有路由功能模块。</li>
</ol>
<p>缺点:</p>
<ol>
<li>使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存</li>
<li>单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</li>
</ol>
<p>​</p>
<p>后端路由</p>
<p>浏览器在地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器响应请求，在后台拼接html文件传给前端显示, 返回不同的页面,</p>
<p>意味着浏览器会刷新页面，网速慢的话说不定屏幕全白再有新内容。后端路由的另外一个极大的问题就是 前后端不分离。</p>
<p>优点：</p>
<p>分担了前端的压力，html和数据的拼接都是由服务器完成。
缺点：</p>
<p>当项目十分庞大时，加大了服务器端的压力，同时在浏览器端不能输入制定的url路径进行指定模块的访问。另外一个就是如果当前网速过慢，那将会延迟页面的加载，对用户体验不是很友好。</p>
<h2 id="掌握-refs-和-el的用法" tabindex="-1"> （掌握）$refs 和 $el的用法</h2>
<p>ref 有三种用法：</p>
<p>1、ref 加在普通的元素上，用<code>this.$refs</code>（ref值） 获取到的是dom元素。</p>
<p>2、ref 加在子组件上，用 <code>this.$refs</code> 获取到的是组件实例，可以使用组件的所有方法。在使用方法的时候直接<code>this.$refs.XX</code>。</p>
<p>vm.$el：</p>
<p>获取Vue实例关联的DOM元素；</p>
<p>比方说我这里想获取自定义组件tabControl，并获取它的OffsetTop，就需要先获取该组件。</p>
<p>在组件内设置 属性 ref='一个名称(tabControl2)', 然后 this.$refs.tabControl2，就拿到了该组件</p>
<p>切记：ref属性，而获取组件的时候要用$refs</p>
<p>获取 OffsetTop，组件不是DOM元素，是没有OffsetTop的，无法通过.OffsetTop来获取的。就需要通过$el来获取组件中的DOM元素:</p>
<div><pre><code><span>this</span><span>.</span>tabOffsetTop<span>=</span><span>this</span><span>.</span>$refs<span>.</span>tabControl2<span>.</span>$el<span>.</span>offsetTop
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="掌握-vue常用的修饰符" tabindex="-1"> （掌握）vue常用的修饰符？</h2>
<p>.prevent: 提交事件不再重载页面；</p>
<p>.stop: 阻止单击事件冒泡；</p>
<p>.self: 当事件发生在该元素本身而不是子元素的时候会触发；</p>
<p>.capture: 事件侦听，事件发生的时候会调用；</p>
<h2 id="掌握-vue中v-if与v-show的区别以及使用场景" tabindex="-1"> （掌握）vue中v-if与v-show的区别以及使用场景</h2>
<p>区别</p>
<ol>
<li>手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；</li>
<li>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</li>
<li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
</ol>
<p>使用场景</p>
<p>基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<h2 id="掌握-v-if和v-for为什么避免一起用" tabindex="-1"> （掌握）v-if和v-for为什么避免一起用</h2>
<p>v-if和v-for一起使用，v-for的优先级要高于v-if，先循环再控制显示隐藏</p>
<p>为了过滤一个列表中的项目（比如v-for = &quot;user in users&quot; v-if = &quot;user.isActive&quot;）。在这种情况下，请将users替换为一个计算属性（比如activeUsers），让其返回过滤后的列表。</p>
<p>为了避免渲染本应该被隐藏的列表（比如v-for = &quot;user in users&quot; v-if = &quot;shouldShowUsers&quot;）。这种情况下，请将v-if移动至容器元素上（比如ul，ol）。</p>
<h1 id="vuex-为什么要分模块并且加命名空间" tabindex="-1"> Vuex 为什么要分模块并且加命名空间</h1>
<p>模块:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p>
<p>命名空间：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。</p>
<p>当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<h1 id="使用过-vue-ssr-吗-说说-ssr" tabindex="-1"> 使用过 Vue SSR 吗？说说 SSR</h1>
<p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p>
<p>优点：</p>
<p>SSR 有着更好的 SEO、并且首屏加载速度更快</p>
<p>缺点： 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。</p>
<p>服务器会有更大的负载需求</p>
<h1 id="vue-中使用了哪些设计模式" tabindex="-1"> vue 中使用了哪些设计模式</h1>
<p>1.工厂模式 - 传入参数即可创建实例</p>
<p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p>
<p>2.单例模式 - 整个程序有且仅有一个实例</p>
<p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p>
<p>3.发布-订阅模式 (vue 事件机制)</p>
<p>4.观察者模式 (响应式数据原理)</p>
<p>5.装饰模式: (@装饰器的用法)</p>
<p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p>
<h1 id="你都做过哪些-vue-的性能优化" tabindex="-1"> 你都做过哪些 Vue 的性能优化</h1>
<ul>
<li>对象层级不要过深，否则性能就会差</li>
<li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li>
<li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li>
<li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li>
<li>图片懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>适当采用 keep-alive 缓存组件</li>
<li>防抖、节流运用</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<h1 id="vue-mixin-的使用场景和原理" tabindex="-1"> Vue.mixin 的使用场景和原理</h1>
<p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立。</p>
<p>可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。</p>
<p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<h1 id="keep-alive-使用场景和原理" tabindex="-1"> keep-alive 使用场景和原理</h1>
<p>keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>
<ul>
<li>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</li>
<li>两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。</li>
<li>keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。</li>
</ul>
<h1 id="vue-set-方法原理" tabindex="-1"> Vue.set 方法原理</h1>
<p>了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的</p>
<p>1.在实例创建之后添加新的属性到实例上（给响应式对象新增属性）</p>
<p>2.直接更改数组下标来修改数组的值</p>
<p>Vue.set 或者说是$set 原理如下</p>
<p>因为响应式数据 我们给对象和数组本身都增加了__ob__属性，代表的是 Observer 实例。</p>
<p>当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪</p>
<p>然后会触发对象__ob__的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组</p>
<h1 id="vue-extend-作用和原理" tabindex="-1"> Vue.extend 作用和原理</h1>
<p>官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
<p>其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并</p>
<h1 id="写过自定义指令吗-原理是什么" tabindex="-1"> 写过自定义指令吗 原理是什么</h1>
<p>指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。</p>
<p>自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind</p>
<ol>
<li>
<p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li>
<p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li>
<p>update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</p>
</li>
<li>
<p>componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</p>
</li>
<li>
<p>unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
</ol>
<p>原理</p>
<p>1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性</p>
<p>2.通过 genDirectives 生成指令代码</p>
<p>3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子</p>
<p>4.当执行指令对应钩子函数时，调用对应指令定义的方法</p>
<h1 id="vue-模板编译原理" tabindex="-1"> Vue 模板编译原理</h1>
<p>Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步</p>
<ul>
<li>第一步是将 模板字符串 转换成 element ASTs（解析器）</li>
<li>第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）</li>
<li>第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）</li>
</ul>
<p>相关代码如下</p>
<div><pre><code><span>export</span> <span>function</span> <span>compileToFunctions</span><span>(</span><span>template</span><span>)</span> <span>{</span>
  <span>// 我们需要把html字符串变成render函数</span>
  <span>// 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span>
  <span>// 很多库都运用到了ast 比如 webpack babel eslint等等</span>
  <span>let</span> ast <span>=</span> <span>parse</span><span>(</span>template<span>)</span><span>;</span>
  <span>// 2.优化静态节点</span>
  <span>// 这个有兴趣的可以去看源码  不影响核心功能就不实现了</span>
  <span>//   if (options.optimize !== false) {</span>
  <span>//     optimize(ast, options);</span>
  <span>//   }</span>

  <span>// 3.通过ast 重新生成代码</span>
  <span>// 我们最后生成的代码需要和render函数一样</span>
  <span>// 类似_c('div',{id:"app"},_c('div',undefined,_v("hello"+_s(name)),_c('span',undefined,_v("world"))))</span>
  <span>// _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span>
  <span>let</span> code <span>=</span> <span>generate</span><span>(</span>ast<span>)</span><span>;</span>
  <span>//   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span>
  <span>let</span> renderFn <span>=</span> <span>new</span> <span>Function</span><span>(</span><span><span>`</span><span>with(this){return </span><span><span>${</span>code<span>}</span></span><span>}</span><span>`</span></span><span>)</span><span>;</span>
  <span>return</span> renderFn<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h1 id="生命周期钩子是如何实现的" tabindex="-1"> 生命周期钩子是如何实现的</h1>
<p>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）</p>
<h2 id="掌握-vue-router如何响应路由参数的变化" tabindex="-1"> （掌握）vue-router如何响应路由参数的变化</h2>
<p>什么是路由参数的变化</p>
<p>当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p>
<p>监测路由参数变化的方法</p>
<p>方法一watch监听：</p>
<div><pre><code><span>watch</span><span>:</span> <span>{</span> <span>// watch的第一种写法</span>
    <span>$route</span> <span>(</span><span>to<span>,</span> <span>from</span></span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>to<span>)</span>
        console<span>.</span><span>log</span><span>(</span>from<span>)</span>
    <span>}</span>
<span>}</span><span>,</span>
<span>// =========================</span>
<span>watch</span><span>:</span> <span>{</span> <span>// watch的第二种写法</span>
    <span>$route</span><span>:</span> <span>{</span>
        <span>handler</span> <span>(</span><span>to<span>,</span> <span>from</span></span><span>)</span><span>{</span>
            console<span>.</span><span>log</span><span>(</span>to<span>)</span>
            console<span>.</span><span>log</span><span>(</span>from<span>)</span>
        <span>}</span><span>,</span>
        <span>// 深度观察监听</span>
        <span>deep</span><span>:</span> <span>true</span>
    <span>}</span>
<span>}</span><span>,</span>
<span>// =========================</span>
<span>watch</span><span>:</span> <span>{</span> <span>// watch的第三种写法</span>
    <span>'$route'</span><span>:</span><span>'getPath'</span>
<span>}</span><span>,</span>
<span>methods</span><span>:</span> <span>{</span>
    <span>getPath</span><span>(</span><span>to<span>,</span> <span>from</span></span><span>)</span><span>{</span>
     console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>$route<span>.</span>path<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>方法二：导航守卫</p>
<div><pre><code><span>beforeRouteEnter</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>
    <span>next</span><span>(</span><span>)</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="掌握-vue中data中变量的数据值发生改变-界面没有跟着更新-是什么原因-vue数据双向绑定失效" tabindex="-1"> （掌握）Vue中data中变量的数据值发生改变，界面没有跟着更新，是什么原因（Vue数据双向绑定失效）</h2>
<p>1.如果data里面定义了对象，对象里面的键值没有，getter/setter函数没法监听到属性值的数据变化，会导致此现象的发生。</p>
<p>解决方法：</p>
<div><pre><code>Vue<span>.</span><span>set</span><span>(</span>obj<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
<span>// or</span>
<span>this</span><span>.</span><span>$set</span><span>(</span>obj<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="掌握-多层父子组件通讯" tabindex="-1"> （掌握）多层父子组件通讯</h2>
<p>有时候需要通讯的组件不是直接的父子组件，而是祖父和孙子，嵌套的层级比较多的情况下，需要传递的事件和属性比较多，会导致代码混乱，这个时候就需要用到Vue提供的更高阶方法：provide/inject</p>
<h2 id="掌握-父子组件通讯方式有哪些" tabindex="-1"> （掌握）父子组件通讯方式有哪些？</h2>
<p>父组件 --&gt; 子组件 ： 自定义属性 props</p>
<p>子组件 --&gt; 父组件 ： 自定义事件 $emit</p>
<p>EventBus</p>
<p>Vuex</p>
<p>v-model</p>
<p>v-model的方式：</p>
<p>我们都在表单中使用过 v-model 来绑定数据，其实组件之间也是可以用 v-model 进行双向绑定的</p>
<p>v-model 的本质就是绑定一个属性和事件</p>
<div><pre><code><span>// 父组件</span>
<span>&lt;</span>aa <span>class</span><span>=</span><span>"abc"</span> v<span>-</span>model<span>=</span><span>"test"</span> <span>></span><span>&lt;</span><span>/</span>aa<span>></span> 

<span>// aa子组件实现一：</span>
<span>&lt;</span>template<span>></span>
  <span>&lt;</span>div<span>></span>
    <span>&lt;</span>ul<span>></span>
      <span>&lt;</span>li<span>></span><span>{</span><span>{</span><span>'里面的值：'</span><span>+</span> msg<span>}</span><span>}</span><span>&lt;</span><span>/</span>li<span>></span>
      <span>&lt;</span>button @click<span>=</span><span>"fn2"</span><span>></span>里面改变外面<span>&lt;</span><span>/</span>button<span>></span>
    <span>&lt;</span><span>/</span>ul<span>></span>
  <span>&lt;</span><span>/</span>div<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>

<span>&lt;</span>script<span>></span>
  <span>export</span> <span>default</span> <span>{</span>
    <span>model</span><span>:</span> <span>{</span>    <span>// 使用model</span>
      <span>prop</span><span>:</span> <span>'msg'</span><span>,</span> <span>//prop属性将msg作为该组件被使用时（此处为aa组件被父组件调用）v-model能取到的值，</span>
      <span>event</span><span>:</span> <span>'cc'</span> <span>// event中的cc就是父组件上的自定义事件，用来更新父组件上的test值</span>
    <span>}</span><span>,</span>
    <span>props</span><span>:</span> <span>{</span>
      <span>msg</span><span>:</span> <span>''</span>
    <span>}</span><span>,</span>
    <span>methods</span><span>:</span> <span>{</span>
      <span>fn2</span> <span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'cc'</span><span>,</span> <span>this</span><span>.</span>msg<span>+</span><span>2</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>

<span>// aa子组件实现方法二：</span>
<span>&lt;</span>template<span>></span>
 <span>&lt;</span>div<span>></span>
    <span>&lt;</span>ul<span>></span>
      <span>&lt;</span>li<span>></span><span>{</span><span>{</span><span>'里面的值：'</span><span>+</span> value<span>}</span><span>}</span><span>&lt;</span><span>/</span>li<span>></span> <span>// value会被赋值为v-model绑定的test的值。</span>
      <span>&lt;</span>button @click<span>=</span><span>"fn2"</span><span>></span>里面改变外面<span>&lt;</span><span>/</span>button<span>></span>
    <span>&lt;</span><span>/</span>ul<span>></span>
  <span>&lt;</span><span>/</span>div<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>

<span>&lt;</span>script<span>></span>
  <span>export</span> <span>default</span> <span>{</span>
    <span>props</span><span>:</span> <span>{</span>
      <span>value</span><span>:</span> <span>{</span> <span>// 必须要使用value</span>
　　　　　<span>default</span><span>:</span> <span>''</span><span>,</span>
　　　　<span>}</span><span>,</span>
    <span>}</span><span>,</span>

    <span>methods</span><span>:</span> <span>{</span>
      <span>fn2</span> <span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'input'</span><span>,</span> <span>this</span><span>.</span>value<span>+</span><span>2</span><span>)</span> <span>// 这儿必须用input 发送数据，发送的数据会被父级v-model=“test”接受到，再被value=test传回来。</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-简述vue的生命周期" tabindex="-1"> （掌握）简述Vue的生命周期</h2>
<p>常用的有8个（生命周期不仅仅是8个），都是成对出现。分别是：</p>
<ul>
<li>beforeCreate阶段、created阶段；</li>
<li>beforeMount阶段、mounted阶段；</li>
<li>beforeUpdate阶段、updated阶段；</li>
<li>beforeDestroy阶段、destroyed阶段；</li>
</ul>
<p>分别为：创建前/后，载入前/后，更新前/后，销毁前/后。</p>
<h2 id="掌握-第一次页面加载会触发哪几个钩子" tabindex="-1"> （掌握）第一次页面加载会触发哪几个钩子？</h2>
<p>beforeCreate, created, beforeMount, mounted</p>
<h2 id="掌握-vue实现数据双向绑定的原理" tabindex="-1"> （掌握）Vue实现数据双向绑定的原理</h2>
<p>vue实现数据双向绑定主要是：</p>
<p>采用数据劫持结合发布者-订阅者模式的方式，通过**Object.defineProperty（）**来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。</p>
<p>当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。</p>
<p>用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>vue的数据双向绑定</p>
<p>将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，</p>
<p>通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，</p>
<p>达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p>
<h2 id="掌握-简单实现双向数据绑定" tabindex="-1"> （掌握）简单实现双向数据绑定</h2>
<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>txt<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>p</span> <span>id</span><span><span>=</span><span>"</span>show<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>
    <span>var</span> obj <span>=</span> <span>{</span><span>}</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> <span>'txt'</span><span>,</span> <span>{</span>
        <span>get</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> obj
        <span>}</span><span>,</span>
        <span>set</span><span>:</span> <span>function</span> <span>(</span><span>newValue</span><span>)</span> <span>{</span>
            document<span>.</span><span>getElementById</span><span>(</span><span>'txt'</span><span>)</span><span>.</span>value <span>=</span> newValue
            document<span>.</span><span>getElementById</span><span>(</span><span>'show'</span><span>)</span><span>.</span>innerHTML <span>=</span> newValue
        <span>}</span>
    <span>}</span><span>)</span>
    document<span>.</span><span>getElementById</span><span>(</span><span>'txt'</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>'keyup'</span><span>,</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
        obj<span>.</span>txt <span>=</span> e<span>.</span>target<span>.</span>value
    <span>}</span><span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-vuex刷新页面数据丢失怎么解决" tabindex="-1"> （掌握）Vuex刷新页面数据丢失怎么解决？</h2>
<p>**办法一：**将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）</p>
<p>**办法二：**在页面刷新的时候再次请求远程数据，使之动态更新vuex数据</p>
<p>**办法三：**在父页面向后台请求远程数据，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）</p>
<h2 id="掌握-简单讲述vuex" tabindex="-1"> （掌握）简单讲述vuex</h2>
<p>vuex是专门为vue.js提供的一种状态管理模式，它采用的是集中式储存和管理所有组件的状态和数据，方便使用。</p>
<p>Vex有5种属性，分别是 state、getter、mutation、action、module：</p>
<p>1、state</p>
<p>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</p>
<p>2、getters</p>
<p>类似vue的计算属性，主要用来过滤一些数据。</p>
<p>3、mutations</p>
<p>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。</p>
<p>4、actions</p>
<p>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</p>
<div><pre><code><span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span> <span>//store实例</span>
  <span>state</span><span>:</span> <span>{</span>
    <span>count</span><span>:</span> <span>0</span>
  <span>}</span><span>,</span>
  <span>mutations</span><span>:</span> <span>{</span>                
    <span>increment</span> <span>(</span><span>state</span><span>)</span> <span>{</span>
      state<span>.</span>count<span>++</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>actions</span><span>:</span> <span>{</span> 
    <span>increment</span> <span>(</span><span>context</span><span>)</span> <span>{</span>
      context<span>.</span><span>commit</span><span>(</span><span>'increment'</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>5、modules</p>
<p>项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
<div><pre><code><span>const</span> moduleA <span>=</span> <span>{</span>
  <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>mutations</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>actions</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>getters</span><span>:</span> <span>{</span> <span>...</span> <span>}</span>
<span>}</span>
            
<span>const</span> moduleB <span>=</span> <span>{</span>
  <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>mutations</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>actions</span><span>:</span> <span>{</span> <span>...</span> <span>}</span>
 <span>}</span>

<span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  <span>modules</span><span>:</span> <span>{</span>
    <span>a</span><span>:</span> moduleA<span>,</span>
    <span>b</span><span>:</span> moduleB
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-vue如何自定义一个过滤器" tabindex="-1"> （掌握）Vue如何自定义一个过滤器</h2>
<p>1、局部过滤器</p>
<p>Html：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
     <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>msg<span>"</span></span> <span>/></span></span>
     {{msg| 过滤器名称 }}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>JS：</p>
<div><pre><code><span>var</span> vm<span>=</span><span>new</span> <span>Vue</span><span>(</span><span>{</span>
    <span>el</span><span>:</span><span>"#app"</span><span>,</span>
    <span>data</span><span>:</span><span>{</span>
        <span>msg</span><span>:</span><span>''</span>
    <span>}</span><span>,</span>
    <span>filters</span><span>:</span> <span>{</span>
      <span>过滤器名称</span><span>:</span> <span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>value<span>)</span> <span>return</span> <span>''</span>
        <span>...</span>
        <span>return</span> value
      <span>}</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>2、全局过滤器</p>
<div><pre><code>Vue<span>.</span><span>filter</span><span>(</span><span>'过滤器名称'</span><span>,</span> <span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>value<span>)</span> <span>return</span> <span>''</span>
  <span>...</span>
  <span>return</span> value
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-对keep-alive-的了解" tabindex="-1"> （掌握）对keep-alive 的了解？</h2>
<p>keep-alive 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</p>
<p>使用方法：</p>
<div><pre><code><span>&lt;</span>keep<span>-</span>alive<span>></span>
  <span>&lt;</span>component<span>></span>
    <span>&lt;</span><span>!</span><span>--</span> 该组件将被缓存！ <span>--</span><span>></span>
  <span>&lt;</span><span>/</span>component<span>></span>
<span>&lt;</span><span>/</span>keep<span>-</span>alive<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-vue-组件-data-为什么必须是函数" tabindex="-1"> （掌握）Vue 组件 data 为什么必须是函数</h2>
<p>data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。</p>
<p>而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
<h2 id="掌握-vue-中怎么自定义指令" tabindex="-1"> （掌握）Vue 中怎么自定义指令</h2>
<p>1、全局注册</p>
<div><pre><code><span>// 注册一个全局自定义指令 `v-focus`</span>
Vue<span>.</span><span>directive</span><span>(</span><span>'focus'</span><span>,</span> <span>{</span>
  <span>// 当被绑定的元素插入到 DOM 中时……</span>
  <span>inserted</span><span>:</span> <span>function</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
    <span>// 聚焦元素</span>
    el<span>.</span><span>focus</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>2、局部注册</p>
<div><pre><code><span>directives</span><span>:</span> <span>{</span>
  <span>focus</span><span>:</span> <span>{</span>
    <span>// 指令的定义</span>
    <span>inserted</span><span>:</span> <span>function</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
      el<span>.</span><span>focus</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-nexttick-是做什么的" tabindex="-1"> （掌握）nextTick 是做什么的</h2>
<p>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的DOM。</p>
<h2 id="掌握-route和-router-的区别" tabindex="-1"> （掌握）<code>$route</code>和 <code>$router</code> 的区别</h2>
<p><code>$router</code> 为 VueRouter 实例，想要导航到不同 URL，则使用 <code>$router.push</code> 方法</p>
<p><code>$route</code> 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等</p>
<h2 id="掌握-vue-cli生成的项目文件夹assets和public-static-的区别" tabindex="-1"> （掌握）vue-cli生成的项目文件夹<code>assets</code>和<code>public(static)</code>的区别</h2>
<p>vue-cli2生成的项目目录是static</p>
<p>vue-cli3以上生成的项目目录是public</p>
<p>相同点：</p>
<p>assets和public(static) 都是存放静态资源的文件。项目所需要的静态文件、图片、样式文件都可以放在这两个文件夹下</p>
<p>不同点：</p>
<p>在assets中存放的静态资源，在项目打包时会将这些静态资源与代码、index.html文件一起一同进行打包压缩，上传到服务器</p>
<p>在public(static)中存放的静态资源，不会被打包压缩格式化等流程，而是直接进入打包好的目录，直接上传到服务器</p>
<h2 id="掌握-dom渲染在哪个周期中就已经完成" tabindex="-1"> （掌握）DOM渲染在哪个周期中就已经完成</h2>
<p>DOM 渲染在 mounted 中就已经完成了。</p>
<h2 id="掌握-virtual-dom-虚拟dom-是什么" tabindex="-1"> （掌握）Virtual DOM（虚拟DOM）是什么？</h2>
<p>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实的DOM上</p>
<p>下面就是一个真实DOM映射到虚拟DOM的例子：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>id</span><span><span>=</span><span>'</span>list<span>'</span></span><span>></span></span>
 <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>'</span>item<span>'</span></span><span>></span></span>Item 1<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>'</span>item<span>'</span></span><span>></span></span>Item 2<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>'</span>item<span>'</span></span><span>></span></span>Item 3<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>虚拟DOM:</p>
<div><pre><code>    <span>var</span> element <span>=</span> <span>{</span>
        <span>tagName</span><span>:</span> <span>'ul'</span><span>,</span> <span>// 节点标签名</span>
        <span>props</span><span>:</span> <span>{</span> <span>// DOM的属性，用一个对象存储键值对</span>
            <span>id</span><span>:</span> <span>'list'</span>
        <span>}</span><span>,</span>
        <span>children</span><span>:</span> <span>[</span> <span>// 该节点的子节点</span>
          <span>{</span><span>tagName</span><span>:</span> <span>'li'</span><span>,</span> <span>props</span><span>:</span> <span>{</span><span>class</span><span>:</span> <span>'item'</span><span>}</span><span>,</span> <span>children</span><span>:</span> <span>[</span><span>"Item 1"</span><span>]</span><span>}</span><span>,</span>
          <span>{</span><span>tagName</span><span>:</span> <span>'li'</span><span>,</span> <span>props</span><span>:</span> <span>{</span><span>class</span><span>:</span> <span>'item'</span><span>}</span><span>,</span> <span>children</span><span>:</span> <span>[</span><span>"Item 2"</span><span>]</span><span>}</span><span>,</span>
          <span>{</span><span>tagName</span><span>:</span> <span>'li'</span><span>,</span> <span>props</span><span>:</span> <span>{</span><span>class</span><span>:</span> <span>'item'</span><span>}</span><span>,</span> <span>children</span><span>:</span> <span>[</span><span>"Item 3"</span><span>]</span><span>}</span><span>,</span>
        <span>]</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="掌握-为何需要virtual-dom" tabindex="-1"> （掌握）为何需要Virtual DOM？</h2>
<p>具备跨平台的优势 由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p>
<p>**操作原生DOM慢，js运行效率高。**我们可以将DOM对比操作放在JS层，提高效率。</p>
<p>因为DOM操作的执行速度远不如Javascript的运算速度快，因此，把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。</p>
<p>**Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。**可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。</p>
<p>CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</p>
<p>提升渲染性能 Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</p>
<h2 id="掌握-virtual-dom的diff算法" tabindex="-1"> （掌握）Virtual DOM的diff算法</h2>
<p>Virtual DOM因为是纯粹的JS对象，所以操作它会很高效，但是Virtual DOM的变更最终会转换成DOM操作，为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。</p>
<p>diff算法包括一下几个步骤:</p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异</li>
<li>把2所记录的差异应用到步骤1所构建的真正的DOM树上(patch)，视图就更新了</li>
<li>diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。</li>
</ul>
<h2 id="掌握-如何让css只在当前组件中起作用" tabindex="-1"> （掌握）如何让CSS只在当前组件中起作用?</h2>
<p>将当前组件的<code>&lt;style&gt;</code> 修改为 <code>&lt;style scoped&gt;</code></p>
<h2 id="掌握-修改第三方库的样式" tabindex="-1"> （掌握） 修改第三方库的样式</h2>
<div><pre><code><span>/</span>deep<span>/</span> <span>>>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="掌握-那你能讲一讲mvvm吗" tabindex="-1"> （掌握）那你能讲一讲MVVM吗？</h2>
<p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。</p>
<p>Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p>
<h2 id="掌握-单向数据流和双向数据流" tabindex="-1"> （掌握）单向数据流和双向数据流</h2>
<p>单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行单向数据通信，两个数据流之间相互独立。</p>
<p>单向数据流指只能从一个方向来修改状态。vuex（组件data -&gt; action -&gt; state-&gt;组件data）</p>
<p>与单向数据流对对应的是双向数据流（也叫双向绑定）。</p>
<p>在双向数据流中，Model（可以理解为状态的集合） 中可以修改自己或其他Model的状态， 用户的操作（如在输入框中输入内容）也可以修改状态。</p>
<p>这使改变一个状态有可能会触发一连串的状态的变化，最后很难预测最终的状态是什么样的。使得代码变得很难调试。</p>
<h2 id="掌握-说一下mvc的理解" tabindex="-1"> （掌握）说一下MVC的理解？</h2>
<p>mvc是模型(model)－视图(view)－控制器(controller)<code>的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</code>MVC对应Html，CSS，js。</p>
<h2 id="掌握-那你知道vue3-x响应式数据原理吗" tabindex="-1"> （掌握）那你知道Vue3.x响应式数据原理吗？</h2>
<p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化</p>
<p>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？（拓展）</p>
<p>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p>
<p>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？（拓展）</p>
<p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<h2 id="掌握-再说一下vue2-x中如何监测数组变化" tabindex="-1"> （掌握）再说一下vue2.x中如何监测数组变化</h2>
<p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写（push,pop,shift,unshift,splice...），指向了自己定义的数组原型方法。</p>
<p>这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>
<h2 id="掌握-computed和watch" tabindex="-1"> （掌握）Computed和Watch</h2>
<p>Computed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。</p>
<p>适用于计算比较消耗性能的计算场景。</p>
<p>当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p>
<p>Watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。</p>
<p>当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。</p>
<p>这样会带来性能问题，优化的话可以使用字符串形式监听。</p>
<h2 id="掌握-再说一下虚拟dom以及key属性的作用" tabindex="-1"> （掌握）再说一下虚拟Dom以及key属性的作用</h2>
<p>由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。</p>
<p>Vue2的Virtual DOM借鉴了开源库snabbdom的实现。</p>
<p>Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)</p>
<p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p>
<p>「key的作用是尽可能的复用 DOM 元素。」</p>
<p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p>
<p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p>
<h2 id="掌握-vue中组件生命周期调用顺序说一下" tabindex="-1"> （掌握）Vue中组件生命周期调用顺序说一下</h2>
<p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p>
<p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p>
<p>加载渲染过程</p>
<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</p>
<p>子组件更新过程</p>
<p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
<p>父组件更新过程</p>
<p>父 beforeUpdate -&gt; 父 updated</p>
<p>销毁过程</p>
<p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
<h2 id="掌握-组件设计应遵循什么原则" tabindex="-1"> （掌握）组件设计应遵循什么原则</h2>
<p>就近管理</p>
<ul>
<li>单文件开发</li>
<li>依赖的静态资源放在统计目录</li>
<li>相关联组件也放在同级目录</li>
</ul>
<p>高复用性</p>
<ul>
<li>页面级别的复用（基础组件）</li>
<li>项目级别的复用-私有组件库（业务组件）</li>
<li>公司级别的复用-开源组件库（element-ui）</li>
</ul>
<p>分层设计</p>
<p>分层架构分为四个层：</p>
<ul>
<li>展示层(presentation layer)</li>
<li>业务层(business layer)</li>
<li>持久层(persistence layer)</li>
<li>数据库层(database layer)</li>
</ul>
<p>灵活扩展</p>
<p>组件要充分的考虑扩展性，除了提供丰富的props还要提供slot插槽来完成用户的定制化需求。或者提供可利用render函数动态渲染的功能。</p>
<h2 id="了解-ssr了解吗" tabindex="-1"> （了解）SSR了解吗？</h2>
<p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>
<p>SSR有着更好的SEO、并且首屏加载速度更快等优点。</p>
<p>不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。</p>
<p>还有就是服务器会有更大的负载需求。</p>
<h2 id="了解-在vuejs中实现防止模板渲染时闪烁的方法" tabindex="-1"> （了解）在vuejs中实现防止模板渲染时闪烁的方法</h2>
<div><pre><code><span>[</span>v<span>-</span>cloak<span>]</span> <span>{</span>
<span>display</span><span>:</span> none<span>;</span>
<span>}</span> 
<span>&lt;</span>div v<span>-</span>cloak<span>></span>
<span>{</span><span>{</span> message <span>}</span><span>}</span>
<span>&lt;</span><span>/</span>div<span>></span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="了解-你对vue-js的template编译的理解" tabindex="-1"> （了解）你对Vue.js的template编译的理解？</h2>
<p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）。</p>
<p>详情步骤：</p>
<p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 抽象语法树 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p>
<p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p>
<h2 id="了解-谈谈vue-extend和vue-component" tabindex="-1"> （了解）谈谈Vue.extend和Vue.component</h2>
<p>Vue.extend返回的是一个扩展实例构造器，也就是预设了部分选项的Vue实例构造器。其主要用来服务于Vue.component。</p>
<p>Vue.component()<code>会注册一个全局的组件，其会自动判断第二个传进来的是Vue继续对象（</code>Vue.extend<code>）还是普通对象(</code>{...}<code>)，如果传进来的是普能对象的话会自动调用</code>Vue.extend</p>
<h2 id="了解-什么是vue的计算属性" tabindex="-1"> （了解）什么是vue的计算属性？</h2>
<p>在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：</p>
<p>① 使得数据处理结构清晰；</p>
<p>② 依赖于数据，数据更新，处理结果自动更新；</p>
<p>③ 计算属性内部this指向vm实例；</p>
<p>④ 在template调用时，直接写计算属性名即可；</p>
<p>⑤ 常用的是getter方法，获取数据，也可以使用set方法改变数据；</p>
<p>⑥ 相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue3</title>
      <link>https://0808200.xyz/Interview/h5/vue3.html</link>
      <guid>https://0808200.xyz/Interview/h5/vue3.html</guid>
      <source url="https://0808200.xyz/rss.xml">Vue3</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="vue2-vue3的区别" tabindex="-1"> vue2/vue3的区别</h2>
<p>Vue 3 的 Template 支持多个根标签，Vue 2 不支持</p>
<p>Vue 3 有 createApp()，而 Vue 2 的是 new Vue() createApp(组件)，new Vue({template, render})</p>
<p>context.emit</p>
<p>新增context.emit，与this.$emit（vue3中只能在methods里使用）作用相同</p>
<p>Vue3中的属性绑定</p>
<p>默认所有属性都绑定到根元素 使用inheritAttrs: false可以取消默认绑定 使用attrs或者context.attrs获取所有属性 使用v-bind=&quot;$attrs&quot;批量绑定属性 使用 const {size, level, ...rest} = context.attrs 将属性分开</p>
<p>使用场景 在vue2中我们在父组件绑定click事件，子组件必须内部触发click，而vue3中在父组件绑定子组件的根元素上也会跟着绑定</p>
<h2 id="vue3为什么要使用组合式api" tabindex="-1"> vue3为什么要使用组合式API</h2>
<p>通过组合式 API 解决了两个问题。</p>
<p>我们让组件拥有了更加良好的代码组织结构</p>
<p>我们让相同的代码逻辑在不同的组件中进行了完整的复用</p>
<h2 id="vue3跨组件传值" tabindex="-1"> vue3跨组件传值</h2>
<p>props + emit</p>
<p>vuex</p>
<p>provide 和 inject 的注入方法</p>
<h2 id="vue组合式api有哪些" tabindex="-1"> vue组合式API有哪些</h2>
<ul>
<li>ref()</li>
<li>reactive()</li>
<li>watch()</li>
<li>生命周期()</li>
<li>computed</li>
<li>watch()</li>
</ul>
<h2 id="watcheffect用来代替生命周期里的onmounted和onupdated" tabindex="-1"> watchEffect用来代替生命周期里的onMounted和onUpdated</h2>
<p>初始化页面的时候watchEffect里的代码会执行，当watchEffect里的数据有更新的时候同样会执行</p>
<div><pre><code><span>const</span> count <span>=</span> <span>ref</span><span>(</span><span>0</span><span>)</span>

<span>watchEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>count<span>.</span>value<span>)</span><span>)</span>
<span>// -> logs 0</span>

<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  count<span>.</span>value<span>++</span>
  <span>// -> logs 1</span>
<span>}</span><span>,</span> <span>100</span><span>)</span>
注意watchEffect第一次运行是在组件挂载之前，如果需要访问<span>DOM</span>需要将我们的watchEffect放在onMounted里

<span>onMounted</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>watchEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>count<span>.</span>value<span>)</span><span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="vite和webpack的区别" tabindex="-1"> vite和webpack的区别</h2>
<p>vite是按需加载,他的优势在开发环境,启动是不打包,即不需要分析模块依赖,也不需要编译,启动速度就快,动态编译模块缩短了编译的时间</p>
<p>webpack是全部加载,在启动开发服务器时会先打包再启动开发服务器</p>
<h2 id="vite创建vue项目和vue-cli创建项目的区别" tabindex="-1"> vite创建vue项目和vue-cli创建项目的区别</h2>
<p>vite是web开发构建工具</p>
<p>vue-cli是官方的vue.js项目脚手架</p>
]]></content:encoded>
    </item>
    <item>
      <title>Webpack</title>
      <link>https://0808200.xyz/Interview/h5/webpack.html</link>
      <guid>https://0808200.xyz/Interview/h5/webpack.html</guid>
      <source url="https://0808200.xyz/rss.xml">Webpack</source>
      <category>Interview</category>
      <pubDate>Sat, 18 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Webpack</p>
<h2 id="掌握-3-那你再说一说loader和plugin的区别" tabindex="-1"> （掌握）3. 那你再说一说Loader和Plugin的区别？</h2>
<p>Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p>
<p>Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p>Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p>
<p>Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p>
<h2 id="掌握-4-webpack构建流程简单说一下" tabindex="-1"> （掌握）4.Webpack构建流程简单说一下</h2>
<p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ul>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件</li>
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
<li>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li>
</ul>
<h2 id="掌握-19、webpack和gulp有什么不同" tabindex="-1"> （掌握）19、webpack和gulp有什么不同？</h2>
<p>Gulp 就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。说的形象点，“Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。” 另外，Gulp是通过task对整个开发过程进行构建。</p>
<p>Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffee、LESS 等。</p>
<p>Gulp和Webpack功能实现对比：从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。</p>
<h2 id="掌握-16、webpack打包文件太大怎么办" tabindex="-1"> （掌握）16、webpack打包文件太大怎么办?</h2>
<p>webpack 把我们所有的文件都打包成一个 JS 文件，这样即使你是小项目，打包后的文件也会非常大。可以从去除不必要的插件，提取第三方库，代码压缩，代码分割，设置缓存几个方面着手优化。</p>
<h2 id="掌握-9-模块打包原理知道吗" tabindex="-1"> （掌握）9.模块打包原理知道吗？</h2>
<p>Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p>
<h2 id="了解-5-使用webpack开发时-你用过哪些可以提高效率的插件" tabindex="-1"> （了解）5.使用webpack开发时，你用过哪些可以提高效率的插件？</h2>
<p>webpack-dashboard：可以更友好的展示相关打包信息。</p>
<p>webpack-merge：提取公共配置，减少重复配置代码</p>
<p>speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</p>
<p>size-plugin：监控资源体积变化，尽早发现问题</p>
<p>HotModuleReplacementPlugin：模块热替换</p>
<h2 id="了解-6-source-map是什么-生产环境怎么用" tabindex="-1"> （了解）6.source map是什么？生产环境怎么用？</h2>
<p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p>
<p>map文件只要不打开开发者工具，浏览器是不会加载的。</p>
<p>线上环境一般处理方案：</p>
<p>sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</p>
<h2 id="了解-7-文件监听原理呢" tabindex="-1"> （了解）7.文件监听原理呢？</h2>
<p>在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<p>Webpack开启监听模式，有两种方式：</p>
<p>启动 webpack 命令时，带上 --watch 参数
在配置 webpack.config.js 中设置 watch:true
缺点：每次需要手动刷新浏览器</p>
<p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。</p>
<div><pre><code>module<span>.</span>export <span>=</span> <span>{</span>
    <span>// 默认false,也就是不开启</span>
    <span>watch</span><span>:</span> <span>true</span><span>,</span>
    <span>// 只有开启监听模式时，watchOptions才有意义</span>
    <span>watchOptions</span><span>:</span> <span>{</span>
        <span>// 默认为空，不监听的文件或者文件夹，支持正则匹配</span>
        <span>ignored</span><span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span>
        <span>// 监听到变化发生后会等300ms再去执行，默认300ms</span>
        <span>aggregateTimeout</span><span>:</span><span>300</span><span>,</span>
        <span>// 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次</span>
        <span>poll</span><span>:</span><span>1000</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="了解-8-说一下-webpack-的热更新原理吧" tabindex="-1"> （了解）8.说一下 Webpack 的热更新原理吧</h2>
<p>Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p>
<p>HMR的核心就是客户端从服务端拉去更新后的文件，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。</p>
<p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</p>
<h2 id="了解-10-如何对bundle体积进行监控和分析" tabindex="-1"> （了解）10. 如何对bundle体积进行监控和分析？</h2>
<p>VSCode 中有一个插件 Import Cost 可以帮助我们对引入模块的大小进行实时监测，还可以使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。</p>
<p>bundlesize 工具包可以进行自动化资源体积监控。</p>
<h2 id="了解-12-如何优化-webpack-的构建速度" tabindex="-1"> （了解）12. 如何优化 Webpack 的构建速度？</h2>
<p>使用高版本的 Webpack 和 Node.js</p>
<p>多进程/多实例构建：HappyPack(不维护了)、thread-loader</p>
<p>压缩代码</p>
<p>多进程并行压缩</p>
<ul>
<li>webpack-paralle-uglify-plugin</li>
<li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)</li>
<li>terser-webpack-plugin 开启 parallel 参数</li>
<li>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li>
</ul>
<p>图片压缩</p>
<ul>
<li>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)</li>
<li>配置 image-webpack-loader</li>
</ul>
<p>缩小打包作用域：</p>
<ul>
<li>exclude/include (确定 loader 规则范围)</li>
<li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li>
<li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li>
<li>resolve.extensions 尽可能减少后缀尝试的可能性</li>
<li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li>
<li>IgnorePlugin (完全排除模块)</li>
<li>合理使用alias</li>
</ul>
<p>提取页面公共资源：</p>
<ul>
<li>
<p>基础包分离：</p>
<ul>
<li>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中</li>
<li>使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件
DLL：</li>
</ul>
</li>
<li>
<p>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</p>
</li>
<li>
<p>HashedModuleIdsPlugin 可以解决模块数字id问题</p>
</li>
</ul>
<p>充分利用缓存提升二次构建速度：</p>
<ul>
<li>babel-loader 开启缓存</li>
<li>terser-webpack-plugin 开启缓存</li>
<li>使用 cache-loader 或者 hard-source-webpack-plugin</li>
</ul>
<p>Tree shaking</p>
<ul>
<li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率</li>
<li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li>
<li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码</li>
<li>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li>
</ul>
<p>Scope hoisting</p>
<ul>
<li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突</li>
<li>必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法</li>
</ul>
<p>动态Polyfill</p>
<ul>
<li>建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</li>
</ul>
<h2 id="了解-13-那代码分割的本质是什么-有什么意义呢" tabindex="-1"> （了解）13. 那代码分割的本质是什么？有什么意义呢？</h2>
<p>代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</p>
<p>「用可接受的服务器性能压力增加来换取更好的用户体验。」</p>
<p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p>
<p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p>
<h2 id="了解-14-是否写过loader-简单描述一下编写loader的思路" tabindex="-1"> （了解）14.是否写过Loader？简单描述一下编写loader的思路？</h2>
<p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p>
<p>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</p>
<p>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</p>
<p>尽可能的异步化 Loader，如果计算量很小，同步也可以</p>
<p>Loader 是无状态的，我们不应该在 Loader 中保留状态</p>
<p>使用 loader-utils 和 schema-utils 为我们提供的实用工具</p>
<h2 id="了解-15-是否写过plugin-简单描述一下编写plugin的思路" tabindex="-1"> （了解）15.是否写过Plugin？简单描述一下编写Plugin的思路？</h2>
<p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p>
<p>compiler 暴露了和 Webpack 整个生命周期相关的钩子</p>
<p>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</p>
<p>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</p>
<p>传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</p>
<p>找出合适的事件点去完成想要的功能</p>
<ul>
<li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</li>
<li>watch-run 当依赖的文件发生变化时会触发</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住。</li>
</ul>
<h2 id="了解-17、什么是长缓存-在webpack中如何做到长缓存优化" tabindex="-1"> （了解）17、什么是长缓存？在webpack中如何做到长缓存优化？</h2>
<p>浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码，最方便和简单的更新方式就是引入新的文件名称。</p>
<p>在webpack中可以在output中输出的文件指定chunkhash,并且分离经常更新的代码和框架代码。</p>
<p>通过NameModulesPlugin或是HashedModuleIdsPlugin使再次打包文件名不变。</p>
<h2 id="了解-18、webpack-dev-server和http服务器-如nginx-有什么区别" tabindex="-1"> （了解）18、webpack-dev-server和http服务器(如nginx)有什么区别?</h2>
<p>webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。</p>
<h2 id="了解-20、前端模块化有哪些" tabindex="-1"> （了解）20、前端模块化有哪些?</h2>
<p>前端模块化有commonJs、AMD与CMD。</p>
<p>其中commonJs是为了JS在后端的表现制定的，不适合前端。</p>
<p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。</p>
<p>CMD推崇就近依赖，只有在用到某个模块的时候再去require。</p>
<h2 id="了解-1-有哪些常见的loader" tabindex="-1"> （了解）1. 有哪些常见的Loader？</h2>
<ul>
<li>raw-loader：加载文件原始内容（utf-8）</li>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li>
<li>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>
<li>svg-inline-loader：将压缩后的 SVG 内容注入代码中</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>json-loader 加载 JSON 文件（默认包含）</li>
<li>handlebars-loader: 将 Handlebars 模版编译成函数并返回</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>ts-loader: 将 TypeScript 转换成 JavaScript</li>
<li>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li>
<li>sass-loader：将SCSS/SASS代码转换成CSS</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>
<li>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
<li>tslint-loader：通过 TSLint检查 TypeScript 代码</li>
<li>mocha-loader：加载 Mocha 测试用例的代码</li>
<li>coverjs-loader：计算测试的覆盖率</li>
<li>vue-loader：加载 Vue.js 单文件组件</li>
<li>i18n-loader: 国际化</li>
<li>cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li>
</ul>
<h2 id="了解-2-有哪些常见的plugin-你用过哪些plugin" tabindex="-1"> （了解）2.有哪些常见的Plugin？你用过哪些Plugin？</h2>
<p>define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</p>
<p>ignore-plugin：忽略部分文件</p>
<p>html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)</p>
<p>web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</p>
<p>uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)</p>
<p>terser-webpack-plugin: 支持压缩 ES6 (Webpack4)</p>
<p>webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度</p>
<p>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</p>
<p>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</p>
<p>clean-webpack-plugin: 目录清理</p>
<p>ModuleConcatenationPlugin: 开启 Scope Hoisting</p>
<p>speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</p>
<p>webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</p>
]]></content:encoded>
    </item>
    <item>
      <title>00 | 开篇词</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/1_opening/lesson00.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/1_opening/lesson00.html</guid>
      <source url="https://0808200.xyz/rss.xml">00 | 开篇词</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_00-开篇词" tabindex="-1"> 00 | 开篇词</h1>
<p>你好，我是罗剑锋，一名埋头于前线，辛勤“耕耘”了十余载的资深“码农”。</p>
<p>工作的这十多年来，我开发过智能 IC 卡，也倒腾过商用密码机；做过政务项目，也做过商务搜索；写过网游核心引擎，也写过 CDN 存储系统；在 Windows 上用 C/C++ 做客户端，在 AIX、Linux 上用 Java、PHP 写后台服务……现在则是专注于“魔改”Nginx，深度定制实现网络协议的分析与检测。</p>
<p>当极客时间的编辑联系我，要我写 HTTP 专栏的时候，我的第一反应是：“HTTP 协议好简单的，有这个必要吗？”</p>
<p>你可能也会有同样的想法：“HTTP 不就是请求 / 响应、GET/POST、Header/Body 吗？网络上的资料一抓一大把，有什么问题搜一下就是了。”</p>
<p>不瞒你说，我当时就是这么想的，在之前的工作中也是一直这么做的，而且一直“感觉良好”，觉得 HTTP 就是这个样子，没有什么特别的地方，没有什么值得讲的。</p>
<p>但在编辑的一再坚持下，我“勉为其难”接下了这个任务。然后做了一个小范围的“调查”，问一些周围的同事，各个领域的都有，比如产品、开发、运维、测试、前端、后端、手机端……想看看他们有什么意见。</p>
<p>出乎我的意料，他们无一例外都对这个“HTTP 专栏”有很强烈的需求，想好好“补补课”，系统地学习了解 HTTP，这其中甚至还包括有七、八年（甚至更多）工作经验的老手。</p>
<p>这不禁让我陷入了思考，为什么如此“简单”的协议却还有这么多的人想要学呢？</p>
<p>我想，一个原因可能是 HTTP 协议“太常见”了。就像现实中的水和空气一样，如此重要却又如此普遍，普遍到我们几乎忽视了它的存在。真的很像那句俗语所说：“鱼总是最后看见水的”，但水对鱼的生存却又是至关重要。</p>
<p>我认真回忆了一下这些年的工作经历，这才发现 HTTP 只是表面上显得简单，而底层的运行机制、工作原理绝不简单，可以说是非常地复杂。只是我们平常总是“KPI 优先”，网上抓到一个解决方法用过就完事了，没有去深究里面的要点和细节。</p>
<p>下面的几个场景，都是我周围同事的实际感受，你是否也在工作中遇到过这样的困惑呢？你能把它们都解释清楚吗？</p>
<ul>
<li>用 Nginx 搭建 Web 服务器，照着网上的文章配好了，但里面那么多的指令，什么 keepalive、rewrite、proxy_pass 都是怎么回事？为什么要这么配置？</li>
<li>用 Python 写爬虫，URI、URL“傻傻分不清”，有时里面还会加一些奇怪的字符，怎么处理才好？</li>
<li>都说 HTTP 缓存很有用，可以大幅度提升系统性能，可它是怎么做到的？又应该用在何时何地？</li>
<li>HTTP 和 HTTPS 是什么关系？还经常听说有 SSL/TLS/SNI/OCSP/ALPN……这么多稀奇古怪的缩写，头都大了，实在是搞不懂。</li>
</ul>
<p>其实这些问题也并不是什么新问题，把关键字粘贴进搜索栏，再点一下按钮，搜索引擎马上就能找出几十万个相关的页面。但看完第一页的前几个链接后，通常还是有种“懵懵懂懂”“似懂非懂”的感觉，觉得说的对，又不全对，和自己的思路总是不够“Match”。</p>
<p>不过大多数情况下你可能都没有时间细想，优先目标是把手头的工作“对付过去”。长此以来，你对 HTTP 的认识也可能仅限于这样的“知其然，而不知其所以然”，实际情况就是 HTTP 天天用，时时用，但想认真、系统地学习一下，梳理出自己的知识体系，经常会发现无从下手。</p>
<p><strong>我把这种 HTTP 学习的现状归纳为三点：正式资料“少”、网上资料“杂”、权威资料“难”。</strong></p>
<p><strong>第一个，正式资料“少”。</strong></p>
<p>上购书网站，搜个 Python、Java，搜个 MySQL、Node.js，能出一大堆。但搜 HTTP，实在是少得可怜，那么几本，一只手的手指头就可以数得过来，和语言类、数据库类、框架类图书真是形成了鲜明的对比。</p>
<p>现有的 HTTP 相关图书我都看过，怎么说呢，它们都有一个特点，“广撒网，捕小鱼”，都是知识点，可未免太“照本宣科”了，理论有余实践不足，看完了还是不知道怎么去用。</p>
<p>而且这些书的“岁数”都很大，依据的都是 20 年前的 RFC2616，很多内容都不合时宜，而新标准 7230 已经更新了很多关键的细节。</p>
<p><strong>第二个，网上资料“杂”。</strong></p>
<p>正式的图书少，而且过时，那就求助于网络社区吧。现在的博客、论坛、搜索引擎非常发达，网上有很多 HTTP 协议相关的文章，也都是网友的实践经验分享，“干货”很多，很能解决实际问题。</p>
<p>但网上文章的特点是细小、零碎，通常只“钉”在一个很小的知识点上，而且由于帖子长度的限制，无法深入展开论述，很多都是“浅尝辄止”，通常都止步在“How”层次，很少能说到“Why”，能说透的更是寥寥无几。</p>
<p>网文还有一个难以避免的“毛病”，就是“良莠不齐”。同一个主题可能会有好几种不同的说法，有的还会互相矛盾、以讹传讹。这种情况是最麻烦的，你必须花大力气去鉴别真假，不小心就会被“带到沟里”。</p>
<p>可想而知，这种“东一榔头西一棒子”的学习方式，用“碎片”拼凑出来的 HTTP 知识体系是非常不完善的，会有各种漏洞，遇到问题时基本派不上用场，还得再去找其他的“碎片”。</p>
<p><strong>第三个，权威资料“难”。</strong></p>
<p>图书少，网文杂，我们还有一个终极的学习资料，那就是 RFC 文档。</p>
<p>RFC 是互联网工程组（IETF）发布的官方文件，是对 HTTP 最权威的定义和解释。但它也是最难懂的，全英文看着费劲，理解起来更是难上加难，文档之间还会互相关联引用，“劝退率”极高。</p>
<p>这三个问题就像是“三座大山”，阻碍了像你这样的很多有心人去学习、了解 HTTP 协议。</p>
<p><strong>那么，怎么才能更好地学习 HTTP 呢？</strong></p>
<p>我为这个专栏定了一个基调：“要有广度，但更要有深度”。目标是成为含金量最高的 HTTP 学习资料，新手可以由浅入深、系统学习，老手可以温故知新、查缺补漏，让你花最少的时间，用最少的精力，掌握最多、最全面、最系统的知识。</p>
<p>由于 HTTP 应用得非常广泛，几乎涉及到所有的领域，所以我会在广度上从 HTTP 尽量向外扩展，不只讲协议本身，与它相关的 TCP/IP、DNS、SSL/TLS、Web Server 等都会讲到，而且会把它们打通串联在一起，形成知识链，让你知道它们之间是怎么联系、怎么运行的。</p>
<p>专栏文章的深度上我也是下足了功夫，全部基于最新的 RFC 标准文档，再结合我自己多年的实践体会，力求讲清讲透，能让你看了以后有豁然开朗的感觉。</p>
<p>比如分析 HTTPS，我会用 Wireshark 从建立 TCP 连接时就开始抓包，从二进制最底层来分析里面的 Record、Cipher Suite、Extension，讲 ECDHE、AES、SHA384，再画出详细的流程图，做到“一览无余”。</p>
<p>陆游有诗：“纸上得来终觉浅，绝知此事要躬行”。学习网络协议最重要的就是实践，在专栏里我还会教你用 Nginx 搭建一个“麻雀虽小，五脏俱全”的实验环境，让你与 HTTP 零距离接触。</p>
<p>它有一个最大的优点：自身就是一个完整的网络环境，即使不联网也能够在里面收发 HTTP 消息。</p>
<p>我还精心设计了配套的测试用例，最小化应用场景，排除干扰因素，你可以在里面任意测试 HTTP 的各种特性，再配合 Wireshark 抓包，就能够理论结合实践，更好地掌握 HTTP 的知识。</p>
<p>每一讲的末尾，我也会留几个思考题，你可以把它当作是求职时的面试官问题，尽量认真思考后再回答，这样能够把专栏的学习由“被动地听”，转变为“主动地学”，实现“学以致用”。</p>
<p>当然了，你和我的“兴趣点”不可能完全一样，我在讲课时也难免“顾此失彼”“挂一漏万”，希望你积极留言，我会视情况做些调整，或者用答疑的形式补充没讲到的内容。</p>
<p>今年是万维网和 HTTP 诞生 30 周年，也是 HTTP/1.1 诞生 20 周年，套用莎翁《哈姆雷特》里的名句，让我们在接下来的三个月里一起努力。</p>
<p>“To Be a HTTP Hero！”</p>
]]></content:encoded>
    </item>
    <item>
      <title>01 | HTTP的前世今生</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson01.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson01.html</guid>
      <source url="https://0808200.xyz/rss.xml">01 | HTTP的前世今生</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_01-http的前世今生" tabindex="-1"> 01 | HTTP的前世今生</h1>
<p>HTTP 协议在我们的生活中随处可见，打开手机或者电脑，只要你上网，不论是用 iPhone、Android、Windows 还是 Mac，不论是用浏览器还是 App，不论是看新闻、短视频还是听音乐、玩游戏，后面总会有 HTTP 在默默为你服务。</p>
<p>据 NetCraft 公司统计，目前全球至少有 16 亿个网站、2 亿多个独立域名，而这个庞大网络世界的底层运转机制就是 HTTP。</p>
<p>那么，在享受如此便捷舒适的网络生活时，你有没有想过，HTTP 协议是怎么来的？它最开始是什么样子的？又是如何一步一步发展到今天，几乎“统治”了整个互联网世界的呢？</p>
<p>常言道：“时势造英雄，英雄亦造时势”。</p>
<p>今天我就和你来聊一聊 HTTP 的发展历程，看看它的成长轨迹，看看历史上有哪些事件推动了它的前进，它又促进了哪些技术的产生，一起来见证“英雄之旅”。</p>
<p>在这个过程中，你也能够顺便了解一下 HTTP 的“历史局限性”，明白 HTTP 为什么会设计成现在这个样子。</p>
<h2 id="史前时期" tabindex="-1"> 史前时期</h2>
<p>20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。</p>
<p>然后在 70 年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网。</p>
<h2 id="创世纪" tabindex="-1"> 创世纪</h2>
<p>1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。</p>
<ol>
<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
</ol>
<p>这三项技术在如今的我们看来已经是稀松平常，但在当时却是了不得的大发明。基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。</p>
<p>所以在这一年，我们的英雄“HTTP”诞生了，从此开始了它伟大的征途。</p>
<h2 id="http-0-9" tabindex="-1"> HTTP/0.9</h2>
<p>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p>
<p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。</p>
<p>HTTP/0.9 虽然很简单，但它作为一个“原型”，充分验证了 Web 服务的可行性，而“简单”也正是它的优点，蕴含了进化和扩展的可能性，因为：</p>
<p>“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多。</p>
<h2 id="http-1-0" tabindex="-1"> HTTP/1.0</h2>
<p>1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。</p>
<p>同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。</p>
<p>这些新软件新技术一经推出立刻就吸引了广大网民的热情，更的多的人开始使用互联网，研究 HTTP 并提出改进意见，甚至实验性地往协议里添加各种特性，从用户需求的角度促进了 HTTP 的发展。</p>
<p>于是在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</p>
<ol>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ol>
<p>但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”。</p>
<p>所以 HTTP/1.0 的发布对于当时正在蓬勃发展的互联网来说并没有太大的实际意义，各方势力仍然按照自己的意图继续在市场上奋力拼杀。</p>
<h2 id="http-1-1" tabindex="-1"> HTTP/1.1</h2>
<p>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。</p>
<p>这场战争的结果你一定早就知道了，最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局）。</p>
<p>“浏览器大战”的是非成败我们放在一边暂且不管，不可否认的是，它再一次极大地推动了 Web 的发展，HTTP/1.0 也在这个过程中经受了实践检验。于是在“浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。</p>
<p>从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p>
<p>不过，说 HTTP/1.1 是“小幅度修正”也不太确切，它还是有很多实质性进步的。毕竟经过了多年的实战检验，比起 0.9/1.0 少了“学术气”，更加“接地气”，同时表述也更加严谨。HTTP/1.1 主要的变更点有：</p>
<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ol>
<p>HTTP/1.1 的推出可谓是“众望所归”，互联网在它的“保驾护航”下迈开了大步，由此走上了“康庄大道”，开启了后续的“Web 1.0”“Web 2.0”时代。现在许多的知名网站都是在这个时间点左右创立的，例如 Google、新浪、搜狐、网易、腾讯等。</p>
<p>不过由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。</p>
<h2 id="http-2" tabindex="-1"> HTTP/2</h2>
<p>HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长，度过了十多年的“快乐时光”，更涌现出了 Facebook、Twitter、淘宝、京东等互联网新贵。</p>
<p>这期间也出现了一些对 HTTP 不满的意见，主要就是连接慢，无法跟上迅猛发展的互联网，但 HTTP/1.1 标准一直“岿然不动”，无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。</p>
<p>终于有一天，搜索巨头 Google 忍不住了，决定“揭竿而起”，就像马云说的“如果银行不改变，我们就改变银行”。那么，它是怎么“造反”的呢？</p>
<p>Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，并在 Chrome 里应用于自家的服务器，如同十多年前的网景与微软一样，从实际的用户方来“倒逼”HTTP 协议的变革，这也开启了第二次的“浏览器大战”。</p>
<p>历史再次重演，不过这次的胜利者是 Google，Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</p>
<p>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</p>
<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ol>
<p>虽然 HTTP/2 到今天已经四岁，也衍生出了 gRPC 等新协议，但由于 HTTP/1.1 实在是太过经典和强势，目前它的普及率还比较低，大多数网站使用的仍然还是 20 年前的 HTTP/1.1。</p>
<h2 id="http-3" tabindex="-1"> HTTP/3</h2>
<p>看到这里，你可能会问了：“HTTP/2 这么好，是不是就已经完美了呢？”</p>
<p>答案是否定的，这一次还是 Google，而且它要“革自己的命”。</p>
<p>在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。</p>
<p>“功夫不负有心人”，当然也是因为 QUIC 确实自身素质过硬。</p>
<p>在去年，也就是 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我和你一起跨越了三十年的历史长河，回顾了 HTTP 协议的整个发展过程，在这里简单小结一下今天的内容：</p>
<ol>
<li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；</li>
<li>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</li>
<li>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</li>
<li>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</li>
<li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</li>
<li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</li>
</ol>
<p>希望通过今天的介绍，你能够对 HTTP 有一个初步但清晰的印象，知道了“来龙”才能更好地知道“去脉”。</p>
<p>课下作业
你认为推动 HTTP 发展的原动力是什么？
你是怎么理解 HTTP（超文本传输协议）的？
欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。暂时回答不出来也不要紧，你可以带着这些问题在后续的课程里寻找答案。</p>
<p>如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
    </item>
    <item>
      <title>02 | HTTP是什么？HTTP又不是什么？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson02.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson02.html</guid>
      <source url="https://0808200.xyz/rss.xml">02 | HTTP是什么？HTTP又不是什么？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_02-http是什么-http又不是什么" tabindex="-1"> 02 | HTTP是什么？HTTP又不是什么？</h1>
<p>首先我来问出这个问题：“你觉得 HTTP 是什么呢？”</p>
<p>你可能会不假思索、脱口而出：“HTTP 就是超文本传输协议，也就是HyperText Transfer Protocol。”</p>
<p>回答非常正确！我必须由衷地恭喜你：能给出这个答案，就表明你具有至少 50%HTTP 相关的知识储备，应该算得上是“半个专家”了。</p>
<p>不过让我们换个对话场景，假设不是我，而是由一位面试官问出刚才的问题呢？</p>
<p>显然，这个答案有点过于简单了，不能让他满意，他肯定会再追问你一些问题：</p>
<ul>
<li>你是怎么理解 HTTP 字面上的“超文本”和“传输协议”的？</li>
<li>能否谈一下你对 HTTP 的认识？越多越好。</li>
<li>HTTP 有什么特点？有什么优点和缺点？</li>
<li>HTTP 下层都有哪些协议？是如何工作的？</li>
<li>……</li>
</ul>
<p>几乎所有面试时问到的 HTTP 相关问题，都可以从这个最简单的“HTTP 是什么？”引出来。</p>
<p>所以，今天的话题就从这里开始，深度地解答一下“HTTP 是什么？”，以及延伸出来的第二个问题“HTTP 不是什么？”</p>
<h2 id="http-是什么" tabindex="-1"> HTTP 是什么</h2>
<p>咱们中国有个成语“人如其名”，意思是一个人的性格和特点是与他的名字相符的。</p>
<p>先看一下 HTTP 的名字：“超文本传输协议”，它可以拆成三个部分，分别是：“超文本”“传输”和“协议”。我们从后往前来逐个解析，理解了这三个词，我们也就明白了什么是 HTTP。</p>
<p><img src="https://img-blog.csdnimg.cn/d2f5eb95644f478b9bc9d4f39c82a96a.png" alt=""></p>
<p>首先，HTTP 是一个协议。不过，协议又是什么呢？</p>
<p>其实“协议”并不仅限于计算机世界，现实生活中也随处可见。例如，你在刚毕业时会签一个“三方协议”，找房子时会签一个“租房协议”，公司入职时还可能会签一个“保密协议”，工作中使用的各种软件也都带着各自的“许可协议”。</p>
<p>刚才说的这几个都是“协议”，本质上与 HTTP 是相同的，那么“协议”有什么特点呢？</p>
<p>第一点，协议必须要有两个或多个参与者，也就是“协”。</p>
<p>如果只有你一个人，那你自然可以想干什么就干什么，想怎么玩就怎么玩，不会干涉其他人，其他人也不会干涉你，也就不需要所谓的“协议”。但是，一旦有了两个以上的参与者出现，为了保证最基本的顺畅交流，协议就自然而然地出现了。</p>
<p>例如，为了保证你顺利就业，“三方协议”里的参与者有三个：你、公司和学校；为了保证你顺利入住，“租房协议”里的参与者有两个：你和房东。</p>
<p>第二点，协议是对参与者的一种行为约定和规范，也就是“议”。</p>
<p>协议意味着有多个参与者为了达成某个共同的目的而站在了一起，除了要无疑义地沟通交流之外，还必须明确地规定各方的“责、权、利”，约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等。例如，“租房协议”里就约定了，租期多少个月，每月租金多少，押金是多少，水电费谁来付，违约应如何处理等等。</p>
<p>好，到这里，你应该能够明白 HTTP 的第一层含义了。</p>
<p><strong>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</strong></p>
<p>接下来我们看 HTTP 字面里的第二部分：“<strong>传输</strong>”。</p>
<p>计算机和网络世界里有数不清的各种角色：CPU、内存、总线、磁盘、操作系统、浏览器、网关、服务器……这些角色之间相互通信也必然会有各式各样、五花八门的协议，用处也各不相同，例如广播协议、寻址协议、路由协议、隧道协议、选举协议等等。</p>
<p>HTTP 是一个“<strong>传输协议</strong>”，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A&lt;===&gt;B”。</p>
<p>别小看了这个简单的动作，它也至少包含了两项重要的信息。</p>
<p>第一点，HTTP 协议是一个“<strong>双向协议</strong>”。</p>
<p>也就是说，有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间双向而不是单向流动。通常我们把先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方。拿我们最常见的上网冲浪来举例子，浏览器就是请求方 A，网易、新浪这些网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把一些数据发送给网站，网站再把一些数据发回给浏览器，最后展现在屏幕上，你就可以看到各种有意思的新闻、视频了。</p>
<p>第二点，数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。</p>
<p>这样，传输方式就从“A&lt;===&gt;B”，变成了“A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B”，A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。</p>
<p>说到这里，你差不多应该能够明白 HTTP 的第二层含义了。</p>
<p><strong>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</strong></p>
<p>讲完了“协议”和“传输”，现在，我们终于到 HTTP 字面里的第三部分：“超文本”。</p>
<p>既然 HTTP 是一个“传输协议”，那么它传输的“超文本”到底是什么呢？我还是用两点来进一步解释。</p>
<p>所谓“文本”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。</p>
<p>在互联网早期，“文本”只是简单的字符文字，但发展到现在，“文本”的涵义已经被大大地扩展了，图片、音频、视频、甚至是压缩包，在 HTTP 眼里都可以算做是“文本”。</p>
<p>所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。</p>
<p>对于“超文本”，我们最熟悉的就应该是 HTML 了，它本身只是纯文字文件，但内部用很多标签定义了对图片、音频、视频等的链接，再经过浏览器的解释，呈现在我们面前的就是一个含有多种视听信息的页面。</p>
<p>OK，经过了对 HTTP 里这三个名词的详细解释，下次当你再面对面试官时，就可以给出比“超文本传输协议”这七个字更准确更有技术含量的答案：“<code>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</code>”。</p>
<h2 id="http-不是什么" tabindex="-1"> HTTP 不是什么</h2>
<p>现在你对“HTTP 是什么？”应该有了比较清晰的认识，紧接着的问题就是“HTTP 不是什么？”，等价的问题是“HTTP 不能干什么？”。想想看，你能回答出来吗？</p>
<p>因为 HTTP 是一个协议，是一种计算机间通信的规范，所以它<strong>不存在“单独的实体”</strong>。它不是浏览器、手机 APP 那样的应用程序，也不是 Windows、Linux 那样的操作系统，更不是 Apache、Nginx、Tomcat 那样的 Web 服务器。</p>
<p>但 HTTP 又与应用程序、操作系统、Web 服务器密切相关，在它们之间的通信过程中存在，而且是一种“动态的存在”，是发生在网络连接、传输超文本数据时的一个“动态过程”。</p>
<h3 id="http-不是互联网。" tabindex="-1"> HTTP 不是互联网。</h3>
<p>互联网（Internet）是遍布于全球的许多网络互相连接而形成的一个巨大的国际网络，在它上面存放着各式各样的资源，也对应着各式各样的协议，例如超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。</p>
<p>但毫无疑问，HTTP 是构建互联网的一块重要拼图，而且是占比最大的那一块。</p>
<h3 id="http-不是编程语言。" tabindex="-1"> HTTP 不是编程语言。</h3>
<p>编程语言是人与计算机沟通交流所使用的语言，而 HTTP 是计算机与计算机沟通交流的语言，我们无法使用 HTTP 来编程，但可以反过来，用编程语言去实现 HTTP，告诉计算机如何用 HTTP 来与外界通信。</p>
<p>很多流行的编程语言都支持编写 HTTP 相关的服务或应用，例如使用 Java 在 Tomcat 里编写 Web 服务，使用 PHP 在后端实现页面模板渲染，使用 JavaScript 在前端实现动态页面更新，你是否也会其中的一两种呢？</p>
<p>HTTP 不是 HTML，这个可能要特别强调一下，千万不要把 HTTP 与 HTML 混为一谈，虽然这两者经常是同时出现。</p>
<p>HTML 是超文本的载体，是一种标记语言，使用各种标签描述文字、图片、超链接等资源，并且可以嵌入 CSS、JavaScript 等技术实现复杂的动态效果。单论次数，在互联网上 HTTP 传输最多的可能就是 HTML，但要是论数据量，HTML 可能要往后排了，图片、音频、视频这些类型的资源显然更大。</p>
<h3 id="http-不是一个孤立的协议。" tabindex="-1"> HTTP 不是一个孤立的协议。</h3>
<p>俗话说“一个好汉三个帮”，HTTP 也是如此。</p>
<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ol>
<li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。</li>
<li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li>
<li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li>
</ol>
<p>把这些综合起来，使用递归缩写方式（模仿 PHP），我们可以把 HTTP 定义为“<strong>与 HTTP 协议相关的所有应用层技术的总和</strong>”。</p>
<p>这里我画了一个思维导图，也可以算是这个专栏系列文章的“知识地图”。</p>
<p><img src="https://img-blog.csdnimg.cn/d291f02a7d86417ebc1167b15de21738.png" alt=""></p>
<p>你可以对照这张图，看一下哪些部分是自己熟悉的，哪些部分是陌生的，又有哪些部分是想要进一步了解的，下一讲我会详细讲解这张图。</p>
<p>课下作业
有一种流行的说法：“HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议”，你认为这种说法对吗？对在哪里，又错在哪里？
你能再说出几个“HTTP 不是什么”吗？
欢迎你通过留言分享答案，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/d2f5eb95644f478b9bc9d4f39c82a96a.png" type="image/png"/>
    </item>
    <item>
      <title>03 | HTTP世界全览（上）：与HTTP相关的各种概念</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson03.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson03.html</guid>
      <source url="https://0808200.xyz/rss.xml">03 | HTTP世界全览（上）：与HTTP相关的各种概念</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_03-http世界全览-上-与http相关的各种概念" tabindex="-1"> 03 | HTTP世界全览（上）：与HTTP相关的各种概念</h1>
<p>在上一讲的末尾，我画了一张图，里面是与 HTTP 关联的各种技术和知识点，也可以说是这个专栏的总索引，不知道你有没有认真看过呢？</p>
<p>那张图左边的部分是与 HTTP 有关系的各种协议，比较偏向于理论；而右边的部分是与 HTTP 有关系的各种应用技术，偏向于实际应用。</p>
<p>我希望借助这张图帮你澄清与 HTTP 相关的各种概念和角色，让你在实际工作中清楚它们在链路中的位置和作用，知道发起一个 HTTP 请求会有哪些角色参与，会如何影响请求的处理，做到“手中有粮，心中不慌”。</p>
<p>因为那张图比较大，所以我会把左右两部分拆开来分别讲，今天先讲右边的部分，也就是与 HTTP 相关的各种应用，着重介绍互联网、浏览器、Web 服务器等常见且重要的概念。</p>
<p><img src="https://img-blog.csdnimg.cn/0779e89db8f047e19072f40a97224af2.png" alt=""></p>
<p>为了方便你查看，我又把这部分重新画了一下，比那张大图小了一些，更容易地阅读，你可以点击查看。</p>
<p>暖场词就到这里，让我们正式开始吧。</p>
<h2 id="网络世界" tabindex="-1"> 网络世界</h2>
<p>你一定已经习惯了现在的网络生活，甚至可能会下意识地认为网络世界就应该是这个样子的：“一张平坦而且一望无际的巨大网络，每一台电脑就是网络上的一个节点，均匀地点缀在这张网上”。</p>
<p>这样的理解既对，又不对。从抽象的、虚拟的层面来看，网络世界确实是这样的，我们可以从一个节点毫无障碍地访问到另一个节点。</p>
<p>但现实世界的网络却远比这个抽象的模型要复杂得多。实际的互联网是由许许多多个规模略小的网络连接而成的，这些“小网络”可能是只有几百台电脑的局域网，可能是有几万、几十万台电脑的广域网，可能是用电缆、光纤构成的固定网络，也可能是用基站、热点构成的移动网络……</p>
<p><code>互联网世界更像是由数不清的大小岛屿组成的“千岛之国”。</code></p>
<p>互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p>
<p>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</p>
<p>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p>
<p>综合起来看，现在的互联网 90% 以上的部分都被万维网，也就是 HTTP 所覆盖，所以把互联网约等于万维网或 HTTP 应该也不算大错。</p>
<h2 id="浏览器" tabindex="-1"> 浏览器</h2>
<p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</p>
<p><img src="https://img-blog.csdnimg.cn/35a91b52fa594062b76e2b6e02d4c80e.png" alt=""></p>
<p>那么你想过没有，所谓的“浏览器”到底是个什么东西呢？</p>
<p>浏览器的正式名字叫“Web Browser”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。</p>
<p>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。</p>
<p>例如，HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展。</p>
<p>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。</p>
<h2 id="web-服务器" tabindex="-1"> Web 服务器</h2>
<p>刚才说的浏览器是 HTTP 里的请求方，那么在协议另一端的应答方（响应方）又是什么呢？</p>
<p>这个你一定也很熟悉，答案就是服务器，Web Server。</p>
<p>Web 服务器是一个很大也很重要的概念，它是 HTTP 协议里响应请求的主体，通常也把控着绝大多数的网络资源，在网络世界里处于强势地位。</p>
<p>当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。</p>
<p>硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</p>
<p>软件含义的 Web 服务器可能我们更为关心，它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。</p>
<p>比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。</p>
<p>Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。</p>
<p>Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。</p>
<p>此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。</p>
<h2 id="cdn-内容分发网络" tabindex="-1"> CDN(内容分发网络)</h2>
<p>浏览器和服务器是 HTTP 协议的两个端点，那么，在这两者之间还有别的什么东西吗？</p>
<p>当然有了。浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</p>
<p>CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p>
<p>CDN 有什么好处呢？</p>
<p>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</p>
<p>打个比方，就好像唐僧西天取经，刚出长安城，就看到阿难与迦叶把佛祖的真经递过来了，是不是很省事？</p>
<p>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分，我也会在后面用一讲的篇幅来专门讲解 CDN。</p>
<h2 id="爬虫" tabindex="-1"> 爬虫</h2>
<p>前面说到过浏览器，它是一种用户代理，代替我们访问互联网。</p>
<p>但 HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是一种可以自动访问 Web 资源的应用程序。</p>
<p>“爬虫”这个名字非常形象，它们就像是一只只不知疲倦的、辛勤的蚂蚁，在无边无际的网络上爬来爬去，不停地在网站间奔走，搜集抓取各种信息。</p>
<p>据估计，互联网上至少有 50% 的流量都是由爬虫产生的，某些特定领域的比例还会更高，也就是说，如果你的网站今天的访问量是十万，那么里面至少有五六万是爬虫机器人，而不是真实的用户。</p>
<p>爬虫是怎么来的呢？</p>
<p>绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</p>
<p>爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。</p>
<p>无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。</p>
<h2 id="html-webservice-waf" tabindex="-1"> HTML/WebService/WAF</h2>
<p>到现在我已经说完了图中右边的五大部分，而左边的 HTML、WebService、WAF 等由于与 HTTP 技术上实质关联不太大，所以就简略地介绍一下，不再过多展开。</p>
<p>HTML是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</p>
<p>HTML 目前有两个主要的标准，HTML4 和 HTML5。广义上的 HTML 通常是指 HTML、JavaScript、CSS 等前端技术的组合，能够实现比传统静态页面更丰富的动态页面。</p>
<p>接下来是Web Service，它的名字与 Web Server 很像，但却是一个完全不同的东西。</p>
<p>Web Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，<strong>它是一个基于 Web（HTTP）的服务架构技术</strong>，既可以运行在内网，也可以在适当保护后运行在外网。</p>
<p>因为采用了 HTTP 协议传输数据，所以在 Web Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</p>
<p>WAF是近几年比较“火”的一个词，意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。</p>
<p>WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我详细介绍了与 HTTP 有关系的各种应用技术，在这里简单小结一下要点。</p>
<ol>
<li>互联网上绝大部分资源都使用 HTTP 协议传输；</li>
<li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li>
<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>
<li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>
<li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li>
</ol>
<p>希望通过今天的讲解，你能够更好地理解这些概念，也利于后续的课程学习。</p>
<p>课下作业
你觉得 CDN 在对待浏览器和爬虫时会有差异吗？为什么？
你怎么理解 WebService 与 Web Server 这两个非常相似的词？
欢迎你通过留言分享答案，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/0779e89db8f047e19072f40a97224af2.png" type="image/png"/>
    </item>
    <item>
      <title>04 | HTTP世界全览（下）：与HTTP相关的各种协议</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson04.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson04.html</guid>
      <source url="https://0808200.xyz/rss.xml">04 | HTTP世界全览（下）：与HTTP相关的各种协议</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_04-http世界全览-下-与http相关的各种协议" tabindex="-1"> 04 | HTTP世界全览（下）：与HTTP相关的各种协议</h1>
<p>在上一讲中，我介绍了与 HTTP 相关的浏览器、服务器、CDN、网络爬虫等应用技术。</p>
<p>今天要讲的则是比较偏向于理论的各种 HTTP 相关协议，重点是 TCP/IP、DNS、URI、HTTPS 等，希望能够帮你理清楚它们与 HTTP 的关系。</p>
<p>同样的，我还是画了一张详细的思维导图，你可以点击后仔细查看。</p>
<p><img src="https://img-blog.csdnimg.cn/022b0f32d670459890ab06d55a32d958.png" alt=""></p>
<h2 id="tcp-ip" tabindex="-1"> TCP/IP</h2>
<p>TCP/IP 协议是目前网络世界“事实上”的标准通信协议，即使你没有用过也一定听说过，因为它太著名了。</p>
<p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是<code>TCP</code>和<code>IP</code>，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<p>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：<code>TCP 属于“传输层”，IP 属于“网际层”</code>。协议的层级关系模型非常重要，我会在下一讲中再专门讲解，这里先暂时放一放。</p>
<p>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。</p>
<p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。</p>
<p>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<code>可靠的、字节流</code>形式的通信，是 HTTP 协议得以实现的基础。</p>
<p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p>
<p>在第 2 讲时我曾经说过，HTTP 是一个&quot;传输协议&quot;，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“<strong>HTTP over TCP/IP</strong>”。</p>
<h2 id="dns" tabindex="-1"> DNS</h2>
<p>在 TCP/IP 协议中使用 IP 地址来标识计算机，数字形式的地址对于计算机来说是方便了，但对于人类来说却既难以记忆又难以输入。</p>
<p>于是“<code>域名系统”（Domain Name System）</code>出现了，用有意义的名字来作为 IP 地址的等价替代。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？</p>
<p>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</p>
<p>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“www.12306.cn”。</p>
<p>但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“<code>域名解析</code>”。</p>
<p>继续用刚才的打电话做个比喻，你想要打电话给小明，但不知道电话号码，就得在手机里的号码簿里一项一项地找，直到找到小明那一条记录，然后才能查到号码。这里的“小明”就相当于域名，而“电话号码”就相当于 IP 地址，这个查找的过程就是域名解析。</p>
<p>域名解析的实际操作要比刚才的例子复杂很多，因为互联网上的电脑实在是太多了。目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。</p>
<p>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p>
<h2 id="uri-url" tabindex="-1"> URI/URL</h2>
<p>有了 TCP/IP 和 DNS，是不是我们就可以任意访问网络上的资源了呢？</p>
<p>还不行，DNS 和 IP 地址只是标记了互联网上的主机，但主机上有那么多文本、图片、页面，到底要找哪一个呢？就像小明管理了一大堆文档，你怎么告诉他是哪个呢？</p>
<p>所以就出现了 URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>
<p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p>
<p>我就拿 Nginx 网站来举例，看一下 URI 是什么样子的。</p>
<div><pre><code>http://nginx.org/en/download.html
</code></pre><div aria-hidden="true"><div></div></div></div><p>你可以看到，URI 主要有三个基本的部分构成：</p>
<ol>
<li>协议名：即访问该资源应当使用的协议，在这里是“http”；</li>
<li>主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</li>
<li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</li>
</ol>
<p>还是用打电话来做比喻，你通过电话簿找到了小明，让他把昨天做好的宣传文案快递过来。那么这个过程中你就完成了一次 URI 资源访问，“小明”就是“主机名”，“昨天做好的宣传文案”就是“路径”，而“快递”，就是你要访问这个资源的“协议名”。</p>
<h2 id="https" tabindex="-1"> HTTPS</h2>
<p>在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地穿梭在互联网世界里，顺利地访问任意的网页了，真的是“好生快活”。</p>
<p>但且慢，互联网上不仅有“美女”，还有很多的“野兽”。</p>
<p>假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。</p>
<p>有没有什么办法能够防止这种情况的发生呢？确实有。你可以使用“加密”的方法，比如这样打电话：</p>
<blockquote>
<p>你：“喂，小明啊，接下来我们改用火星文通话吧。”<br/>
小明：“好啊好啊，就用火星文吧。”<br/>
你：“巴拉巴拉巴拉巴拉……”<br/>
小明：“巴拉巴拉巴拉巴拉……”</p>
</blockquote>
<p>如果你和小明说的火星文只有你们两个才懂，那么即使窃听到了这段谈话，他也不会知道你们到底在说什么，也就无从破坏你们的通话过程。</p>
<p>HTTPS 就相当于这个比喻中的“火星文”，它的全称是“<code>HTTP over SSL/TLS</code>”，也就是运行在 SSL/TLS 协议上的 HTTP。</p>
<p>注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。</p>
<p>因为 HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，其中的“HTTP”和“TCP/IP”我们都已经明白了，只要再了解一下 SSL/TLS，HTTPS 也就能够轻松掌握。</p>
<p>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</p>
<p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>
<p>你可以在今后上网时留心看一下浏览器地址栏，如果有一个小锁头标志，那就表明网站启用了安全的 HTTPS 协议，而 URI 里的协议名，也从“http”变成了“https”。</p>
<h2 id="代理" tabindex="-1"> 代理</h2>
<p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</p>
<p>代理有很多的种类，常见的有：</p>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li>
<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>
</ol>
<p>上一讲提到的 CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>
<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</p>
<ol>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩、加密等额外的功能。</li>
</ol>
<p>关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订，但并不是 RFC 标准，我也会在之后的课程里专门讲解。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>这次我介绍了与 HTTP 相关的各种协议，在这里简单小结一下今天的内容。</p>
<ol>
<li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>
<li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</li>
<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>
<li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；</li>
<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>
</ol>
<p>经过这两讲的学习，相信你应该对 HTTP 有了一个比较全面的了解，虽然还不是很深入，但已经为后续的学习扫清了障碍。</p>
<p>课下作业
DNS 与 URI 有什么关系？
在讲代理时我特意没有举例说明，你能够用引入一个“小强”的角色，通过打电话来比喻一下吗？
欢迎你通过留言分享答案，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/022b0f32d670459890ab06d55a32d958.png" type="image/png"/>
    </item>
    <item>
      <title>05 | 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson05.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson05.html</guid>
      <source url="https://0808200.xyz/rss.xml">05 | 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_05-常说的-四层-和-七层-到底是什么-五层-六层-哪去了" tabindex="-1"> 05 | 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？</h1>
<p>在上一讲中，我简单提到了 TCP/IP 协议，它是 HTTP 协议的下层协议，负责具体的数据传输工作。并且还特别说了，TCP/IP 协议是一个“<strong>有层次的协议栈</strong>”。</p>
<p>在工作中你一定经常听别人谈起什么“四层负载均衡”“七层负载均衡”，什么“二层转发”“三层路由”，那么你真正理解这些层次的含义吗？</p>
<p>网络分层的知识教科书上都有，但很多都是“泛泛而谈”，只有“学术价值”，于是就容易和实际应用“脱节”，造成的后果就是“似懂非懂”，真正用的时候往往会“一头雾水”。</p>
<p>所以，今天我就从 HTTP 应用的角度，帮你把这些模糊的概念弄清楚。</p>
<h2 id="tcp-ip-网络分层模型" tabindex="-1"> TCP/IP 网络分层模型</h2>
<p>还是先从 TCP/IP 协议开始讲起，一是因为它非常经典，二是因为它是目前事实上的网络通信标准，研究它的实用价值最大。</p>
<p>TCP/IP 当初的设计者真的是非常聪明，创造性地提出了“分层”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。</p>
<p>你应该对 TCP/IP 的协议栈有所了解吧，这里我再贴一下层次图。</p>
<p><img src="https://img-blog.csdnimg.cn/5eb1cea25e674393b9850c3950d355a3.png" alt=""></p>
<p>TCP/IP 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。</p>
<p>我们来仔细地看一下这个精巧的积木架构，注意它的层次顺序是“从下往上”数的，所以第一层就是最下面的一层。</p>
<p>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>
<p>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>
<p>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>
<p>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</p>
<p>关于 TCP 和 UDP 可以展开讨论的话题还有很多，比如最经典的“三次握手”和“四次挥手”，一时半会很难说完，好在与 HTTP 的关系不是太大，以后遇到了再详细讲解。</p>
<p>协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</p>
<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>
<h2 id="osi-网络分层模型" tabindex="-1"> OSI 网络分层模型</h2>
<p>看完 TCP/IP 协议栈，你可能要问了，“它只有四层，那常说的七层怎么没见到呢？”</p>
<p>别着急，这就是今天要说的第二个网络分层模型：OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。</p>
<p>TCP/IP 发明于 1970 年代，当时除了它还有很多其他的网络协议，整个网络世界比较混乱。</p>
<p>这个时候国际标准组织（ISO）注意到了这种现象，感觉“野路子”太多，就想要来个“大一统”。于是设计出了一个新的网络分层模型，想用这个新框架来统一既存的各种网络协议。</p>
<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>
<p><img src="https://img-blog.csdnimg.cn/4f2b42251bdc4885b0d5a0fc0dcc7186.png" alt=""></p>
<p>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
第三层：网络层，相当于 TCP/IP 里的网际层；
第四层：传输层，相当于 TCP/IP 里的传输层；
第五层：会话层，维护网络中的连接状态，即保持会话和同步；
第六层：表示层，把数据转换为合适、可理解的语法和语义；
第七层：应用层，面向具体的应用传输数据。</p>
<p>至此，我们常说的“四层”“七层”就出现了。</p>
<p>不过国际标准组织心里也很清楚，TCP/IP 等协议已经在许多网络上实际运行，再推翻重来是不可能的。所以，OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准，意思就是说，“你们以后该干什么还干什么，我不管，但面子上还是要按照我说的来”。</p>
<p>但 OSI 模型也是有优点的。对比一下就可以看出，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。</p>
<p>还有一个重要的形式上的优点：OSI 为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。显然，在交流的时候说“七层”要比“应用层”更简单快捷，特别是英文，对比一下“Layer seven”与“application layer”。</p>
<p>综合以上几点，在 OSI 模型之后，“四层”“七层”这样的说法就逐渐流行开了。不过在实际工作中你一定要注意，这种说法只是“理论上”的层次，并不是与现实完全对应。</p>
<h2 id="两个分层模型的映射关系" tabindex="-1"> 两个分层模型的映射关系</h2>
<p>现在我们有了两个网络分层模型：TCP/IP 和 OSI，新的问题又出现了，一个是四层模型，一个是七层模型，这两者应该如何互相映射或者说互相解释呢？</p>
<p>好在 OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。</p>
<p><img src="https://img-blog.csdnimg.cn/e5906602044d4c35bd2bea251cf66680.png" alt=""></p>
<p>第一层：物理层，TCP/IP 里无对应；
第二层：数据链路层，对应 TCP/IP 的链接层；
第三层：网络层，对应 TCP/IP 的网际层；
第四层：传输层，对应 TCP/IP 的传输层；
第五、六、七层：统一对应到 TCP/IP 的应用层。</p>
<p>所以你看，这就是“理想与现实”之间的矛盾。理想很美好，有七层，但现实很残酷，只有四层，“多余”的五层、六层就这样“消失”了。</p>
<p>但这也有一定的实际原因。</p>
<p>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</p>
<p>到这里，你应该能够明白一开始那些“某某层”的概念了。</p>
<p>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>
<p>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>
<h2 id="tcp-ip-协议栈的工作方式" tabindex="-1"> TCP/IP 协议栈的工作方式</h2>
<p>TCP/IP 协议栈是如何工作的呢？</p>
<p>你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。</p>
<p>假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。</p>
<p>你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。</p>
<p>接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。</p>
<p>之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。</p>
<p>快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。</p>
<p>这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。</p>
<p>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</p>
<p>接收数据是则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</p>
<p>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</p>
<p>我为这个过程画了一张图，你可以对照着加深理解。</p>
<p><img src="https://img-blog.csdnimg.cn/a459d273a7e14ae88f9273cf35db909e.png" alt=""></p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>这次我们学习了 HTTP 所在的网络分层模型，它是工作中常用的交流语言，在这里简单小结一下今天的内容。</p>
<ol>
<li>TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；</li>
<li>OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；</li>
<li>OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；</li>
<li>日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；</li>
<li>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</li>
</ol>
<p>有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</p>
<p>课下作业
你能用自己的话解释一下“二层转发”“三层路由”吗？
你认为上一讲中的 DNS 协议位于哪一层呢？
你认为 CDN 工作在那一层呢？
欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/5eb1cea25e674393b9850c3950d355a3.png" type="image/png"/>
    </item>
    <item>
      <title>06 | 域名里有哪些门道？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson06.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson06.html</guid>
      <source url="https://0808200.xyz/rss.xml">06 | 域名里有哪些门道？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_06-域名里有哪些门道" tabindex="-1"> 06 | 域名里有哪些门道？</h1>
<p>在上一讲里，我们学习了 HTTP 协议使用的 TCP/IP 协议栈，知道了 HTTP 协议是运行在 TCP/IP 上的。</p>
<p>IP 协议的职责是“网际互连”，它在 MAC 层之上，使用 IP 地址把 MAC 编号转换成了四位数字，这就对物理网卡的 MAC 地址做了一层抽象，发展出了许多的“新玩法”。</p>
<p>例如，分为 A、B、C、D、E 五种类型，公有地址和私有地址，掩码分割子网等。只要每个小网络在 IP 地址这个概念上达成一致，不管它在 MAC 层有多大的差异，都可以接入 TCP/IP 协议栈，最终汇合进整个互联网。</p>
<p>但接入互联网的计算机越来越多，IP 地址的缺点也就暴露出来了，最主要的是它“对人不友好”，虽然比 MAC 的 16 进制数要好一点，但还是难于记忆和输入。</p>
<p>怎么解决这个问题呢？</p>
<p>那就“以其人之道还治其人之身”，在 IP 地址之上再来一次抽象，把数字形式的 IP 地址转换成更有意义更好记的名字，在字符串的层面上再增加“新玩法”。于是，DNS 域名系统就这么出现了。</p>
<h2 id="域名的形式" tabindex="-1"> 域名的形式</h2>
<p>在第 4 讲曾经说过，域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</p>
<p>最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。</p>
<p>看一下极客时间的域名“time.geekbang.org”，这里的“org”就是顶级域名，“geekbang”是二级域名，“time”则是主机名。使用这个域名，DNS 就会把它转换成相应的 IP 地址，你就可以访问极客时间的网站了。</p>
<p>域名不仅能够代替 IP 地址，还有许多其他的用途。</p>
<p>在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：</p>
<div><pre><code>server {
    listen 80;                       # 监听 80 端口
    server_name  time.geekbang.org;  # 主机名是 time.geekbang.org
    ...
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>域名本质上还是个名字空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识。</p>
<p>举个例子吧，假设 A 公司里有个小明，B 公司里有个小强，于是他们就可以分别说是“小明.A 公司”，“小强.B 公司”，即使 B 公司里也有个小明也不怕，可以标记为“小明.B 公司”，很好地解决了重名问题。</p>
<p>因为这个特性，域名也被扩展到了其他应用领域，比如 Java 的包机制就采用域名作为命名空间，只是它使用了反序。如果极客时间要开发 Java 应用，那么它的包名可能就是“org.geekbang.time”。</p>
<p>而 XML 里使用 URI 作为名字空间，也是间接使用了域名。</p>
<h2 id="域名的解析" tabindex="-1"> 域名的解析</h2>
<p>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。</p>
<p>目前全世界有几亿个站点，有几十亿网民，而每天网络上发生的 HTTP 流量更是天文数字。这些请求绝大多数都是基于域名来访问网站的，所以 DNS 就成了互联网的重要基础设施，必须要保证域名解析稳定可靠、快速高效。</p>
<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>
<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/a6cc6a54265b47b8949efb27e419d2ce.png" alt=""></p>
<p>在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。</p>
<p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>
<p>例如，你要访问“www.apple.com”，就要进行下面的三次查询：</p>
<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</li>
</ol>
<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>
<p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。</p>
<p>首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>
<p>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>
<p>其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>
<p>另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p>
<p>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作就都不用“跋山涉水”了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了。</p>
<p>下面的这张图比较完整地表示了现在的 DNS 架构。</p>
<p><img src="https://img-blog.csdnimg.cn/6ce628ba3353409f8cb43e9699b37941.png" alt=""></p>
<p>在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。</p>
<div><pre><code>resolver 8.8.8.8 valid=30s;  # 指定 Google 的 DNS，缓存 30 秒
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="域名的-新玩法" tabindex="-1"> 域名的“新玩法”</h2>
<p>有了域名，又有了可以稳定工作的解析系统，于是我们就可以实现比 IP 地址更多的“新玩法”了。</p>
<p>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</p>
<p>比如，你有一台“buy.tv”的服务器要临时停机维护，那你就可以通知 DNS 服务器：“我这个 buy.tv 域名的地址变了啊，原先是 1.2.3.4，现在是 5.6.7.8，麻烦你改一下。”DNS 于是就修改内部的 IP 地址映射关系，之后再有访问 buy.tv 的请求就不走 1.2.3.4 这台主机，改由 5.6.7.8 来处理，这样就可以保证业务服务不中断。</p>
<p>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</p>
<p>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。</p>
<p>这种“玩法”也有两种方式，两种方式可以混用。</p>
<p>第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</p>
<p>第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</p>
<p>前面我们说的都是可信的 DNS，如果有一些不怀好意的 DNS，那么它也可以在域名这方面“做手脚”，弄一些比较“恶意”的“玩法”，举两个例子：</p>
<ul>
<li>“域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；</li>
<li>“域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。</li>
</ul>
<p>好在互联网上还是好人多，而且 DNS 又是互联网的基础设施，这些“恶意 DNS”并不多见，你上网的时候不需要太过担心。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>这次我们学习了与 HTTP 协议有重要关系的域名和 DNS，在这里简单小结一下今天的内容：</p>
<ol>
<li>域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；</li>
<li>DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；</li>
<li>DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；</li>
<li>使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。</li>
</ol>
<p>课下作业
在浏览器地址栏里随便输入一个不存在的域名，比如就叫“www. 不存在.com”，试着解释一下它的 DNS 解析过程。
如果因为某些原因，DNS 失效或者出错了，会出现什么后果？
欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/a6cc6a54265b47b8949efb27e419d2ce.png" type="image/png"/>
    </item>
    <item>
      <title>07 | 自己动手，搭建HTTP实验环境</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson07.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/2_ice/lesson07.html</guid>
      <source url="https://0808200.xyz/rss.xml">07 | 自己动手，搭建HTTP实验环境</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_07-自己动手-搭建http实验环境" tabindex="-1"> 07 | 自己动手，搭建HTTP实验环境</h1>
<p>这一讲是“破冰篇”的最后一讲，我会先简单地回顾一下之前的内容，然后在 Windows 系统上实际操作，用几个应用软件搭建出一个“最小化”的 HTTP 实验环境，方便后续的“基础篇”“进阶篇”“安全篇”的学习。</p>
<h2 id="破冰篇-回顾" tabindex="-1"> “破冰篇”回顾</h2>
<p>HTTP 协议诞生于 30 年前，设计之初的目的是用来传输纯文本数据。但由于形式灵活，搭配 URI、HTML 等技术能够把互联网上的资源都联系起来，构成一个复杂的超文本系统，让人们自由地获取信息，所以得到了迅猛发展。</p>
<p>HTTP 有多个版本，目前应用的最广泛的是 HTTP/1.1，它几乎可以说是整个互联网的基石。但 HTTP/1.1 的性能难以满足如今的高流量网站，于是又出现了 HTTP/2 和 HTTP/3。不过这两个新版本的协议还没有完全推广开。在可预见的将来，HTTP/1.1 还会继续存在下去。</p>
<p>HTTP 翻译成中文是“超文本传输协议”，是一个应用层的协议，通常基于 TCP/IP，能够在网络的任意两点之间传输文字、图片、音频、视频等数据。</p>
<p>HTTP 协议中的两个端点称为<strong>请求方和应答方</strong>。请求方通常就是 Web 浏览器，也叫 user agent，应答方是 Web 服务器，存储着网络上的大部分静态或动态的资源。</p>
<p>在浏览器和服务器之间还有一些“中间人”的角色，如 CDN、网关、代理等，它们也同样遵守 HTTP 协议，可以帮助用户更快速、更安全地获取资源。</p>
<p>HTTP 协议不是一个孤立的协议，需要下层很多其他协议的配合。最基本的是 TCP/IP，实现寻址、路由和可靠的数据传输，还有 DNS 协议实现对互联网上主机的定位查找。</p>
<p>对 HTTP 更准确的称呼是“HTTP over TCP/IP”，而另一个“HTTP over SSL/TLS”就是增加了安全功能的 HTTPS。</p>
<h2 id="软件介绍" tabindex="-1"> 软件介绍</h2>
<p>常言道“实践出真知”，又有俗语“光说不练是假把式”。要研究 HTTP 协议，最好有一个实际可操作、可验证的环境，通过实际的数据、现象来学习，肯定要比单纯的“动嘴皮子”效果要好的多。</p>
<p>现成的环境当然有，只要能用浏览器上网，就会有 HTTP 协议，就可以进行实验。但现实的网络环境又太复杂了，有很多无关的干扰因素，这些“噪音”会“淹没”真正有用的信息。</p>
<p>所以，我给你的建议是：搭建一个“最小化”的环境，在这个环境里仅有 HTTP 协议的两个端点：请求方和应答方，去除一切多余的环节，从而可以抓住重点，快速掌握 HTTP 的本质。</p>
<p><img src="https://img-blog.csdnimg.cn/5686b7e5321d45589305801efba25490.png" alt=""></p>
<p>简单说一下这个“最小化”环境用到的应用软件：</p>
<ul>
<li>Wireshark</li>
<li>Chrome/Firefox</li>
<li>Telnet</li>
<li>OpenResty</li>
</ul>
<p><strong>Wireshark</strong>是著名的网络抓包工具，能够截获在 TCP/IP 协议栈中传输的所有流量，并按协议类型、地址、端口等任意过滤，功能非常强大，是学习网络协议的必备工具。</p>
<p>它就像是网络世界里的一台“高速摄像机”，把只在一瞬间发生的网络传输过程如实地“拍摄”下来，事后再“慢速回放”，让我们能够静下心来仔细地分析那一瞬到底发生了什么。</p>
<p><strong>Chrome</strong>是 Google 开发的浏览器，是目前的主流浏览器之一。它不仅上网方便，也是一个很好的调试器，对 HTTP/1.1、HTTPS、HTTP/2、QUIC 等的协议都支持得非常好，用 F12 打开“开发者工具”还可以非常详细地观测 HTTP 传输全过程的各种数据。</p>
<p>如果你更习惯使用Firefox，那也没问题，其实它和 Chrome 功能上都差不太多，选择自己喜欢的就好。</p>
<p>与 Wireshark 不同，Chrome 和 Firefox 属于“事后诸葛亮”，不能观测 HTTP 传输的过程，只能看到结果。</p>
<p><strong>Telnet</strong>是一个经典的虚拟终端，基于 TCP 协议远程登录主机，我们可以使用它来模拟浏览器的行为，连接服务器后手动发送 HTTP 请求，把浏览器的干扰也彻底排除，能够从最原始的层面去研究 HTTP 协议。</p>
<p><strong>OpenResty</strong>你可能比较陌生，它是基于 Nginx 的一个“强化包”，里面除了 Nginx 还有一大堆有用的功能模块，不仅支持 HTTP/HTTPS，还特别集成了脚本语言 Lua 简化 Nginx 二次开发，方便快速地搭建动态网关，更能够当成应用容器来编写业务逻辑。</p>
<p>选择 OpenResty 而不直接用 Nginx 的原因是它相当于 Nginx 的“超集”，功能更丰富，安装部署更方便。我也会用 Lua 编写一些服务端脚本，实现简单的 Web 服务器响应逻辑，方便实验。</p>
<h2 id="安装过程" tabindex="-1"> 安装过程</h2>
<p>这个“最小化”环境的安装过程也比较简单，大约只需要你半个小时不到的时间就能搭建完成。</p>
<p>我在 GitHub 上为本专栏开了一个项目：<a href="https://github.com/chronolaw/http_study.git" target="_blank" rel="noopener noreferrer">http_study</a>，可以直接用“git clone”下载，或者去 Release 页面，下载打好的<a href="https://github.com/chronolaw/http_study/releases" target="_blank" rel="noopener noreferrer">压缩包</a>。</p>
<p>我使用的操作环境是 Windows 10，如果你用的是 Mac 或者 Linux，可以用 VirtualBox 等虚拟机软件安装一个 Windows 虚拟机，再在里面操作。</p>
<p>首先你要获取最新的 http_study 项目源码，假设 clone 或解压的目录是“D:\http_study”，操作完成后大概是下图这个样子。</p>
<p><img src="https://img-blog.csdnimg.cn/4d9226ee77494702989fb18c247253cf.png" alt=""></p>
<p>Chrome 和 WireShark 的安装比较简单，一路按“下一步”就可以了。版本方面使用最新的就好，我的版本可能不是最新的，Chrome 是 73，WireShark 是 3.0.0。</p>
<p>Windows 10 自带 Telnet，不需要安装，但默认是不启用的，需要你稍微设置一下。</p>
<p>打开 Windows 的设置窗口，搜索“Telnet”，就会找到“启用或关闭 Windows 功能”，在这个窗口里找到“Telnet 客户端”，打上对钩就可以了，可以参考截图。</p>
<p><img src="https://img-blog.csdnimg.cn/a5458cc2128d4ef7b15553db3a75bb11.png" alt=""></p>
<p>接下来我们要安装 OpenResty，去它的<a href="http://openresty.org/" target="_blank" rel="noopener noreferrer">官网</a>，点击左边栏的“Download”，进入下载页面，下载适合你系统的版本（这里我下载的是 64 位的 1.15.8.1，包的名字是“openresty-1.15.8.1-win64.zip”）。</p>
<p><img src="https://img-blog.csdnimg.cn/cab9e1024ebc4bffa41de3729c274190.png" alt=""></p>
<p>然后要注意，你必须把 OpenResty 的压缩包解压到刚才的“D:\http_study”目录里，并改名为“openresty”。</p>
<p><img src="https://img-blog.csdnimg.cn/168b2eba2beb4bff9d403e91115134f1.png" alt=""></p>
<p>安装工作马上就要完成了，为了能够让浏览器能够使用 DNS 域名访问我们的实验环境，还要改一下本机的 hosts 文件，位置在“C:\WINDOWS\system32\drivers\etc”，在里面添加三行本机 IP 地址到测试域名的映射，你也可以参考 GitHub 项目里的 hosts 文件，这就相当于在一台物理实机上“托管”了三个虚拟主机。</p>
<div><pre><code>127.0.0.1       www.chrono.com
127.0.0.1       www.metroid.net
127.0.0.1       origin.io
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>注意修改 hosts 文件需要管理员权限，直接用记事本编辑是不行的，可以切换管理员身份，或者改用其他高级编辑器，比如 Notepad++，而且改之前最好做个备份。</p>
<p>到这里，我们的安装工作就完成了！之后你就可以用 Wireshark、Chrome、Telnet 在这个环境里随意“折腾”，弄坏了也不要紧，只要把目录删除，再来一遍操作就能复原。</p>
<h2 id="测试验证" tabindex="-1"> 测试验证</h2>
<p>实验环境搭建完了，但还需要把它运行起来，做一个简单的测试验证，看是否运转正常。</p>
<p>首先我们要启动 Web 服务器，也就是 OpenResty。</p>
<p>在 http_study 的“www”目录下有四个批处理文件，分别是：</p>
<p><img src="https://img-blog.csdnimg.cn/69433298659a4d90a36b75dc69d3248d.png" alt=""></p>
<ul>
<li>start：启动 OpenResty 服务器；</li>
<li>stop：停止 OpenResty 服务器；</li>
<li>reload：重启 OpenResty 服务器；</li>
<li>list：列出已经启动的 OpenResty 服务器进程。</li>
</ul>
<p>使用鼠标双击“start”批处理文件，就会启动 OpenResty 服务器在后台运行，这个过程可能会有 Windows 防火墙的警告，选择“允许”即可。</p>
<p>运行后，鼠标双击“list”可以查看 OpenResty 是否已经正常启动，应该会有两个 nginx.exe 的后台进程，大概是下图的样子。</p>
<p><img src="https://img-blog.csdnimg.cn/e4f6712980ab4206b71c6c1468d3c402.png" alt=""></p>
<p>有了 Web 服务器后，接下来我们要运行 Wireshark，开始抓包。</p>
<p>因为我们的实验环境运行在本机的 127.0.0.1 上，也就是 loopback“环回”地址。所以，在 Wireshark 里要选择“Npcap loopback Adapter”，过滤器选择“HTTP TCP port(80)”，即只抓取 HTTP 相关的数据包。鼠标双击开始界面里的“Npcap loopback Adapter”即可开始抓取本机上的网络数据。</p>
<p><img src="https://img-blog.csdnimg.cn/31f97bd688924c7d91684fe97a80a3bb.png" alt=""></p>
<p>然后我们打开 Chrome，在地址栏输入“http://localhost/”，访问刚才启动的 OpenResty 服务器，就会看到一个简单的欢迎界面，如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/c611ccd056054819b04986e7f6b58d46.png" alt=""></p>
<p>这时再回头去看 Wireshark，应该会显示已经抓到了一些数据，就可以用鼠标点击工具栏里的“停止捕获”按钮告诉 Wireshark“到此为止”，不再继续抓包。</p>
<p><img src="https://img-blog.csdnimg.cn/fa0c7431a6374fffbeb2e609914ed588.png" alt=""></p>
<p>至于这些数据是什么，表示什么含义，我会在下一讲再详细介绍。</p>
<p>如果你能够在自己的电脑上走到这一步，就说明“最小化”的实验环境已经搭建成功了，不要忘了实验结束后运行批处理“stop”停止 OpenResty 服务器。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>这次我们学习了如何在自己的电脑上搭建 HTTP 实验环境，在这里简单小结一下今天的内容。</p>
<ul>
<li>现实的网络环境太复杂，有很多干扰因素，搭建“最小化”的环境可以快速抓住重点，掌握 HTTP 的本质；</li>
<li>我们选择 Wireshark 作为抓包工具，捕获在 TCP/IP 协议栈中传输的所有流量；</li>
<li>我们选择 Chrome 或 Firefox 浏览器作为 HTTP 协议中的 user agent；</li>
<li>我们选择 OpenResty 作为 Web 服务器，它是一个 Nginx 的“强化包”，功能非常丰富；</li>
<li>Telnet 是一个命令行工具，可用来登录主机模拟浏览器操作；</li>
<li>在 GitHub 上可以下载到本专栏的专用项目源码，只要把 OpenResty 解压到里面即可完成实验环境的搭建。</li>
</ul>
<p>课下作业</p>
<ol>
<li>
<p>按照今天所学的，在你自己的电脑上搭建出这个 HTTP 实验环境并测试验证。</p>
</li>
<li>
<p>由于篇幅所限，我无法详细介绍 Wireshark，你有时间可以再上网搜索 Wireshark 相关的资料，了解更多的用法。</p>
</li>
</ol>
<p>欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/5686b7e5321d45589305801efba25490.png" type="image/png"/>
    </item>
    <item>
      <title>08 | 键入网址再按下回车，后面究竟发生了什么？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson08.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson08.html</guid>
      <source url="https://0808200.xyz/rss.xml">08 | 键入网址再按下回车，后面究竟发生了什么？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_08-键入网址再按下回车-后面究竟发生了什么" tabindex="-1"> 08 | 键入网址再按下回车，后面究竟发生了什么？</h1>
<p>经过上一讲的学习，你是否已经在自己的电脑上搭建好了“最小化”的 HTTP 实验环境呢？</p>
<p>我相信你的答案一定是“Yes”，那么，让我们立刻开始“螺蛳壳里做道场”，在这个实验环境里看一下 HTTP 协议工作的全过程。</p>
<h2 id="使用-ip-地址访问-web-服务器" tabindex="-1"> 使用 IP 地址访问 Web 服务器</h2>
<p>首先我们运行 www 目录下的“start”批处理程序，启动本机的 OpenResty 服务器，启动后可以用“list”批处理确认服务是否正常运行。</p>
<p>然后我们打开 Wireshark，选择“HTTP TCP port(80)”过滤器，再鼠标双击“Npcap loopback Adapter”，开始抓取本机 127.0.0.1 地址上的网络数据。</p>
<p>第三步，在 Chrome 浏览器的地址栏里输入“http://127.0.0.1/”，再按下回车键，等欢迎页面显示出来后 Wireshark 里就会有捕获的数据包，如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/a8fcb947f26f47d4830d7d31a2161df1.png" alt=""></p>
<p>如果你还没有搭好实验环境，或者捕获与本文里的不一致也没关系。我把这次捕获的数据存成了 pcap 包，文件名是“08-1”，放到了 GitHub 上，你可以下载到本地后再用 Wireshark 打开，完全精确“重放”刚才的 HTTP 传输过程。</p>
<h2 id="抓包分析" tabindex="-1"> 抓包分析</h2>
<p>在 Wireshark 里你可以看到，这次一共抓到了 11 个包（这里用了滤包功能，滤掉了 3 个包，原本是 14 个包），耗时 0.65 秒，下面我们就来一起分析一下&quot;键入网址按下回车&quot;后数据传输的全过程。</p>
<p>通过前面“破冰篇”的讲解，你应该知道 HTTP 协议是运行在 TCP/IP 基础上的，依靠 TCP/IP 协议来实现数据的可靠传输。所以浏览器要用 HTTP 协议收发数据，<code>首先要做的就是建立 TCP 连接</code>。</p>
<p>因为我们在地址栏里直接输入了 IP 地址“127.0.0.1”，而 Web 服务器的默认端口是 80，所以浏览器就要依照 TCP 协议的规范，使用“三次握手”建立与 Web 服务器的连接。</p>
<p>对应到 Wireshark 里，就是最开始的三个抓包，浏览器使用的端口是 52085，服务器使用的端口是 80，经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</p>
<p>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文，也就是 Wireshark 里的第四个包。至于包的内容具体是什么现在先不用管，我们下一讲再说。</p>
<p>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</p>
<p>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。</p>
<p>它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。这就是 Wireshark 里的第六个包“HTTP/1.1 200 OK”，底层走的还是 TCP 协议。</p>
<p>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢。”，即第七个包。</p>
<p>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</p>
<p>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。但因为我们的实验环境没有这个文件，所以服务器在硬盘上找不到，返回了一个“404 Not Found”。</p>
<p>至此，“键入网址再按下回车”的全过程就结束了。</p>
<p>我为这个过程画了一个交互图，你可以对照着看一下。不过要提醒你，图里 TCP 关闭连接的“四次挥手”在抓包里没有出现，这是因为 HTTP/1.1 长连接特性，默认不会立即关闭连接。</p>
<p><img src="https://img-blog.csdnimg.cn/cbe73620d5494678b124cf267d55182a.png" alt=""></p>
<p>再简要叙述一下这次最简单的浏览器 HTTP 请求过程：</p>
<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>
<h2 id="使用域名访问-web-服务器" tabindex="-1"> 使用域名访问 Web 服务器</h2>
<p>刚才我们是在浏览器地址栏里直接输入 IP 地址，但绝大多数情况下，我们是不知道服务器 IP 地址的，使用的是域名，那么改用域名后这个过程会有什么不同吗？</p>
<p>还是实际动手试一下吧，把地址栏的输入改成“http://www.Chrono.com”，重复 Wireshark 抓包过程，你会发现，好像没有什么不同，浏览器上同样显示出了欢迎界面，抓到的包也同样是 11 个：先是三次握手，然后是两次 HTTP 传输。</p>
<p>这里就出现了一个问题：浏览器是如何从网址里知道“www.Chrono.com”的 IP 地址就是“127.0.0.1”的呢？</p>
<p>还记得我们之前讲过的 DNS 知识吗？浏览器看到了网址里的“www.Chrono.com”，发现它不是数字形式的 IP 地址，那就肯定是域名了，于是就会发起域名解析动作，通过访问一系列的域名解析服务器，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址。</p>
<p>不过因为域名解析的全过程实在是太复杂了，如果每一个域名都要大费周折地去网上查一下，那我们上网肯定会慢得受不了。</p>
<p>所以，在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，也就是上一讲中我们修改的“C:\WINDOWS\system32\drivers\etc\hosts”。</p>
<p>刚好，里面有一行映射关系“127.0.0.1 www.Chrono.com”，于是浏览器就知道了域名对应的 IP 地址，就可以愉快地建立 TCP 连接发送 HTTP 请求了。</p>
<p>我把这个过程也画出了一张图，但省略了 TCP/IP 协议的交互部分，里面的浏览器多出了一个访问 hosts 文件的动作，也就是本机的 DNS 解析。</p>
<p><img src="https://img-blog.csdnimg.cn/c66027ad3c58469ba80b877757bc5788.png" alt=""></p>
<h2 id="真实的网络世界" tabindex="-1"> 真实的网络世界</h2>
<p>通过上面两个在“最小化”环境里的实验，你是否已经对 HTTP 协议的工作流程有了基本的认识呢？</p>
<p>第一个实验是最简单的场景，只有两个角色：浏览器和服务器，浏览器可以直接用 IP 地址找到服务器，两者直接建立 TCP 连接后发送 HTTP 报文通信。</p>
<p>第二个实验在浏览器和服务器之外增加了一个 DNS 的角色，浏览器不知道服务器的 IP 地址，所以必须要借助 DNS 的域名解析功能得到服务器的 IP 地址，然后才能与服务器通信。</p>
<p>真实的互联网世界要比这两个场景要复杂的多，我利用下面的这张图来做一个详细的说明。</p>
<p><img src="https://img-blog.csdnimg.cn/6ace94ea7afa4882a0db378265aea908.png" alt=""></p>
<p>如果你用的是电脑台式机，那么你可能会使用带水晶头的双绞线连上网口，由交换机接入固定网络。如果你用的是手机、平板电脑，那么你可能会通过蜂窝网络、WiFi，由电信基站、无线热点接入移动网络。</p>
<p>接入网络的同时，网络运行商会给你的设备分配一个 IP 地址，这个地址可能是静态分配的，也可能是动态分配的。静态 IP 就始终不变，而动态 IP 可能你下次上网就变了。</p>
<p>假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用域名“www.apple.com”访问，那么接下来要做的必然是域名解析。这就要用 DNS 协议开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间有缓存，可能不会费太多时间就能拿到结果。</p>
<p>别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</p>
<p>因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。</p>
<p>由 PHP、Java 等后台服务动态生成的页面属于“动态资源”，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的“漫长跋涉”，经过无数的路由器、网关、代理，最后到达目的地。</p>
<p>目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</p>
<p>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</p>
<p>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</p>
<p>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</p>
<p>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们在本机的环境里做了两个简单的实验，学习了 HTTP 协议请求 - 应答的全过程，在这里做一个小结。</p>
<ul>
<li>HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；</li>
<li>如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；</li>
<li>建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；</li>
<li>为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作；</li>
<li>虽然现实中的 HTTP 传输过程非常复杂，但理论上仍然可以简化成实验里的“两点”模型。</li>
</ul>
<p>课下作业
你能试着解释一下在浏览器里点击页面链接后发生了哪些事情吗？
这一节课里讲的都是正常的请求处理流程，如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？
欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/a8fcb947f26f47d4830d7d31a2161df1.png" type="image/png"/>
    </item>
    <item>
      <title>09 | HTTP报文是什么样子的？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson09.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson09.html</guid>
      <source url="https://0808200.xyz/rss.xml">09 | HTTP报文是什么样子的？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_09-http报文是什么样子的" tabindex="-1"> 09 | HTTP报文是什么样子的？</h1>
<p>在上一讲里，我们在本机的最小化环境了做了两个 HTTP 协议的实验，使用 Wireshark 抓包，弄清楚了 HTTP 协议基本工作流程，也就是“请求 - 应答”“一发一收”的模式。</p>
<p>可以看到，HTTP 的工作模式是非常简单的，由于 TCP/IP 协议负责底层的具体传输工作，HTTP 协议基本上不用在这方面操心太多。单从这一点上来看，所谓的“超文本传输协议”其实并不怎么管“传输”的事情，有点“名不副实”。</p>
<p>那么 HTTP 协议的核心部分是什么呢？</p>
<p>答案就是它传输的报文内容。</p>
<p>HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。</p>
<p>报文结构
你也许对 TCP/UDP 的报文格式有所了解，拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</p>
<p>有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/ec22b1a46eb046e6b570f529492e564f.png" alt=""></p>
<p>HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“<strong>纯文本</strong>”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。</p>
<p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>
<p>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”，但与“<strong>header</strong>”对应，很多时候就直接称为“<strong>body</strong>”。</p>
<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>
<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>
<p><img src="https://img-blog.csdnimg.cn/ea2d3d8aa78242509bf4700436cda53d.png" alt=""></p>
<p>说到这里，我不由得想起了一部老动画片《大头儿子和小头爸爸》，你看，HTTP 的报文结构像不像里面的“大头儿子”？</p>
<p>报文里的 header 就是“大头儿子”的“大头”，空行就是他的“脖子”，而后面的 body 部分就是他的身体了。</p>
<p>看一下我们之前用 Wireshark 抓的包吧。</p>
<p><img src="https://img-blog.csdnimg.cn/44b144bccb8f476b8fd78cc5c926abc3.png" alt=""></p>
<p>在这个浏览器发出的请求报文里，第一行“GET / HTTP/1.1”就是请求行，而后面的“Host”“Connection”等等都属于 header，报文的最后是一个空白行结束，没有 body。</p>
<p>在很多时候，特别是浏览器发送 GET 请求的时候都是这样，HTTP 报文经常是只有 header 而没 body，相当于只发了一个超级“大头”过来，你可以想象的出来：每时每刻网络上都会有数不清的“大头儿子”在跑来跑去。</p>
<p>不过这个“大头”也不能太大，虽然 HTTP 协议对 header 的大小没有做限制，但各个 Web 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。</p>
<h2 id="请求行" tabindex="-1"> 请求行</h2>
<p>了解了 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是请求行（request line），它简要地描述了<strong>客户端想要如何操作服务器端的资源</strong>。</p>
<p>请求行由三部分构成：</p>
<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>
<p><img src="https://img-blog.csdnimg.cn/11286d042e3e4fcc9a34ac6cc6e500a6.png" alt=""></p>
<p>还是用 Wireshark 抓包的数据来举例：</p>
<div><pre><code>GET / HTTP/1.1
</code></pre><div aria-hidden="true"><div></div></div></div><p>在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</p>
<p>别看请求行就一行，貌似很简单，其实这里面的“讲究”是非常多的，尤其是前面的请求方法和请求目标，组合起来变化多端，后面我还会详细介绍。</p>
<h2 id="状态行" tabindex="-1"> 状态行</h2>
<p>看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是<strong>服务器响应的状态</strong>。</p>
<p>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</p>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/f07b057a9017481caf94992444e5f740.png" alt=""></p>
<p>看一下上一讲里 Wireshark 抓包里的响应报文，状态行是：</p>
<div><pre><code>HTTP/1.1 200 OK
</code></pre><div aria-hidden="true"><div></div></div></div><p>意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</p>
<p>而另一个“GET /favicon.ico HTTP/1.1”的响应报文状态行是：</p>
<div><pre><code>HTTP/1.1 404 Not Found
</code></pre><div aria-hidden="true"><div></div></div></div><p>翻译成人话就是：“抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是 404，接下来的事情你就看着办吧。”</p>
<h2 id="头部字段" tabindex="-1"> 头部字段</h2>
<p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，我画了两个示意图，你可以看一下。</p>
<p><img src="https://img-blog.csdnimg.cn/ca6ed9259db042ef8f4887c0eee49761.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/5f7ec07944014f6e88a3863a11d7b75a.png" alt=""></p>
<p>请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以我把请求头和响应头里的字段放在一起介绍。</p>
<p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</p>
<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>
<p>不过使用头字段需要注意下面几点：</p>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
</ol>
<p>我在实验环境里用 Lua 编写了一个小服务程序，URI 是“/09-1”，效果是输出所有的请求头。</p>
<p>你可以在实验环境里用 Telnet 连接 OpenResty 服务器试一下，手动发送 HTTP 请求头，试验各种正确和错误的情况。</p>
<p>先启动 OpenResty 服务器，然后用组合键“Win+R”运行 telnet，输入命令“open www.chrono.com 80”，就连上了 Web 服务器。</p>
<p><img src="https://img-blog.csdnimg.cn/92721b649a1b4e85ae9cf45c89b5d108.png" alt=""></p>
<p>连接上之后按组合键“CTRL+]”，然后按回车键，就进入了编辑模式。在这个界面里，你可以直接用鼠标右键粘贴文本，敲两下回车后就会发送数据，也就是模拟了一次 HTTP 请求。</p>
<p>下面是两个最简单的 HTTP 请求，第一个在“:”后有多个空格，第二个在“:”前有空格。</p>
<div><pre><code>GET /09-1 HTTP/1.1
Host:   www.chrono.com
 
 
GET /09-1 HTTP/1.1
Host : www.chrono.com
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>第一个可以正确获取服务器的响应报文，而第二个得到的会是一个“400 Bad Request”，表示请求报文格式有误，服务器无法正确处理：</p>
<div><pre><code>HTTP/1.1 400 Bad Request
Server: openresty/1.15.8.1
Connection: close
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="常用头字段" tabindex="-1"> 常用头字段</h2>
<p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>
<p>对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。</p>
<p>后续的课程中我将会以应用领域为切入点介绍连接管理、缓存控制等头字段，今天先讲几个最基本的头，看完了它们你就应该能够读懂大多数 HTTP 报文了。</p>
<p>首先要说的是Host字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。</p>
<p>Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p>
<p>例如我们的试验环境，在 127.0.0.1 上有三个虚拟主机：“www.chrono.com”“www.metroid.net”和“origin.io”。那么当使用域名的方式访问时，就必须要用 Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理。</p>
<p><strong>User-Agent</strong>是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</p>
<p>但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。</p>
<p>不过有的比较“诚实”的爬虫会在 User-Agent 里用“spider”标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略。</p>
<p><strong>Date</strong>字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p>
<p><strong>Server</strong>字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。</p>
<p>Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</p>
<p>比如 GitHub，它的 Server 字段里就看不出是使用了 Apache 还是 Nginx，只是显示为“GitHub.com”。</p>
<p><img src="https://img-blog.csdnimg.cn/131d7ca770774f9991674077a1e8ff33.png" alt=""></p>
<p>实体字段里要说的一个是<strong>Content-Length</strong>，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 的报文结构，下面做一个简单小结。</p>
<ul>
<li>HTTP 报文结构就像是“大头儿子”，由“起始行 + 头部 + 空行 + 实体”组成，简单地说就是“header+body”；</li>
<li>HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行，形象地说就是“大头”必须要带着“脖子”；</li>
<li>请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；</li>
<li>请求行有三部分：请求方法，请求目标和版本号；</li>
<li>状态行也有三部分：版本号，状态码和原因字符串；</li>
<li>头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；</li>
<li>HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。</li>
</ul>
<p>课下作业
如果拼 HTTP 报文的时候，在头字段后多加了一个 CRLF，导致出现了一个空行，会发生什么？
讲头字段时说“:”后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？
欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/ec22b1a46eb046e6b570f529492e564f.png" type="image/png"/>
    </item>
    <item>
      <title>10 | 应该如何理解请求方法？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson10.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson10.html</guid>
      <source url="https://0808200.xyz/rss.xml">10 | 应该如何理解请求方法？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_10-应该如何理解请求方法" tabindex="-1"> 10 | 应该如何理解请求方法？</h1>
<p>上一讲我介绍了 HTTP 的报文结构，它是由 header+body 构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语，今天要说的就是请求头里的请求方法。</p>
<h2 id="标准请求方法" tabindex="-1"> 标准请求方法</h2>
<p>HTTP 协议里为什么要有“请求方法”这个东西呢？</p>
<p>这就要从 HTTP 协议设计时的定位说起了。还记得吗？蒂姆·伯纳斯 - 李最初设想的是要用 HTTP 协议构建一个超链接文档系统，使用 URI 来定位这些文档，也就是资源。那么，该怎么在协议里操作这些资源呢？</p>
<p>很显然，需要有某种“动作的指示”，告诉操作这些资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。</p>
<p>目前 HTTP/1.1 规定了八种方法，单词<strong>都必须是大写的形式</strong>，我先简单地列把它们列出来，后面再详细讲解。</p>
<ul>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ul>
<p>!{}(https://img-blog.csdnimg.cn/24e82a57aca14c6a9f71677d6c5d91d8.png)</p>
<p>看看这些方法，是不是有点像对文件或数据库的“增删改查”操作，只不过这些动作操作的目标不是本地资源，而是远程服务器上的资源，所以只能由客户端“请求”或者“指示”服务器来完成。</p>
<p>既然请求方法是一个“指示”，那么客户端自然就没有决定权，服务器掌控着所有资源，也就有绝对的决策权力。它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”。</p>
<p>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</p>
<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。</li>
</ol>
<h2 id="get-head" tabindex="-1"> GET/HEAD</h2>
<p>虽然 HTTP/1.1 里规定了八种请求方法，但只有前四个是比较常用的，所以我们先来看一下这四个方法。</p>
<p><strong>GET</strong>方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自 0.9 版出现并一直被保留至今，是名副其实的“元老”。</p>
<p>它的含义是请求<strong>从服务器获取资源</strong>，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</p>
<p>GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。</p>
<p>例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。</p>
<p><strong>HEAD</strong>方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。</p>
<p>HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。</p>
<p>比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</p>
<p>你可以在实验环境里试一下这两个方法，运行 Telnet，分别向 URI“/10-1”发送 GET 和 HEAD 请求，观察一下响应头是否一致。</p>
<div><pre><code>GET /10-1 HTTP/1.1
Host: www.chrono.com
 
 
HEAD /10-1 HTTP/1.1
Host: www.chrono.com
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="post-put" tabindex="-1"> POST/PUT</h2>
<p>接下来要说的是<strong>POST和PUT</strong>方法，这两个方法也很像。</p>
<p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p>
<p>POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。</p>
<p>比如，你上论坛灌水，敲了一堆字后点击“发帖”按钮，浏览器就执行了一次 POST 请求，把你的文字放进报文的 body 里，然后拼好 POST 请求头，通过 TCP 协议发给服务器。</p>
<p>又比如，你上购物网站，看到了一件心仪的商品，点击“加入购物车”，这时也会有 POST 请求，浏览器会把商品 ID 发给服务器，服务器再把 ID 写入你的购物车相关的数据库记录。</p>
<p>PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。</p>
<p>在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。</p>
<p>实验环境的“/10-2”模拟了 POST 和 PUT 方法的处理过程，你仍然可以用 Telnet 发送测试请求，看看运行的效果。注意，在发送请求时，头字段“Content-Length”一定要写对，是空行后 body 的长度：</p>
<div><pre><code>POST /10-2 HTTP/1.1
Host: www.chrono.com
Content-Length: 17
 
POST DATA IS HERE
 
PUT /10-2 HTTP/1.1
Host: www.chrono.com
Content-Length: 16

PUT DATA IS HE
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="其他方法" tabindex="-1"> 其他方法</h2>
<p>讲完了 GET/HEAD/POST/PUT，还剩下四个标准请求方法，它们属于比较“冷僻”的方法，应用的不是很多。</p>
<p><strong>DELETE</strong>方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</p>
<p><strong>CONNECT</strong>是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</p>
<p><strong>OPTIONS</strong>方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</p>
<p><strong>TRACE</strong>方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p>
<h2 id="扩展方法" tabindex="-1"> 扩展方法</h2>
<p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p>
<p>例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。</p>
<p>此外，还有一些得到了实际应用的请求方法（WebDAV），例如 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。</p>
<p>当然了，你也完全可以根据实际需求，自己发明新的方法，比如“PULL”拉取某些资源到本地，“PURGE”清理某个目录下的所有缓存数据。</p>
<h2 id="安全与幂等" tabindex="-1"> 安全与幂等</h2>
<p>关于请求方法还有两个面试时有可能会问到、比较重要的概念：<strong>安全与幂等</strong>。</p>
<p>在 HTTP 协议里，所谓的“<strong>安全</strong>”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</p>
<p>按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。</p>
<p>而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。</p>
<p>所谓的“<strong>幂等</strong>”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</p>
<p>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p>
<p>POST 和 PUT 的幂等性质就略费解一点。</p>
<p>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p>
<p>我对你的建议是，你可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 报文里请求方法相关的知识，简单小结一下。</p>
<ul>
<li>请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；</li>
<li>请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；</li>
<li>最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；</li>
<li>HEAD 方法是轻量级的 GET，用来获取资源的元信息；</li>
<li>PUT 基本上是 POST 的同义词，多用于更新数据；</li>
<li>“安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。</li>
</ul>
<p>课下作业
你能把 GET/POST 等请求方法对应到数据库的“增删改查”操作吗？请求头应该如何设计呢？
你觉得 TRACE/OPTIONS/CONNECT 方法能够用 GET 或 POST 间接实现吗？</p>
<p>欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
    </item>
    <item>
      <title>11 | 你能写出正确的网址吗？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson11.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson11.html</guid>
      <source url="https://0808200.xyz/rss.xml">11 | 你能写出正确的网址吗？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_11-你能写出正确的网址吗" tabindex="-1"> 11 | 你能写出正确的网址吗？</h1>
<p>上一讲里我们一起学习了 HTTP 协议里的请求方法，其中最常用的一个是 GET，它用来从服务器上某个资源获取数据，另一个是 POST，向某个资源提交数据。</p>
<p>那么，应该用什么来标记服务器上的资源呢？怎么区分“这个”资源和“那个”资源呢？</p>
<p>经过前几讲的学习，你一定已经知道了，用的是 URI，也就是<strong>统一资源标识符</strong>（Uniform Resource Identifier）。因为它经常出现在浏览器的地址栏里，所以俗称为“网络地址”，简称“网址”。</p>
<p>严格地说，URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——<strong>统一资源定位符</strong>（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。</p>
<p>不仅我们生活中的上网要用到 URI，平常的开发、测试、运维的工作中也少不了它。</p>
<p>如果你在客户端做 iOS、 Android 或者某某小程序开发，免不了要连接远程服务，就会调用底层 API 用 URI 访问服务。</p>
<p>如果你使用 Java、PHP 做后台 Web 开发，也会调用 getPath()、parse_url() 等函数来处理 URI，解析里面的各个要素。</p>
<p>在测试、运维配置 Apache、Nginx 等 Web 服务器的时候也必须正确理解 URI，分离静态资源与动态资源，或者设置规则实现网页的重定向跳转。</p>
<p>总之一句话，URI 非常重要，要搞懂 HTTP 甚至网络应用，就必须搞懂 URI。</p>
<h2 id="uri-的格式" tabindex="-1"> URI 的格式</h2>
<p>不知道你平常上网的时候有没有关注过地址栏里的那一长串字符，有的比较简短，有的则一行都显示不下，有的意思大概能看明白，而有的则带着各种怪字符，有如“天书”。</p>
<p>其实只要你弄清楚了 URI 的格式，就能够轻易地“破解”这些难懂的“天书”了。</p>
<p>URI 本质上是一个字符串，这个字符串的作用是<strong>唯一地标记资源的位置或者名字</strong>。</p>
<p>这里我要提醒你注意，它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。</p>
<p>下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>
<p><img src="https://img-blog.csdnimg.cn/5d632c91b4ab4ecd8e49ea1bfdc1917d.png" alt=""></p>
<h2 id="uri-的基本组成" tabindex="-1"> URI 的基本组成</h2>
<p>URI 第一个组成部分叫<strong>scheme</strong>，翻译成中文叫“<strong>方案名</strong>”或者“<strong>协议名</strong>”，表示<strong>资源应该使用哪种协议</strong>来访问。</p>
<p>最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</p>
<p>浏览器或者你的应用程序看到 URI 里的 scheme，就知道下一步该怎么走了，会调用相应的 HTTP 或者 HTTPS 下层 API。显然，如果一个 URI 没有提供 scheme，即使后面的地址再完善，也是无法处理的。</p>
<p>在 scheme 之后，必须是<strong>三个特定的字符“<code>://</code>”</strong>，它把 scheme 和后面的部分分离开。</p>
<p>实话实说，这个设计非常的怪异，我最早上网的时候看见地址栏里的“<code>://</code>”就觉得很别扭，直到现在也还是没有太适应。URI 的创造者蒂姆·伯纳斯 - 李也曾经私下承认“<code>://</code>”并非必要，当初有些“过于草率”了。</p>
<p>不过这个设计已经有了三十年的历史，不管我们愿意不愿意，只能接受。</p>
<p>在“<code>://</code>”之后，是被称为“<strong>authority</strong>”的部分，表示<strong>资源所在的主机名</strong>，通常的形式是“host:port”，即主机名加端口号。</p>
<p>主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。</p>
<p>有了协议名和主机地址、端口号，再加上后面<strong>标记资源所在位置的path</strong>，浏览器就可以连接服务器访问资源了。</p>
<p>URI 里 path 采用了类似文件系统“目录”“路径”的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的“/”风格。其实也比较好理解，它与 scheme 后面的“<code>://</code>”是一致的。</p>
<p>这里我也要再次提醒你注意，URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。</p>
<p>说了这么多“理论”，来看几个实例。</p>
<div><pre><code>http://nginx.org
http://www.chrono.com:8080/11-1
https://tools.ietf.org/html/rfc7230
file:///D:/http_study/www/
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>第一个 URI 算是最简单的了，协议名是“http”，主机名是“nginx.org”，端口号省略，所以是默认的 80，而路径部分也被省略了，默认就是一个“/”，表示根目录。</p>
<p>第二个 URI 是在实验环境里这次课程的专用 URI，主机名是“www.chrono.com”，端口号是 8080，后面的路径是“/11-1”。</p>
<p>第三个是 HTTP 协议标准文档 RFC7230 的 URI，主机名是“tools.ietf.org”，路径是“/html/rfc7230”。</p>
<p>最后一个 URI 要注意了，它的协议名不是“http”，而是“file”，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？</p>
<p>如果你刚才仔细听了 scheme 的介绍就能明白，这三个斜杠里的前两个属于 URI 特殊分隔符“<code>://</code>”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</p>
<p>但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</p>
<p>我们可以在实验环境里用 Chrome 浏览器再仔细观察一下 HTTP 报文里的 URI。</p>
<p>运行 Chrome，用 F12 打开开发者工具，然后在地址栏里输入“http://www.chrono.com/11-1”，得到的结果如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/6e86a41750eb4a3fa731e50659983d1a.png" alt=""></p>
<p>在开发者工具里依次选“Network”“Doc”，就可以找到请求的 URI。然后在 Headers 页里看 Request Headers，用“view source”就可以看到浏览器发的原始请求头了。</p>
<p>发现了什么特别的没有？</p>
<p>在 HTTP 报文里的 URI“/11-1”与浏览器里输入的“http://www.chrono.com/11-1”有很大的不同，协议名和主机名都不见了，只剩下了后面的部分。</p>
<p>这是因为协议名和主机名已经分别出现在了请求行的版本号和请求头的 Host 字段里，没有必要再重复。当然，在请求行里使用完整的 URI 也是可以的，你可以在课后自己试一下。</p>
<p>通过这个小实验，我们还得到了一个结论：<code>客户端和服务器看到的 URI 是不一样的</code>。客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。</p>
<p>如果你配置过 Nginx，你就应该明白了，Nginx 作为一个 Web 服务器，它的 location、rewrite 等指令操作的 URI 其实指的是真正 URI 里的 path 和后续的部分。</p>
<h2 id="uri-的查询参数" tabindex="-1"> URI 的查询参数</h2>
<p>使用“协议名 + 主机名 + 路径”的方式，已经可以精确定位网络上的任何资源了。但这还不够，很多时候我们还想在操作资源的时候附加一些额外的修饰参数。</p>
<p>举几个例子：获取商品图片，但想要一个 32×32 的缩略图版本；获取商品列表，但要按某种规则做分页和排序；跳转页面，但想要标记跳转前的原始页面。</p>
<p>仅用“协议名 + 主机名 + 路径”的方式是无法适应这些场景的，所以 URI 后面还有一个“query”部分，它在 path 之后，用一个“?”开始，但不包含“?”，表示对资源附加的额外要求。这是个很形象的符号，比“<code>://</code>”要好的多，很明显地表示了“查询”的含义。</p>
<p>查询参数 <strong>query</strong> 有一套自己的格式，是多个“<strong>key=value</strong>”的字符串，这些 KV 值用字符“&amp;”连接，浏览器和客户端都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。</p>
<p>你可以在实验环境里用 Chrome 试试下面这个加了 query 参数的 URI：</p>
<div><pre><code>http://www.chrono.com:8080/11-1?uid=1234&amp;name=mario&amp;referer=xxx
</code></pre><div aria-hidden="true"><div></div></div></div><p>Chrome 的开发者工具也能解码出 query 里的 KV 对，省得我们“人肉”分解。</p>
<p><img src="https://img-blog.csdnimg.cn/8e7d5b41397c44bca08abfb158619fce.png" alt=""></p>
<p>还可以再拿一个实际的 URI 来看一下，这个 URI 是某电商网站的一个商品查询 URI，比较复杂，但相信现在的你能够毫不费力地区分出里面的协议名、主机名、路径和查询参数。</p>
<div><pre><code>https://search.jd.com/Search?keyword=openresty&amp;enc=utf-8&amp;qrst=1&amp;rt=1&amp;stop=1&amp;vt=2&amp;wq=openresty&amp;psort=3&amp;click=0
</code></pre><div aria-hidden="true"><div></div></div></div><p>你也可以把这个 URI 输入到 Chrome 的地址栏里，再用开发者工具仔细检查它的组成部分。</p>
<h2 id="uri-的完整格式" tabindex="-1"> URI 的完整格式</h2>
<p>讲完了 query 参数，URI 就算完整了，HTTP 协议里用到的 URI 绝大多数都是这种形式。</p>
<p>不过必须要说的是，URI 还有一个“真正”的完整形态，如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/6cb7d8e1c33c40fc8e93bf8906d761c8.png" alt=""></p>
<p>这个“真正”形态比基本形态多了两部分。</p>
<p>第一个多出的部分是协议名之后、主机名之前的<strong>身份信息</strong>“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。</p>
<p>第二个多出的部分是查询参数后的<strong>片段标识符</strong>“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。</p>
<p>但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。</p>
<h2 id="uri-的编码" tabindex="-1"> URI 的编码</h2>
<p>刚才我们看到了，在 URI 里只能使用 ASCII 码，但如果要在 URI 里使用英语以外的汉语、日语等其他语言该怎么办呢？</p>
<p>还有，某些特殊的 URI，会在 path、query 里出现“@&amp;?&quot;等起界定符作用的字符，会导致 URI 解析错误，这时又该怎么办呢？</p>
<p>所以，URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</p>
<p>URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。</p>
<p>例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。</p>
<p>有了这个编码规则后，URI 就更加完美了，可以支持任意的字符集用任何语言来标记资源。</p>
<p>不过我们在浏览器的地址栏里通常是不会看到这些转义后的“乱码”的，这实际上是浏览器一种“友好”表现，隐藏了 URI 编码后的“丑陋一面”，不信你可以试试下面的这个 URI。</p>
<div><pre><code>http://www.chrono.com:8080/11-1? 夸父逐日
</code></pre><div aria-hidden="true"><div></div></div></div><p>先在 Chrome 的地址栏里输入这个 query 里含有中文的 URI，然后点击地址栏，把它再拷贝到其他的编辑器里，它就会“现出原形”：</p>
<div><pre><code>http://www.chrono.com:8080/11-1?%E5%A4%B8%E7%88%B6%E9%80%90%E6%97%A5
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了网址也就是 URI 的知识，在这里小结一下今天的内容。</p>
<ul>
<li>URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；</li>
<li>URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；</li>
<li>scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；</li>
<li>“host:port”表示资源所在的主机名和端口号；</li>
<li>path 标记资源所在的位置；</li>
<li>query 表示对资源附加的额外要求；</li>
<li>在 URI 里对“@&amp;/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。</li>
</ul>
<p>课下作业
HTTP 协议允许在在请求行里使用完整的 URI，但为什么浏览器没有这么做呢？
URI 的查询参数和头字段很相似，都是 key-value 形式，都可以任意自定义，那么它们在使用时该如何区别呢？</p>
<p>欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/5d632c91b4ab4ecd8e49ea1bfdc1917d.png" type="image/png"/>
    </item>
    <item>
      <title>12 | 响应状态码该怎么用？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson12.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson12.html</guid>
      <source url="https://0808200.xyz/rss.xml">12 | 响应状态码该怎么用？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_12-响应状态码该怎么用" tabindex="-1"> 12 | 响应状态码该怎么用？</h1>
<p>前两讲中，我们学习了 HTTP 报文里请求行的组成部分，包括请求方法和 URI。有了请求行，加上后面的头字段就形成了请求头，可以通过 TCP/IP 协议发送给服务器。</p>
<p>服务器收到请求报文，解析后需要进行处理，具体的业务逻辑多种多样，但最后必定是拼出一个响应报文发回客户端。</p>
<p>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</p>
<p>我们先来复习一下状态行的结构，有三部分：</p>
<p><img src="https://img-blog.csdnimg.cn/5439c8b65f9748038e6a940d1dee2352.png" alt=""></p>
<p>开头的 Version 部分是 HTTP 协议的版本号，通常是 HTTP/1.1，用处不是很大。</p>
<p>后面的 Reason 部分是原因短语，是状态码的简短文字描述，例如“OK”“Not Found”等等，也可以自定义。但它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。</p>
<p>所以，状态行里有用的就只剩下中间的状态码（Status Code）了。它是一个十进制数字，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。</p>
<p>不过你要注意，它的名字是“状态码”而不是“错误码”。也就是说，它的含义不仅是错误，更重要的意义在于表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思。</p>
<h2 id="状态码" tabindex="-1"> 状态码</h2>
<p>目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太“low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。</p>
<p>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。</p>
<p>这五类的具体含义是：</p>
<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>
<p>在 HTTP 协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。</p>
<p>客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。</p>
<p>服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。</p>
<p>目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。</p>
<p>在我们的实验环境里也可以对这些状态码做测试验证，访问 URI“/12-1”，用查询参数“code=xxx”来检查这些状态码的效果，服务器不仅会在状态行里显示状态码，还会在响应头里用自定义的“Expect-Code”字段输出这个代码。</p>
<p>例如，在 Chrome 里访问“http://www.chrono.com/12-1?code=405”的结果如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/72e2afc59ff746f3aaca59440dc677ab.png" alt=""></p>
<p>接下来我就挑一些实际开发中比较有价值的状态码逐个详细介绍。</p>
<h2 id="_1××" tabindex="-1"> 1××</h2>
<p>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p>
<p>我们偶尔能够见到的是“<strong>101 Switching Protocols</strong>”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>
<h2 id="_2××" tabindex="-1"> 2××</h2>
<p>2××类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。</p>
<p>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<p>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<p>“<strong>206 Partial Content</strong>”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>
<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>
<h2 id="_3××" tabindex="-1"> 3××</h2>
<p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p>
<p>“<strong>301 Moved Permanently</strong>”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。</p>
<p>与它类似的是“<strong>302 Found</strong>”，曾经的描述短语是“<strong>Moved Temporarily</strong>”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>
<p>301 和 302 都会在响应头里使用字段Location指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</p>
<p>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</p>
<p>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</p>
<p>“<strong>304 Not Modified</strong>” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p>
<p>301、302 和 304 分别涉及了 HTTP 协议里重要的“重定向跳转”和“缓存控制”，在之后的课程中我还会细讲。</p>
<h2 id="_4××" tabindex="-1"> 4××</h2>
<p>4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。</p>
<p>“<strong>400 Bad Request</strong>”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<p>“<strong>403 Forbidden</strong>”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</p>
<p>“<strong>404 Not Found</strong>”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<p>4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>
<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
<h2 id="_5××" tabindex="-1"> 5××</h2>
<p>5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。</p>
<p>“<strong>500 Internal Server Error</strong>”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p>
<p>“<strong>501 Not Implemented</strong>”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</p>
<p>“<strong>502 Bad Gateway</strong>”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p>
<p>“<strong>503 Service Unavailable</strong>”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>
<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>状态码在响应报文里表示了服务器对请求的处理结果；</li>
<li>状态码后的原因短语是简单的文字描述，可以自定义；</li>
<li>状态码是十进制的三位数，分为五类，从 100 到 599；</li>
<li>2××类状态码表示成功，常用的有 200、204、206；</li>
<li>3××类状态码表示重定向，常用的有 301、302、304；</li>
<li>4××类状态码表示客户端错误，常用的有 400、403、404；</li>
<li>5××类状态码表示服务器错误，常用的有 500、501、502、503。</li>
</ul>
<p>课下作业
你在开发 HTTP 客户端，收到了一个非标准的状态码，比如 4××、5××，应当如何应对呢？
你在开发 HTTP 服务器，处理请求时发现报文里缺了一个必需的 query 参数，应该如何告知客户端错误原因呢？</p>
<p>欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/5439c8b65f9748038e6a940d1dee2352.png" type="image/png"/>
    </item>
    <item>
      <title>13 | HTTP有哪些特点？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson13.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson13.html</guid>
      <source url="https://0808200.xyz/rss.xml">13 | HTTP有哪些特点？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_13-http有哪些特点" tabindex="-1"> 13 | HTTP有哪些特点？</h1>
<p>通过“基础篇”前几讲的学习，你应该已经知道了 HTTP 协议的基本知识，了解它的报文结构，请求头、响应头以及内部的请求方法、URI 和状态码等细节。</p>
<p>你会不会有种疑惑：“HTTP 协议好像也挺简单的啊，凭什么它就能统治互联网这么多年呢？”</p>
<p>所以接下来的这两讲，我会跟你聊聊 HTTP 协议的特点、优点和缺点。既要看到它好的一面，也要正视它不好的一面，只有全方位、多角度了解 HTTP，才能实现“扬长避短”，更好地利用 HTTP。</p>
<p>今天这节课主要说的是 HTTP 协议的特点，但不会讲它们的好坏，这些特点即有可能是优点，也有可能是缺点，你可以边听边思考。</p>
<p><img src="https://img-blog.csdnimg.cn/fb28fe6b8a9048f5ae937fd4d524be3b.png" alt=""></p>
<h2 id="灵活可扩展" tabindex="-1"> 灵活可扩展</h2>
<p>首先， <code>HTTP 协议是一个“灵活可扩展”的传输协议</code>。</p>
<p>HTTP 协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。</p>
<p>所以，HTTP 协议就随着互联网的发展一同成长起来了。在这个过程中，HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或 HTML，而是能够传输图片、音频视频等任意数据，这些都是源于它的“灵活可扩展”的特点。</p>
<p>而那些 RFC 文档，实际上也可以理解为是对已有扩展的“承认和标准化”，实现了“从实践中来，到实践中去”的良性循环。</p>
<p>也正是因为这个特点，HTTP 才能在三十年的历史长河中“屹立不倒”，从最初的低速实验网络发展到现在的遍布全球的高速互联网，始终保持着旺盛的生命力。</p>
<h2 id="可靠传输" tabindex="-1"> 可靠传输</h2>
<p>第二个特点， <code>HTTP 协议是一个“可靠”的传输协议</code>。</p>
<p>这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</p>
<p>它的具体做法与 TCP/UDP 差不多，都是对实际传输的数据（entity）做了一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收。</p>
<p>不过我们必须正确地理解“可靠”的含义，HTTP 并不能 100% 保证数据一定能够发送到另一端，在网络繁忙、连接质量差等恶劣的环境下，也有可能收发失败。“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。</p>
<p>当然，如果遇到光纤被意外挖断这样的极端情况，即使是神仙也不能发送成功。所以，“可靠”传输是指在网络基本正常的情况下数据收发必定成功，借用运维里的术语，大概就是“3 个 9”或者“4 个 9”的程度吧。</p>
<h2 id="应用层协议" tabindex="-1"> 应用层协议</h2>
<p>第三个特点，<code>HTTP 协议是一个应用层的协议</code>。</p>
<p>这个特点也是不言自明的，但却很重要。</p>
<p>在 TCP/IP 诞生后的几十年里，虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在通用的数据传输方面“完全不能打”。</p>
<p>所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。</p>
<p>套用一个网上流行的段子，HTTP 完全可以用开玩笑的口吻说：“不要误会，我不是针对 FTP，我是说在座的应用层各位，都是垃圾。”</p>
<h2 id="请求-应答" tabindex="-1"> 请求 - 应答</h2>
<p>第四个特点，<code>HTTP 协议使用的是请求 - 应答通信模式</code>。</p>
<p>这个请求 - 应答模式是 HTTP 协议最根本的通信模型，通俗来讲就是“一发一收”“有来有去”，就像是写代码时的函数调用，只要填好请求头里的字段，“调用”后就会收到答复。</p>
<p>请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。</p>
<p>当然，请求方和应答方的角色也不是绝对的，在浏览器 - 服务器的场景里，通常服务器都是应答方，但如果将它用作代理连接后端服务器，那么它就可能同时扮演请求方和应答方的角色。</p>
<p>HTTP 的请求 - 应答模式也恰好契合了传统的 C/S（Client/Server）系统架构，请求方作为客户端、应答方作为服务器。所以，随着互联网的发展就出现了 B/S（Browser/Server）架构，用轻量级的浏览器代替笨重的客户端应用，实现零维护的“瘦”客户端，而服务器则摈弃私有通信协议转而使用 HTTP 协议。</p>
<p>此外，请求 - 应答模式也完全符合 RPC（Remote Procedure Call）的工作模式，可以把 HTTP 请求处理封装成远程函数调用，导致了 WebService、RESTful 和 gPRC 等的出现。</p>
<h2 id="无状态" tabindex="-1"> 无状态</h2>
<p>第五个特点，<code>HTTP 协议是无状态的</code>。</p>
<p>这个所谓的“状态”应该怎么理解呢？</p>
<p>“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。</p>
<p>你一定知道，TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。</p>
<p>这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量，标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。</p>
<p>再来看 HTTP，那么对比一下 TCP 就看出来了，在整个协议里没有规定任何的“状态”，客户端和服务器永远是处在一种“<strong>无知</strong>”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。</p>
<p>“无状态”形象地来说就是“没有记忆能力”。比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”</p>
<p>我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</p>
<p>但不要忘了 HTTP 是“灵活可扩展”的，虽然标准里没有规定“状态”，但完全能够在协议的框架里给它“打个补丁”，增加这个特性。</p>
<h2 id="其他特点" tabindex="-1"> 其他特点</h2>
<p>除了以上的五大特点，其实 HTTP 协议还可以列出非常多的特点，例如传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；</li>
<li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；</li>
<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li>
<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li>
<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ul>
<p>课下作业
就如同开头我讲的那样，你能说一下今天列出的这些 HTTP 的特点中哪些是优点，哪些是缺点吗？
不同的应用场合有不同的侧重方面，你觉得哪个特点对你来说是最重要的呢？</p>
<p>欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/fb28fe6b8a9048f5ae937fd4d524be3b.png" type="image/png"/>
    </item>
    <item>
      <title>14 | HTTP有哪些优点？又有哪些缺点？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson14.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/3_based/lesson14.html</guid>
      <source url="https://0808200.xyz/rss.xml">14 | HTTP有哪些优点？又有哪些缺点？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_14-http有哪些优点-又有哪些缺点" tabindex="-1"> 14 | HTTP有哪些优点？又有哪些缺点？</h1>
<p>上一讲我介绍了 HTTP 的五个基本特点，这一讲要说的则是它的优点和缺点。其实这些也应该算是 HTTP 的特点，但这一讲会更侧重于评价它们的优劣和好坏。</p>
<p>上一讲我也留了两道课下作业，不知道你有没有认真思考过，今天可以一起来看看你的答案与我的观点想法是否相符，共同探讨。</p>
<p>不过在正式开讲之前我还要提醒你一下，今天的讨论范围仅限于 HTTP/1.1，所说的优点和缺点也仅针对 HTTP/1.1。实际上，专栏后续要讲的 HTTPS 和 HTTP/2 都是对 HTTP/1.1 优点的发挥和缺点的完善。</p>
<h2 id="简单、灵活、易于扩展" tabindex="-1"> 简单、灵活、易于扩展</h2>
<p>首先，HTTP 最重要也是最突出的优点是“简单、灵活、易于扩展”。</p>
<p>初次接触 HTTP 的人都会认为，HTTP 协议是很“简单”的，基本的报文格式就是“header+body”，头部信息也是简单的文本格式，用的也都是常见的英文单词，即使不去看 RFC 文档，只靠猜也能猜出个“八九不离十”。</p>
<p>可不要小看了“简单”这个优点，它不仅降低了学习和使用的门槛，能够让更多的人研究和开发 HTTP 应用，而且我在第 1 讲时就说过，“简单”蕴含了进化和扩展的可能性，所谓“少即是多”，“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多。</p>
<p>所以，在“简单”这个最基本的设计理念之下，HTTP 协议又多出了“灵活和易于扩展”的优点。</p>
<p>“灵活和易于扩展”实际上是一体的，它们互为表里、相互促进，因为“灵活”所以才会“易于扩展”，而“易于扩展”又反过来让 HTTP 更加灵活，拥有更强的表现能力。</p>
<p>HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被“写死”，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由，也正好符合了互联网“自由与平等”的精神——缺什么功能自己加个字段或者错误码什么的补上就是了。</p>
<p>“请勿跟踪”所使用的头字段 DNT（Do Not Track）就是一个很好的例子。它最早由 Mozilla 提出，用来保护用户隐私，防止网站监测追踪用户的偏好。不过可惜的是 DNT 从推出至今有差不多七八年的历史，但很多网站仍然选择“无视”DNT。虽然 DNT 基本失败了，但这也正说明 HTTP 协议是“灵活自由的”，不会受单方面势力的压制。</p>
<p>“灵活、易于扩展”的特性还表现在 HTTP 对“可靠传输”的定义上，它不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定。</p>
<h2 id="应用广泛、环境成熟" tabindex="-1"> 应用广泛、环境成熟</h2>
<p>HTTP 协议的另一大优点是“应用广泛”，软硬件环境都非常成熟。</p>
<p>随着互联网特别是移动互联网的普及，HTTP 的触角已经延伸到了世界的每一个角落：从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP，从看新闻、泡论坛到购物、理财、“吃鸡”，你很难找到一个没有使用 HTTP 的地方。</p>
<p>不仅在应用领域，在开发领域 HTTP 协议也得到了广泛的支持。它并不限定某种编程语言或者操作系统，所以天然具有“<strong>跨语言、跨平台</strong>”的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具，这一点我觉得就不用再举例了吧，你可能比我更熟悉。</p>
<p>HTTP 广泛应用的背后还有许多硬件基础设施支持，各个互联网公司和传统行业公司都不遗余力地“触网”，购买服务器开办网站，建设数据中心、CDN 和高速光纤，持续地优化上网体验，让 HTTP 运行的越来越顺畅。</p>
<p>“应用广泛”的这个优点也就决定了：无论是创业者还是求职者，无论是做网站服务器还是写应用客户端，HTTP 协议都是必须要掌握的基本技能。</p>
<h2 id="无状态" tabindex="-1"> 无状态</h2>
<p>看过了两个优点，我们再来看看一把“双刃剑”，也就是上一讲中说到的“无状态”，它对于 HTTP 来说既是优点也是缺点。</p>
<p>“无状态”有什么好处呢？</p>
<p>因为服务器没有“记忆能力”，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>
<p>而且，“无状态”也表示服务器都是相同的，没有“状态”的差异，所以可以很容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用。</p>
<p>那么，“无状态”又有什么坏处呢？</p>
<p>既然服务器没有“记忆能力”，它就无法支持需要连续多个步骤的“事务”操作。例如电商购物，首先要登录，然后添加购物车，再下单、结算、支付，这一系列操作都需要知道用户的身份才行，但“无状态”服务器是不知道这些请求是相互关联的，每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。</p>
<p>所以，HTTP 协议最好是既“无状态”又“有状态”，不过还真有“鱼和熊掌”两者兼得这样的好事，这就是“小甜饼”Cookie 技术（第 19 讲）。</p>
<h2 id="明文" tabindex="-1"> 明文</h2>
<p>HTTP 协议里还有一把优缺点一体的“双刃剑”，就是<strong>明文传输</strong>。</p>
<p>“明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</p>
<p>对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利。</p>
<p>当然，明文的缺点也是一样显而易见，HTTP 报文的所有信息都会暴露在“光天化日之下”，在漫长的传输链路的每一个环节上都毫无隐私可言，不怀好意的人只要侵入了这个链路里的某个设备，简单地“旁路”一下流量，就可以实现对通信的窥视。</p>
<p>你有没有听说过“免费 WiFi 陷阱”之类的新闻呢？</p>
<p>黑客就是利用了 HTTP 明文传输的缺点，在公共场所架设一个 WiFi 热点开始“钓鱼”，诱骗网民上网。一旦你连上了这个 WiFi 热点，所有的流量都会被截获保存，里面如果有银行卡号、网站密码等敏感信息的话那就危险了，黑客拿到了这些数据就可以冒充你为所欲为。</p>
<h2 id="不安全" tabindex="-1"> 不安全</h2>
<p>与“明文”缺点相关但不完全等同的另一个缺点是“不安全”。</p>
<p>安全有很多的方面，明文只是“机密”方面的一个缺点，在“身份认证”和“完整性校验”这两方面 HTTP 也是欠缺的。</p>
<p>“身份认证”简单来说就是“<strong>怎么证明你就是你</strong>”。在现实生活中比较好办，你可以拿出身份证、驾照或者护照，上面有照片和权威机构的盖章，能够证明你的身份。</p>
<p>但在虚拟的网络世界里这却是个麻烦事。HTTP 没有提供有效的手段来确认通信双方的真实身份。虽然协议里有一个基本的认证机制，但因为刚才所说的明文传输缺点，这个机制几乎可以说是“纸糊的”，非常容易被攻破。如果仅使用 HTTP 协议，很可能你会连到一个页面一模一样但却是个假冒的网站，然后再被“钓”走各种私人信息。</p>
<p>HTTP 协议也不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。</p>
<p>比如，你收到了一条银行用 HTTP 发来的消息：“小明向你转账一百元”，你无法知道小明是否真的就只转了一百元，也许他转了一千元或者五十元，但被黑客窜改成了一百元，真实情况到底是什么样子 HTTP 协议没有办法给你答案。</p>
<p>虽然银行可以用 MD5、SHA1 等算法给报文加上数字摘要，但还是因为“明文”这个致命缺点，黑客可以连同摘要一同修改，最终还是判断不出报文是否被窜改。</p>
<p>为了解决 HTTP 不安全的缺点，所以就出现了 HTTPS，这个我们以后再说。</p>
<h2 id="性能" tabindex="-1"> 性能</h2>
<p>最后我们来谈谈 HTTP 的性能，可以用六个字来概括：“<strong>不算差，不够好</strong>”。</p>
<p>HTTP 协议基于 TCP/IP，并且使用了“请求 - 应答”的通信模式，所以性能的关键就在这两点上。</p>
<p>必须要说的是，TCP 的性能是不差的，否则也不会纵横互联网江湖四十余载了，而且它已经被研究的很透，集成在操作系统内核里经过了细致的优化，足以应付大多数的场景。</p>
<p>只可惜如今的江湖已经不是从前的江湖，现在互联网的特点是移动和高并发，不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好。</p>
<p>而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p>
<p>为了解决这个问题，就诞生出了一个专门的研究课题“Web 性能优化”，HTTP 官方标准里就有“缓存”一章（RFC7234），非官方的“花招”就更多了，例如切图、数据内嵌与合并，域名分片、JavaScript“黑科技”等等。</p>
<p>不过现在已经有了终极解决方案：HTTP/2 和 HTTP/3，后面我也会展开来讲。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>
</ul>
<p>虽然 HTTP 免不了这样那样的缺点，但你也不要怕，别忘了它有一个最重要的“灵活可扩展”的优点，所有的缺点都可以在这个基础上想办法解决，接下来的“进阶篇”和“安全篇”就会讲到。</p>
<p>课下作业
你最喜欢的 HTTP 优点是哪个？最不喜欢的缺点又是哪个？为什么？
你能够再进一步扩展或补充论述今天提到这些优点或缺点吗？</p>
<p>你能试着针对这些缺点提出一些自己的解决方案吗？
欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
    </item>
    <item>
      <title>15 | 海纳百川：HTTP的实体数据</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson15.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson15.html</guid>
      <source url="https://0808200.xyz/rss.xml">15 | 海纳百川：HTTP的实体数据</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_15-海纳百川-http的实体数据" tabindex="-1"> 15 | 海纳百川：HTTP的实体数据</h1>
<p>你好，我是 Chrono。</p>
<p>今天我要与你分享的话题是“海纳百川：HTTP 的实体数据”。</p>
<p>这一讲是“进阶篇”的第一讲，从今天开始，我会用连续的 8 讲的篇幅来详细解析 HTTP 协议里的各种头字段，包括定义、功能、使用方式、注意事项等等。学完了这些课程，你就可以完全掌握 HTTP 协议。</p>
<p>在前面的“基础篇”里我们了解了 HTTP 报文的结构，知道一个 HTTP 报文是由“header+body”组成的。但那时我们主要研究的是 header，没有涉及到 body。所以，“进阶篇”的第一讲就从 HTTP 的 body 谈起。</p>
<h2 id="数据类型与编码" tabindex="-1"> 数据类型与编码</h2>
<p>在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</p>
<p>而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。</p>
<p>你可以设想一下，假如 HTTP 没有告知数据类型的功能，服务器把“一大坨”数据发给了浏览器，浏览器看到的是一个“黑盒子”，这时候该怎么办呢？</p>
<p>当然，它可以“猜”。因为很多数据都是有固定格式的，所以通过检查数据的前几个字节也许就能知道这是个 GIF 图片、或者是个 MP3 音乐文件，但这种方式无疑十分低效，而且有很大几率会检查不出来文件类型。</p>
<p>幸运的是，早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“<strong>多用途互联网邮件扩展</strong>”（Multipurpose Internet Mail Extensions），简称为 MIME。</p>
<p>MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“<strong>MIME type</strong>”。</p>
<p>MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</p>
<p>这里简单列举一下在 HTTP 里经常遇到的几个类别：</p>
<ol>
<li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li>
<li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li>
<li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</li>
</ol>
<p>但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</p>
<p>比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</p>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li>
</ol>
<h2 id="数据类型使用的头字段" tabindex="-1"> 数据类型使用的头字段</h2>
<p>有了 MIME type 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了。</p>
<p>HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“内容协商”。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/1f159e4142b04c5fbaa2fed202507c75.png" alt=""></p>
<p><strong>Accept</strong>字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p>
<div><pre><code>Accept: text/html,application/xml,image/webp,image/png
</code></pre><div aria-hidden="true"><div></div></div></div><p>这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。</p>
<p>相应的，服务器会在响应报文里用头字段Content-Type告诉实体数据的真实类型：</p>
<div><pre><code>Content-Type: text/html
Content-Type: image/png
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。</p>
<p><strong>Accept-Encoding</strong>字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段Content-Encoding里。</p>
<div><pre><code>Accept-Encoding: gzip, deflate, br
Content-Encoding: gzip
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>不过这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p>
<h2 id="语言类型与编码" tabindex="-1"> 语言类型与编码</h2>
<p>MIME type 和 Encoding type 解决了计算机理解 body 数据的问题，但互联网遍布全球，不同国家不同地区的人使用了很多不同的语言，虽然都是 text/html，但如何让浏览器显示出每个人都可理解可阅读的语言文字呢？</p>
<p>这实际上就是“国际化”的问题。HTTP 采用了与数据类型相似的解决方案，又引入了两个概念：语言类型与字符集。</p>
<p>所谓的“<strong>语言类型</strong>”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用“type-subtype”的形式，不过这里的格式与数据类型不同，<strong>分隔符不是“/”，而是“-”</strong>。</p>
<p>举几个例子：en 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语。</p>
<p>关于自然语言的计算机处理还有一个更麻烦的东西叫做“字符集”。</p>
<p>在计算机发展的早期，各个国家和地区的人们“各自为政”，发明了许多字符编码方式来处理文字，比如英语世界用的 ASCII、汉语世界用的 GBK、BIG5，日语世界用的 Shift_JIS 等。同样的一段文字，用一种编码显示正常，换另一种编码后可能就会变得一团糟。</p>
<p>所以后来就出现了 Unicode 和 UTF-8，把世界上所有的语言都容纳在一种编码方案里，UTF-8 也成为了互联网上的标准字符集。</p>
<h2 id="语言类型使用的头字段" tabindex="-1"> 语言类型使用的头字段</h2>
<p>同样的，HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言与编码进行“内容协商”。</p>
<p>Accept-Language字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</p>
<div><pre><code>Accept-Language: zh-CN, zh, en
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</p>
<p>相应的，服务器应该在响应报文里用头字段Content-Language告诉客户端实体数据使用的实际语言类型：</p>
<div><pre><code>Content-Language: zh-CN
</code></pre><div aria-hidden="true"><div></div></div></div><p>字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。</p>
<p>例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样：</p>
<div><pre><code>Accept-Charset: gbk, utf-8
Content-Type: text/html; charset=utf-8
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。</p>
<p><img src="https://img-blog.csdnimg.cn/ff32354ea37b475eaddc29679a1560dd.png" alt=""></p>
<h2 id="内容协商的质量值" tabindex="-1"> 内容协商的质量值</h2>
<p>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。</p>
<p>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。</p>
<p>这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。</p>
<p>例如下面的 Accept 字段：</p>
<div><pre><code>Accept: text/html,application/xml;q=0.9,*/*;q=0.8
</code></pre><div aria-hidden="true"><div></div></div></div><p>它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p>
<h2 id="内容协商的结果" tabindex="-1"> 内容协商的结果</h2>
<p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个Vary字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p>
<div><pre><code>Vary: Accept-Encoding,User-Agent,Accept
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</p>
<p>Vary 字段可以认为是响应报文的一个特殊的“版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务，这个之后讲“HTTP 缓存”时还会再提到。</p>
<h2 id="动手实验" tabindex="-1"> 动手实验</h2>
<p>上面讲完了理论部分，接下来就是实际动手操作了。可以用我们的实验环境，在 www 目录下有一个 mime 目录，里面预先存放了几个文件，可以用 URI“/15-1?name=file”的形式访问，例如：</p>
<div><pre><code>http://www.chrono.com/15-1?name=a.json
http://www.chrono.com/15-1?name=a.xml
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>在 Chrome 里打开开发者工具，就能够看到 Accept 和 Content 头：</p>
<p><img src="https://img-blog.csdnimg.cn/0a9e6d22efba457ebd95f4bef100f55b.png" alt=""></p>
<p>你也可以把任意的文件拷贝到 mime 目录下，比如压缩包、MP3、图片、视频等，再用 Chrome 访问，观察更多的 MIME type。</p>
<p>有了这些经验后，你还可以离开实验环境，直接访问各大门户网站，看看真实网络世界里的 HTTP 报文是什么样子的。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 里的数据类型和语言类型，在这里为今天的内容做个小结。</p>
<p><img src="https://img-blog.csdnimg.cn/9d8d28c3d7904d4398a4c0971689be74.png" alt=""></p>
<ul>
<li>数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；</li>
<li>数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；</li>
<li>语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；</li>
<li>字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；</li>
<li>客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；</li>
<li>Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。</li>
</ul>
<p>课下作业
试着解释一下这个请求头“Accept-Encoding: gzip, deflate;q=1.0, *;q=0.5, br;q=0”，再模拟一下服务器的响应头。
假设你要使用 POST 方法向服务器提交一些 JSON 格式的数据，里面包含有中文，请求头应该是什么样子的呢？
试着用快递发货收货比喻一下 MIME、Encoding 等概念。</p>
<p>欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/1f159e4142b04c5fbaa2fed202507c75.png" type="image/png"/>
    </item>
    <item>
      <title>16 | 把大象装进冰箱：HTTP传输大文件的方法</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson16.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson16.html</guid>
      <source url="https://0808200.xyz/rss.xml">16 | 把大象装进冰箱：HTTP传输大文件的方法</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_16-把大象装进冰箱-http传输大文件的方法" tabindex="-1"> 16 | 把大象装进冰箱：HTTP传输大文件的方法</h1>
<p>上次我们谈到了 HTTP 报文里的 body，知道了 HTTP 可以传输很多种类的数据，不仅是文本，也能传输图片、音频和视频。</p>
<p>早期互联网上传输的基本上都是只有几 K 大小的文本和小图片，现在的情况则大有不同。网页里包含的信息实在是太多了，随随便便一个主页 HTML 就有可能上百 K，高质量的图片都以 M 论，更不要说那些电影、电视剧了，几 G、几十 G 都有可能。</p>
<p>相比之下，100M 的光纤固网或者 4G 移动网络在这些大文件的压力下都变成了“小水管”，无论是上传还是下载，都会把网络传输链路挤的“满满当当”。</p>
<p>所以，如何在有限的带宽下高效快捷地传输这些大文件就成了一个重要的课题。这就好比是已经打开了冰箱门（建立连接），该怎么把大象（文件）塞进去再关上门（完成传输）呢？</p>
<p>今天我们就一起看看 HTTP 协议里有哪些手段能解决这个问题。</p>
<h2 id="数据压缩" tabindex="-1"> 数据压缩</h2>
<p>还记得上一讲中说到的“数据类型与编码”吗？如果你还有印象的话，肯定能够想到一个最基本的解决方案，那就是“数据压缩”，把大象变成小猪佩奇，再放进冰箱。</p>
<p>通常浏览器在发送请求时都会带着“<strong>Accept-Encoding</strong>”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“<strong>Content-Encoding</strong>”响应头里，再把原数据压缩后发给浏览器。</p>
<p>如果压缩率能有 50%，也就是说 100K 的数据能够压缩成 50K 的大小，那么就相当于在带宽不变的情况下网速提升了一倍，加速的效果是非常明显的。</p>
<p>不过这个解决方法也有个缺点，gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</p>
<p>不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。</p>
<h2 id="分块传输" tabindex="-1"> 分块传输</h2>
<p>在数据压缩之外，还能有什么办法来解决大文件的问题呢？</p>
<p>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</p>
<p>这样浏览器和服务器都不用在内存里保存文件的全部，每次只收发一小部分，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。</p>
<p>这种“<strong>化整为零</strong>”的思路在 HTTP 协议里就是“<strong>chunked</strong>”分块传输编码，在响应报文里用头字段“<strong>Transfer-Encoding: chunked</strong>”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</p>
<p>这就好比是用魔法把大象变成“乐高积木”，拆散了逐个装进冰箱，到达目的地后再施法拼起来“满血复活”。</p>
<p>分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“<strong>Content-Length</strong>”里给出确切的长度，所以也只能用 chunked 方式分块发送。</p>
<p>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是<strong>互斥的</strong>，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。</p>
<p>下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。</p>
<ol>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li>
<li>最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。</li>
</ol>
<p>听起来好像有点难懂，看一下图就好理解了：</p>
<p><img src="https://img-blog.csdnimg.cn/0832723e7df1420e9a96e27b12de6273.png" alt=""></p>
<p>实验环境里的 URI“/16-1”简单地模拟了分块传输，可以用 Chrome 访问这个地址看一下效果：</p>
<p><img src="https://img-blog.csdnimg.cn/18c5bb1fb27240858b01e4b12985d1c2.png" alt=""></p>
<p>不过浏览器在收到分块传输的数据后会自动按照规则去掉分块编码，重新组装出内容，所以想要看到服务器发出的原始报文形态就得用 Telnet 手工发送请求（或者用 Wireshark 抓包）：</p>
<div><pre><code>GET /16-1 HTTP/1.1
Host: www.chrono.com
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>因为 Telnet 只是收到响应报文就完事了，不会解析分块数据，所以可以很清楚地看到响应报文里的 chunked 数据格式：先是一行 16 进制长度，然后是数据，然后再是 16 进制长度和数据，如此重复，最后是 0 长度分块结束。</p>
<p><img src="https://img-blog.csdnimg.cn/cae2db1084974d428a12419de91376ce.png" alt=""></p>
<h2 id="范围请求" tabindex="-1"> 范围请求</h2>
<p>有了分块传输编码，服务器就可以轻松地收发大文件了，但对于上 G 的超大文件，还有一些问题需要考虑。</p>
<p>比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</p>
<p>HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。</p>
<p>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“<strong>Accept-Ranges: bytes</strong>”明确告知客户端：“我是支持范围请求的”。</p>
<p>如果不支持的话该怎么办呢？服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。</p>
<p>请求头<strong>Range</strong>是 HTTP 范围请求的专用字段，格式是“<strong>bytes=x-y</strong>”，其中的 x 和 y 是以字节为单位的数据范围。</p>
<p>要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</p>
<p>Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</p>
<ul>
<li>“0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；</li>
<li>“10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；</li>
<li>“-1”是文档的最后一个字节，相当于“99-99”；</li>
<li>“-10”是从文档末尾倒数 10 个字节，相当于“90-99”。</li>
</ul>
<p>服务器收到 Range 字段后，需要做四件事。</p>
<p>第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码<strong>416</strong>，意思是“你的范围请求有误，我无法处理，请再检查一下”。</p>
<p>第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“<strong>206 Partial Content</strong>”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</p>
<p>第三，服务器要添加一个响应头字段<strong>Content-Range</strong>，告诉片段的实际偏移量和资源的总大小，格式是“<strong>bytes x-y/length</strong>”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</p>
<p>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。</p>
<p>你可以用实验环境的 URI“/16-2”来测试范围请求，它处理的对象是“/mime/a.txt”。不过我们不能用 Chrome 浏览器，因为它没有编辑 HTTP 请求头的功能（这点上不如 Firefox 方便），所以还是要用 Telnet。</p>
<p>例如下面的这个请求使用 Range 字段获取了文件的前 32 个字节：</p>
<div><pre><code>GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-31
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>返回的数据是（去掉了几个无关字段）：</p>
<div><pre><code>HTTP/1.1 206 Partial Content
Content-Length: 32
Accept-Ranges: bytes
Content-Range: bytes 0-31/96
 
// this is a plain text json doc
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</p>
<p>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</p>
<ul>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ul>
<h2 id="多段数据" tabindex="-1"> 多段数据</h2>
<p>刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</p>
<p>这种情况需要使用一种特殊的 MIME 类型：“<strong>multipart/byteranges</strong>”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“<strong>boundary=xxx</strong>”给出段之间的分隔标记。</p>
<p>多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段，可以通过图来对比一下。</p>
<p><img src="https://img-blog.csdnimg.cn/d8598e07ad224b309c9f3c59485caf47.png" alt=""></p>
<p>每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。</p>
<p>例如，我们在实验环境里用 Telnet 发出有两个范围的请求：</p>
<div><pre><code>GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-9, 20-29
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>得到的就会是下面这样：</p>
<div><pre><code>HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes
 
 
--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96
 
// this is
--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96
 
ext json d
--00000000001--
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>报文里的“- -00000000001”就是多段的分隔符，使用它客户端就可以很容易地区分出多段 Range 数据。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 传输大文件相关的知识，在这里做一下简单小结：</p>
<ul>
<li>压缩 HTML 等文本文件是传输大文件最基本的方法；</li>
<li>分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；</li>
<li>范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；</li>
<li>也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。</li>
<li>要注意这四种方法不是互斥的，而是可以混合起来使用，例如压缩后再分块传输，或者分段后再分块，实验环境的 URI“/16-3”就模拟了后一种的情形，你可以自己用 Telnet 试一下。</li>
</ul>
<p>课下作业
分块传输数据的时候，如果数据里含有回车换行（\r\n）是否会影响分块的处理呢？
如果对一个被 gzip 的文件执行范围请求，比如“Range: bytes=10-19”，那么这个范围是应用于原文件还是压缩后的文件呢？</p>
<p>欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/0832723e7df1420e9a96e27b12de6273.png" type="image/png"/>
    </item>
    <item>
      <title>17 | 排队也要讲效率：HTTP的连接管理</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson17.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson17.html</guid>
      <source url="https://0808200.xyz/rss.xml">17 | 排队也要讲效率：HTTP的连接管理</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_17-排队也要讲效率-http的连接管理" tabindex="-1"> 17 | 排队也要讲效率：HTTP的连接管理</h1>
<p>在第 14 讲里，我曾经提到过 HTTP 的性能问题，用了六个字来概括：“不算差，不够好”。同时，我也谈到了“队头阻塞”，但由于时间的限制没有展开来细讲，这次就来好好地看看 HTTP 在连接这方面的表现。</p>
<p>HTTP 的连接管理也算得上是个“老生常谈”的话题了，你一定曾经听说过“短连接”“长连接”之类的名词，今天让我们一起来把它们弄清楚。</p>
<h2 id="短连接" tabindex="-1"> 短连接</h2>
<p>HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的“请求 - 应答”方式。</p>
<p>它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。</p>
<p>因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“<strong>短连接</strong>”（short-lived connections）。早期的 HTTP 协议也被称为是“<strong>无连接</strong>”的协议。</p>
<p>短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。</p>
<p>而 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是“3÷5=60%”，有三分之二的时间被浪费掉了，传输效率低得惊人。</p>
<p><img src="https://img-blog.csdnimg.cn/c52c7c76487742ae8008a665988ec863.png" alt=""></p>
<p>单纯地从理论上讲，TCP 协议你可能还不太好理解，我就拿打卡考勤机来做个形象的比喻吧。</p>
<p>假设你的公司买了一台打卡机，放在前台，因为这台机器比较贵，所以专门做了一个保护罩盖着它，公司要求每次上下班打卡时都要先打开盖子，打卡后再盖上盖子。</p>
<p>可是偏偏这个盖子非常牢固，打开关闭要费很大力气，打卡可能只要 1 秒钟，而开关盖子却需要四五秒钟，大部分时间都浪费在了毫无意义的开关盖子操作上了。</p>
<p>可想而知，平常还好说，一到上下班的点在打卡机前就会排起长队，每个人都要重复“开盖 - 打卡 - 关盖”的三个步骤，你说着急不着急。</p>
<p>在这个比喻里，打卡机就相当于服务器，盖子的开关就是 TCP 的连接与关闭，而每个打卡的人就是 HTTP 请求，很显然，短连接的缺点严重制约了服务器的服务能力，导致它无法处理更多的请求。</p>
<h2 id="长连接" tabindex="-1"> 长连接</h2>
<p>针对短连接暴露出的缺点，HTTP 协议就提出了“<strong>长连接</strong>”的通信方式，也叫“<strong>持久连接</strong>”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。</p>
<p>其实解决办法也很简单，用的就是“<strong>成本均摊</strong>”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上。</p>
<p>这样虽然不能改善 TCP 的连接效率，但基于“<strong>分母效应</strong>”，每个“请求 - 应答”的无效时间就会降低不少，整体传输效率也就提高了。</p>
<p>这里我画了一个短连接与长连接的对比示意图。</p>
<p><img src="https://img-blog.csdnimg.cn/cbc399de1f544fc6847684bea7929719.png" alt=""></p>
<p>在短连接里发送了三次 HTTP“请求 - 应答”，每次都会浪费 60% 的 RTT 时间。而在长连接的情况下，同样发送三次请求，因为只在第一次时建立连接，在最后一次时关闭连接，所以浪费率就是“3÷9≈33%”，降低了差不多一半的时间损耗。显然，如果在这个长连接上发送的请求越多，分母就越大，利用率也就越高。</p>
<p>继续用刚才的打卡机的比喻，公司也觉得这种反复“开盖 - 打卡 - 关盖”的操作太“反人类”了，于是颁布了新规定，早上打开盖子后就不用关上了，可以自由打卡，到下班后再关上盖子。</p>
<p>这样打卡的效率（即服务能力）就大幅度提升了，原来一次打卡需要五六秒钟，现在只要一秒就可以了，上下班时排长队的景象一去不返，大家都开心。</p>
<h2 id="连接相关的头字段" tabindex="-1"> 连接相关的头字段</h2>
<p>由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</p>
<p>当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是<strong>Connection</strong>，值是“<strong>keep-alive</strong>”。</p>
<p>不过不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“<strong>Connection: keep-alive</strong>”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。</p>
<p>你可以在实验环境里访问 URI“/17-1”，用 Chrome 看一下服务器返回的响应头：</p>
<p><img src="https://img-blog.csdnimg.cn/3b84b2abfb5b4d8289180b1469f8f96f.png" alt=""></p>
<p>不过长连接也有一些小缺点，问题就出在它的“长”字上。</p>
<p>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</p>
<p>所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。</p>
<p>在客户端，可以在请求头里加上“<strong>Connection: close</strong>”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p>
<p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ol>
<li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ol>
<p>另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</p>
<p>我们的实验环境配置了“keepalive_timeout 60”和“keepalive_requests 5”，意思是空闲连接最多 60 秒，最多发送 5 个请求。所以，如果连续刷新五次页面，就能看到响应头里的“Connection: close”了。</p>
<p>把这个过程用 Wireshark 抓一下包，就能够更清晰地看到整个长连接中的握手、收发数据与挥手过程，在课后你可以再实际操作看看。</p>
<p><img src="https://img-blog.csdnimg.cn/54456f8aceaa417fa7ea8bb6b4b72fdd.png" alt=""></p>
<h2 id="队头阻塞" tabindex="-1"> 队头阻塞</h2>
<p>看完了短连接和长连接，接下来就要说到著名的“队头阻塞”（Head-of-line blocking，也叫“队首阻塞”）了。</p>
<p>“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。</p>
<p>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p>
<p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p>
<p><img src="https://img-blog.csdnimg.cn/953b3bb6ed9042e9ab4775438fdd1edb.png" alt=""></p>
<p>还是用打卡机做个比喻。</p>
<p>上班的时间点上，大家都在排队打卡，可这个时候偏偏最前面的那个人遇到了打卡机故障，怎么也不能打卡成功，急得满头大汗。等找人把打卡机修好，后面排队的所有人全迟到了。</p>
<h2 id="性能优化" tabindex="-1"> 性能优化</h2>
<p>因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？</p>
<p>公司里可以再多买几台打卡机放在前台，这样大家可以不用挤在一个队伍里，分散打卡，一个队伍偶尔阻塞也不要紧，可以改换到其他不阻塞的队伍。</p>
<p>这在 HTTP 里就是“<strong>并发连接</strong>”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。</p>
<p>但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。</p>
<p>所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。</p>
<p>但“并发连接”所压榨出的性能也跟不上高速发展的互联网无止境的需求，还有什么别的办法吗？</p>
<p>公司发展的太快了，员工越来越多，上下班打卡成了迫在眉睫的大问题。前台空间有限，放不下更多的打卡机了，怎么办？那就多开几个打卡的地方，每个楼层、办公区的入口也放上三四台打卡机，把人进一步分流，不要都往前台挤。</p>
<p>这个就是“<strong>域名分片</strong>”（domain sharding）技术，还是用数量来解决质量的思路。</p>
<p>HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 www.chrono.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>这一讲中我们学习了 HTTP 协议里的短连接和长连接，简单小结一下今天的内容：</p>
<ul>
<li>早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；</li>
<li>HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；</li>
<li>服务器会发送“Connection: keep-alive”字段表示启用了长连接；</li>
<li>报文头里如果有“Connection: close”就意味着长连接即将关闭；</li>
<li>过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；</li>
<li>“队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。</li>
</ul>
<p>课下作业
在开发基于 HTTP 协议的客户端时应该如何选择使用的连接模式呢？短连接还是长连接？
应当如何降低长连接对服务器的负面影响呢？</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/c52c7c76487742ae8008a665988ec863.png" type="image/png"/>
    </item>
    <item>
      <title>18 | 四通八达：HTTP的重定向和跳转</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson18.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson18.html</guid>
      <source url="https://0808200.xyz/rss.xml">18 | 四通八达：HTTP的重定向和跳转</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_18-四通八达-http的重定向和跳转" tabindex="-1"> 18 | 四通八达：HTTP的重定向和跳转</h1>
<p>在专栏第 1 讲时我曾经说过，为了实现在互联网上构建超链接文档系统的设想，蒂姆·伯纳斯 - 李发明了万维网，使用 HTTP 协议传输“超文本”，让全世界的人都能够自由地共享信息。</p>
<p>“超文本”里含有“超链接”，可以从一个“超文本”跳跃到另一个“超文本”，对线性结构的传统文档是一个根本性的变革。</p>
<p>能够使用“超链接”在网络上任意地跳转也是万维网的一个关键特性。它把分散在世界各地的文档连接在一起，形成了复杂的网状结构，用户可以在查看时随意点击链接、转换页面。再加上浏览器又提供了“前进”“后退”“书签”等辅助功能，让用户在文档间跳转时更加方便，有了更多的主动性和交互性。</p>
<p>那么，点击页面“链接”时的跳转是怎样的呢？具体一点，比如在 Nginx 的主页上点了一下“download”链接，会发生什么呢？</p>
<p>结合之前的课程，稍微思考一下你就能得到答案：浏览器首先要解析链接文字里的 URI。</p>
<div><pre><code>http://nginx.org/en/download.html
</code></pre><div aria-hidden="true"><div></div></div></div><p>再用这个 URI 发起一个新的 HTTP 请求，获取响应报文后就会切换显示内容，渲染出新 URI 指向的页面。</p>
<p>这样的跳转动作是由浏览器的使用者主动发起的，可以称为“<strong>主动跳转</strong>”，但还有一类跳转是由服务器来发起的，浏览器使用者无法控制，相对地就可以称为“<strong>被动跳转</strong>”，这在 HTTP 协议里有个专门的名词，叫做“<strong>重定向</strong>”（Redirection）。</p>
<h2 id="重定向的过程" tabindex="-1"> 重定向的过程</h2>
<p>其实之前我们就已经见过重定向了，在第 12 讲里 3××状态码时就说过，301 是“永久重定向”，302 是“临时重定向”，浏览器收到这两个状态码就会跳转到新的 URI。</p>
<p>那么，它们是怎么做到的呢？难道仅仅用这两个代码就能够实现跳转页面吗？</p>
<p>先在实验环境里看一下重定向的过程吧，用 Chrome 访问 URI “/18-1”，它会使用 302 立即跳转到“/index.html”。</p>
<p><img src="https://img-blog.csdnimg.cn/665beea8d06245f38becde2b28e5bf3c.png" alt=""></p>
<p>从这个实验可以看到，这一次“重定向”实际上发送了两次 HTTP 请求，第一个请求返回了 302，然后第二个请求就被重定向到了“/index.html”。但如果不用开发者工具的话，你是完全看不到这个跳转过程的，也就是说，重定向是“用户无感知”的。</p>
<p>我们再来看看第一个请求返回的响应报文：</p>
<p><img src="https://img-blog.csdnimg.cn/f9fb7872473a40fd8560a7e4e476750f.png" alt=""></p>
<p>这里出现了一个新的头字段“Location: /index.html”，它就是 301/302 重定向跳转的秘密所在。</p>
<p>“<strong>Location</strong>”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它<strong>标记了服务器要求重定向的 URI</strong>，这里就是要求浏览器跳转到“index.html”。</p>
<p>浏览器收到 301/302 报文，会检查响应头里有没有“Location”。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求，相当于自动替我们点击了这个链接。</p>
<p>在“Location”里的 URI 既可以使用绝对 URI，也可以使用相对 URI。所谓“绝对 URI”，就是完整形式的 URI，包括 scheme、host:port、path 等。所谓“相对 URI”，就是省略了 scheme 和 host:port，只有 path 和 query 部分，是不完整的，但可以从请求上下文里计算得到。</p>
<p>例如，刚才的实验例子里的“Location: /index.html”用的就是相对 URI。它没有说明访问 URI 的协议和主机，但因为是由“<code>http://www.chrono.com/18-1</code>”重定向返回的响应报文，所以浏览器就可以拼出完整的 URI：</p>
<div><pre><code>http://www.chrono.com/index.html
</code></pre><div aria-hidden="true"><div></div></div></div><p>实验环境的 URI“/18-1”还支持使用 query 参数“dst=xxx”，指明重定向的 URI，你可以用这种形式再多试几次重定向，看看浏览器是如何工作的。</p>
<div><pre><code>http://www.chrono.com/18-1?dst=/15-1?name=a.json
http://www.chrono.com/18-1?dst=/17-1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>注意，在重定向时如果只是在站内跳转，你可以放心地使用相对 URI。但如果要跳转到站外，就必须用绝对 URI。</p>
<p>例如，如果想跳转到 Nginx 官网，就必须在“nginx.org”前把“http://”都写出来，否则浏览器会按照相对 URI 去理解，得到的就会是一个不存在的 URI“<code>http://www.chrono.com/nginx.org</code>”</p>
<div><pre><code>http://www.chrono.com/18-1?dst=nginx.org           # 错误
http://www.chrono.com/18-1?dst=http://nginx.org    # 正确
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/52af1ad8123d4b76a13824e7737f0f80.png" alt=""></p>
<p>那么，如果 301/302 跳转时没有 Location 字段会怎么样呢？</p>
<p>这个你也可以自己试一下，使用第 12 讲里的 URI“/12-1”，查询参数用“code=302”：</p>
<div><pre><code>http://www.chrono.com/12-1?code=302
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="重定向状态码" tabindex="-1"> 重定向状态码</h2>
<p>刚才我把重定向的过程基本讲完了，现在来说一下重定向用到的状态码。</p>
<p>最常见的重定向状态码就是 301 和 302，另外还有几个不太常见的，例如 303、307、308 等。它们最终的效果都差不多，让浏览器跳转到新的 URI，但语义上有一些细微的差别，使用的时候要特别注意。</p>
<p><strong>301</strong>俗称“<strong>永久重定向</strong>”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。</p>
<p>浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。</p>
<p><strong>302</strong>俗称“<strong>临时重定向</strong>”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。</p>
<p>浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。</p>
<p>301/302 是最常用的重定向状态码，在 3××里剩下的几个还有：</p>
<ul>
<li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。</li>
</ul>
<p>不过这三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用。</p>
<h2 id="重定向的应用场景" tabindex="-1"> 重定向的应用场景</h2>
<p>理解了重定向的工作原理和状态码的含义，我们就可以<strong>在服务器端拥有主动权</strong>，控制浏览器的行为，不过要怎么利用重定向才好呢？</p>
<p>使用重定向跳转，核心是要理解“<strong>重定向</strong>”和“<strong>永久 / 临时</strong>”这两个关键词。</p>
<p>先来看什么时候需要重定向。</p>
<p>一个最常见的原因就是“<strong>资源不可用</strong>”，需要用另一个新的 URI 来代替。</p>
<p>至于不可用的原因那就很多了。例如域名变更、服务器变更、网站改版、系统维护，这些都会导致原 URI 指向的资源无法访问，为了避免出现 404，就需要用重定向跳转到新的 URI，继续为网民提供服务。</p>
<p>另一个原因就是“<strong>避免重复</strong>”，让多个网址都跳转到一个 URI，增加访问入口的同时还不会增加额外的工作量。</p>
<p>例如，有的网站都会申请多个名称类似的域名，然后把它们再重定向到主站上。比如，你可以访问一下“qq.com”“github.com ”“bing.com”（记得事先清理缓存），看看它是如何重定向的。</p>
<p>决定要实行重定向后接下来要考虑的就是“永久”和“临时”的问题了，也就是选择 301 还是 302。</p>
<p>301 的含义是“永久”的。</p>
<p>如果域名、服务器、网站架构发生了大幅度的改变，比如启用了新域名、服务器切换到了新机房、网站目录层次重构，这些都算是“永久性”的改变。原来的 URI 已经不能用了，必须用 301“永久重定向”，通知浏览器和搜索引擎更新到新地址，这也是搜索引擎优化（SEO）要考虑的因素之一。</p>
<p>302 的含义是“临时”的。</p>
<p>原来的 URI 在将来的某个时间点还会恢复正常，常见的应用场景就是系统维护，把网站重定向到一个通知页面，告诉用户过一会儿再来访问。另一种用法就是“服务降级”，比如在双十一促销的时候，把订单查询、领积分等不重要的功能入口暂时关闭，保证核心服务能够正常运行。</p>
<h2 id="重定向的相关问题" tabindex="-1"> 重定向的相关问题</h2>
<p>重定向的用途很多，掌握了重定向，就能够在架设网站时获得更多的灵活性，不过在使用时还需要注意两个问题。</p>
<p>第一个问题是“<strong>性能损耗</strong>”。很明显，重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次。</p>
<p>虽然 301/302 报文很小，但大量的跳转对服务器的影响也是不可忽视的。站内重定向还好说，可以长连接复用，站外重定向就要开两个连接，如果网络连接质量差，那成本可就高多了，会严重影响用户的体验。</p>
<p>所以重定向应当适度使用，决不能滥用。</p>
<p>第二个问题是“<strong>循环跳转</strong>”。如果重定向的策略设置欠考虑，可能会出现“A=&gt;B=&gt;C=&gt;A”的无限循环，不停地在这个链路里转圈圈，后果可想而知。</p>
<p>所以 HTTP 协议特别规定，浏览器必须具有检测“循环跳转”的能力，在发现这种情况时应当停止发送请求并给出错误提示。</p>
<p>实验环境的 URI“/18-2”就模拟了这样的一个“循环跳转”，它跳转到“/18-1”，并用参数“dst=/18-2”再跳回自己，实现了两个 URI 的无限循环。</p>
<p>使用 Chrome 访问这个地址，会得到“该网页无法正常运作”的结果：</p>
<p><img src="https://img-blog.csdnimg.cn/1cdb7c7a6eb14136b398ff90fc919c56.png" alt=""></p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 里的重定向和跳转，简单小结一下这次的内容：</p>
<ul>
<li>重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；</li>
<li>301/302 是最常用的重定向状态码，分别是“永久重定向”和“临时重定向”；</li>
<li>响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；</li>
<li>重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多；</li>
<li>使用重定向时需要当心性能损耗，还要避免出现循环跳转。</li>
</ul>
<p>课下作业
301 和 302 非常相似，试着结合第 12 讲，用自己的理解再描述一下两者的异同点。
你能结合自己的实际情况，再列出几个应当使用重定向的场景吗？</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/665beea8d06245f38becde2b28e5bf3c.png" type="image/png"/>
    </item>
    <item>
      <title>19 | 让我知道你是谁：HTTP的Cookie机制</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson19.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson19.html</guid>
      <source url="https://0808200.xyz/rss.xml">19 | 让我知道你是谁：HTTP的Cookie机制</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_19-让我知道你是谁-http的cookie机制" tabindex="-1"> 19 | 让我知道你是谁：HTTP的Cookie机制</h1>
<p>在之前的第 13、14 讲中，我曾经说过，HTTP 是“无状态”的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作。</p>
<p>好在 HTTP 协议是可扩展的，后来发明的 Cookie 技术，给 HTTP 增加了“记忆能力”。</p>
<h2 id="什么是-cookie" tabindex="-1"> 什么是 Cookie？</h2>
<p>不知道你有没有看过克里斯托弗·诺兰导演的一部经典电影《记忆碎片》（Memento），里面的主角患有短期失忆症，记不住最近发生的事情。</p>
<p>比如，电影里有个场景，某人刚跟主角说完话，大闹了一通，过了几分钟再回来，主角却是一脸茫然，完全不记得这个人是谁，刚才又做了什么，只能任人摆布。</p>
<p>这种情况就很像 HTTP 里“无状态”的 Web 服务器，只不过服务器的“失忆症”比他还要严重，连一分钟的记忆也保存不了，请求处理完立刻就忘得一干二净。即使这个请求会让服务器发生 500 的严重错误，下次来也会依旧“热情招待”。</p>
<p>如果 Web 服务器只是用来管理静态文件还好说，对方是谁并不重要，把文件从磁盘读出来发走就可以了。但随着 HTTP 应用领域的不断扩大，对“记忆能力”的需求也越来越强烈。比如网上论坛、电商购物，都需要“看客下菜”，只有记住用户的身份才能执行发帖子、下订单等一系列会话事务。</p>
<p>那该怎么样让原本无“记忆能力”的服务器拥有“记忆能力”呢？</p>
<p>看看电影里的主角是怎么做的吧。他通过纹身、贴纸条、立拍得等手段，在外界留下了各种记录，一旦失忆，只要看到这些提示信息，就能够在头脑中快速重建起之前的记忆，从而把因失忆而耽误的事情继续做下去。</p>
<p>HTTP 的 Cookie 机制也是一样的道理，既然服务器记不住，那就在外部想办法记住。相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。</p>
<h2 id="cookie-的工作过程" tabindex="-1"> Cookie 的工作过程</h2>
<p>那么，Cookie 这张小纸条是怎么传递的呢？</p>
<p>这要用到两个字段：响应头字段<strong>Set-Cookie</strong>和请求头字段<strong>Cookie</strong>。</p>
<p>当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的身份标识数据，格式是“<strong>key=value</strong>”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。</p>
<p>浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。</p>
<p>因为第二次请求里面有了 Cookie 字段，服务器就知道这个用户不是新人，之前来过，就可以拿出 Cookie 里的值，识别出用户的身份，然后提供个性化的服务。</p>
<p>不过因为服务器的“记忆能力”实在是太差，一张小纸条经常不够用。所以，服务器有时会在响应头里添加多个 Set-Cookie，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行。</p>
<p>我画了一张图来描述这个过程，你看过就能理解了。</p>
<p><img src="https://img-blog.csdnimg.cn/cfadbfadc7684281abe5c44c923ebccb.png" alt=""></p>
<p>从这张图中我们也能够看到，Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。</p>
<p>如果你换个浏览器或者换台电脑，新的浏览器里没有服务器对应的 Cookie，就好像是脱掉了贴着纸条的衣服，“健忘”的服务器也就认不出来了，只能再走一遍 Set-Cookie 流程。</p>
<p>在实验环境里，你可以用 Chrome 访问 URI“/19-1”，实地看一下 Cookie 工作过程。</p>
<p>首次访问时服务器会设置两个 Cookie。</p>
<p><img src="https://img-blog.csdnimg.cn/106edf8fcb474c18b079bf6a347f6f21.png" alt=""></p>
<p>然后刷新这个页面，浏览器就会在请求头里自动送出 Cookie，服务器就能认出你了。</p>
<p><img src="https://img-blog.csdnimg.cn/20b5c370a9884c6aab7bd363c4e96515.png" alt=""></p>
<p>如果换成 Firefox 等其他浏览器，因为 Cookie 是存在 Chrome 里的，所以服务器就又“蒙圈”了，不知道你是谁，就会给 Firefox 再贴上小纸条。</p>
<h2 id="ookie-的属性" tabindex="-1"> ookie 的属性</h2>
<p>说到这里，你应该知道了，Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息。所以，就需要在“key=value”外再用一些手段来保护，防止外泄或窃取，这些手段就是 Cookie 的属性。</p>
<p>下面这个截图是实验环境“/19-2”的响应头，我来对着这个实际案例讲一下都有哪些常见的 Cookie 属性。</p>
<p><img src="https://img-blog.csdnimg.cn/e1e3c5b510e74771bc0ea75c36ed5326.png" alt=""></p>
<p>首先，我们应该<strong>设置 Cookie 的生存周期</strong>，也就是它的有效期，让它只能在一段时间内可用，就像是食品的“保鲜期”，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。</p>
<p>Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。</p>
<p>“<strong>Expires</strong>”俗称“<strong>过期时间</strong>”，用的是绝对时间点，可以理解为“截止日期”（deadline）。“<strong>Max-Age</strong>”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。</p>
<p>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。</p>
<p>比如在这个例子里，Expires 标记的过期时间是“GMT 2019 年 6 月 7 号 8 点 19 分”，而 Max-Age 则只有 10 秒，如果现在是 6 月 6 号零点，那么 Cookie 的实际有效期就是“6 月 6 号零点过 10 秒”。</p>
<p>其次，我们需要<strong>设置 Cookie 的作用域</strong>，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。</p>
<p>作用域的设置比较简单，“<strong>Domain</strong>”和“<strong>Path</strong>”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</p>
<p>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如“/19-1”用一个 Cookie，“/19-2”再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。</p>
<p>最后要考虑的就是<strong>Cookie 的安全性</strong>了，尽量不要让服务器以外的人看到。</p>
<p>写过前端的同学一定知道，在 JS 脚本里可以用 document.cookie 来读写 Cookie 数据，这就带来了安全隐患，有可能会导致“跨站脚本”（XSS）攻击窃取数据。</p>
<p>属性“<strong>HttpOnly</strong>”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</p>
<p>另一个属性“<strong>SameSite</strong>”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</p>
<p>还有一个属性叫“<strong>Secure</strong>”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</p>
<p>Chrome 开发者工具是查看 Cookie 的有力工具，在“Network-Cookies”里可以看到单个页面 Cookie 的各种属性，另一个“Application”面板里则能够方便地看到全站的所有 Cookie。</p>
<p><img src="https://img-blog.csdnimg.cn/c90a9f5b9d3f4cb59a1f01a23412efb1.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/a14851d9d7af4b848e0229e26878d923.png" alt=""></p>
<h2 id="cookie-的应用" tabindex="-1"> Cookie 的应用</h2>
<p>现在回到我们最开始的话题，有了 Cookie，服务器就有了“记忆能力”，能够保存“状态”，那么应该如何使用 Cookie 呢？</p>
<p>Cookie 最基本的一个用途就是<strong>身份识别</strong>，保存用户的登录信息，实现会话事务。</p>
<p>比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie，内容大概是“name=yourid”，这样就成功地把身份标签贴在了你身上。</p>
<p>之后你在网站里随便访问哪件商品的页面，浏览器都会自动把身份 Cookie 发给服务器，所以服务器总会知道你的身份，一方面免去了重复登录的麻烦，另一方面也能够自动记录你的浏览记录和购物下单（在后台数据库或者也用 Cookie），实现了“状态保持”。</p>
<p>Cookie 的另一个常见用途是<strong>广告跟踪</strong>。</p>
<p>你上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google），它会“偷偷地”给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。</p>
<p>这种 Cookie 不是由访问的主站存储的，所以又叫“第三方 Cookie”（third-party cookie）。如果广告商势力很大，广告到处都是，那么就比较“恐怖”了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告“精准打击”。</p>
<p>为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT（Do Not Track）和 P3P（Platform for Privacy Preferences Project），但实际作用不大。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 里的 Cookie 知识。虽然现在已经出现了多种 Local Web Storage 技术，能够比 Cookie 存储更多的数据，但 Cookie 仍然是最通用、兼容性最强的客户端数据存储手段。</p>
<p>简单小结一下今天的内容：</p>
<ul>
<li>Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”；</li>
<li>响应报文使用 Set-Cookie 字段发送“key=value”形式的 Cookie 值；</li>
<li>请求报文里用 Cookie 字段发送多个 Cookie 值；</li>
<li>为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 等；</li>
<li>Cookie 最基本的用途是身份识别，实现有状态的会话事务。</li>
</ul>
<p>还要提醒你一点，因为 Cookie 并不属于 HTTP 标准（RFC6265，而不是 RFC2616/7230），所以语法上与其他字段不太一致，使用的分隔符是“;”，与 Accept 等字段的“,”不同，小心不要弄错了。</p>
<p>课下作业
如果 Cookie 的 Max-Age 属性设置为 0，会有什么效果呢？
Cookie 的好处已经很清楚了，你觉得它有什么缺点呢？</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/cfadbfadc7684281abe5c44c923ebccb.png" type="image/png"/>
    </item>
    <item>
      <title>20 | 生鲜速递：HTTP的缓存控制</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson20.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson20.html</guid>
      <source url="https://0808200.xyz/rss.xml">20 | 生鲜速递：HTTP的缓存控制</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_20-生鲜速递-http的缓存控制" tabindex="-1"> 20 | 生鲜速递：HTTP的缓存控制</h1>
<p>缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。</p>
<p>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。</p>
<p>试想一下，如果有几十 K 甚至几十 M 的数据，不是从网络而是从本地磁盘获取，那将是多么大的一笔节省，免去多少等待的时间。</p>
<p>实际上，HTTP 传输的每一个环节基本上都会有缓存，非常复杂。</p>
<p>基于“请求 - 应答”模式的特点，可以大致分为客户端缓存和服务器端缓存，因为服务器端缓存经常与代理服务“混搭”在一起，所以今天我先讲客户端——也就是浏览器的缓存。</p>
<h2 id="服务器的缓存控制" tabindex="-1"> 服务器的缓存控制</h2>
<p>为了更好地说明缓存的运行机制，下面我用“生鲜速递”作为比喻，看看缓存是如何工作的。</p>
<p>夏天到了，天气很热。你想吃西瓜消暑，于是打开冰箱，但很不巧，冰箱是空的。不过没事，现在物流很发达，给生鲜超市打个电话，不一会儿，就给你送来一个 8 斤的沙瓤大西瓜，上面还贴着标签：“保鲜期 5 天”。好了，你把它放进冰箱，想吃的时候随时拿出来。</p>
<p>在这个场景里，“生鲜超市”就是 Web 服务器，“你”就是浏览器，“冰箱”就是浏览器内部的缓存。整个流程翻译成 HTTP 就是：</p>
<ol>
<li>浏览器发现缓存无数据，于是发送请求，向服务器获取资源；</li>
<li>服务器响应请求，返回资源，同时标记资源的有效期；</li>
<li>浏览器缓存资源，等待下次重用。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/7cbaf3dadb074f4692d761c2ed2dcca7.png" alt=""></p>
<p>你可以访问实验环境的 URI “/20-1”，看看具体的请求 - 应答过程。</p>
<p><img src="https://img-blog.csdnimg.cn/631043a641a54daf9d1a6fd5c59db3ca.png" alt=""></p>
<p>服务器标记资源有效期使用的头字段是“<strong>Cache-Control</strong>”，里面的值“<strong>max-age=30</strong>”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</p>
<p>你可能要问了，让浏览器直接缓存数据就好了，为什么要加个有效期呢？</p>
<p>这是因为网络上的数据随时都在变化，不能保证它稍后的一段时间还是原来的样子。就像生鲜超市给你快递的西瓜，只有 5 天的保鲜期，过了这个期限最好还是别吃，不然可能会闹肚子。</p>
<p>“Cache-Control”字段里的“max-age”和上一讲里 Cookie 有点像，都是标记资源的有效期。</p>
<p>但我必须提醒你注意，这里的 max-age 是“<strong>生存时间</strong>”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。</p>
<p>比如，服务器设定“max-age=5”，但因为网络质量很糟糕，等浏览器收到响应报文已经过去了 4 秒，那么这个资源在客户端就最多能够再存 1 秒钟，之后就会失效。</p>
<p>“max-age”是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存：</p>
<ul>
<li>no_store：<strong>不允许缓存</strong>，用于某些变化非常频繁的数据，例如秒杀页面；</li>
<li>no_cache：它的字面含义容易与 no_store 搞混，实际的意思并不是不允许缓存，而是<strong>可以缓存</strong>，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；</li>
<li>must-revalidate：又是一个和 no_cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。</li>
</ul>
<p>听的有点糊涂吧。没关系，我拿生鲜速递来举例说明一下：</p>
<ul>
<li>no_store：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉；</li>
<li>no_cache：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的；</li>
<li>must-revalidate：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。</li>
</ul>
<p>你看，这超市管的还真多啊，西瓜到了家里怎么吃还得听他。不过没办法，在 HTTP 协议里服务器就是这样的“霸气”。</p>
<p>我把服务器的缓存控制策略画了一个流程图，对照着它你就可以在今后的后台开发里明确“Cache-Control”的用法了。</p>
<p><img src="https://img-blog.csdnimg.cn/d7915bb206a74e5b9d8cdc43df7abaf4.png" alt=""></p>
<h2 id="客户端的缓存控制" tabindex="-1"> 客户端的缓存控制</h2>
<p>现在冰箱里已经有了“缓存”的西瓜，是不是就可以直接开吃了呢？</p>
<p>你可以在 Chrome 里点几次“刷新”按钮，估计你会失望，页面上的 ID 一直在变，根本不是缓存的结果，明明说缓存 30 秒，怎么就不起作用呢？</p>
<p>其实不止服务器可以发“Cache-Control”头，浏览器也可以发“Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。</p>
<p>当你点“刷新”按钮的时候，浏览器会在请求头里加一个“<strong>Cache-Control: max-age=0</strong>”。因为 max-age 是“<strong>生存时间</strong>”，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。</p>
<p>Ctrl+F5 的“强制刷新”又是什么样的呢？</p>
<p>它其实是发了一个“<strong>Cache-Control: no-cache</strong>”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</p>
<p><img src="https://img-blog.csdnimg.cn/6c8d21f6095648b4bba99d388d08d19e.png" alt=""></p>
<p>那么，浏览器的缓存究竟什么时候才能生效呢？</p>
<p>别着急，试着点一下浏览器的“前进”“后退”按钮，再看开发者工具，你就会惊喜地发现“from disk cache”的字样，意思是没有发送网络请求，而是读取的磁盘上的缓存。</p>
<p>另外，如果用第 18 讲里的重定向跳转功能，也可以发现浏览器使用了缓存：</p>
<div><pre><code>http://www.chrono.com/18-1?dst=20-1
</code></pre><div aria-hidden="true"><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/6c8d21f6095648b4bba99d388d08d19e.png" alt=""></p>
<p>这几个操作与刷新有什么区别呢？</p>
<p>其实也很简单，在“前进”“后退”“跳转”这些重定向动作中浏览器不会“夹带私货”，只用最基本的请求头，没有“Cache-Control”，所以就会检查缓存，直接利用之前的资源，不再进行网络通信。</p>
<p>这个过程你也可以用 Wireshark 抓包，看看是否真的没有向服务器发请求。</p>
<h2 id="条件请求" tabindex="-1"> 条件请求</h2>
<p>浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。</p>
<p>那么该怎么做呢？</p>
<p>浏览器可以用两个连续的请求组成“验证动作”：先是一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一个 GET 请求，获取最新的版本。</p>
<p>但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了<strong>一系列“If”开头的“条件请求”字段</strong>，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。</p>
<p>条件请求一共有 5 个头字段，我们最常用的是“<strong>if-Modified-Since</strong>”和“<strong>If-None-Match</strong>”这两个。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</p>
<p>如果资源没有变，服务器就回应一个“<strong>304 Not Modified</strong>”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</p>
<p><img src="https://img-blog.csdnimg.cn/c51ccf7895754170843dad5cedcf79f5.png" alt=""></p>
<p>“Last-modified”很好理解，就是文件的最后修改时间。ETag 是什么呢？</p>
<p><strong>ETag</strong> 是“实体标签”（Entity Tag）的缩写，是<strong>资源的一个唯一标识</strong>，主要是用来解决修改时间无法准确区分文件变化的问题。</p>
<p>比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。</p>
<p>再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</p>
<p>使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。</p>
<p>ETag 还有“强”“弱”之分。</p>
<p>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p>
<p>还是拿生鲜速递做比喻最容易理解：</p>
<p>你打电话给超市，“我这个西瓜是 3 天前买的，还有最新的吗？”。超市看了一下库存，说：“没有啊，我这里都是 3 天前的。”于是你就知道了，再让超市送货也没用，还是吃冰箱里的西瓜吧。这就是“if-Modified-Since”和“Last-modified”。</p>
<p>但你还是想要最新的，就又打电话：“有不是沙瓤的西瓜吗？”，超市告诉你都是沙瓤的（Match），于是你还是只能吃冰箱里的沙瓤西瓜。这就是“<strong>If-None-Match</strong>”和“<strong>弱 ETag</strong>”。</p>
<p>第三次打电话，你说“有不是 8 斤的沙瓤西瓜吗？”，这回超市给了你满意的答复：“有个 10 斤的沙瓤西瓜”。于是，你就扔掉了冰箱里的存货，让超市重新送了一个新的大西瓜。这就是“<strong>If-None-Match</strong>”和“<strong>强 ETag</strong>”。</p>
<p>再来看看实验环境的 URI “/20-2”。它为资源增加了 ETag 字段，刷新页面时浏览器就会同时发送缓存控制头“max-age=0”和条件请求头“If-None-Match”，如果缓存有效服务器就会返回 304：</p>
<p><img src="https://img-blog.csdnimg.cn/c51ccf7895754170843dad5cedcf79f5.png" alt=""></p>
<p>条件请求里其他的三个头字段是“If-Unmodified-Since”“If-Match”和“If-Range”，其实只要你掌握了“if-Modified-Since”和“If-None-Match”，可以轻易地“举一反三”。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTP 的缓存控制和条件请求，用好它们可以减少响应时间、节约网络流量，一起小结一下今天的内容吧：</p>
<ul>
<li>缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存；</li>
<li>服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有效期；</li>
<li>浏览器收到数据就会存入缓存，如果没过期就可以直接使用，过期就要去服务器验证是否仍然可用；</li>
<li>验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“If-None-Match”，收到 304 就可以复用缓存里的资源；</li>
<li>验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先在响应报文里设置，搭配条件请求使用；</li>
<li>浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。</li>
<li>HTTP 缓存看上去很复杂，但基本原理说白了就是一句话：“没有消息就是好消息”，“没有请求的请求，才是最快的请求。”</li>
</ul>
<p>课下作业
Cache 和 Cookie 都是服务器发给客户端并存储的数据，你能比较一下两者的异同吗？
即使有“Last-modified”和“ETag”，强制刷新（Ctrl+F5）也能够从服务器获取最新数据（返回 200 而不是 304），请你在实验环境里试一下，观察请求头和响应头，解释原因。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/7cbaf3dadb074f4692d761c2ed2dcca7.png" type="image/png"/>
    </item>
    <item>
      <title>21 | 良心中间商：HTTP的代理服务</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson21.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson21.html</guid>
      <source url="https://0808200.xyz/rss.xml">21 | 良心中间商：HTTP的代理服务</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_21-良心中间商-http的代理服务" tabindex="-1"> 21 | 良心中间商：HTTP的代理服务</h1>
<p>在前面讲 HTTP 协议的时候，我们严格遵循了 HTTP 的“请求 - 应答”模型，协议中只有两个互相通信的角色，分别是“请求方”浏览器（客户端）和“应答方”服务器。</p>
<p>今天，我们要在这个模型里引入一个新的角色，那就是<code>HTTP 代理</code>。</p>
<p>引入 HTTP 代理后，原来简单的双方通信就变复杂了一些，加入了一个或者多个中间人，但整体上来看，还是一个有顺序关系的链条，而且链条里相邻的两个角色仍然是简单的一对一通信，不会出现越级的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/7ce109228b7448cb9e75ba3ad38190ba.png" alt=""></p>
<p>链条的起点还是客户端（也就是浏览器），中间的角色被称为代理服务器（proxy server），链条的终点被称为源服务器（origin server），意思是数据的“源头”“起源”。</p>
<h2 id="代理服务" tabindex="-1"> 代理服务</h2>
<p>“代理”这个词听起来好像很神秘，有点“高大上”的感觉。</p>
<p>但其实 HTTP 协议里对它并没有什么特别的描述，它就是在客户端和服务器原本的通信链路中插入的一个中间环节，也是一台服务器，但提供的是“代理服务”。</p>
<p>所谓的“代理服务”就是指<code>服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份</code>：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。</p>
<p>还是拿上一讲的“生鲜超市”来打个比方。</p>
<p>之前你都是从超市里买东西，现在楼底下新开了一家 24 小时便利店，由超市直接供货，于是你就可以在便利店里买到原本必须去超市才能买到的商品。</p>
<p>这样超市就不直接和你打交道了，成了“源服务器”，便利店就成了超市的“代理服务器”。</p>
<p>在第 4 讲中，我曾经说过，代理有很多的种类，例如匿名代理、透明代理、正向代理和反向代理。</p>
<p>今天我主要讲的是实际工作中最常见的反向代理，它在传输链路中更靠近源服务器，为源服务器提供代理服务。</p>
<h2 id="代理的作用" tabindex="-1"> 代理的作用</h2>
<p>为什么要有代理呢？换句话说，代理能干什么、带来什么好处呢？</p>
<p>你也许听过这样一句至理名言：“<code>计算机科学领域里的任何问题，都可以通过引入一个中间层来解决</code>”（在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）。TCP/IP 协议栈是这样，而代理也是这样。</p>
<p>由于代理处在 HTTP 通信过程的中间位置，相应地就对上屏蔽了真实客户端，对下屏蔽了真实服务器，简单的说就是“<strong>欺上瞒下</strong>”。在这个中间层的“小天地”里就可以做很多的事情，为 HTTP 协议增加更多的灵活性，实现客户端和服务器的“双赢”。</p>
<p>代理最基本的一个功能是<strong>负载均衡</strong>。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的“大权”，决定由后面的哪台服务器来响应请求。</p>
<p><img src="https://img-blog.csdnimg.cn/471d0f12d3f64cc29b360499a4ce06b7.png" alt=""></p>
<p>代理中常用的负载均衡算法你应该也有所耳闻吧，比如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。</p>
<p>在负载均衡的同时，代理服务还可以执行更多的功能，比如：</p>
<ul>
<li>健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；</li>
<li>安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；</li>
<li>加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；</li>
<li>数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；</li>
<li>内容缓存：暂存、复用服务器响应，这个与第 20 讲密切相关，我们稍后再说。</li>
</ul>
<p>接着拿刚才的便利店来举例说明。</p>
<p>因为便利店和超市之间是专车配送，所以有了便利店，以后你买东西就更省事了，打电话给便利店让它去帮你取货，不用关心超市是否停业休息、是否人满为患，而且总能买到最新鲜的。</p>
<p>便利店同时也方便了超市，不用额外加大店面就可以增加客源和销量，货物集中装卸也节省了物流成本，由于便利店直接面对客户，所以也可以把恶意骚扰电话挡在外面。</p>
<h2 id="代理相关头字段" tabindex="-1"> 代理相关头字段</h2>
<p>代理的好处很多，但因为它“欺上瞒下”的特点，隐藏了真实客户端和服务器，如果双方想要获得这些“丢失”的原始信息，该怎么办呢？</p>
<p>首先，代理服务器需要用<code>字段“Via”标明代理的身份</code>。</p>
<p>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</p>
<p>如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。</p>
<p>例如下图中有两个代理：proxy1 和 proxy2，客户端发送请求会经过这两个代理，依次添加就是“Via: proxy1, proxy2”，等到服务器返回响应报文的时候就要反过来走，头字段就是“Via: proxy2, proxy1”。</p>
<p><img src="https://img-blog.csdnimg.cn/d7b4ea8b104441e6a71c149605fe3364.png" alt=""></p>
<p><code>Via</code>字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息。</p>
<p>但服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</p>
<p>可惜的是 HTTP 标准里并没有为此定义头字段，但已经出现了很多“事实上的标准”，<strong>最常用的两个头字段是“X-Forwarded-For”和“X-Real-IP”</strong>。</p>
<p>“X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。但“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就客户端的地址。</p>
<p>“X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是“X-Forwarded-For”的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。</p>
<p>我们的实验环境实现了一个反向代理，访问“http://www.chrono.com/21-1”，它会转而访问“http://origin.io”。这里的“origin.io”就是源站，它会在响应报文里输出“Via”“X-Forwarded-For”等代理头字段信息：</p>
<p><img src="https://img-blog.csdnimg.cn/78a4fb94e15f4b8f93883a33538b1aed.png" alt=""></p>
<p>单从浏览器的页面上很难看出代理做了哪些工作，因为代理的转发都在后台不可见，所以我把这个过程用 Wireshark 抓了一个包：</p>
<p><img src="https://img-blog.csdnimg.cn/817c3fa537b444288192caaf9b71e787.png" alt=""></p>
<p>从抓包里就可以清晰地看出代理与客户端、源服务器的通信过程：</p>
<ol>
<li>客户端 55061 先用三次握手连接到代理的 80 端口，然后发送 GET 请求；</li>
<li>代理不直接生产内容，所以就代表客户端，用 55063 端口连接到源服务器，也是三次握手；</li>
<li>代理成功连接源服务器后，发出了一个 HTTP/1.0 的 GET 请求；</li>
<li>因为 HTTP/1.0 默认是短连接，所以源服务器发送响应报文后立即用四次挥手关闭连接；</li>
<li>代理拿到响应报文后再发回给客户端，完成了一次代理服务。</li>
</ol>
<p>在这个实验中，你可以看到除了“X-Forwarded-For”和“X-Real-IP”，还出现了两个字段：“X-Forwarded-Host”和“X-Forwarded-Proto”，它们的作用与“X-Real-IP”类似，只记录客户端的信息，分别是客户端请求的原始域名和原始协议名。</p>
<h2 id="代理协议" tabindex="-1"> 代理协议</h2>
<p>有了“X-Forwarded-For”等头字段，源服务器就可以拿到准确的客户端信息了。但对于代理服务器来说它并不是一个最佳的解决方案。</p>
<p>因为通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。</p>
<p>另一个问题是“X-Forwarded-For”等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。</p>
<p>所以就出现了一个专门的“代理协议”（The PROXY protocol），它由知名的代理软件 HAProxy 所定义，也是一个“事实标准”，被广泛采用（注意并不是 RFC）。</p>
<p>“代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。今天只介绍比较好理解的 v1，它在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。</p>
<p>这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。</p>
<p>例如下面的这个例子，在 GET 请求行前多出了 PROXY 信息行，客户端的真实 IP 地址是“1.1.1.1”，端口号是 55555。</p>
<div><pre><code>PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n
GET / HTTP/1.1\r\n
Host: www.xxx.com\r\n
\r\n
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据，省了很多事情。</p>
<p>不过代理协议并不支持“X-Forwarded-For”的链式地址形式，所以拿到客户端地址后再如何处理就需要代理服务器与后端自行约定。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>HTTP 代理就是客户端和服务器通信链路中的一个中间环节，为两端提供“代理服务”；</li>
<li>代理处于中间层，为 HTTP 处理增加了更多的灵活性，可以实现负载均衡、安全防护、数据过滤等功能；</li>
<li>代理服务器需要使用字段“Via”标记自己的身份，多个代理会形成一个列表；</li>
<li>如果想要知道客户端的真实 IP 地址，可以使用字段“X-Forwarded-For”和“X-Real-IP”；</li>
<li>专门的“代理协议”可以在不改动原始报文的情况下传递客户端的真实 IP。</li>
</ul>
<p>课下作业
你觉得代理有什么缺点？实际应用时如何避免？
你知道多少反向代理中使用的负载均衡算法？它们有什么优缺点？</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/7ce109228b7448cb9e75ba3ad38190ba.png" type="image/png"/>
    </item>
    <item>
      <title>22 | 冷链周转：HTTP的缓存代理</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson22.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/4_advanced/lesson22.html</guid>
      <source url="https://0808200.xyz/rss.xml">22 | 冷链周转：HTTP的缓存代理</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_22-冷链周转-http的缓存代理" tabindex="-1"> 22 | 冷链周转：HTTP的缓存代理</h1>
<p>在第 20 讲中，我介绍了 HTTP 的缓存控制，第 21 讲我介绍了 HTTP 的代理服务。那么，把这两者结合起来就是这节课所要说的“<strong>缓存代理</strong>”，也就是支持缓存控制的代理服务。</p>
<p>之前谈到缓存时，主要讲了客户端（浏览器）上的缓存控制，它能够减少响应时间、节约带宽，提升客户端的用户体验。</p>
<p>但 HTTP 传输链路上，不只是客户端有缓存，服务器上的缓存也是非常有价值的，可以让请求不必走完整个后续处理流程，“就近”获得响应结果。</p>
<p>特别是对于那些“读多写少”的数据，例如突发热点新闻、爆款商品的详情页，一秒钟内可能有成千上万次的请求。即使仅仅缓存数秒钟，也能够把巨大的访问流量挡在外面，让 RPS（request per second）降低好几个数量级，减轻应用服务器的并发压力，对性能的改善是非常显著的。</p>
<p>HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然也经常有各种缓存（如 Memcache、Redis、Varnish 等），但与 HTTP 没有太多关系，所以这里暂且不说。</p>
<h2 id="缓存代理服务" tabindex="-1"> 缓存代理服务</h2>
<p>我还是沿用“生鲜速递 + 便利店”的比喻，看看缓存代理是怎么回事。</p>
<p>便利店作为超市的代理，生意非常红火，顾客和超市双方都对现状非常满意。但时间一长，超市发现还有进一步提升的空间，因为每次便利店接到顾客的请求后都要专车跑一趟超市，还是挺麻烦的。</p>
<p>干脆这样吧，给便利店配发一个大冰柜。水果海鲜什么的都可以放在冰柜里，只要产品在保鲜期内，就允许顾客直接从冰柜提货。这样便利店就可以一次进货多次出货，省去了超市之间的运输成本。</p>
<p><img src="https://img-blog.csdnimg.cn/ab5fb4b84a0e4b028d3ca7552a6c1a85.png" alt=""></p>
<p>通过这个比喻，你可以看到：在没有缓存的时候，代理服务器每次都是直接转发客户端和服务器的报文，中间不会存储任何数据，只有最简单的中转功能。</p>
<p>加入了缓存后就不一样了。</p>
<p>代理服务收到源服务器发来的响应数据后需要做两件事。第一个当然是把报文转发给客户端，而第二个就是把报文存入自己的 Cache 里。</p>
<p>下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽。</p>
<p>在 HTTP 的缓存体系中，缓存代理的身份十分特殊，它“<code>既是客户端，又是服务器</code>”，同时也“<code>既不是客户端，又不是服务器</code>”。</p>
<p>说它“即是客户端又是服务器”，是因为它面向源服务器时是客户端，在面向客户端时又是服务器，所以它即可以用客户端的缓存控制策略也可以用服务器端的缓存控制策略，也就是说它可以同时使用第 20 讲的各种“Cache-Control”属性。</p>
<p>但缓存代理也“即不是客户端又不是服务器”，因为它只是一个数据的“中转站”，并不是真正的数据消费者和生产者，所以还需要有一些新的“Cache-Control”属性来对它做特别的约束。</p>
<h2 id="源服务器的缓存控制" tabindex="-1"> 源服务器的缓存控制</h2>
<p>第 20 讲介绍了 4 种服务器端的“Cache-Control”属性：max-age、no_store、no_cache 和 must-revalidate，你应该还有印象吧？</p>
<p>这 4 种缓存属性可以约束客户端，也可以约束代理。</p>
<p>但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。</p>
<p>首先，我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“<strong>private</strong>”和“<strong>public</strong>”。</p>
<p>“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。</p>
<p>比如你登录论坛，返回的响应报文里用“Set-Cookie”添加了论坛 ID，这就属于私人数据，不能存在代理上。不然，别人访问代理获取了被缓存的响应就麻烦了。</p>
<p>其次，缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），“<strong>must-revalidate</strong>”是只要过期就必须回源服务器验证，而新的“<strong>proxy-revalidate</strong>”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。</p>
<p>再次，缓存的生存时间可以使用新的“<strong>s-maxage</strong>”（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max_age”。</p>
<p>还有一个代理专用的属性“<strong>no-transform</strong>”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做，不许“偷偷摸摸搞小动作”。</p>
<p>这些新的缓存控制属性比较复杂，还是用“便利店冷柜”来举例好理解一些。</p>
<p>水果上贴着标签“private, max-age=5”。这就是说水果不能放进冷柜，必须直接给顾客，保鲜期 5 天，过期了还得去超市重新进货。</p>
<p>冻鱼上贴着标签“public, max-age=5, s-maxage=10”。这个的意思就是可以在冰柜里存 10 天，但顾客那里只能存 5 天，过期了可以来便利店取，只要在 10 天之内就不必再找超市。</p>
<p>排骨上贴着标签“max-age=30, proxy-revalidate, no-transform”。因为缓存默认是 public 的，那么它在便利店和顾客的冰箱里就都可以存 30 天，过期后便利店必须去超市进新货，而且不能擅自把“大排”改成“小排”。</p>
<p>下面的流程图是完整的服务器端缓存控制策略，可以同时控制客户端和代理。</p>
<p><img src="https://img-blog.csdnimg.cn/4ac763a6180f4177a3f4b72ca756cd8b.png" alt=""></p>
<p>我还要提醒你一点，源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。</p>
<h2 id="客户端的缓存控制" tabindex="-1"> 客户端的缓存控制</h2>
<p>说完了服务器端的缓存控制策略，稍微歇一口气，我们再来看看客户端。</p>
<p>客户端在 HTTP 缓存体系里要面对的是代理和源服务器，也必须区别对待，这里我就直接上图了，来个“看图说话”。</p>
<p><img src="https://img-blog.csdnimg.cn/475a7c3bb6ed472fb18d749139e2579a.png" alt=""></p>
<p>max-age、no_store、no_cache 这三个属性在第 20 讲已经介绍过了，它们也是同样作用于代理和源服务器。</p>
<p>关于缓存的生存时间，多了两个新属性“<strong>max-stale</strong>”和“<strong>min-fresh</strong>”。</p>
<p>“max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。“min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。</p>
<p>比如，草莓上贴着标签“max-age=5”，现在已经在冰柜里存了 7 天。如果有请求“max-stale=2”，意思是过期两天也能接受，所以刚好能卖出去。</p>
<p>但要是“min-fresh=1”，这是绝对不允许过期的，就不会买走。这时如果有另外一个菠萝是“max-age=10”，那么“7+1&lt;10”，在一天之后还是新鲜的，所以就能卖出去。</p>
<p>有的时候客户端还会发出一个特别的“<strong>only-if-cached</strong>”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。</p>
<h2 id="实验环境" tabindex="-1"> 实验环境</h2>
<p>信息量有些大，到这里你是不是有点头疼了，好在我们还有实验环境，用 URI“/22-1”试一下吧。</p>
<p>它设置了“Cache-Control: public, max-age=10, s-maxage=30”，数据可以在浏览器里存 10 秒，在代理上存 30 秒，你可以反复刷新，看看代理和源服务器是怎么响应的，同样也可以配合 Wireshark 抓包。</p>
<p>代理在响应报文里还额外加了“X-Cache”“X-Hit”等自定义头字段，表示缓存是否命中和命中率，方便你观察缓存代理的工作情况。</p>
<p><img src="https://img-blog.csdnimg.cn/bb18f4a82c1b439eaf3ecf81a0df538f.png" alt=""></p>
<h2 id="其他问题" tabindex="-1"> 其他问题</h2>
<p>缓存代理的知识就快讲完了，下面再简单说两个相关的问题。</p>
<p>第一个是“<strong>Vary</strong>”字段，在第 15 讲曾经说过，它是内容协商的结果，相当于报文的一个版本标记。</p>
<p>同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，“Vary: Accept-Encoding”“Vary: User-Agent”，缓存代理必须要存储这些不同的版本。</p>
<p>当再收到相同的请求时，代理就读取缓存里的“Vary”，对比请求头里相应的“ Accept-Encoding”“User-Agent”等字段，如果和上一个请求的完全匹配，比如都是“gzip”“Chrome”，就表示版本一致，可以返回缓存的数据。</p>
<p>另一个问题是“<strong>Purge</strong>”，也就是“缓存清理”，它对于代理也是非常重要的功能，例如：</p>
<ul>
<li>过期的数据应该及时淘汰，避免占用空间；</li>
<li>源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；</li>
<li>有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。</li>
</ul>
<p>清理缓存的方法有很多，比较常用的一种做法是使用自定义请求方法“PURGE”，发给代理服务器，要求删除 URI 对应的缓存数据。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>
<p>计算机领域里最常用的性能优化手段是“时空转换”，也就是“时间换空间”或者“空间换时间”，HTTP 缓存属于后者；</p>
</li>
<li>
<p>缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端；</p>
</li>
<li>
<p>“Cache-Control”字段也可以控制缓存代理，常用的有“private”“s-maxage”“no-transform”等，同样必须配合“Last-modified”“ETag”等字段才能使用；</p>
</li>
<li>
<p>缓存代理有时候也会带来负面影响，缓存不良数据，需要及时刷新或删除。</p>
</li>
<li>
<p>课下作业</p>
</li>
<li>
<p>加入了代理后 HTTP 的缓存复杂了很多，试着用自己的语言把这些知识再整理一下，画出有缓存代理时浏览器的工作流程图，加深理解。</p>
</li>
<li>
<p>缓存的时间策略很重要，太大太小都不好，你觉得应该如何设置呢？</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/ab5fb4b84a0e4b028d3ca7552a6c1a85.png" type="image/png"/>
    </item>
    <item>
      <title>23 | HTTPS是什么？SSL/TLS又是什么？</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson23.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson23.html</guid>
      <source url="https://0808200.xyz/rss.xml">23 | HTTPS是什么？SSL/TLS又是什么？</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_23-https是什么-ssl-tls又是什么" tabindex="-1"> 23 | HTTPS是什么？SSL/TLS又是什么？</h1>
<p>从今天开始，我们开始进入全新的“安全篇”，聊聊与安全相关的 HTTPS、SSL、TLS。</p>
<p>在第 14 讲中，我曾经谈到过 HTTP 的一些缺点，其中的“无状态”在加入 Cookie 后得到了解决，而另两个缺点——“明文”和“不安全”仅凭 HTTP 自身是无力解决的，需要引入新的 HTTPS 协议。</p>
<h2 id="为什么要有-https" tabindex="-1"> 为什么要有 HTTPS？</h2>
<p>简单的回答是“<strong>因为 HTTP 不安全</strong>”。</p>
<p>由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。</p>
<p>比如，前几讲中说过的“代理服务”。它作为 HTTP 通信的中间人，在数据上下行的时候可以添加或删除部分头字段，也可以使用黑白名单过滤 body 里的关键字，甚至直接发送虚假的请求、响应，而浏览器和源服务器都没有办法判断报文的真伪。</p>
<p>这对于网络购物、网上银行、证券交易等需要高度信任的应用场景来说是非常致命的。如果没有基本的安全保护，使用互联网进行各种电子商务、电子政务就根本无从谈起。</p>
<p>对于安全性要求不那么高的新闻、视频、搜索等网站来说，由于互联网上的恶意用户、恶意代理越来越多，也很容易遭到“流量劫持”的攻击，在页面里强行嵌入广告，或者分流用户，导致各种利益损失。</p>
<p>对于你我这样的普通网民来说，HTTP 不安全的隐患就更大了，上网的记录会被轻易截获，网站是否真实也无法验证，黑客可以伪装成银行网站，盗取真实姓名、密码、银行卡等敏感信息，威胁人身安全和财产安全。</p>
<p>总的来说，今天的互联网已经不再是早期的“田园牧歌”时代，而是进入了“黑暗森林”状态。上网的时候必须步步为营、处处小心，否则就会被不知道埋伏在哪里的黑客所“猎杀”。</p>
<h2 id="什么是安全" tabindex="-1"> 什么是安全？</h2>
<p>既然 HTTP“不安全”，那什么样的通信过程才是安全的呢？</p>
<p>通常认为，<code>如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认</code>。</p>
<p><strong>机密性</strong>（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。</p>
<p>比如小明和小红私下聊天，但“隔墙有耳”，被小强在旁边的房间里全偷听到了，这就是没有机密性。我们之前一直用的 Wireshark ，实际上也是利用了 HTTP 的这个特点，捕获了传输过程中的所有数据。</p>
<p><strong>完整性</strong>（Integrity，也叫一致性）是指数据在传输过程中没有被窜改，不多也不少，“完完整整”地保持着原状。</p>
<p>机密性虽然可以让数据成为“秘密”，但不能防止黑客对数据的修改，黑客可以替换数据，调整数据的顺序，或者增加、删除部分数据，破坏通信过程。</p>
<p>比如，小明给小红写了张纸条：“明天公园见”。小强把“公园”划掉，模仿小明的笔迹把这句话改成了“明天广场见”。小红收到后无法验证完整性，信以为真，第二天的约会就告吹了。</p>
<p><strong>身份认证</strong>（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。</p>
<p>如果通信时另一方是假冒的网站，那么数据再保密也没有用，黑客完全可以使用冒充的身份“套”出各种信息，加密和没加密一样。</p>
<p>比如，小明给小红写了封情书：“我喜欢你”，但不留心发给了小强。小强将错就错，假冒小红回复了一个“白日做梦”，小明不知道这其实是小强的话，误以为是小红的，后果可想而知。</p>
<p>第四个特性是<strong>不可否认</strong>（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。</p>
<p>使用前三个特性，可以解决安全通信的大部分问题，但如果缺了不可否认，那通信的事务真实性就得不到保证，有可能出现“老赖”。</p>
<p>比如，小明借了小红一千元，没写借条，第二天矢口否认，小红也确实拿不出借钱的证据，只能认倒霉。另一种情况是小明借钱后还了小红，但没写收条，小红于是不承认小明还钱的事，说根本没还，要小明再掏出一千元。</p>
<p>所以，只有同时具备了机密性、完整性、身份认证、不可否认这四个特性，通信双方的利益才能有保障，才能算得上是真正的安全。</p>
<h2 id="什么是-https" tabindex="-1"> 什么是 HTTPS？</h2>
<p>说到这里，终于轮到今天的主角 HTTPS 出场了，它为 HTTP 增加了刚才所说的四大安全特性。</p>
<p>HTTPS 其实是一个“非常简单”的协议，RFC 文档很小，只有短短的 7 页，里面规定了<strong>新的协议名“https”，默认端口号 443</strong>，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。</p>
<p>也就是说，除了协议名“http”和端口号 80 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。</p>
<p>不信你可以用 URI“https://www.chrono.com”访问之前 08 至 21 讲的所有示例，看看它的响应报文是否与 HTTP 一样。</p>
<div><pre><code>https://www.chrono.com
https://www.chrono.com/11-1
https://www.chrono.com/15-1?name=a.json
https://www.chrono.com/16-1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/c46843ebb5794f59b6d410201ee51fbe.png" alt=""></p>
<p>你肯定已经注意到了，在用 HTTPS 访问实验环境时 Chrome 会有不安全提示，必须点击“高级 - 继续前往”才能顺利显示页面。而且如果用 Wireshark 抓包，也会发现与 HTTP 不一样，不再是简单可见的明文，多了“Client Hello”“Server Hello”等新的数据包。</p>
<p>这就是 HTTPS 与 HTTP 最大的区别，它能够鉴别危险的网站，并且尽最大可能保证你的上网安全，防御黑客对信息的窃听、窜改或者“钓鱼”、伪造。</p>
<p>你可能要问了，既然没有新东西，HTTPS 凭什么就能做到机密性、完整性这些安全特性呢？</p>
<p>秘密就在于 HTTPS 名字里的“S”，它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“<strong>HTTP over TCP/IP</strong>”变成了“<strong>HTTP over SSL/TLS</strong>”，让 HTTP 运行在了安全的 SSL/TLS 协议上（可参考第 4 讲和第 5 讲），收发报文不再使用 Socket API，而是调用专门的安全接口。</p>
<p><img src="https://img-blog.csdnimg.cn/da2b4f156c694b4bb1e0d89dce6dc3f1.png" alt=""></p>
<p>所以说，HTTPS 本身并没有什么“惊世骇俗”的本事，全是靠着后面的 SSL/TLS“撑腰”。只要学会了 SSL/TLS，HTTPS 自然就“手到擒来”。</p>
<h2 id="ssl-tls" tabindex="-1"> SSL/TLS</h2>
<p>现在我们就来看看 SSL/TLS，它到底是个什么来历。</p>
<p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p>
<p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。</p>
<p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。</p>
<p>目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</p>
<p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。</p>
<p>你可以访问实验环境的 URI“/23-1”，对 TLS 和密码套件有个感性的认识。</p>
<p><img src="https://img-blog.csdnimg.cn/048959e69394443bbd081bd8b2521062.png" alt=""></p>
<p>你可以看到，实验环境使用的 TLS 是 1.2，客户端和服务器都支持非常多的密码套件，而最后协商选定的是“ECDHE-RSA-AES256-GCM-SHA384”。</p>
<p>这么长的名字看着有点晕吧，不用怕，其实 TLS 的密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”，比如刚才的密码套件的意思就是：</p>
<p>“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”</p>
<h2 id="openssl" tabindex="-1"> OpenSSL</h2>
<p>说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p>
<p>OpenSSL 是从另一个开源库 SSLeay 发展出来的，曾经考虑命名为“OpenTLS”，但当时（1998 年）TLS 还未正式确立，而 SSL 早已广为人知，所以最终使用了“OpenSSL”的名字。</p>
<p>OpenSSL 目前有三个主要的分支，1.0.2 和 1.1.0 都将在今年（2019）年底不再维护，最新的长期支持版本是 1.1.1，我们的实验环境使用的 OpenSSL 是“1.1.0j”。</p>
<p>由于 OpenSSL 是开源的，所以它还有一些代码分支，比如 Google 的 BoringSSL、OpenBSD 的 LibreSSL，这些分支在 OpenSSL 的基础上删除了一些老旧代码，也增加了一些新特性，虽然背后有“大金主”，但离取代 OpenSSL 还差得很远。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>因为 HTTP 是明文传输，所以不安全，容易被黑客窃听或窜改；</li>
<li>通信安全必须同时具备机密性、完整性，身份认证和不可否认这四个特性；</li>
<li>HTTPS 的语法、语义仍然是 HTTP，但把下层的协议由 TCP/IP 换成了 SSL/TLS；</li>
<li>SSL/TLS 是信息安全领域中的权威标准，采用多种先进的加密技术保证通信安全；</li>
<li>OpenSSL 是著名的开源密码学工具包，是 SSL/TLS 的具体实现。</li>
</ul>
<p>课下作业</p>
<ul>
<li>你能说出 HTTPS 与 HTTP 有哪些区别吗？</li>
<li>你知道有哪些方法能够实现机密性、完整性等安全特性呢？</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/c46843ebb5794f59b6d410201ee51fbe.png" type="image/png"/>
    </item>
    <item>
      <title>24 | 固若金汤的根本（上）：对称加密与非对称加密</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson24.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson24.html</guid>
      <source url="https://0808200.xyz/rss.xml">24 | 固若金汤的根本（上）：对称加密与非对称加密</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_24-固若金汤的根本-上-对称加密与非对称加密" tabindex="-1"> 24 | 固若金汤的根本（上）：对称加密与非对称加密</h1>
<p>在上一讲中，我们初步学习了 HTTPS，知道 HTTPS 的安全性是由 TLS 来保证的。</p>
<p>你一定很好奇，它是怎么为 HTTP 增加了机密性、完整性，身份认证和不可否认等特性的呢？</p>
<p>先说说机密性。它是信息安全的基础，缺乏机密性 TLS 就会成为“无水之源”“无根之木”。</p>
<p>实现机密性最常用的手段是“加密”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。</p>
<p>这里的“钥匙”就叫做“密钥”（key），加密前的消息叫“明文”（plain text/clear text），加密后的乱码叫“密文”（cipher text），使用密钥还原明文的过程叫“解密”（decrypt），是加密的反操作，加密解密的操作过程就是“加密算法”。</p>
<p>所有的加密算法都是公开的，任何人都可以去分析研究，而算法使用的“密钥”则必须保密。那么，这个关键的“密钥”又是什么呢？</p>
<p>由于 HTTPS、TLS 都运行在计算机上，所以“密钥”就是一长串的数字，但约定俗成的度量单位是“位”（bit），而不是“字节”（byte）。比如，说密钥长度是 128，就是 16 字节的二进制串，密钥长度 1024，就是 128 字节的二进制串。</p>
<p>按照密钥的使用方式，加密可以分为两大类：<strong>对称加密和非对称加密</strong>。</p>
<h2 id="对称加密" tabindex="-1"> 对称加密</h2>
<p>“对称加密”很好理解，就是指加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<p>举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密码，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。</p>
<p><img src="https://img-blog.csdnimg.cn/49aebc26244143cfabb96d4ba20f89e6.png" alt=""></p>
<p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p>
<p>AES 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法。</p>
<p>ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。</p>
<h2 id="加密分组模式" tabindex="-1"> 加密分组模式</h2>
<p>对称算法还有一个“<strong>分组模式</strong>”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。</p>
<p>最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。</p>
<p>把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。</p>
<p>比如，AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM；ChaCha20-Poly1305 的意思是 ChaCha20 算法，使用的分组模式是 Poly1305。</p>
<p>你可以用实验环境的 URI“/24-1”来测试 OpenSSL 里的 AES128-CBC，在 URI 后用参数“key”“plain”输入密钥和明文，服务器会在响应报文里输出加密解密的结果。</p>
<div><pre><code>https://www.chrono.com/24-1?key=123456
 
algo  = aes_128_cbc
plain = hello openssl
enc   = 93a024a94083bc39fb2c2b9f5ce27c09
dec   = hello openssl
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="非对称加密" tabindex="-1"> 非对称加密</h2>
<p>对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“<strong>密钥交换</strong>”。</p>
<p>因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</p>
<p>这个问题该怎么解决呢？</p>
<p>你或许会说：“把密钥再加密一下发过去就好了”，但传输“加密密钥的密钥”又成了新问题。这就像是“鸡生蛋、蛋生鸡”，可以无限递归下去。只用对称加密算法，是绝对无法解决密钥交换的问题的。</p>
<p>所以，就出现了非对称加密（也叫公钥加密算法）。</p>
<p>它有两个密钥，一个叫“<strong>公钥</strong>”（public key），一个叫“<strong>私钥</strong>”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</p>
<p>公钥和私钥有个特别的“<strong>单向</strong>”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</p>
<p>非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。</p>
<p><img src="https://img-blog.csdnimg.cn/b89ba963421047cab795c43d5f31262c.png" alt=""></p>
<p>非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。</p>
<p>RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“<strong>整数分解</strong>”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。</p>
<p>10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在 1024 已经不安全，普遍认为至少要 2048 位。</p>
<p>ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“<strong>椭圆曲线离散对数</strong>”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。</p>
<p>目前比较常用的两个曲线是 P-256（secp256r1，在 OpenSSL 称为 prime256v1）和 x25519。P-256 是 NIST（美国国家标准技术研究所）和 NSA（美国国家安全局）推荐使用的曲线，而 x25519 被认为是最安全、最快速的曲线。</p>
<p>ECC 名字里的“椭圆”经常会引起误解，其实它的曲线并不是椭圆形，只是因为方程很类似计算椭圆周长的公式，实际的形状更像抛物线，比如下面的图就展示了两个简单的椭圆曲线。</p>
<p><img src="https://img-blog.csdnimg.cn/4a9d6205561341799474ffe088f71019.png" alt=""></p>
<p>两个简单的椭圆曲线：y<sup>2=x</sup>3+7，y<sup>2=x</sup>3-x</p>
<p>比起 RSA，ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的 RSA。因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了，对于现在的移动互联网非常有吸引力。</p>
<p>实验环境的 URI“/24-2”演示了 RSA1024，你在课后可以动手试一下。</p>
<h2 id="混合加密" tabindex="-1"> 混合加密</h2>
<p>看到这里，你是不是认为可以抛弃对称加密，只用非对称加密来实现机密性呢？</p>
<p>很遗憾，虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</p>
<p>实验环境的 URI“/24-3”对比了 AES 和 RSA 这两种算法的性能，下面列出了一次测试的结果：</p>
<div><pre><code>aes_128_cbc enc/dec 1000 times : 0.97ms, 13.11MB/s
 
rsa_1024 enc/dec 1000 times : 138.59ms, 93.80KB/s
rsa_1024/aes ratio = 143.17
 
rsa_2048 enc/dec 1000 times : 840.35ms, 15.47KB/s
rsa_2048/aes ratio = 868.13
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，RSA 的运算速度是非常慢的，2048 位的加解密大约是 15KB/S（微秒或毫秒级），而 AES128 则是 13MB/S（纳秒级），差了几百倍。</p>
<p>那么，是不是能够把对称加密和非对称加密结合起来呢，两者互相取长补短，即能高效地加密解密，又能安全地密钥交换。</p>
<p>这就是现在 TLS 里使用的<strong>混合加密</strong>方式，其实说穿了也很简单：</p>
<p>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</p>
<p>然后用随机数产生对称算法使用的“<strong>会话密钥</strong>”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</p>
<p>对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。</p>
<p><img src="https://img-blog.csdnimg.cn/25894c5c9e46421caf58cf586a15780f.png" alt=""></p>
<p>这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。</p>
<p>不过这只是“万里长征的第一步”，后面还有完整性、身份认证、不可否认等特性没有实现，所以现在的通信还不是绝对安全，我们下次再说。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>加密算法的核心思想是“把一个小秘密（密钥）转化为一个大秘密（密文消息）”，守住了小秘密，也就守住了大秘密；</li>
<li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；</li>
<li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；</li>
<li>把对称加密和非对称加密结合起来就得到了“又好又快”的混合加密，也就是 TLS 里使用的加密方式。</li>
</ul>
<p>课下作业</p>
<ul>
<li>加密算法中“密钥”的名字很形象，你能试着用现实中的锁和钥匙来比喻一下吗？</li>
<li>在混合加密中用到了公钥加密，因为只能由私钥解密。那么反过来，私钥加密后任何人都可以用公钥解密，这有什么用呢？</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/49aebc26244143cfabb96d4ba20f89e6.png" type="image/png"/>
    </item>
    <item>
      <title>25 | 固若金汤的根本（下）：数字签名与证书</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson25.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson25.html</guid>
      <source url="https://0808200.xyz/rss.xml">25 | 固若金汤的根本（下）：数字签名与证书</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_25-固若金汤的根本-下-数字签名与证书" tabindex="-1"> 25 | 固若金汤的根本（下）：数字签名与证书</h1>
<p>上一讲中我们学习了对称加密和非对称加密，以及两者结合起来的混合加密，实现了机密性。</p>
<p>但仅有机密性，离安全还差的很远。</p>
<p>黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</p>
<p>另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</p>
<p>所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。</p>
<h2 id="摘要算法" tabindex="-1"> 摘要算法</h2>
<p>实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。</p>
<p>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</p>
<p>换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</p>
<p><img src="https://img-blog.csdnimg.cn/253d4af924294309bef4f03ca6235dbd.png" alt=""></p>
<p>摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。</p>
<p>因为摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数（PRF，pseudo random function）。</p>
<p>你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。</p>
<p>目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。</p>
<p>SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。</p>
<p>你可以用实验环境的 URI“/25-1”来测试一下 TLS 里的各种摘要算法，包括 MD5、SHA-1 和 SHA-2。</p>
<div><pre><code>https://www.chrono.com/25-1?algo=md5
https://www.chrono.com/25-1?algo=sha1
https://www.chrono.com/25-1?algo=sha256
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="完整性" tabindex="-1"> 完整性</h2>
<p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。</p>
<p>比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。</p>
<p>如果黑客在中间哪怕改动了一个标点符号，摘要也会完全不同，网站计算比对就会发现消息被窜改，是不可信的。</p>
<p>不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</p>
<p>所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。</p>
<p>这有个术语，叫哈希消息认证码（HMAC）。</p>
<p><img src="https://img-blog.csdnimg.cn/7091b220f3984110ab2b7de964a2bd7b.png" alt=""></p>
<h2 id="数字签名" tabindex="-1"> 数字签名</h2>
<p>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。</p>
<p>就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</p>
<p>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</p>
<p>你回想一下之前的课程，在 TLS 里有什么东西和现实中的签名、印章很像，只能由本人持有，而其他任何人都不会有呢？只要用这个东西，就能够在数字世界里证明你的身份。</p>
<p>没错，这个东西就是非对称加密里的“私钥”，<strong>使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”</strong>。</p>
<p>数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。</p>
<p>但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。</p>
<p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。</p>
<p><img src="https://img-blog.csdnimg.cn/809b42111a8b49f8aa0d8c34ea8be14b.png" alt=""></p>
<p>刚才的这两个行为也有专用术语，叫做“签名”和“验签”。</p>
<p>只要你和网站互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。</p>
<p>比如，你用自己的私钥签名一个消息“我是小明”。网站收到后用你的公钥验签，确认身份没问题，于是也用它的私钥签名消息“我是某宝”。你收到后再用它的公钥验一下，也没问题，这样你和网站就都知道对方不是假冒的，后面就可以用混合加密进行安全通信了。</p>
<p>实验环境的 URI“/25-2”演示了 TLS 里的数字签名，它使用的是 RSA1024。</p>
<h2 id="数字证书和-ca" tabindex="-1"> 数字证书和 CA</h2>
<p>到现在，综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，是不是已经完美了呢？</p>
<p>不是的，这里还有一个“公钥的信任”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢？</p>
<p>真是“按下葫芦又起了瓢”，安全还真是个麻烦事啊，“一环套一环”的。</p>
<p>我们可以用类似密钥交换的方法来解决公钥认证问题，用别的私钥来给公钥签名，显然，这又会陷入“无穷递归”。</p>
<p>但这次实在是“没招”了，要终结这个“死循环”，就必须引入“外力”，找一个公认的可信第三方，让它作为“信任的起点，递归的终点”，构建起公钥的信任链。</p>
<p>这个“第三方”就是我们常说的<strong>CA</strong>（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p>
<p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“<strong>数字证书</strong>”（Certificate）。</p>
<p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。</p>
<p>DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。</p>
<p>不过，CA 怎么证明自己呢？</p>
<p>这还是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是<strong>Root CA</strong>，就只能自己证明自己了，这个就叫“<strong>自签名证书</strong>”（Self-Signed Certificate）或者“<strong>根证书</strong>”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。</p>
<p><img src="https://img-blog.csdnimg.cn/d27e52754ce54404882d6313fdc11928.png" alt=""></p>
<p>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</p>
<p>我们的实验环境里使用的证书是“野路子”的自签名证书（在 Linux 上用 OpenSSL 命令行签发），肯定是不会被浏览器所信任的，所以用 Chrome 访问时就会显示成红色，标记为不安全。但你只要把它安装进系统的根证书存储区里，让它作为信任链的根，就不会再有危险警告。</p>
<p><img src="https://img-blog.csdnimg.cn/a6035c91d16c418aa00c8e63780d0d7f.png" alt=""></p>
<h2 id="证书体系的弱点" tabindex="-1"> 证书体系的弱点</h2>
<p>证书体系（PKI，Public Key Infrastructure）虽然是目前整个网络世界的安全基础设施，但绝对的安全是不存在的，它也有弱点，还是关键的“<strong>信任</strong>”二字。</p>
<p>如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。</p>
<p>还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。</p>
<p>这两种事情并不是“耸人听闻”，都曾经实际出现过。所以，需要再给证书体系打上一些补丁。</p>
<p>针对第一种，开发出了 CRL（证书吊销列表，Certificate revocation list）和 OCSP（在线证书状态协议，Online Certificate Status Protocol），及时废止有问题的证书。</p>
<p>对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上“下狠手”了，撤销对 CA 的信任，列入“黑名单”，这样它颁发的所有证书就都会被认为是不安全的。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了数字签名和证书、CA，是不是有种“盗梦空间”一层套一层的感觉？你可以在课后再去各大网站，结合它们“小锁头”里的信息来加深理解。</p>
<p>今天的内容可以简单概括为四点：</p>
<ul>
<li>
<p>摘要算法用来实现完整性，能够为数据生成独一无二的“指纹”，常用的算法是 SHA-2；</p>
</li>
<li>
<p>数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认；</p>
</li>
<li>
<p>公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的；</p>
</li>
<li>
<p>作为信任链的源头 CA 有时也会不可信，解决办法有 CRL、OCSP，还有终止信任。</p>
<p>课下作业</p>
</li>
<li>
<p>为什么公钥能够建立信任链，用对称加密算法里的对称密钥行不行呢？</p>
</li>
<li>
<p>假设有一个三级的证书体系（Root CA=&gt; 一级 CA=&gt; 二级 CA），你能详细解释一下证书信任链的验证过程吗？</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/253d4af924294309bef4f03ca6235dbd.png" type="image/png"/>
    </item>
    <item>
      <title>26 | 信任始于握手：TLS1.2连接过程解析</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson26.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson26.html</guid>
      <source url="https://0808200.xyz/rss.xml">26 | 信任始于握手：TLS1.2连接过程解析</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_26-信任始于握手-tls1-2连接过程解析" tabindex="-1"> 26 | 信任始于握手：TLS1.2连接过程解析</h1>
<p>经过前几讲的介绍，你应该已经熟悉了对称加密与非对称加密、数字签名与证书等密码学知识。</p>
<p>有了这些知识“打底”，现在我们就可以正式开始研究 HTTPS 和 TLS 协议了。</p>
<h2 id="https-建立连接" tabindex="-1"> HTTPS 建立连接</h2>
<p>当你在浏览器地址栏里键入“https”开头的 URI，再按下回车，会发生什么呢？</p>
<p>回忆一下第 8 讲的内容，你应该知道，浏览器首先要从 URI 里提取出协议名和域名。因为协议名是“https”，所以浏览器就知道了端口号是默认的 443，它再用 DNS 解析域名，得到目标的 IP 地址，然后就可以使用三次握手与网站建立 TCP 连接了。</p>
<p>在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。</p>
<p>这个“握手”过程与 TCP 有些类似，是 HTTPS 和 TLS 协议里最重要、最核心的部分，懂了它，你就可以自豪地说自己“掌握了 HTTPS”。</p>
<h2 id="tls-协议的组成" tabindex="-1"> TLS 协议的组成</h2>
<p>在讲 TLS 握手之前，我先简单介绍一下 TLS 协议的组成。</p>
<p>TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</p>
<p><strong>记录协议</strong>（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</p>
<p><strong>警报协议</strong>（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</p>
<p><strong>握手协议</strong>（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</p>
<p>最后一个是<strong>变更密码规范协议</strong>（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。</p>
<p>下面的这张图简要地描述了 TLS 的握手过程，其中每一个“框”都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>
<p><img src="https://img-blog.csdnimg.cn/58231ab6751247cf9fa4141c67dfd075.png" alt=""></p>
<h2 id="抓包的准备工作" tabindex="-1"> 抓包的准备工作</h2>
<p>这次我们在实验环境里测试 TLS 握手的 URI 是“/26-1”，看了上面的图你就可以知道，TLS 握手的前几个消息都是明文的，能够在 Wireshark 里直接看。但只要出现了“Change Cipher Spec”，后面的数据就都是密文了，看到的也就会是乱码，不知道究竟是什么东西。</p>
<p>为了更好地分析 TLS 握手过程，你可以再对系统和 Wireshark 做一下设置，让浏览器导出握手过程中的秘密信息，这样 Wireshark 就可以把密文解密，还原出明文。</p>
<p>首先，你需要在 Windows 的设置里新增一个系统变量“SSLKEYLOGFILE”，设置浏览器日志文件的路径，比如“D:\http_study\www\temp\sslkey.log”（具体的设置过程就不详细说了，可以在设置里搜索“系统变量”）。</p>
<p><img src="https://img-blog.csdnimg.cn/00c82c12f1954a5599d7a3fcacd36513.png" alt=""></p>
<p>然后在 Wireshark 里设置“Protocols-TLS”（较早版本的 Wireshark 里是“SSL”），在“(Pre)-Master-Secret log filename”里填上刚才的日志文件。</p>
<p><img src="https://img-blog.csdnimg.cn/97b6e8aadb2e47679d84f98162fb55fc.png" alt=""></p>
<p>设置好之后，过滤器选择“<strong>tcp port 443</strong>”，就可以抓到实验环境里的所有 HTTPS 数据了。</p>
<p>如果你觉得麻烦也没关系，GitHub 上有抓好的包和相应的日志，用 Wireshark 直接打开就行。</p>
<h2 id="ecdhe-握手过程" tabindex="-1"> ECDHE 握手过程</h2>
<p>刚才你看到的是握手过程的简要图，我又画了一个详细图，对应 Wireshark 的抓包，下面我就用这个图来仔细剖析 TLS 的握手过程。</p>
<p><img src="https://img-blog.csdnimg.cn/a4cebb7dca684c9b9ca779cd85cf55b7.png" alt=""></p>
<p>在 TCP 建立连接之后，浏览器会首先发一个“<strong>Client Hello</strong>”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个<strong>随机数（Client Random）</strong>，用于后续生成会话密钥。</p>
<div><pre><code>Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: 1cbf803321fd2623408dfe…
    Cipher Suites (17 suites)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个的意思就是：“我这边有这些这些信息，你看看哪些是能用的，关键的随机数可得留着。”</p>
<p>作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个<strong>随机数</strong>（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。</p>
<div><pre><code>Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 0e6320f21bae50842e96…
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这个的意思就是：“版本号对上了，可以加密，你的密码套件挺多，我选一个最合适的吧，用椭圆曲线加 RSA、AES、SHA384。我也给你一个随机数，你也得留着。”</p>
<p>然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</p>
<p>接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“<strong>Server Key Exchange</strong>”消息，里面是<strong>椭圆曲线的公钥</strong>（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。</p>
<div><pre><code>Handshake Protocol: Server Key Exchange
    EC Diffie-Hellman Server Params
        Curve Type: named_curve (0x03)
        Named Curve: x25519 (0x001d)
        Pubkey: 3b39deaf00217894e...
        Signature Algorithm: rsa_pkcs1_sha512 (0x0601)
        Signature: 37141adac38ea4...
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”</p>
<p>之后是“<strong>Server Hello Done</strong>”消息，服务器说：“我的信息就是这些，打招呼完毕。”</p>
<p>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：<strong>Client Random</strong>、<strong>Server Random</strong> 和 <strong>Server Params</strong>。</p>
<p>客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？</p>
<p>这就要用到第 25 讲里的知识了，开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”</p>
<p>然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</p>
<div><pre><code>Handshake Protocol: Client Key Exchange
    EC Diffie-Hellman Client Params
        Pubkey: 8c674d0e08dc27b5eaa…
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。</p>
<p>至于具体的计算原理和过程，因为太复杂就不细说了，但算法可以保证即使黑客截获了之前的参数，也是绝对算不出这个随机数的。</p>
<p>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会 话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</p>
<p>为什么非得这么麻烦，非要三个随机数呢？</p>
<p>这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。</p>
<p>你一定很想知道“Master Secret”究竟是怎么算出来的吧，贴一下 RFC 里的公式：</p>
<p>master_secret = PRF(pre_master_secret, &quot;master secret&quot;,
ClientHello.random + ServerHello.random)
这里的“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，比如这次的 SHA384，通过摘要算法来再一次强化“Master Secret”的随机性。</p>
<p>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</p>
<p>有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“<strong>Change Cipher Spec</strong>”，然后再发一个“<strong>Finished</strong>”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。</p>
<p>意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</p>
<p>服务器也是同样的操作，发“<strong>Change Cipher Spec</strong>”和“<strong>Finished</strong>”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</p>
<h2 id="rsa-握手过程" tabindex="-1"> RSA 握手过程</h2>
<p>整个握手过程可真是够复杂的，但你可能会问了，好像这个过程和其他地方看到的不一样呢？</p>
<p>刚才说的其实是如今主流的 TLS 握手过程，这与传统的握手有两点不同。</p>
<p>第一个，使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出“Server Key Exchange”消息。</p>
<p>第二个，因为使用了 ECDHE，客户端可以不用等到服务器发回“Finished”确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫“<strong>TLS False Start</strong>”，意思就是“抢跑”，和“TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。</p>
<p>实验环境在 440 端口（<code>https://www.chrono.com:440/26-1</code>）实现了传统的 RSA 密钥交换，没有“False Start”，你可以课后自己抓包看一下，这里我也画了个图。</p>
<p><img src="https://img-blog.csdnimg.cn/d5da5e8fc9124ff7ad2a2ff3286337ed.png" alt=""></p>
<p>大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“<strong>Client Key Exchange</strong>”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</p>
<h2 id="双向认证" tabindex="-1"> 双向认证</h2>
<p>到这里 TLS 握手就基本讲完了。</p>
<p>不过上面说的是“<strong>单向认证</strong>”握手过程，只认证了服务器的身份，而没有认证客户端的身份。这是因为通常单向认证通过后已经建立了安全通信，用账号、密码等简单的手段就能够确认用户的真实身份。</p>
<p>但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“<strong>双向认证</strong>”，这样会更加安全。</p>
<p>双向认证的流程也没有太多变化，只是在“<strong>Server Hello Done</strong>”之后，“<strong>Client Key Exchange</strong>”之前，客户端要发送“<strong>Client Certificate</strong>”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们学习了 HTTPS/TLS 的握手，内容比较多、比较难，不过记住下面四点就可以。</p>
<ul>
<li>HTTPS 协议会先与服务器执行 TCP 握手，然后执行 TLS 握手，才能建立安全连接；</li>
<li>握手的目标是安全地交换对称密钥，需要三个随机数，第三个随机数“Pre-Master”必须加密传输，绝对不能让黑客破解；</li>
<li>“Hello”消息交换随机数，“Key Exchange”消息交换“Pre-Master”；</li>
<li>“Change Cipher Spec”之前传输的都是明文，之后都是对称密钥加密的密文。</li>
</ul>
<p>课下作业</p>
<ul>
<li>密码套件里的那些算法分别在握手过程中起了什么作用？</li>
<li>你能完整地描述一下 RSA 的握手过程吗？</li>
<li>你能画出双向认证的流程图吗？</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/58231ab6751247cf9fa4141c67dfd075.png" type="image/png"/>
    </item>
    <item>
      <title>27 | 更好更快的握手：TLS1.3特性解析</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson27.html</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/5_security/lesson27.html</guid>
      <source url="https://0808200.xyz/rss.xml">27 | 更好更快的握手：TLS1.3特性解析</source>
      <pubDate>Tue, 07 Feb 2023 15:04:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_27-更好更快的握手-tls1-3特性解析" tabindex="-1"> 27 | 更好更快的握手：TLS1.3特性解析</h1>
<p>上一讲中我讲了 TLS1.2 的握手过程，你是不是已经完全掌握了呢？</p>
<p>不过 TLS1.2 已经是 10 年前（2008 年）的“老”协议了，虽然历经考验，但毕竟“岁月不饶人”，在安全、性能等方面已经跟不上如今的互联网了。</p>
<p>于是经过四年、近 30 个草案的反复打磨，TLS1.3 终于在去年（2018 年）“粉墨登场”，再次确立了信息安全领域的新标准。</p>
<p>在抓包分析握手之前，我们先来快速浏览一下 TLS1.3 的三个主要改进目标：<strong>兼容、安全与性能</strong>。</p>
<h2 id="最大化兼容性" tabindex="-1"> 最大化兼容性</h2>
<p>由于 1.1、1.2 等协议已经出现了很多年，很多应用软件、中间代理（官方称为“MiddleBox”）只认老的记录协议格式，更新改造很困难，甚至是不可行（设备僵化）。</p>
<p>在早期的试验中发现，一旦变更了记录头字段里的版本号，也就是由 0x303（TLS1.2）改为 0x304（TLS1.3）的话，大量的代理服务器、网关都无法正确处理，最终导致 TLS 握手失败。</p>
<p>为了保证这些被广泛部署的“老设备”能够继续使用，避免新协议带来的“冲击”，TLS1.3 不得不做出妥协，保持现有的记录格式不变，通过“伪装”来实现兼容，使得 TLS1.3 看上去“像是”TLS1.2。</p>
<p>那么，该怎么区分 1.2 和 1.3 呢？</p>
<p>这要用到一个<strong>新的扩展协议</strong>（Extension Protocol），它有点“补充条款”的意思，通过在记录末尾添加一系列的“扩展字段”来增加新的功能，老版本的 TLS 不认识它可以直接忽略，这就实现了“后向兼容”。</p>
<p>在记录头的 Version 字段被兼容性“固定”的情况下，只要是 TLS1.3 协议，握手的“Hello”消息后面就必须有“<strong>supported_versions</strong>”扩展，它标记了 TLS 的版本号，使用它就能区分新旧协议。</p>
<p>其实上一讲 Chrome 在握手时发的就是 TLS1.3 协议，你可以看一下“Client Hello”消息后面的扩展，只是因为服务器不支持 1.3，所以就“后向兼容”降级成了 1.2。</p>
<div><pre><code>Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Extension: supported_versions (len=11)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>TLS1.3 利用扩展实现了许多重要的功能，比如“supported_groups”“key_share”“signature_algorithms”“server_name”等，这些等后面用到的时候再说。</p>
<h2 id="强化安全" tabindex="-1"> 强化安全</h2>
<p>TLS1.2 在十来年的应用中获得了许多宝贵的经验，陆续发现了很多的漏洞和加密算法的弱点，所以 TLS1.3 就在协议里修补了这些不安全因素。</p>
<p>比如：</p>
<ul>
<li>伪随机数函数由 PRF 升级为 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）；</li>
<li>明确禁止在记录协议里使用压缩；</li>
<li>废除了 RC4、DES 对称加密算法；</li>
<li>废除了 ECB、CBC 等传统分组模式；</li>
<li>废除了 MD5、SHA1、SHA-224 摘要算法；</li>
<li>废除了 RSA、DH 密钥交换算法和许多命名曲线。</li>
</ul>
<p>经过这一番“减肥瘦身”之后，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被“砍”到只剩 P-256 和 x25519 等 5 种。</p>
<p>减肥可以让人变得更轻巧灵活，TLS 也是这样。</p>
<p>算法精简后带来了一个意料之中的好处：原来众多的算法、参数组合导致密码套件非常复杂，难以选择，而现在的 TLS1.3 里只有 5 个套件，无论是客户端还是服务器都不会再犯“选择困难症”了。</p>
<p><img src="https://img-blog.csdnimg.cn/b927b8be3b1f43a3b1aa5d09d7cdb039.png" alt=""></p>
<p>这里还要特别说一下废除 RSA 和 DH 密钥交换算法的原因。</p>
<p>上一讲用 Wireshark 抓包时你一定看到了，浏览器默认会使用 ECDHE 而不是 RSA 做密钥交换，这是因为它不具有“<strong>前向安全</strong>”（Forward Secrecy）。</p>
<p>假设有这么一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者巨型计算机），那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文。</p>
<p>这就是所谓的“<strong>今日截获，明日破解</strong>”。</p>
<p>而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是“一次一密”，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。</p>
<p>所以现在主流的服务器和浏览器在握手阶段都已经不再使用 RSA，改用 ECDHE，而 TLS1.3 在协议里明确废除 RSA 和 DH 则在标准层面保证了“前向安全”。</p>
<h2 id="提升性能" tabindex="-1"> 提升性能</h2>
<p>HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重。</p>
<p>现在因为密码套件大幅度简化，也就没有必要再像以前那样走复杂的协商流程了。TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。</p>
<p>那么它是怎么做的呢？</p>
<p>其实具体的做法还是利用了扩展。客户端在“Client Hello”消息里直接用“<strong>supported_groups</strong>”带上支持的曲线，比如 P-256、x25519，用“<strong>key_share</strong>”带上曲线对应的客户端公钥参数，用“<strong>signature_algorithms</strong>”带上签名算法。</p>
<p>服务器收到后在这些扩展里选定一个曲线和参数，再用“key_share”扩展返回服务器这边的公钥参数，就实现了双方的密钥交换，后面的流程就和 1.2 基本一样了。</p>
<p>我为 1.3 的握手过程画了一张图，你可以对比 1.2 看看区别在哪里。</p>
<p><img src="https://img-blog.csdnimg.cn/2c8768d68f494a18bcb67e451c9f1074.png" alt=""></p>
<p>除了标准的“1-RTT”握手，TLS1.3 还引入了“0-RTT”握手，用“pre_shared_key”和“early_data”扩展，在 TCP 连接后立即就建立安全连接发送加密消息，不过这需要有一些前提条件，今天暂且不说。</p>
<h2 id="握手分析" tabindex="-1"> 握手分析</h2>
<p>目前 Nginx 等 Web 服务器都能够很好地支持 TLS1.3，但要求底层的 OpenSSL 必须是 1.1.1，而我们实验环境里用的 OpenSSL 是 1.1.0，所以暂时无法直接测试 TLS1.3。</p>
<p>不过我在 Linux 上用 OpenSSL1.1.1 编译了一个支持 TLS1.3 的 Nginx，用 Wireshark 抓包存到了 GitHub 上，用它就可以分析 TLS1.3 的握手过程。</p>
<p><img src="https://img-blog.csdnimg.cn/40308c7a44cd4babb77782f36e014ea7.png" alt=""></p>
<p>在 TCP 建立连接之后，浏览器首先还是发一个“<strong>Client Hello</strong>”。</p>
<p>因为 1.3 的消息兼容 1.2，所以开头的版本号、支持的密码套件和随机数（Client Random）结构都是一样的（不过这时的随机数是 32 个字节）。</p>
<div><pre><code>Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: cebeb6c05403654d66c2329…
    Cipher Suites (18 suites)
        Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
        Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)
        Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)
    Extension: supported_versions (len=9)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
    Extension: supported_groups (len=14)
        Supported Groups (6 groups)
            Supported Group: x25519 (0x001d)
            Supported Group: secp256r1 (0x0017)
    Extension: key_share (len=107)
        Key Share extension
            Client Key Share Length: 105
            Key Share Entry: Group: x25519
            Key Share Entry: Group: secp256r1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意“Client Hello”里的扩展，“<strong>supported_versions</strong>”表示这是 TLS1.3，“<strong>supported_groups</strong>”是支持的曲线，“<strong>key_share</strong>”是曲线对应的参数。</p>
<p>这就好像是说：</p>
<p>“还是照老规矩打招呼，这边有这些这些信息。但我猜你可能会升级，所以再多给你一些东西，也许后面用的上，咱们有话尽量一口气说完。”</p>
<p>服务器收到“Client Hello”同样返回“Server Hello”消息，还是要给出一个随机数（Server Random）和选定密码套件。</p>
<div><pre><code>Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 12d2bce6568b063d3dee2…
    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
    Extension: supported_versions (len=2)
        Supported Version: TLS 1.3 (0x0304)
    Extension: key_share (len=36)
        Key Share extension
            Key Share Entry: Group: x25519, Key Exchange length: 32
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>表面上看和 TLS1.2 是一样的，重点是后面的扩展。“<strong>supported_versions</strong>”里确认使用的是 TLS1.3，然后在“<strong>key_share</strong>”扩展带上曲线和对应的公钥参数。</p>
<p>服务器的“Hello”消息大概是这个意思：</p>
<p>“还真让你给猜对了，虽然还是按老规矩打招呼，但咱们来个‘旧瓶装新酒’。刚才你给的我都用上了，我再给几个你缺的参数，这次加密就这么定了。”</p>
<p>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：<strong>Client Random</strong>和<strong>Server Random</strong>、<strong>Client Params</strong>和<strong>Server Params</strong>，两边就可以各自用 ECDHE 算出“<strong>Pre-Master</strong>”，再用 HKDF 生成主密钥“<strong>Master Secret</strong>”，效率比 TLS1.2 提高了一大截。</p>
<p>在算出主密钥后，服务器立刻发出“<strong>Change Cipher Spec</strong>”消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露。</p>
<p>这里 TLS1.3 还有一个安全强化措施，多了个“<strong>Certificate Verify</strong>”消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和“Finished”消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改。</p>
<p>这两个“Hello”消息之后，客户端验证服务器证书，再发“<strong>Finished</strong>”消息，就正式完成了握手，开始收发 HTTP 报文。</p>
<p>虽然我们的实验环境暂时不能抓包测试 TLS1.3，但互联网上很多网站都已经支持了 TLS1.3，比如Nginx、GitHub，你可以课后自己用 Wireshark 试试。</p>
<p>在 Chrome 的开发者工具里，可以看到这些网站的 TLS1.3 应用情况。</p>
<p><img src="https://img-blog.csdnimg.cn/1657fe9b29094a5d9d6a003bb5a02729.png" alt=""></p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>今天我们一起学习了 TLS1.3 的新特性，用抓包研究了它的握手过程，不过 TLS1.3 里的内容很多，还有一些特性没有谈到，后面会继续讲。</p>
<ul>
<li>为了兼容 1.1、1.2 等“老”协议，TLS1.3 会“伪装”成 TLS1.2，新特性在“扩展”里实现；</li>
<li>1.1、1.2 在实践中发现了很多安全隐患，所以 TLS1.3 大幅度删减了加密算法，只保留了 ECDHE、AES、ChaCha20、SHA-2 等极少数算法，强化了安全；</li>
<li>TLS1.3 也简化了握手过程，完全握手只需要一个消息往返，提升了性能。</li>
</ul>
<p>课下作业</p>
<ul>
<li>TLS1.3 里的密码套件没有指定密钥交换算法和签名算法，那么在握手的时候会不会有问题呢？</li>
<li>结合上一讲的 RSA 握手过程，解释一下为什么 RSA 密钥交换不具有“前向安全”。</li>
<li>TLS1.3 的握手过程与 TLS1.2 的“False Start”有什么异同？</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/b927b8be3b1f43a3b1aa5d09d7cdb039.png" type="image/png"/>
    </item>
    <item>
      <title>如何创建一个Ajax？</title>
      <link>https://0808200.xyz/Interview/base/Ajax.html</link>
      <guid>https://0808200.xyz/Interview/base/Ajax.html</guid>
      <source url="https://0808200.xyz/rss.xml">如何创建一个Ajax？</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>什么是<code> Ajax</code>? 如何创建一个<code>Ajax</code>？</li>
</ul>
<ul>
<li>
<p><code>AJAX(Asynchronous Javascript And XML) </code>= 异步 <code>JavaScript</code> + <code>XML</code> 在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。</p>
</li>
<li>
<p>创建 <code>ajax</code> 步骤：</p>
<ul>
<li>1.创建 <code>XMLHttpRequest</code> 对象</li>
<li>2.创建一个新的 <code>HTTP</code> 请求，并指定该 <code>HTTP</code> 请求的类型、验证信息</li>
<li>3.设置响应 <code>HTTP</code> 请求状态变化的回调函数</li>
<li>4.发送 <code>HTTP</code> 请求</li>
<li>5.获取异步调用返回的数据</li>
<li>6.使用 <code>JavaScript</code> 和 <code>DOM</code> 实现局部刷新</li>
</ul>
</li>
</ul>
<div><pre><code><span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
xhr<span>.</span><span>open</span><span>(</span><span>"POST"</span><span>,</span> url<span>,</span> <span>true</span><span>)</span><span>;</span>
xhr<span>.</span><span>setRequestHeader</span><span>(</span><span>"Content-type"</span><span>,</span> <span>"application/x-www-form-urlencoded"</span><span>)</span><span>;</span>
xhr<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>xhr<span>.</span>readyState <span>==</span> <span>4</span> <span>&amp;&amp;</span> <span>(</span>xhr<span>.</span>status <span>==</span> <span>200</span> <span>||</span> xhr<span>.</span>status <span>==</span> <span>304</span><span>)</span><span>)</span> <span>{</span>
        <span>fn</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> xhr<span>.</span>responseText<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
xhr<span>.</span><span>send</span><span>(</span>data<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>安全问题：XSS和CSRF</title>
      <link>https://0808200.xyz/Interview/base/CSRF_and_XSS.html</link>
      <guid>https://0808200.xyz/Interview/base/CSRF_and_XSS.html</guid>
      <source url="https://0808200.xyz/rss.xml">安全问题：XSS和CSRF</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-前言" tabindex="-1"> 1 前言</h2>
<blockquote>
<p>面试中的安全问题，明确来说，就两个方面：</p>
</blockquote>
<ul>
<li><code>CSRF</code>：基本概念、攻击方式、防御措施</li>
<li><code>XSS</code>：基本概念、攻击方式、防御措施</li>
</ul>
<blockquote>
<p>这两个问题，一般不会问太难。</p>
</blockquote>
<blockquote>
<p>有人问：<code>SQL</code>注入算吗？答案：这个其实跟前端的关系不是很大。</p>
</blockquote>
<h2 id="_2-csrf" tabindex="-1"> 2 CSRF</h2>
<blockquote>
<p>问的不难，一般问：</p>
</blockquote>
<ul>
<li><code>CSRF</code>的基本概念、缩写、全称</li>
<li>攻击原理</li>
<li>防御措施</li>
</ul>
<blockquote>
<p>如果把<strong>攻击原理</strong>和<strong>防御措施</strong>掌握好，基本没什么问题。</p>
</blockquote>
<h3 id="_2-1-csrf的基本概念、缩写、全称" tabindex="-1"> 2.1 CSRF的基本概念、缩写、全称</h3>
<blockquote>
<p><code>CSRF</code>（<code>Cross-site request forgery</code>）：<strong>跨站请求伪造</strong>。</p>
</blockquote>
<p>PS：中文名一定要记住。英文全称，如果记不住也拉倒。</p>
<h3 id="_2-2-csrf的攻击原理" tabindex="-1"> 2.2 CSRF的攻击原理</h3>
<p><img src="http://img.smyhvae.com/20180307_1735.png" alt=""></p>
<blockquote>
<p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发<code>cookie</code>。</p>
</blockquote>
<blockquote>
<p>从上图可以看出，要完成一次<code>CSRF</code>攻击，受害者必须满足两个必要的条件：</p>
</blockquote>
<ol>
<li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code>。（如果用户没有登录网站<code>A</code>，那么网站<code>B</code>在诱导的时候，请求网站<code>A</code>的<code>api</code>接口时，会提示你登录）</li>
<li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code>（其实是利用了网站<code>A</code>的漏洞）。</li>
</ol>
<blockquote>
<p>我们在讲<code>CSRF</code>时，一定要把上面的两点说清楚。</p>
</blockquote>
<blockquote>
<p>温馨提示一下，<code>cookie</code>保证了用户可以处于登录状态，但网站<code>B</code>其实拿不到 <code>cookie</code>。</p>
</blockquote>
<blockquote>
<p>举个例子，前段时间里，微博网站有个<code>api</code>接口有漏洞，导致很多用户的粉丝暴增。</p>
</blockquote>
<h3 id="_2-3-csrf如何防御" tabindex="-1"> 2.3 CSRF如何防御</h3>
<p><strong>方法一、Token 验证：</strong>（用的最多）</p>
<ol>
<li>服务器发送给客户端一个<code>token</code>；</li>
<li>客户端提交的表单中带着这个<code>token</code>。</li>
<li>如果这个 <code>token</code> 不合法，那么服务器拒绝这个请求。</li>
</ol>
<p><strong>方法二：隐藏令牌：</strong></p>
<ul>
<li>把 <code>token</code> 隐藏在 <code>http</code> 的 <code>head</code>头中。</li>
</ul>
<blockquote>
<p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p>
</blockquote>
<p><strong>方法三、Referer 验证：</strong></p>
<blockquote>
<p><code>Referer</code> 指的是页面请求来源。意思是，<strong>只接受本站的请求，服务器才做响应</strong>；如果不是，就拦截。</p>
</blockquote>
<h2 id="_3-xss" tabindex="-1"> 3 XSS</h2>
<h3 id="_3-1-xss的基本概念" tabindex="-1"> 3.1 XSS的基本概念</h3>
<blockquote>
<p>`XSS（Cross Site Scripting）``：<strong>跨域脚本攻击</strong>。</p>
</blockquote>
<ul>
<li>接下来，我们详细讲一下 <code>XSS</code> 的内容。</li>
</ul>
<blockquote>
<p>预备知识：<code>HTTP</code>、<code>Cookie</code>、<code>Ajax</code>。</p>
</blockquote>
<h3 id="_3-2-xss的攻击原理" tabindex="-1"> 3.2 XSS的攻击原理</h3>
<blockquote>
<p><code>XSS</code>攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在<code>url</code>中输入、在评论框中输入），向你的页面注入脚本（可能是<code>js</code>、<code>hmtl</code>代码块等）。</p>
</blockquote>
<blockquote>
<p>最后导致的结果可能是：</p>
</blockquote>
<ul>
<li>盗用<code>Cookie</code></li>
<li>破坏页面的正常结构，插入广告等恶意内容</li>
<li><code>D-doss</code>攻击</li>
</ul>
<h3 id="_3-3-xss的攻击方式" tabindex="-1"> 3.3 XSS的攻击方式</h3>
<ol>
<li>反射型</li>
</ol>
<blockquote>
<p>发出请求时，<code>XSS</code>代码出现在<code>url</code>中，作为输入提交到服务器端，服务器端解析后响应，<code>XSS</code>代码随响应内容一起传回给浏览器，最后浏览器解析执行<code>XSS</code>代码。这个过程像一次反射，所以叫反射型<code>XSS</code>。</p>
</blockquote>
<ol start="2">
<li>存储型</li>
</ol>
<blockquote>
<p>存储型<code>XSS</code>和反射型<code>XSS</code>的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。</p>
</blockquote>
<h3 id="_3-4-xss的防范措施-encode-过滤" tabindex="-1"> 3.4 XSS的防范措施（encode + 过滤）</h3>
<p><strong>XSS的防范措施主要有三个：</strong></p>
<p><strong>1. 编码</strong>：</p>
<blockquote>
<p>对用户输入的数据进行<code>HTML Entity</code>编码。</p>
</blockquote>
<p>如上图所示，把字符转换成 转义字符。</p>
<blockquote>
<p><code>Encode</code>的作用是将<code>$var</code>等一些字符进行转化，使得浏览器在最终输出结果上是一样的。</p>
</blockquote>
<p>比如说这段代码：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span><span>alert</span><span>(</span><span>1</span><span>)</span></span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。</p>
</blockquote>
<blockquote>
<p>进行编码处理之后，L在浏览器中的显示结果就是<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，实现了将``$var<code>作为纯文本进行输出，且不引起J</code>avaScript`的执行。</p>
</blockquote>
<p><strong>2、过滤：</strong></p>
<ul>
<li>移除用户输入的和事件相关的属性。如<code>onerror</code>可以自动触发攻击，还有<code>onclick</code>等。（总而言是，过滤掉一些不安全的内容）</li>
<li>移除用户输入的<code>Style</code>节点、<code>Script</code>节点、<code>Iframe</code>节点。（尤其是<code>Script</code>节点，它可是支持跨域的呀，一定要移除）。</li>
</ul>
<p><strong>3、校正</strong></p>
<ul>
<li>避免直接对<code>HTML Entity</code>进行解码。</li>
<li>使用<code>DOM Parse</code>转换，校正不配对的<code>DOM</code>标签。</li>
</ul>
<blockquote>
<p>备注：我们应该去了解一下<code>DOM Parse</code>这个概念，它的作用是把文本解析成<code>DOM</code>结构。</p>
</blockquote>
<p>比较常用的做法是，通过第一步的编码转成文本，然后第三步转成<code>DOM</code>对象，然后经过第二步的过滤。</p>
<p><strong>还有一种简洁的答案：</strong></p>
<p>首先是encode，如果是富文本，就白名单。</p>
<h2 id="_4-csrf-和-xss-的区别" tabindex="-1"> 4 CSRF 和 XSS 的区别</h2>
<blockquote>
<p>面试官还可能喜欢问二者的区别。</p>
</blockquote>
<p><strong>区别一：</strong></p>
<ul>
<li><code>CSRF</code>：需要用户先登录网站<code>A</code>，获取 <code>cookie</code></li>
<li><code>XSS</code>：不需要登录。</li>
</ul>
<p><strong>区别二：（原理的区别）</strong></p>
<ul>
<li><code>CSRF</code>：是利用网站<code>A</code>本身的漏洞，去请求网站<code>A</code>的<code>api</code>。</li>
<li><code>XSS</code>：是向网站 <code>A</code> 注入 <code>JS</code>代码，然后执行 <code>JS</code> 里的代码，篡改网站<code>A</code>的内容。</li>
</ul>
]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180307_1735.png" type="image/png"/>
    </item>
    <item>
      <title>CSS基础</title>
      <link>https://0808200.xyz/Interview/base/CSS.html</link>
      <guid>https://0808200.xyz/Interview/base/CSS.html</guid>
      <source url="https://0808200.xyz/rss.xml">CSS基础</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="css" tabindex="-1"> CSS</h3>
<hr>
<p><strong>display: none; 与 visibility: hidden; 的区别</strong></p>
<ul>
<li>联系：它们都能让元素不可见</li>
<li>区别：
<ul>
<li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li>
<li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden</code>;是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible</code>;可以让子孙节点显式</li>
<li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li>
<li>读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容</li>
</ul>
</li>
</ul>
<p><strong>css hack原理及常用hack</strong></p>
<ul>
<li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li>
<li>常见的hack有
<ul>
<li>属性hack</li>
<li>选择器hack</li>
<li>IE条件注释</li>
</ul>
</li>
</ul>
<p><strong>link 与 @import 的区别</strong></p>
<ul>
<li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式</li>
<li><code>link </code>最大限度支持并行下载，<code> @import</code> 过多嵌套导致串行下载，出现FOUC</li>
<li><code>link</code> 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式</li>
<li>浏览器对 <code>link</code> 支持早于<code> @import</code> ，可以使用 <code>@import</code> 对老浏览器隐藏样式</li>
<li><code>@import</code> 必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li>
<li>总体来说：<code>link</code>优于<code>@import</code></li>
</ul>
<p><strong>CSS有哪些继承属性</strong></p>
<ul>
<li>关于文字排版的属性如：
<ul>
<li><code>font</code>
<ul>
<li><code>word-break</code></li>
<li><code>letter-spacing</code></li>
<li><code>text-align</code></li>
<li><code>text-rendering</code></li>
<li><code>word-spacing</code></li>
<li><code>white-space</code></li>
<li><code>text-indent</code></li>
<li><code>text-transform</code></li>
<li><code>text-shadow</code></li>
</ul>
</li>
<li><code>line-height</code></li>
<li><code>color</code></li>
<li><code>visibility</code></li>
<li><code>cursor</code></li>
</ul>
</li>
</ul>
<p><strong>display,float,position的关系</strong></p>
<ul>
<li>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</li>
<li>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整</li>
<li>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</li>
<li>否则，如果元素是根元素，<code>display</code>根据下表进行调整</li>
<li>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code></li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" alt="图片转自网络"></p>
<p><strong>外边距折叠(collapsing margins)</strong></p>
<ul>
<li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：
<ul>
<li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li>
<li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li>
<li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li>
<li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li>
</ul>
</li>
</ul>
<p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p>
<ul>
<li>有两种， IE 盒子模型、W3C 盒子模型；</li>
<li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li>
<li>区  别： IE的content部分把 border 和 padding计算了进去;</li>
</ul>
<p><strong>CSS选择符有哪些？哪些属性可以继承？</strong></p>
<ul>
<li>
<p>id选择器（ # myid）</p>
</li>
<li>
<p>类选择器（.myclassname）</p>
</li>
<li>
<p>标签选择器（div, h1, p）</p>
</li>
<li>
<p>相邻选择器（h1 + p）</p>
</li>
<li>
<p>子选择器（ul &gt; li）</p>
</li>
<li>
<p>后代选择器（li a）</p>
</li>
<li>
<p>通配符选择器（ * ）</p>
</li>
<li>
<p>属性选择器（a[rel = &quot;external&quot;]）</p>
</li>
<li>
<p>伪类选择器（a:hover, li:nth-child）</p>
</li>
<li>
<p>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></p>
</li>
<li>
<p>不可继承的样式：<code>border padding margin width height </code></p>
</li>
</ul>
<p><strong>CSS优先级算法如何计算？</strong></p>
<ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准</li>
<li>载入样式以最后载入的定位为准</li>
<li>优先级为: <code>!important &gt;  id &gt; class &gt; tag</code> important 比 内联优先级高</li>
</ul>
<p><strong>CSS3新增伪类有那些？</strong></p>
<div><pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p> 元素的每个 &lt;p> 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p> 元素的每个 &lt;p> 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p> 元素的每个 &lt;p> 元素。
p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p> 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p> 元素。

:after          在元素之前添加内容,也可以用来做清除浮动。
:before         在元素之后添加内容
:enabled        
:disabled       控制表单控件的禁用状态。
:checked        单选框或复选框被选中
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</strong></p>
<ul>
<li>给<code>div</code>设置一个宽度，然后添加<code>margin:0 auto</code>属性</li>
</ul>
<div><pre><code>div{
    width:200px;
    margin:0 auto;
 }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>居中一个浮动元素</li>
</ul>
<div><pre><code>//确定容器的宽高 宽500 高 300 的层
//设置层的外边距

 .div {
      width:500px ; height:300px;//高度可以不设
      margin: -150px 0 0 -250px;
      position:relative;         //相对定位
      background-color:pink;     //方便看效果
      left:50%;
      top:50%;
 }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>让绝对定位的div居中</li>
</ul>
<div><pre><code>  position: absolute;
  width: 1200px;
  background: none;
  margin: 0 auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>display有哪些值？说明他们的作用</strong></p>
<ul>
<li>block         象块类型元素一样显示。</li>
<li>none          缺省值。象行内元素类型一样显示。</li>
<li>inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</li>
<li>list-item     象块类型元素一样显示，并添加样式列表标记。</li>
<li>table         此元素会作为块级表格来显示</li>
<li>inherit       规定应该从父元素继承 display 属性的值</li>
</ul>
<p><strong>position的值relative和absolute定位原点是？</strong></p>
<ul>
<li>absolute
<ul>
<li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li>
</ul>
</li>
<li>fixed （老IE不支持）
<ul>
<li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
</ul>
</li>
<li>relative
<ul>
<li>生成相对定位的元素，相对于其正常位置进行定位。</li>
</ul>
</li>
<li>static
<ul>
<li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li>
</ul>
</li>
<li>inherit
<ul>
<li>规定从父元素继承 position 属性的值</li>
</ul>
</li>
</ul>
<p><strong>CSS3有哪些新特性？</strong></p>
<ul>
<li>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）</li>
<li>圆角           （border-radius:8px）</li>
<li>多列布局        （multi-column layout）</li>
<li>阴影和反射        （Shadow\Reflect）</li>
<li>文字特效      （text-shadow、）</li>
<li>文字渲染      （Text-decoration）</li>
<li>线性渐变      （gradient）</li>
<li>旋转          （transform）</li>
<li>增加了旋转,缩放,定位,倾斜,动画，多背景</li>
<li><code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></li>
</ul>
<p><strong>用纯CSS创建一个三角形的原理是什么？</strong></p>
<div><pre><code>// 把上、左、右三条边隐藏掉（颜色设为 transparent）
#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>一个满屏 品 字布局 如何设计?</strong></p>
<ul>
<li>简单的方式：
<ul>
<li>上面的div宽100%，</li>
<li>下面的两个div分别宽50%，</li>
<li>然后用float或者inline使其不换行即可</li>
</ul>
</li>
</ul>
<p><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</strong></p>
<ul>
<li>
<p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p>
</li>
<li>
<p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</p>
</li>
<li>
<p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</p>
</li>
<li>
<p>Firefox下,只能使用getAttribute()获取自定义属性。</p>
<ul>
<li>解决方法:统一通过getAttribute()获取自定义属性</li>
</ul>
</li>
<li>
<p>IE下,even对象有x,y属性,但是没有pageX,pageY属性</p>
</li>
<li>
<p>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</p>
</li>
</ul>
<p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p>
<ul>
<li>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</li>
</ul>
<p><strong>为什么要初始化CSS样式</strong></p>
<ul>
<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</li>
</ul>
<p><strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong></p>
<ul>
<li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型</li>
<li>不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li>
</ul>
<p><strong>css定义的权重</strong></p>
<div><pre><code>// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：

/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
}

// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>display:inline-block 什么时候会显示间隙？(携程)</strong></p>
<ul>
<li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li>
</ul>
<p><strong>谈谈浮动和清除浮动</strong></p>
<ul>
<li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li>
</ul>
<p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p>
<ul>
<li>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</li>
<li>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</li>
<li>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</li>
<li>怪异(IE)盒模型：元素宽度 = width + margin</li>
<li>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</li>
</ul>
<p><strong>box-sizing 常用的属性有哪些？分别有什么作用？</strong></p>
<ul>
<li>box-sizing: content-box;  // 默认的标准(W3C)盒模型元素效果</li>
<li>box-sizing: border-box;   // 触发怪异(IE)盒模型元素的效果</li>
<li>box-sizing: inherit;      //  继承父元素 box-sizing 属性的值</li>
</ul>
<p><strong>CSS选择器有哪些？</strong></p>
<ul>
<li>id选择器        #id</li>
<li>类选择器        .class</li>
<li>标签选择器      div, h1, p</li>
<li>相邻选择器      h1 + p</li>
<li>子选择器        ul &gt; li</li>
<li>后代选择器      li a</li>
<li>通配符选择器    *</li>
<li>属性选择器      a[rel='external']</li>
<li>伪类选择器      a:hover, li:nth-child</li>
</ul>
<p><strong>CSS哪些属性可以继承？哪些属性不可以继承？</strong></p>
<ul>
<li>可以继承的样式：font-size、font-family、color、list-style、cursor</li>
<li>不可继承的样式：width、height、border、padding、margin、background</li>
</ul>
<p><strong>CSS如何计算选择器优先？</strong></p>
<ul>
<li>相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式</li>
<li>含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式</li>
<li>选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]</li>
<li>在同一组属性设置中，!important 优先级最高，高于行内样式</li>
</ul>
<p><strong>CSS3新增伪类有哪些？</strong></p>
<ul>
<li>
<p>:root           选择文档的根元素，等同于 html 元素</p>
</li>
<li>
<p>:empty          选择没有子元素的元素</p>
</li>
<li>
<p>:target         选取当前活动的目标元素</p>
</li>
<li>
<p>:not(selector)  选择除 selector 元素意外的元素</p>
</li>
<li>
<p>:enabled        选择可用的表单元素</p>
</li>
<li>
<p>:disabled       选择禁用的表单元素</p>
</li>
<li>
<p>:checked        选择被选中的表单元素</p>
</li>
<li>
<p>:after          在元素内部最前添加内容</p>
</li>
<li>
<p>:before         在元素内部最后添加内容</p>
</li>
<li>
<p>:nth-child(n)      匹配父元素下指定子元素，在所有子元素中排序第n</p>
</li>
<li>
<p>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</p>
</li>
<li>
<p>:nth-child(odd)</p>
</li>
<li>
<p>:nth-child(even)</p>
</li>
<li>
<p>:nth-child(3n+1)</p>
</li>
<li>
<p>:first-child</p>
</li>
<li>
<p>:last-child</p>
</li>
<li>
<p>:only-child</p>
</li>
<li>
<p>:nth-of-type(n)      匹配父元素下指定子元素，在同类子元素中排序第n</p>
</li>
<li>
<p>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</p>
</li>
<li>
<p>:nth-of-type(odd)</p>
</li>
<li>
<p>:nth-of-type(even)</p>
</li>
<li>
<p>:nth-of-type(3n+1)</p>
</li>
<li>
<p>:first-of-type</p>
</li>
<li>
<p>:last-of-type</p>
</li>
<li>
<p>:only-of-type</p>
</li>
<li>
<p>::selection     选择被用户选取的元素部分</p>
</li>
<li>
<p>:first-line     选择元素中的第一行</p>
</li>
<li>
<p>:first-letter   选择元素中的第一个字符</p>
</li>
</ul>
<p><strong>请列举几种隐藏元素的方法</strong></p>
<ul>
<li>visibility: hidden;   这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li>
<li>opacity: 0;           CSS3属性，设置0可以使一个元素完全透明</li>
<li>position: absolute;   设置一个很大的 left 负值定位，使元素定位在可见区域之外</li>
<li>display: none;        元素会变得不可见，并且不会再占用文档的空间。</li>
<li>transform: scale(0);  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li>
<li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态</li>
<li>height: 0;            将元素高度设为 0 ，并消除边框</li>
<li>filter: blur(0);      CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中</li>
</ul>
<p><strong>rgba() 和 opacity 的透明效果有什么不同？</strong></p>
<ul>
<li>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</li>
<li>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li>
</ul>
<p><strong>css 属性 content 有什么作用？</strong></p>
<ul>
<li>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</li>
</ul>
<p><strong>CSS3有哪些新特性？</strong></p>
<ul>
<li>新增选择器     p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li>
<li>弹性盒模型     display: flex;</li>
<li>多列布局       column-count: 5;</li>
<li>媒体查询       @media (max-width: 480px) {.box: {column-count: 1;}}</li>
<li>个性化字体     @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li>
<li>颜色透明度     color: rgba(255, 0, 0, 0.75);</li>
<li>圆角           border-radius: 5px;</li>
<li>渐变           background:linear-gradient(red, green, blue);</li>
<li>阴影           box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li>
<li>倒影           box-reflect: below 2px;</li>
<li>文字装饰       text-stroke-color: red;</li>
<li>文字溢出       text-overflow:ellipsis;</li>
<li>背景效果       background-size: 100px 100px;</li>
<li>边框效果       border-image:url(bt_blue.png) 0 10;</li>
<li>转换
<ul>
<li>旋转          transform: rotate(20deg);</li>
<li>倾斜          transform: skew(150deg, -10deg);</li>
<li>位移          transform: translate(20px, 20px);</li>
<li>缩放          transform: scale(.5);</li>
</ul>
</li>
<li>平滑过渡       transition: all .3s ease-in .1s;</li>
<li>动画           @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li>
</ul>
<p><strong>请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</strong></p>
<ul>
<li>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</li>
</ul>
<p><strong>经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？</strong></p>
<ul>
<li>当前样式：getComputedStyle(el, null) VS el.currentStyle</li>
<li>事件对象：e VS window.event</li>
<li>鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y</li>
<li>按键码：e.which VS event.keyCode</li>
<li>文本节点：el.textContent VS el.innerText</li>
</ul>
<p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p>
<ul>
<li>li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔</li>
<li>解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小</li>
</ul>
<p><strong>什么是外边距重叠？ 重叠的结果是什么？</strong></p>
<ul>
<li>
<p>外边距重叠就是 margin-collapse</p>
</li>
<li>
<p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。
这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</p>
</li>
<li>
<p>折叠结果遵循下列计算规则：</p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和</li>
</ul>
</li>
</ul>
<p><strong>请写出多种等高布局</strong></p>
<ul>
<li>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</li>
<li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li>
<li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li>
</ul>
<p><strong>css垂直居中的方法有哪些？</strong></p>
<ul>
<li>如果是单行文本, line-height 设置成和 height 值</li>
</ul>
<div><pre><code>.vertical {
      height: 100px;
      line-height: 100px;
    }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>已知高度的块级子元素，采用绝对定位和负边距</li>
</ul>
<div><pre><code>.container {
  position: relative;
}
.vertical {
  height: 300px;  /*子元素高度*/
  position: absolute;
  top:50%;  /*父元素高度50%*/
  margin-top: -150px; /*自身高度一半*/
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>未知高度的块级父子元素居中，模拟表格布局</li>
<li>缺点：IE67不兼容，父级 overflow：hidden 失效</li>
</ul>
<div><pre><code>.container {
      display: table;
    }
    .content {
      display: table-cell;
      vertical-align: middle;
    }

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>新增 inline-block 兄弟元素，设置 vertical-align
<ul>
<li>缺点：需要增加额外标签，IE67不兼容</li>
</ul>
</li>
</ul>
<div><pre><code>
.container {
  height: 100%;/*定义父级高度，作为参考*/
}
.extra .vertical{
  display: inline-block;  /*行内块显示*/
  vertical-align: middle; /*垂直居中*/
}
.extra {
  height: 100%; /*设置新增元素高度为100%*/
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>绝对定位配合 CSS3 位移</li>
</ul>
<div><pre><code>.vertical {
  position: absolute;
  top:50%;  /*父元素高度50%*/
  transform:translateY(-50%, -50%);
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>CSS3弹性盒模型</li>
</ul>
<div><pre><code>.container {
  display:flex;
  justify-content: center; /*子元素水平居中*/
  align-items: center; /*子元素垂直居中*/
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>圣杯布局的实现原理？</strong></p>
<ul>
<li>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽
<ul>
<li>好处：重要的内容放在文档流前面可以优先渲染</li>
<li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li>
</ul>
</li>
</ul>
<div><pre><code>  <span>.container</span> <span>{</span>
      <span>padding-left</span><span>:</span> 150px<span>;</span>
      <span>padding-right</span><span>:</span> 190px<span>;</span>
  <span>}</span>
  <span>.main</span> <span>{</span>
      <span>float</span><span>:</span> left<span>;</span>
      <span>width</span><span>:</span> 100%<span>;</span>
  <span>}</span>
  <span>.left</span> <span>{</span>
      <span>float</span><span>:</span> left<span>;</span>
      <span>width</span><span>:</span> 190px<span>;</span>
      <span>margin-left</span><span>:</span> -100%<span>;</span>
      <span>position</span><span>:</span> relative<span>;</span>
      <span>left</span><span>:</span> -150px<span>;</span>
  <span>}</span>
  <span>.right</span> <span>{</span>
      <span>float</span><span>:</span> left<span>;</span>
      <span>width</span><span>:</span> 190px<span>;</span>
      <span>margin-left</span><span>:</span> -190px<span>;</span>
      <span>position</span><span>:</span> relative<span>;</span>
      <span>right</span><span>:</span> -190px<span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>什么是双飞翼布局？实现原理？</strong></p>
<ul>
<li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li>
<li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li>
</ul>
<div><pre><code><span>.container</span> <span>{</span>
    <span>/*padding-left:150px;*/</span>
    <span>/*padding-right:190px;*/</span>
<span>}</span>
<span>.main-wrap</span> <span>{</span>
    <span>width</span><span>:</span> 100%<span>;</span>
    <span>float</span><span>:</span> left<span>;</span>
<span>}</span>
<span>.main</span> <span>{</span>
    <span>margin-left</span><span>:</span> 150px<span>;</span>
    <span>margin-right</span><span>:</span> 190px<span>;</span>
<span>}</span>
<span>.left</span> <span>{</span>
    <span>float</span><span>:</span> left<span>;</span>
    <span>width</span><span>:</span> 150px<span>;</span>
    <span>margin-left</span><span>:</span> -100%<span>;</span>
    <span>/*position: relative;*/</span>
    <span>/*left:-150px;*/</span>
<span>}</span>
<span>.right</span> <span>{</span>
    <span>float</span><span>:</span> left<span>;</span>
    <span>width</span><span>:</span> 190px<span>;</span>
    <span>margin-left</span><span>:</span> -190px<span>;</span>
    <span>/*position:relative;*/</span>
    <span>/*right:-190px;*/</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>在CSS样式中常使用 px、em 在表现上有什么区别？</strong></p>
<ul>
<li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li>
<li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li>
</ul>
<p><strong>为什么要初始化CSS样式？</strong></p>
<ul>
<li>不同浏览器对有些标签样式的默认值解析不同</li>
<li>不初始化CSS会造成各现浏览器之间的页面显示差异</li>
<li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li>
</ul>
<p><strong>解释下什么是浮动和它的工作原理？</strong></p>
<ul>
<li>非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。
此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</li>
<li>工作原理：
<ul>
<li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li>
<li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li>
</ul>
</li>
</ul>
<p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
</ul>
<p><strong>列举几种清除浮动的方式？</strong></p>
<ul>
<li>添加额外标签，例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></li>
<li>使用 br 标签和其自身的 clear 属性，例如 <code>&lt;br clear=&quot;all&quot; /&gt;</code></li>
<li>父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;</li>
<li>父元素也设置浮动</li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout</li>
</ul>
<p><strong>清除浮动最佳实践（after伪元素闭合浮动）：</strong></p>
<div><pre><code>.clearfix:after{
    content: "\200B";
    display: table; 
    height: 0;
    clear: both;
  }
  .clearfix{
    *zoom: 1;
  }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</strong></p>
<ul>
<li>当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：
没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC</li>
<li>产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。</li>
<li>等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li>
<li>解决方法：使用 link 标签将样式表放在文档 head</li>
</ul>
<p><strong>介绍使用过的 CSS 预处理器？</strong></p>
<ul>
<li>CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</li>
<li>开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用</li>
<li>使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性</li>
<li>最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS</li>
</ul>
<p><strong>CSS优化、提高性能的方法有哪些？</strong></p>
<ul>
<li>多个css合并，尽量减少HTTP请求</li>
<li>将css文件放在页面最上面</li>
<li>移除空的css规则</li>
<li>避免使用CSS表达式</li>
<li>选择器优化嵌套，尽量避免层级过深</li>
<li>充分利用css继承属性，减少代码量</li>
<li>抽象提取公共样式，减少代码量</li>
<li>属性值为0时，不加单位</li>
<li>属性值为小于1的小数时，省略小数点前面的0</li>
<li>css雪碧图</li>
</ul>
<p><strong>浏览器是怎样解析CSS选择器的？</strong></p>
<ul>
<li>浏览器解析 CSS 选择器的方式是从右到左</li>
</ul>
<p><strong>在网页中的应该使用奇数还是偶数的字体？</strong></p>
<ul>
<li>在网页中的应该使用“偶数”字体：
<ul>
<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li>
<li>使用奇数号字体时文本段落无法对齐</li>
<li>宋体的中文网页排布中使用最多的就是 12 和 14</li>
</ul>
</li>
</ul>
<p><strong>margin和padding分别适合什么场景使用？</strong></p>
<ul>
<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin</li>
<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding</li>
</ul>
<p><strong>抽离样式模块怎么写，说出思路？</strong></p>
<ul>
<li>CSS可以拆分成2部分：公共CSS 和 业务CSS：
<ul>
<li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li>
<li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li>
</ul>
</li>
</ul>
<p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p>
<ul>
<li>元素竖向的百分比设定是相对于容器的宽度，而不是高度</li>
</ul>
<p><strong>全屏滚动的原理是什么？ 用到了CSS的那些属性？</strong></p>
<ul>
<li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li>
<li>可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none;</li>
</ul>
<p><strong>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</strong></p>
<ul>
<li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li>
<li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li>
<li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li>
</ul>
<div><pre><code><span>$</span><span>(</span>window<span>)</span><span>.</span><span>resize</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>screenRespond</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>screenRespond</span><span>(</span><span>)</span><span>;</span>
<span>function</span> <span>screenRespond</span><span>(</span><span>)</span><span>{</span>
<span>var</span> screenWidth <span>=</span> <span>$</span><span>(</span>window<span>)</span><span>.</span><span>width</span><span>(</span><span>)</span><span>;</span>
<span>if</span><span>(</span>screenWidth <span>&lt;=</span> <span>1800</span><span>)</span><span>{</span>
  <span>$</span><span>(</span><span>"body"</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>"class"</span><span>,</span> <span>"w1800"</span><span>)</span><span>;</span>
<span>}</span>
<span>if</span><span>(</span>screenWidth <span>&lt;=</span> <span>1400</span><span>)</span><span>{</span>
  <span>$</span><span>(</span><span>"body"</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>"class"</span><span>,</span> <span>"w1400"</span><span>)</span><span>;</span>
<span>}</span>
<span>if</span><span>(</span>screenWidth <span>></span> <span>1800</span><span>)</span><span>{</span>
  <span>$</span><span>(</span><span>"body"</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>"class"</span><span>,</span> <span>""</span><span>)</span><span>;</span>
<span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>什么是视差滚动效果，如何给每页做不同的动画？</strong></p>
<ul>
<li>
<p>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</p>
</li>
<li>
<p>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</p>
</li>
<li>
<p>实现原理</p>
<ul>
<li>以 “页面滚动条” 作为 “视差动画进度条”</li>
<li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li>
<li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li>
</ul>
</li>
</ul>
<p><strong>a标签上四个伪类的执行顺序是怎么样的？</strong></p>
<p><code>link &gt; visited &gt; hover &gt; active</code></p>
<ul>
<li>L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆</li>
</ul>
<p><strong>伪元素和伪类的区别和作用？</strong></p>
<ul>
<li>伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li>
<li>它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li>
</ul>
<div><pre><code>p::before {content:"第一章：";}
p::after {content:"Hot!";}
p::first-line {background:red;}
p::first-letter {font-size:30px;}

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li>
</ul>
<div><pre><code>a:hover {color: #FF00FF}
p:first-child {color: red}
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><strong>::before 和 :after 中双冒号和单冒号有什么区别？</strong></p>
<ul>
<li>在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</li>
<li>伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after</li>
<li>后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</li>
<li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li>
<li>综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法</li>
</ul>
<p><strong>如何修改Chrome记住密码后自动填充表单的黄色背景？</strong></p>
<ul>
<li>产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的</li>
<li>解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=&quot;off&quot;</li>
<li>解决方案2：input:-webkit-autofill { background-color: transparent; }</li>
</ul>
<p><strong>input [type=search] 搜索框右侧小图标如何美化？</strong></p>
<div><pre><code><span>input[type="search"]::-webkit-search-cancel-button</span><span>{</span>
  <span>-webkit-appearance</span><span>:</span> none<span>;</span>
  <span>height</span><span>:</span> 15px<span>;</span>
  <span>width</span><span>:</span> 15px<span>;</span>
  <span>border-radius</span><span>:</span> 8px<span>;</span>
  <span>background</span><span>:</span><span><span>url</span><span>(</span><span>"images/searchicon.png"</span><span>)</span></span> no-repeat 0 0<span>;</span>
  <span>background-size</span><span>:</span> 15px 15px<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>网站图片文件，如何点击下载？而非点击预览？</strong></p>
<p><code>&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;</code>
<code>&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt;</code></p>
<p><strong>iOS safari 如何阻止“橡皮筋效果”？</strong></p>
<div><pre><code>  <span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
      <span>var</span> <span>stopScrolling</span> <span>=</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
          event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
      <span>}</span>
      document<span>.</span><span>addEventListener</span><span>(</span><span>'touchstart'</span><span>,</span> stopScrolling<span>,</span> <span>false</span><span>)</span><span>;</span>
      document<span>.</span><span>addEventListener</span><span>(</span><span>'touchmove'</span><span>,</span> stopScrolling<span>,</span> <span>false</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>你对 line-height 是如何理解的？</strong></p>
<ul>
<li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li>
<li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li>
<li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li>
<li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li>
<li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会</li>
</ul>
<p><strong>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</strong></p>
<ul>
<li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li>
<li>百分比：将计算后的值传递给后代</li>
</ul>
<p><strong>设置元素浮动后，该元素的 display 值会如何变化？</strong></p>
<ul>
<li>设置元素浮动后，该元素的 display 值自动变成 block</li>
</ul>
<p><strong>怎么让Chrome支持小于12px 的文字？</strong></p>
<div><pre><code>  <span>.shrink</span><span>{</span>
    <span>-webkit-transform</span><span>:</span><span>scale</span><span>(</span>0.8<span>)</span><span>;</span>
    <span>-o-transform</span><span>:</span><span>scale</span><span>(</span>1<span>)</span><span>;</span>
    <span>display</span><span>:</span>inline-block<span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</strong></p>
<div><pre><code>  <span>-webkit-font-smoothing</span><span>:</span> antialiased<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>font-style 属性 oblique 是什么意思？</strong></p>
<ul>
<li>font-style: oblique; 使没有 italic 属性的文字实现倾斜</li>
</ul>
<p><strong>如果需要手动写动画，你认为最小时间间隔是多久？</strong></p>
<ul>
<li>16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms</li>
</ul>
<p><strong>display:inline-block 什么时候会显示间隙？</strong></p>
<ul>
<li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li>
<li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li>
<li>可以借助 vertical-align:top; 消除垂直间隙</li>
<li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li>
<li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li>
</ul>
<p><strong>overflow: scroll 时不能平滑滚动的问题怎么处理？</strong></p>
<ul>
<li>监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。</li>
</ul>
<p><strong>一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</strong></p>
<ul>
<li>方案1：
<code>.sub { height: calc(100%-100px); }</code></li>
<li>方案2：
<code>.container { position:relative; }</code>
<code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li>
<li>方案3：
<code>.container { display:flex; flex-direction:column; }</code>
<code>.sub { flex:1; }</code></li>
</ul>
]]></content:encoded>
      <enclosure url="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" type="image/png"/>
    </item>
    <item>
      <title>CSS盒模型及BFC</title>
      <link>https://0808200.xyz/Interview/base/CSS_box_and_BFC.html</link>
      <guid>https://0808200.xyz/Interview/base/CSS_box_and_BFC.html</guid>
      <source url="https://0808200.xyz/rss.xml">CSS盒模型及BFC</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="题目-谈一谈你对css盒模型的认识" tabindex="-1"> 题目：谈一谈你对CSS盒模型的认识</h2>
<blockquote>
<p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p>
</blockquote>
<ol>
<li>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></li>
<li>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</li>
<li><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</li>
<li><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</li>
<li>实例题：根据盒模型解释<strong>边距重叠</strong>。</li>
</ol>
<blockquote>
<p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p>
</blockquote>
<ol start="6">
<li><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</li>
</ol>
<blockquote>
<p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p>
</blockquote>
<p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p>
<p>接下来，我们把上面的六条，依次讲解。</p>
<p><strong>标准盒模型和IE盒子模型</strong></p>
<p>标准盒子模型：</p>
<p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt=""></p>
<p><code>IE</code>盒子模型：</p>
<p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt=""></p>
<p>上图显示：</p>
<blockquote>
<p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p>
</blockquote>
<ul>
<li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li>
<li><code>padding</code>：内边距。</li>
<li><code>border</code>：边框。</li>
<li><code>margin</code>：外边距。</li>
</ul>
<blockquote>
<p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p>
</blockquote>
<ul>
<li>
<p>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
</li>
<li>
<p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p>
</li>
</ul>
<p><strong>CSS如何设置这两种模型</strong></p>
<p>代码如下：</p>
<div><pre><code><span>/* 设置当前盒子为 标准盒模型（默认） */</span>
box<span>-</span>sizing<span>:</span> content<span>-</span>box<span>;</span>

<span>/* 设置当前盒子为 IE盒模型 */</span>
box<span>-</span>sizing<span>:</span> border<span>-</span>box<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>备注：盒子默认为标准盒模型。</p>
</blockquote>
<p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p>
<blockquote>
<p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p>
</blockquote>
<div><pre><code>element<span>.</span>style<span>.</span>width<span>/</span>height<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p>
</blockquote>
<p>这种方式有局限性，但应该了解。</p>
<blockquote>
<p>方式二（通用型）</p>
</blockquote>
<div><pre><code>window<span>.</span><span>getComputedStyle</span><span>(</span>element<span>)</span><span>.</span>width<span>/</span>height<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p>
</blockquote>
<blockquote>
<p>方式三（IE独有的）</p>
</blockquote>
<div><pre><code>	element<span>.</span>currentStyle<span>.</span>width<span>/</span>height<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p>
</blockquote>
<blockquote>
<p>方式四</p>
</blockquote>
<div><pre><code>	element<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>.</span>width<span>/</span>height<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p>
</blockquote>
<p><strong>margin塌陷/margin重叠</strong></p>
<p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p>
<blockquote>
<p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p>
</blockquote>
<blockquote>
<p>我们来看几个例子。</p>
</blockquote>
<p><strong>兄弟元素之间</strong></p>
<p>如下图所示：</p>
<p><img src="http://img.smyhvae.com/20170805_0904.png" alt=""></p>
<p><strong>子元素和父元素之间</strong></p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>

        <span>*</span> <span>{</span>
            <span>margin</span><span>:</span> 0<span>;</span>
            <span>padding</span><span>:</span> 0<span>;</span>
        <span>}</span>

        <span>.father</span> <span>{</span>
            <span>background</span><span>:</span> green<span>;</span>

        <span>}</span>

        <span>/* 给儿子设置margin-top为10像素 */</span>
        <span>.son</span> <span>{</span>
            <span>height</span><span>:</span> 100px<span>;</span>
            <span>margin-top</span><span>:</span> 10px<span>;</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>father<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>son<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p>
</blockquote>
<p>儿子这个盒子：</p>
<p><img src="http://img.smyhvae.com/20180305_2216.png" alt=""></p>
<p>父亲这个盒子：</p>
<p><img src="http://img.smyhvae.com/20180305_2217.png" alt=""></p>
<blockquote>
<p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p>
</blockquote>
<p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p>
<blockquote>
<p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p>
</blockquote>
<p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p>
<div><pre><code>	<span><span><span>&lt;</span>div</span><span>></span></span>
		<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
	<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20170806_1537.png" alt=""></p>
<blockquote>
<p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20170806_1544.png" alt=""></p>
<blockquote>
<p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p>
</blockquote>
<p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p>
<blockquote>
<p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。</p>
</blockquote>
<p><strong>BFC（边距重叠解决方案）</strong></p>
<blockquote>
<p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p>
</blockquote>
<p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p>
<p><strong>BFC 的原理/BFC的布局规则【非常重要】</strong></p>
<blockquote>
<p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p>
</blockquote>
<ol>
<li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li>
<li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li>
<li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li>
<li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li>
</ol>
<p><strong>如何生成BFC</strong></p>
<blockquote>
<p>有以下几种方法：</p>
</blockquote>
<ul>
<li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li>
<li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li>
<li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li>
<li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li>
</ul>
<p><strong>BFC 的应用</strong></p>
<p>**举例1：**解决 margin 重叠</p>
<blockquote>
<p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p>
</blockquote>
<p>比如说，针对下面这样一个 <code>div</code> 结构：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>father<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>son<span>"</span></span><span>></span></span>
    <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>father<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>son<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>overflow</span><span>:</span> hidden</span><span>"</span></span></span><span>></span></span>
    <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p>
</blockquote>
<p><strong>举例2</strong>：BFC区域不与float区域重叠：</p>
<p>针对下面这样一个div结构；</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>

        <span>.father-layout</span> <span>{</span>
            <span>background</span><span>:</span> pink<span>;</span>
        <span>}</span>

        <span>.father-layout .left</span> <span>{</span>
            <span>float</span><span>:</span> left<span>;</span>
            <span>width</span><span>:</span> 100px<span>;</span>
            <span>height</span><span>:</span> 100px<span>;</span>
            <span>background</span><span>:</span> green<span>;</span>
        <span>}</span>

        <span>.father-layout .right</span> <span>{</span>
            <span>height</span><span>:</span> 150px<span>;</span>  <span>/*右侧标准流里的元素，比左侧浮动的元素要高*/</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>

<span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>father-layout<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>left<span>"</span></span><span>></span></span>
        左侧，生命壹号
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span><span>></span></span>
        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>section</span><span>></span></span>

<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180306_0825.png" alt=""></p>
<blockquote>
<p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p>
</blockquote>
<p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p>
<div><pre><code>    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>overflow</span><span>:</span> hidden</span><span>"</span></span></span><span>></span></span>
        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，
    <span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><img src="http://img.smyhvae.com/20180306_0827.png" alt=""></p>
<p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p>
<p>**举例3：**清除浮动</p>
<p>现在有下面这样的结构：</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>

        <span>.father</span> <span>{</span>
            <span>background</span><span>:</span> pink<span>;</span>
        <span>}</span>

        <span>.son</span> <span>{</span>
            <span>float</span><span>:</span> left<span>;</span>
            <span>background</span><span>:</span> green<span>;</span>
        <span>}</span>

    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>

<span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>father<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>son<span>"</span></span><span>></span></span>
        生命壹号
    <span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;/</span>section</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180306_0840.png" alt=""></p>
<p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p>
<blockquote>
<p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_0845.png" alt=""></p>
<blockquote>
<p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/2015-10-03-css-27.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>ES6 的特性</title>
      <link>https://0808200.xyz/Interview/base/ES6.html</link>
      <guid>https://0808200.xyz/Interview/base/ES6.html</guid>
      <source url="https://0808200.xyz/rss.xml">ES6 的特性</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、es5、es6和es2015有什么区别" tabindex="-1"> 1、ES5、ES6和ES2015有什么区别?</h2>
<blockquote>
<p><code>ES2015</code>特指在<code>2015</code>年发布的新一代<code>JS</code>语言标准，<code>ES6</code>泛指下一代JS语言标准，包含<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>等。现阶段在绝大部分场景下，<code>ES2015</code>默认等同<code>ES6</code>。<code>ES5</code>泛指上一代语言标准。<code>ES2015</code>可以理解为<code>ES5</code>和<code>ES6</code>的时间分界线</p>
</blockquote>
<h2 id="_2、babel是什么-有什么作用" tabindex="-1"> 2、babel是什么，有什么作用?</h2>
<blockquote>
<p><code>babel</code>是一个 <code>ES6</code> 转码器，可以将 <code>ES6</code> 代码转为 <code>ES5</code> 代码，以便兼容那些还没支持<code>ES6</code>的平台</p>
</blockquote>
<h2 id="_3、let有什么用-有了var为什么还要用let" tabindex="-1"> 3、let有什么用，有了var为什么还要用let？</h2>
<blockquote>
<p>在<code>ES6</code>之前，声明变量只能用<code>var</code>，<code>var</code>方式声明变量其实是很不合理的，准确的说，是因为<code>ES5</code>里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如<code>for</code>循环<code>var</code>变量泄露，变量覆盖等问题。<code>let</code>声明的变量拥有自己的块级作用域，且修复了<code>var</code>声明变量带来的变量提升问题。</p>
</blockquote>
<h2 id="_4、举一些es6对string字符串类型做的常用升级优化" tabindex="-1"> 4、举一些ES6对String字符串类型做的常用升级优化?</h2>
<p><strong>优化部分</strong></p>
<blockquote>
<p><code>ES6</code>新增了字符串模板，在拼接大段字符串时，用反斜杠<code>(</code>)`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>String</code>原型上新增了<code>includes()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含字符的方法(<code>indexOf</code>返回<code>-1</code>表示没查到不如<code>includes</code>方法返回<code>false</code>更明确，语义更清晰), 此外还新增了<code>startsWith()</code>, <code>endsWith(),</code> <code>padStart()</code>,<code>padEnd()</code>,<code>repeat()</code>等方法，可方便的用于查找，补全字符串</p>
</blockquote>
<h2 id="_5、举一些es6对array数组类型做的常用升级优化" tabindex="-1"> 5、举一些ES6对Array数组类型做的常用升级优化</h2>
<p><strong>优化部分</strong></p>
<ul>
<li>数组解构赋值。<code>ES6</code>可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多<code>let(var),</code>且映射关系清晰，且支持赋默认值</li>
<li>扩展运算符。<code>ES6</code>新增的扩展运算符(<code>...</code>)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代<code>arguments</code>对象和<code>apply</code>方法，轻松获取未知参数个数情况下的参数集合。（尤其是在<code>ES5</code>中，<code>arguments</code>并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]</code>; <code>let b = [...a]</code>）</li>
</ul>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Array</code>原型上新增了<code>find()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含数组项目的方法,且修复了<code>indexOf</code>查找不到<code>NaN的bug([NaN].indexOf(NaN) === -1)</code>.此外还新增了<code>copyWithin()</code>,<code> includes()</code>, <code>fill()</code>,<code>flat()</code>等方法，可方便的用于字符串的查找，补全,转换等</p>
</blockquote>
<h2 id="_6、举一些es6对number数字类型做的常用升级优化" tabindex="-1"> 6、举一些ES6对Number数字类型做的常用升级优化</h2>
<p><strong>优化部分</strong></p>
<blockquote>
<p>ES6在<code>Number</code>原型上新增了<code>isFinite()</code>, <code>isNaN()</code>方法，用来取代传统的全局<code>isFinite(),</code> <code>isNaN()</code>方法检测数值是否有限、是否是<code>NaN</code>。<code>ES5</code>的<code>isFinite()</code>, <code>isNaN()</code>方法都会先将非数值类型的参数转化为<code>Number</code>类型再做判断，这其实是不合理的，最造成i<code>sNaN('NaN') === true</code>的奇怪行为<code>--'NaN'</code>是一个字符串，但是<code>isNaN</code>却说这就是<code>NaN</code>。而<code>Number.isFinite()</code>和<code>Number.isNaN()</code>则不会有此类问题(<code>Number.isNaN('NaN') === false</code>)。（<code>isFinite()</code>同上）</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Math</code>对象上新增了<code>Math.cbrt()</code>，<code>trunc()</code>，<code>hypot()</code>等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算</p>
</blockquote>
<h2 id="_7、举一些es6对object类型做的常用升级优化-重要" tabindex="-1"> 7、举一些ES6对Object类型做的常用升级优化?(重要)</h2>
<p><strong>优化部分</strong></p>
<blockquote>
<p>对象属性变量式声明。<code>ES6</code>可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰</p>
</blockquote>
<div><pre><code><span>let</span> <span>[</span>apple<span>,</span> orange<span>]</span> <span>=</span> <span>[</span><span>'red appe'</span><span>,</span> <span>'yellow orange'</span><span>]</span><span>;</span>
<span>let</span> myFruits <span>=</span> <span>{</span>apple<span>,</span> orange<span>}</span><span>;</span>    <span>// let myFruits = {apple: 'red appe', orange: 'yellow orange'};</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显</p>
</blockquote>
<div><pre><code><span>let</span> <span>{</span>keys<span>,</span> values<span>,</span> entries<span>}</span> <span>=</span> Object<span>;</span>
<span>let</span> MyOwnMethods <span>=</span> <span>{</span>keys<span>,</span> values<span>,</span> entries<span>}</span><span>;</span> <span>// let MyOwnMethods = {keys: keys, values: values, entries: entries}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法</p>
<div><pre><code><span>let</span> es5Fun <span>=</span> <span>{</span>
    <span>method</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span>
<span>}</span><span>;</span> 
<span>let</span> es6Fun <span>=</span> <span>{</span>
    <span>method</span><span>(</span><span>)</span><span>{</span><span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>对象的解构赋值。 <code>ES6</code>对象也可以像数组解构赋值那样，进行变量的解构赋值</p>
</blockquote>
<div><pre><code><span>let</span> <span>{</span>apple<span>,</span> orange<span>}</span> <span>=</span> <span>{</span><span>apple</span><span>:</span> <span>'red appe'</span><span>,</span> <span>orange</span><span>:</span> <span>'yellow orange'</span><span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>对象的扩展运算符(<code>...</code>)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解</p>
</blockquote>
<div><pre><code><span>let</span> <span>{</span>apple<span>,</span> orange<span>,</span> <span>...</span>otherFruits<span>}</span> <span>=</span> <span>{</span><span>apple</span><span>:</span> <span>'red apple'</span><span>,</span> <span>orange</span><span>:</span> <span>'yellow orange'</span><span>,</span> <span>grape</span><span>:</span> <span>'purple grape'</span><span>,</span> <span>peach</span><span>:</span> <span>'sweet peach'</span><span>}</span><span>;</span> 
<span>// otherFruits  {grape: 'purple grape', peach: 'sweet peach'}</span>
<span>// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)</span>
<span>let</span> moreFruits <span>=</span> <span>{</span><span>watermelon</span><span>:</span> <span>'nice watermelon'</span><span>}</span><span>;</span>
<span>let</span> allFruits <span>=</span> <span>{</span>apple<span>,</span> orange<span>,</span> <span>...</span>otherFruits<span>,</span> <span>...</span>moreFruits<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>super</code> 关键字。<code>ES6</code>在<code>Class</code>类里新增了类似<code>this</code>的关键字<code>super</code>。同<code>this</code>总是指向当前函数所在的对象不同，<code>super</code>关键字总是指向当前函数所在对象的原型对象</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Object</code>原型上新增了<code>is()</code>方法，做两个目标对象的相等比较，用来完善<code>'==='</code>方法。<code>'==='</code>方法中<code>NaN === NaN //false</code>其实是不合理的，<code>Object.is</code>修复了这个小<code>bug</code>。<code>(Object.is(NaN, NaN) // true)</code></p>
</blockquote>
<blockquote>
<p><code>ES6</code>在<code>Object</code>原型上新增了<code>assign()</code>方法，用于对象新增属性或者多个对象合并</p>
</blockquote>
<div><pre><code><span>const</span> target <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>const</span> source1 <span>=</span> <span>{</span> <span>b</span><span>:</span> <span>2</span> <span>}</span><span>;</span>
<span>const</span> source2 <span>=</span> <span>{</span> <span>c</span><span>:</span> <span>3</span> <span>}</span><span>;</span>
Object<span>.</span><span>assign</span><span>(</span>target<span>,</span> source1<span>,</span> source2<span>)</span><span>;</span>
target <span>// {a:1, b:2, c:3}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><strong>注意</strong>: <code>assign</code>合并的对象<code>target</code>只能合并<code>source1</code>、s<code>ource2</code>中的自身属性，并不会合并<code>source1</code>、<code>source2</code>中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行<code>get/set</code>函数，取<code>return</code>的值）</p>
</blockquote>
<ul>
<li><code>ES6</code>在<code>Object</code>原型上新增了<code>getOwnPropertyDescriptors()</code>方法，此方法增强了<code>ES5</code>中<code>getOwnPropertyDescriptor()</code>方法，可以获取指定对象所有自身属性的描述对象。结合<code>defineProperties()</code>方法，可以完美复制对象，包括复制<code>get</code>和<code>set</code>属性</li>
<li><code>ES6</code>在<code>Object</code>原型上新增了<code>getPrototypeOf()</code>和<code>setPrototypeOf()</code>方法，用来获取或设置当前对象的<code>prototype</code>对象。这个方法存在的意义在于，<code>ES5</code>中获取设置<code>prototype</code>对像是通过<code>__proto__</code>属性来实现的，然而<code>__proto__</code>属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的<code>prototype</code>对象时，都应该采用ES6新增的标准用法</li>
<li><code>ES6</code>在<code>Object</code>原型上还新增了<code>Object.keys()</code>，<code>Object.values()</code>，<code>Object.entries()</code>方法，用来获取对象的所有键、所有值和所有键值对数组</li>
</ul>
<h2 id="_8、举一些es6对function函数类型做的常用升级优化" tabindex="-1"> 8、举一些ES6对Function函数类型做的常用升级优化?</h2>
<p><strong>优化部分</strong></p>
<blockquote>
<p>箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点</p>
</blockquote>
<ul>
<li>箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下<code>this</code>的指向变得很难理解，尤其是非严格模式情况下，<code>this</code>有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的<code>this</code>,这也就导致了<code>this</code>总是指向上一层的<code>this</code>，如果上一层还是箭头函数，则继续向上指，直到指向到有自己<code>this</code>的函数为止，并作为自己的<code>this</code></li>
<li>箭头函数不能用作构造函数，因为它没有自己的<code>this</code>，无法实例化</li>
<li>也是因为箭头函数没有自己的this,所以箭头函数 内也不存在<code>arguments</code>对象。（可以用扩展运算符代替）</li>
<li>函数默认赋值。<code>ES6</code>之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。<code>ES6</code>以更简洁更明确的方式进行函数默认赋值</li>
</ul>
<div><pre><code><span>function</span> <span>es6Fuc</span> <span>(</span>x<span>,</span> y <span>=</span> <span>'default'</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
<span>}</span>
<span>es6Fuc</span><span>(</span><span>4</span><span>)</span> <span>// 4, default</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>升级部分</strong></p>
<blockquote>
<p>ES6新增了双冒号运算符，用来取代以往的<code>bind</code>，<code>call</code>,和<code>apply</code>。(浏览器暂不支持，<code>Babel</code>已经支持转码)</p>
</blockquote>
<div><pre><code><span>foo</span><span>:</span><span>:</span>bar<span>;</span>
<span>// 等同于</span>
<span>bar</span><span>.</span><span>bind</span><span>(</span>foo<span>)</span><span>;</span>

<span>foo</span><span>:</span><span>:</span><span>bar</span><span>(</span><span>...</span>arguments<span>)</span><span>;</span>
<span>// 等同于</span>
<span>bar</span><span>.</span><span>apply</span><span>(</span>foo<span>,</span> arguments<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_9、symbol是什么-有什么作用" tabindex="-1"> 9、Symbol是什么，有什么作用？</h2>
<blockquote>
<p><code>Symbol</code>是<code>ES6</code>引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中<code>Symbol()</code>属性不能被<code>for...in</code>遍历，但是也不是私有属性</p>
</blockquote>
<h2 id="_10、set是什么-有什么作用" tabindex="-1"> 10、Set是什么，有什么作用？</h2>
<blockquote>
<p><code>Set</code>是<code>ES6</code>引入的一种类似<code>Array</code>的新的数据结构，<code>Set</code>实例的成员类似于数组<code>item</code>成员，区别是<code>Set</code>实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重</p>
</blockquote>
<h2 id="_11、map是什么-有什么作用" tabindex="-1"> 11、Map是什么，有什么作用？</h2>
<blockquote>
<p><code>Map</code>是<code>ES6</code>引入的一种类似<code>Object</code>的新的数据结构，<code>Map</code>可以理解为是<code>Object</code>的超集，打破了以传统键值对形式定义对象，对象的<code>key</code>不再局限于字符串，也可以是<code>Object</code>。可以更加全面的描述对象的属性</p>
</blockquote>
<h2 id="_12、proxy是什么-有什么作用" tabindex="-1"> 12、Proxy是什么，有什么作用？</h2>
<blockquote>
<p><code>Proxy</code>是<code>ES6</code>新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的<code>get/set</code>等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的<code>get/set</code>方法，可以轻松地定制自己想要的<code>key</code>或者<code>value</code>。下面的例子可以看到，随便定义一个<code>myOwnObj</code>的<code>key</code>,都可以变成自己想要的函数`</p>
</blockquote>
<div><pre><code><span>function</span> <span>createMyOwnObj</span><span>(</span><span>)</span> <span>{</span>
	<span>//想把所有的key都变成函数，或者Promise,或者anything</span>
	<span>return</span> <span>new</span> <span>Proxy</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>{</span>
		<span>get</span><span>(</span>target<span>,</span> propKey<span>,</span> receiver<span>)</span> <span>{</span>
			<span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
				<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
					<span>let</span> randomBoolean <span>=</span> Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>></span> <span>0.5</span><span>;</span>
					<span>let</span> Message<span>;</span>
					<span>if</span> <span>(</span>randomBoolean<span>)</span> <span>{</span>
						Message <span>=</span> <span><span>`</span><span>你的</span><span><span>${</span>propKey<span>}</span></span><span>运气不错，成功了</span><span>`</span></span><span>;</span>
						<span>resolve</span><span>(</span>Message<span>)</span><span>;</span>
					<span>}</span> <span>else</span> <span>{</span>
						Message <span>=</span> <span><span>`</span><span>你的</span><span><span>${</span>propKey<span>}</span></span><span>运气不行，失败了</span><span>`</span></span><span>;</span>
						<span>reject</span><span>(</span>Message<span>)</span><span>;</span>
					<span>}</span>
				<span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
			<span>}</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>let</span> myOwnObj <span>=</span> <span>createMyOwnObj</span><span>(</span><span>)</span><span>;</span>

myOwnObj<span>.</span>hahaha<span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>
	console<span>.</span><span>log</span><span>(</span>result<span>)</span> <span>//你的hahaha运气不错，成功了</span>
<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>
	console<span>.</span><span>log</span><span>(</span>error<span>)</span> <span>//你的hahaha运气不行，失败了</span>
<span>}</span><span>)</span>

myOwnObj<span>.</span>wuwuwu<span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>
	console<span>.</span><span>log</span><span>(</span>result<span>)</span> <span>//你的wuwuwu运气不错，成功了</span>
<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>error</span> <span>=></span> <span>{</span>
	console<span>.</span><span>log</span><span>(</span>error<span>)</span> <span>//你的wuwuwu运气不行，失败了</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_13、reflect是什么-有什么作用" tabindex="-1"> 13、Reflect是什么，有什么作用？</h2>
<blockquote>
<p><code>Reflect</code>是<code>ES6</code>引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在<code>Object</code>、<code>Function</code>或者全局函数里的方法(如<code>apply</code>、<code>delete</code>、<code>get</code>、<code>set</code>等等)，统一整合到<code>Reflect</code>上，这样可以更加方便更加统一的管理一些原生<code>API</code>。其次就是因为<code>Proxy</code>可以改写默认的原生API，如果一旦原生<code>API</code>别改写可能就找不到了，所以<code>Reflect</code>也可以起到备份原生API的作用，使得即使原生<code>API</code>被改写了之后，也可以在被改写之后的<code>API</code>用上默认的<code>API</code></p>
</blockquote>
<h2 id="_14、promise是什么-有什么作用" tabindex="-1"> 14、Promise是什么，有什么作用？</h2>
<blockquote>
<p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的<code>API</code>，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用</p>
</blockquote>
<h2 id="_15、iterator是什么-有什么作用-重要" tabindex="-1"> 15、Iterator是什么，有什么作用？(重要)</h2>
<ul>
<li><code>Iterator</code>是<code>ES6</code>中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为<code>ES6</code>新增了<code>Set</code>、<code>Map</code>类型，他们和<code>Array</code>、<code>Object</code>类型很像，<code>Array</code>、<code>Object</code>都是可以遍历的，但是<code>Set</code>、<code>Map</code>都不能用for循环遍历，解决这个问题有两种方案，一种是为<code>Set</code>、<code>Map</code>单独新增一个用来遍历的<code>API</code>，另一种是为<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>Object</code>新增一个统一的遍历<code>API</code>，显然，第二种更好，<code>ES6</code>也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。<code>Iterator</code>正是这样一种标准。或者说是一种规范理念</li>
<li>就好像<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现一样，<code>Iterator</code>标准的具体实现是<code>Iterator</code>遍历器。<code>Iterator</code>标准规定，所有部署了<code>key</code>值为<code>[Symbol.iterator]</code>，且<code>[Symbol.iterator]</code>的<code>value</code>是标准的<code>Iterator</code>接口函数(标准的<code>Iterator</code>接口函数: 该函数必须返回一个对象，且对象中包含<code>next</code>方法，且执行<code>next()</code>能返回包含<code>value/done</code>属性的<code>Iterator</code>对象)的对象，都称之为可遍历对象，<code>next()</code>后返回的<code>Iterator</code>对象也就是<code>Iterator</code>遍历器</li>
</ul>
<div><pre><code><span>//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span>
<span>//obj.[Symbol.iterator]() 就是Iterator遍历器</span>
<span>let</span> obj <span>=</span> <span>{</span>
  <span>data</span><span>:</span> <span>[</span> <span>'hello'</span><span>,</span> <span>'world'</span> <span>]</span><span>,</span>
  <span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> self <span>=</span> <span>this</span><span>;</span>
    <span>let</span> index <span>=</span> <span>0</span><span>;</span>
    <span>return</span> <span>{</span>
      <span>next</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> self<span>.</span>data<span>.</span>length<span>)</span> <span>{</span>
          <span>return</span> <span>{</span>
            <span>value</span><span>:</span> self<span>.</span>data<span>[</span>index<span>++</span><span>]</span><span>,</span>
            <span>done</span><span>:</span> <span>false</span>
          <span>}</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>return</span> <span>{</span> <span>value</span><span>:</span> <span>undefined</span><span>,</span> <span>done</span><span>:</span> <span>true</span> <span>}</span><span>;</span>
        <span>}</span>
      <span>}</span>
    <span>}</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>ES6</code>给<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>都加上了<code>[Symbol.iterator]</code>方法，且<code>[Symbol.iterator]</code>方法函数也符合标准的<code>Iterator</code>接口规范，所以<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>默认都是可以遍历的</p>
</blockquote>
<div><pre><code><span>//Array</span>
<span>let</span> array <span>=</span> <span>[</span><span>'red'</span><span>,</span> <span>'green'</span><span>,</span> <span>'blue'</span><span>]</span><span>;</span>
array<span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span> <span>//Iterator遍历器</span>
array<span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span> <span>//{value: "red", done: false}</span>

<span>//String</span>
<span>let</span> string <span>=</span> <span>'1122334455'</span><span>;</span>
string<span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span> <span>//Iterator遍历器</span>
string<span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span> <span>//{value: "1", done: false}</span>

<span>//set</span>
<span>let</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>'red'</span><span>,</span> <span>'green'</span><span>,</span> <span>'blue'</span><span>]</span><span>)</span><span>;</span>
<span>set</span><span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span> <span>//Iterator遍历器</span>
<span>set</span><span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span> <span>//{value: "red", done: false}</span>

<span>//Map</span>
<span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
<span>let</span> obj<span>=</span> <span>{</span><span>map</span><span>:</span> <span>'map'</span><span>}</span><span>;</span>
map<span>.</span><span>set</span><span>(</span>obj<span>,</span> <span>'mapValue'</span><span>)</span><span>;</span>
map<span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span>  <span>{</span><span>value</span><span>:</span> <span>Array</span><span>(</span><span>2</span><span>)</span><span>,</span> <span>done</span><span>:</span> <span>false</span><span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_16、for-in-和for-of有什么区别" tabindex="-1"> 16、for...in 和for...of有什么区别？</h2>
<blockquote>
<p>如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用<code>for...of</code>。ES6规定，有所部署了载了<code>Iterator</code>接口的对象(可遍历对象)都可以通过<code>for...of</code>去遍历，而<code>for..in</code>仅仅可以遍历对象</p>
</blockquote>
<ul>
<li>这也就意味着，数组也可以用<code>for...of</code>遍历，这极大地方便了数组的取值，且避免了很多程序用<code>for..in</code>去遍历数组的恶习</li>
</ul>
<h2 id="_17、generator函数是什么-有什么作用" tabindex="-1"> 17、Generator函数是什么，有什么作用？</h2>
<ul>
<li>如果说<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现、<code>Iterator</code>遍历器是<code>Iterator</code>的具体实现，那么<code>Generator</code>函数可以说是<code>Iterator</code>接口的具体实现方式。</li>
<li>执行<code>Generator</code>函数会返回一个遍历器对象，每一次<code>Generator</code>函数里面的<code>yield</code>都相当一次遍历器对象的<code>next()</code>方法，并且可以通过<code>next(value)</code>方法传入自定义的value,来改变<code>Generator</code>函数的行为。</li>
<li><code>Generator</code>函数可以通过配合<code>Thunk</code> 函数更轻松更优雅的实现异步编程和控制流管理。</li>
</ul>
<h2 id="_18、async函数是什么-有什么作用" tabindex="-1"> 18、async函数是什么，有什么作用？</h2>
<blockquote>
<p><code>async</code>函数可以理解为内置自动执行器的<code>Generator</code>函数语法糖，它配合<code>ES6</code>的<code>Promise</code>近乎完美的实现了异步编程解决方案</p>
</blockquote>
<h2 id="_19、class、extends是什么-有什么作用" tabindex="-1"> 19、Class、extends是什么，有什么作用？</h2>
<blockquote>
<p><code>ES6</code> 的<code>class</code>可以看作只是一个<code>ES5</code>生成实例对象的构造函数的语法糖。它参考了<code>java</code>语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。<code>Class</code>类可以通过<code>extends</code>实现继承。它和ES5构造函数的不同点</p>
</blockquote>
<p>类的内部定义的所有方法，都是不可枚举的</p>
<div><pre><code><span>///ES5</span>
<span>function</span> <span>ES5Fun</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
	<span>this</span><span>.</span>x <span>=</span> x<span>;</span>
	<span>this</span><span>.</span>y <span>=</span> y<span>;</span>
<span>}</span>
<span>ES5Fun</span><span>.</span>prototype<span>.</span><span>toString</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
	 <span>return</span> <span>'('</span> <span>+</span> <span>this</span><span>.</span>x <span>+</span> <span>', '</span> <span>+</span> <span>this</span><span>.</span>y <span>+</span> <span>')'</span><span>;</span>
<span>}</span>
<span>var</span> p <span>=</span> <span>new</span> <span>ES5Fun</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>)</span><span>;</span>
p<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
Object<span>.</span><span>keys</span><span>(</span><span>ES5Fun</span><span>.</span>prototype<span>)</span><span>;</span> <span>//['toString']</span>

<span>//ES6</span>
<span>class</span> <span>ES6Fun</span> <span>{</span>
	<span>constructor</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
		<span>this</span><span>.</span>x <span>=</span> x<span>;</span>
		<span>this</span><span>.</span>y <span>=</span> y<span>;</span>
	<span>}</span>
	<span>toString</span> <span>(</span><span>)</span> <span>{</span>
		<span>return</span> <span>'('</span> <span>+</span> <span>this</span><span>.</span>x <span>+</span> <span>', '</span> <span>+</span> <span>this</span><span>.</span>y <span>+</span> <span>')'</span><span>;</span>
	<span>}</span>
<span>}</span>

Object<span>.</span><span>keys</span><span>(</span><span>ES6Fun</span><span>.</span>prototype<span>)</span><span>;</span> <span>//[]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><code>ES6</code>的<code>class</code>类必须用<code>new</code>命令操作，而<code>ES5</code>的构造函数不用<code>new</code>也可以执行。</li>
<li><code>ES6</code>的<code>class</code>类不存在变量提升，必须先定义<code>class</code>之后才能实例化，不像<code>ES5</code>中可以将构造函数写在实例化之后。</li>
<li><code>ES5</code> 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面。<code>ES6</code> 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li>
</ul>
<h2 id="_20、module、export、import是什么-有什么作用" tabindex="-1"> 20、module、export、import是什么，有什么作用？</h2>
<ul>
<li><code>module</code>、<code>export</code>、<code>import</code>是<code>ES6</code>用来统一前端模块化方案的设计思路和实现方案。<code>export</code>、<code>import</code>的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的<code>AMD/CMD</code>、<code>requireJS</code>、<code>seaJS</code>、<code>commondJS</code>等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，<code>JS</code>也能更加能实现大型的应用程序开发。</li>
<li><code>import</code>引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</li>
<li><code>import</code>引入<code>export</code>导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li>
</ul>
<h2 id="_21、日常前端代码开发中-有哪些值得用es6去改进的编程优化或者规范" tabindex="-1"> 21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</h2>
<ul>
<li>常用箭头函数来取代<code>var self = this</code>;的做法。</li>
<li>常用<code>let</code>取代<code>var</code>命令。</li>
<li>常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。</li>
<li>在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。</li>
<li>用<code>Class</code>类取代传统的构造函数，来生成实例化对象。</li>
<li>在大型应用开发中，要保持<code>module</code>模块化开发思维，分清模块之间的关系，常用<code>import</code>、<code>export</code>方法。</li>
</ul>
<h2 id="_22、es6的了解" tabindex="-1"> 22、ES6的了解</h2>
<blockquote>
<p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念</p>
</blockquote>
<h2 id="_23、说说你对promise的理解" tabindex="-1"> 23、说说你对Promise的理解</h2>
<ul>
<li>
<p>依照 Promise/A+ 的定义，Promise 有四种状态：</p>
<ul>
<li>
<p>pending: 初始状态, 非 fulfilled 或 rejected.</p>
</li>
<li>
<p>fulfilled: 成功的操作.</p>
</li>
<li>
<p>rejected: 失败的操作.</p>
</li>
<li>
<p>settled: Promise已被fulfilled或rejected，且不是pending</p>
</li>
</ul>
</li>
<li>
<p>另外， fulfilled 与 rejected 一起合称 settled</p>
</li>
<li>
<p>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算</p>
</li>
</ul>
<h2 id="_24、promise-的构造函数" tabindex="-1"> 24、Promise 的构造函数</h2>
<ul>
<li>构造一个 Promise，最基本的用法如下：</li>
</ul>
<div><pre><code><span>var</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>

        <span>if</span> <span>(</span><span>...</span><span>)</span> <span>{</span>  <span>// succeed</span>

            <span>resolve</span><span>(</span>result<span>)</span><span>;</span>

        <span>}</span> <span>else</span> <span>{</span>   <span>// fails</span>

            <span>reject</span><span>(</span><span>Error</span><span>(</span>errMessage<span>)</span><span>)</span><span>;</span>

        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：</li>
</ul>
<div><pre><code>promise.then(onFulfilled, onRejected)
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</li>
</ul>
<p><strong>什么是 Promise ？</strong></p>
<ul>
<li>Promise 就是一个对象，用来表示并传递异步操作的最终结果</li>
<li>Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因</li>
<li>Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱）</li>
</ul>
<h2 id="_25、谈一谈你了解ecmascript6的新特性" tabindex="-1"> 25、谈一谈你了解ECMAScript6的新特性？</h2>
<ul>
<li>块级作用区域              <code>let a = 1;</code></li>
<li>可定义常量                <code>const PI = 3.141592654;</code></li>
<li>变量解构赋值              <code>var [a, b, c] = [1, 2, 3];</code></li>
<li>字符串的扩展(模板字符串)  <code>var sum =</code>${a + b}<code>;</code></li>
<li>数组的扩展(转换数组类型)   <code>Array.from($('li'));</code></li>
<li>函数的扩展(扩展运算符)     <code>[1, 2].push(...[3, 4, 5]);</code></li>
<li>对象的扩展(同值相等算法)   <code> Object.is(NaN, NaN);</code></li>
<li>新增数据类型(Symbol)      <code>let uid = Symbol('uid');</code></li>
<li>新增数据结构(Map)        <code> let set = new Set([1, 2, 2, 3]);</code></li>
<li>for...of循环            <code>for(let val of arr){};</code></li>
<li>Promise对象            <code> var promise = new Promise(func);</code></li>
<li>Generator函数          <code> function* foo(x){yield x; return x*x;}</code></li>
<li>引入Class(类)          <code> class Foo {}</code></li>
<li>引入模块体系            <code> export default func;</code></li>
<li>引入async函数[ES7]</li>
</ul>
<div><pre><code><span>async</span> <span>function</span> <span>asyncPrint</span><span>(</span><span>value<span>,</span> ms</span><span>)</span> <span>{</span>
      <span>await</span> <span>timeout</span><span>(</span>ms<span>)</span><span>;</span>
      console<span>.</span><span>log</span><span>(</span>value<span>)</span>
     <span>}</span>
     
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_26、object-is-与原来的比较操作符-、-的区别" tabindex="-1"> 26、Object.is() 与原来的比较操作符 ===、== 的区别？</h2>
<ul>
<li>== 相等运算符，比较时会自动进行数据类型转换</li>
<li>=== 严格相等运算符，比较时不进行隐式类型转换</li>
<li>Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理</li>
</ul>
<div><pre><code>+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_27、什么是-babel" tabindex="-1"> 27、什么是 Babel</h2>
<ul>
<li>Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。
这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。</li>
<li>Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>前端模块化</title>
      <link>https://0808200.xyz/Interview/base/Front-end-frame-relative.html</link>
      <guid>https://0808200.xyz/Interview/base/Front-end-frame-relative.html</guid>
      <source url="https://0808200.xyz/rss.xml">前端模块化</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>什么是单页面应用(SPA)？</strong></p>
<ul>
<li>
<p>单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页</p>
</li>
<li>
<p>目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。</p>
</li>
<li>
<p>流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据</p>
</li>
<li>
<p>实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。</p>
</li>
<li>
<p>优点：用户体验流畅，服务器压力小，前后端职责分离</p>
</li>
<li>
<p>缺点：关键词布局难度加大，不利于 SEO</p>
</li>
</ul>
<p><strong>什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点?</strong></p>
<ul>
<li>前端路由通过 URL 和 History 来实现页面切换</li>
<li>应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目</li>
<li>优点：用户体验好，交互流畅</li>
<li>缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存</li>
</ul>
<p><strong>模块化开发怎么做？</strong></p>
<ul>
<li>封装对象作为命名空间 -- 内部状态可以被外部改写</li>
<li>立即执行函数(IIFE) -- 需要依赖多个JS文件，并且严格按顺序加载</li>
<li>使用模块加载器 -- require.js, sea.js, EC6 模块</li>
</ul>
<p><strong>通行的 Javascript 模块的规范有哪些？</strong></p>
<ul>
<li>CommonJS -- 主要用在服务器端 node.js</li>
</ul>
<div><pre><code><span>var</span> math <span>=</span> <span>require</span><span>(</span><span>'./math'</span><span>)</span><span>;</span>
math<span>.</span><span>add</span><span>(</span><span>2</span><span>,</span><span>3</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li>AMD(异步模块定义) -- require.js</li>
</ul>
<div><pre><code><span>require</span><span>(</span><span>[</span><span>'./math'</span><span>]</span><span>,</span> <span>function</span> <span>(</span><span>math</span><span>)</span> <span>{</span>
    math<span>.</span><span>add</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>CMD(通用模块定义) -- sea.js</li>
</ul>
<div><pre><code><span>var</span> math <span>=</span> <span>require</span><span>(</span><span>'./math'</span><span>)</span><span>;</span>
math<span>.</span><span>add</span><span>(</span><span>2</span><span>,</span><span>3</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li>ES6 模块</li>
</ul>
<div><pre><code><span>import</span> <span>{</span>math<span>}</span> <span>from</span> <span>'./math'</span><span>;</span>
math<span>.</span><span>add</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><strong>AMD 与 CMD 规范的区别？</strong></p>
<ul>
<li>
<p>规范化产出：</p>
<ul>
<li>AMD 由 RequireJS 推广产出</li>
<li>CMD 由 SeaJS 推广产出</li>
</ul>
</li>
<li>
<p>模块的依赖:</p>
<ul>
<li>AMD 提前执行，推崇依赖前置</li>
<li>CMD 延迟执行，推崇依赖就近</li>
</ul>
</li>
<li>
<p>API 功能:</p>
<ul>
<li>AMD 的 API 默认多功能（分全局 require 和局部 require）</li>
<li>CMD 的 API 推崇职责单一纯粹（没有全局 require）</li>
</ul>
</li>
<li>
<p>模块定义规则：</p>
<ul>
<li>AMD 默认一开始就载入全部依赖模块</li>
</ul>
</li>
</ul>
<div><pre><code>  <span>define</span><span>(</span><span>[</span><span>'./a'</span><span>,</span> <span>'./b'</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
      a<span>.</span><span>doSomething</span><span>(</span><span>)</span><span>;</span>
      b<span>.</span><span>doSomething</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>CMD 依赖模块在用到时才就近载入</li>
</ul>
<div><pre><code>  <span>define</span><span>(</span><span>function</span><span>(</span><span>require<span>,</span> exports<span>,</span> module</span><span>)</span> <span>{</span>
      <span>var</span> a <span>=</span> <span>require</span><span>(</span><span>'./a'</span><span>)</span><span>;</span>
      a<span>.</span><span>doSomething</span><span>(</span><span>)</span><span>;</span>
      <span>var</span> b <span>=</span> <span>require</span><span>(</span><span>'./b'</span><span>)</span><span>;</span>
      b<span>.</span><span>doSomething</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>requireJS的核心原理是什么？</strong></p>
<ul>
<li>每个模块所依赖模块都会比本模块预先加载</li>
</ul>
<p><strong>对 Node.js 的优点、缺点提出了自己的看法？ Node.js的特点和适用场景？</strong></p>
<ul>
<li>Node.js的特点：单线程，非阻塞I/O，事件驱动</li>
<li>Node.js的优点：擅长处理高并发；适合I/O密集型应用</li>
</ul>
<ul>
<li>
<p>Node.js的缺点：不适合CPU密集运算；不能充分利用多核CPU；可靠性低，某个环节出错会导致整个系统崩溃</p>
</li>
<li>
<p>Node.js的适用场景：</p>
<ul>
<li>RESTful API</li>
<li>实时应用：在线聊天、图文直播</li>
<li>工具类应用：前端部署(npm, gulp)</li>
<li>表单收集：问卷系统</li>
</ul>
</li>
</ul>
<p><strong>如何判断当前脚本运行在浏览器还是node环境中？</strong></p>
<ul>
<li>判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中</li>
</ul>
<p><strong>什么是 npm ？</strong></p>
<ul>
<li>npm 是 Node.js 的模块管理和发布工具</li>
</ul>
<p><strong>什么是 WebKit ？</strong></p>
<ul>
<li>WebKit 是一个开源的浏览器内核，由渲染引擎(WebCore)和JS解释引擎(JSCore)组成</li>
<li>通常所说的 WebKit 指的是 WebKit(WebCore)，主要工作是进行 HTML/CSS 渲染</li>
<li>WebKit 一直是 Safari 和 Chrome(之前) 使用的浏览器内核，后来 Chrome 改用Blink 内核</li>
</ul>
<p><strong>如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)?</strong></p>
<ul>
<li>通过为前端代码编写单元测试(Unit Test)来测试前端代码</li>
<li>Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码</li>
<li>BDD：行为驱动开发 -- 业务需求描述产出产品代码的开发方法</li>
<li>TDD：测试驱动开发 -- 单元测试用例代码产出产品代码的开发方法</li>
<li>单元测试框架：</li>
</ul>
<div><pre><code><span>// mocha 示例</span>
<span>describe</span><span>(</span><span>'Test add'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>it</span><span>(</span><span>'1 + 2 = 3'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      <span>expect</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>.</span>to<span>.</span>be<span>.</span><span>equal</span><span>(</span><span>3</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// jasmin 示例</span>
<span>describe</span><span>(</span><span>'Test add'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>it</span><span>(</span><span>'1 + 2 = 3'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>expect</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>.</span><span>toEqual</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>介绍你知道的前端模板引擎？</strong></p>
<ul>
<li>artTemplate, underscore, handlebars</li>
</ul>
<p><strong>什么是 Modernizr？ Modernizr 工作原理？</strong></p>
<ul>
<li>Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况</li>
</ul>
<p><strong>移动端最小触控区域是多大？</strong></p>
<ul>
<li>44 * 44 px</li>
</ul>
<p><strong>移动端的点击事件的延迟时间是多长，为什么会有延迟？ 如何解决这个延时？</strong></p>
<ul>
<li>移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计</li>
<li>解决方案：
<ul>
<li>禁用缩放(对safari无效)</li>
<li>使用指针事件(IE私有特性，且仅IE10+)</li>
<li>使用 Zepto 的 tap 事件(有点透BUG)</li>
<li>使用 FastClick 插件(体积大[压缩后8k])</li>
</ul>
</li>
</ul>
<p><strong>什么是函数式编程？</strong></p>
<ul>
<li>
<p>函数式编程是一种&quot;编程范式&quot;，主要思想是把运算过程尽量写成一系列嵌套的函数调用</p>
</li>
<li>
<p>例如：var result = subtract(multiply(add(1,2), 3), 4);</p>
</li>
<li>
<p>函数式编程的特点：</p>
<ul>
<li>函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值</li>
<li>只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值</li>
<li>没有&quot;副作用&quot;：所有功能只为返回一个新的值，不修改外部变量</li>
<li>引用透明：运行不依赖于外部变量，只依赖于输入的参数</li>
</ul>
</li>
<li>
<p>函数式编程的优点：</p>
<ul>
<li>代码简洁，接近自然语言，易于理解</li>
<li>便于维护，利于测试、除错、组合</li>
<li>易于“并发编程“，不用担心一个线程的数据，被另一个线程修改</li>
<li>可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机</li>
</ul>
</li>
</ul>
<p><strong>什么是函数柯里化Currying)？</strong></p>
<ul>
<li>
<p>柯里化：</p>
<ul>
<li>通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数</li>
<li>期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程</li>
<li>柯里化的作用：延迟计算；参数复用；动态创建函数</li>
</ul>
</li>
<li>
<p>柯里化的缺点：</p>
<ul>
<li>函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等）</li>
</ul>
</li>
</ul>
<p><strong>什么是依赖注入？</strong></p>
<ul>
<li>当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。</li>
<li>依赖注入解决的就是如何有效组织代码依赖模块的问题</li>
</ul>
<p><strong>设计模式：什么是 singleton, factory, strategy, decorator？</strong></p>
<ul>
<li>Singleton(单例)   一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点</li>
<li>Factory (工厂)    解决实列化对象产生重复的问题</li>
<li>Strategy(策略)    将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用</li>
<li>Observer(观察者)  多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知</li>
<li>Prototype(原型)   一个完全初始化的实例，用于拷贝或者克隆</li>
<li>Adapter(适配器)   将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作</li>
<li>Proxy(代理模式)   一个充当过滤转发的对象用来代表一个真实的对象</li>
<li>Iterator(迭代器)  在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素</li>
<li>Chain of Responsibility(职责连)  处理请求组成的对象一条链，请求链中传递，直到有对象可以处理</li>
</ul>
<p><strong>什么是前端工程化？</strong></p>
<ul>
<li>
<p>前端工程化就是把一整套前端工作流程使用工具自动化完成</p>
</li>
<li>
<p>前端开发基本流程：</p>
<ul>
<li>项目初始化：yeoman, FIS</li>
<li>引入依赖包：bower, npm</li>
<li>模块化管理：npm, browserify, Webpack</li>
<li>代码编译：babel, sass, less</li>
<li>代码优化(压缩/合并)：Gulp, Grunt</li>
<li>代码检查：JSHint, ESLint</li>
<li>代码测试：Mocha</li>
</ul>
</li>
<li>
<p>目前最知名的构建工具：Gulp, Grunt, npm + Webpack</p>
</li>
</ul>
<p><strong>介绍 Yeoman 是什么？</strong></p>
<ul>
<li>Yeoman --前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架</li>
<li>Yeoman 其实是三类工具的合体，三类工具各自独立：
<ul>
<li>yo --- 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起）</li>
<li>Grunt、gulp --- 自动化构建工具 （最初只有grunt，之后加入了gulp）</li>
<li>Bower、npm --- 包管理工具 （原来是bower，之后加入了npm）</li>
</ul>
</li>
</ul>
<p><strong>介绍 WebPack 是什么？ 有什么优势？</strong></p>
<ul>
<li>WebPack 是一款[模块加载器]兼[打包工具]，用于把各种静态资源（js/css/image等）作为模块来使用</li>
<li>WebPack 的优势：
<ul>
<li>WebPack 同时支持 commonJS 和 AMD/CMD，方便代码迁移</li>
<li>不仅仅能被模块化 JS ，还包括 CSS、Image 等</li>
<li>能替代部分 grunt/gulp 的工作，如打包、压缩混淆、图片base64</li>
<li>扩展性强，插件机制完善，特别是支持 React 热插拔的功能</li>
</ul>
</li>
</ul>
<p><strong>介绍类库和框架的区别？</strong></p>
<ul>
<li>类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码</li>
<li>框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架</li>
</ul>
<p><strong>什么是 MVC/MVP/MVVM/Flux？</strong></p>
<ul>
<li>
<p>MVC(Model-View-Controller)</p>
<ul>
<li>V-&gt;C, C-&gt;M, M-&gt;V</li>
<li>通信都是单向的；C只起路由作用，业务逻辑都部署在V</li>
<li>Backbone</li>
</ul>
</li>
<li>
<p>MVP(Model-View-Presenter)</p>
<ul>
<li>V&lt;-&gt;P, P&lt;-&gt;M</li>
<li>通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P</li>
<li>Riot.js</li>
</ul>
</li>
<li>
<p>MVVM(Model-View-ViewModel)</p>
<ul>
<li>V-&gt;VM, VM&lt;-&gt;M</li>
<li>采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面</li>
<li>Angular</li>
</ul>
</li>
<li>
<p>Flux(Dispatcher-Store-View)</p>
<ul>
<li>Action-&gt;Dispatcher-&gt;Store-&gt;View, View-&gt;Action</li>
<li>Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想</li>
<li>基于一个简单的原则：数据在应用中单向流动（单向数据流）</li>
<li>React(Flux 中 View，只关注表现层)</li>
</ul>
</li>
</ul>
<p><strong>Backbone 是什么？</strong></p>
<ul>
<li>Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架</li>
</ul>
<p><strong>AngularJS 是什么？</strong></p>
<ul>
<li>AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等</li>
<li>AngularJS 由 Google 维护，用来协助大型单一页面应用开发。</li>
</ul>
<p><strong>React 是什么？</strong></p>
<ul>
<li>React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层</li>
<li>React 主要的原理：
<ul>
<li>虚拟 DOM + diff 算法 -&gt; 不直接操作 DOM 对象</li>
<li>Components 组件 -&gt; Virtual DOM 的节点</li>
<li>State 触发视图的渲染 -&gt; 单向数据绑定</li>
<li>React 解决方案：React + Redux + react-router + Fetch + webpack</li>
</ul>
</li>
</ul>
<p><strong>react-router 路由系统的实现原理？</strong></p>
<ul>
<li>实现原理：location 与 components 之间的同步</li>
</ul>
<ul>
<li>路由的职责是保证 UI 和 URL 的同步</li>
<li>在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定</li>
<li>因此，路由在 react-router 中就转变成 location 与 components 之间的同步</li>
</ul>
<p><strong>Meteor 是什么</strong></p>
<ul>
<li>Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。</li>
<li>Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>GIT</title>
      <link>https://0808200.xyz/Interview/base/Git.html</link>
      <guid>https://0808200.xyz/Interview/base/Git.html</guid>
      <source url="https://0808200.xyz/rss.xml">GIT</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>git fetch和git pull的区别</strong></p>
<ul>
<li>git pull：相当于是从远程获取最新版本并merge到本地</li>
<li>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>HTML 基础</title>
      <link>https://0808200.xyz/Interview/base/HTML.html</link>
      <guid>https://0808200.xyz/Interview/base/HTML.html</guid>
      <source url="https://0808200.xyz/rss.xml">HTML 基础</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="html" tabindex="-1"> HTML</h3>
<p><strong>语义化</strong></p>
<ul>
<li>
<p>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构</p>
</li>
<li>
<p>css命名的语义化是指：为html标签添加有意义的class</p>
</li>
<li>
<p>为什么需要语义化：</p>
<ul>
<li>去掉样式后页面呈现清晰的结构</li>
<li>盲人使用读屏器更好地阅读</li>
<li>搜索引擎更好地理解页面，有利于收录</li>
<li>便团队项目的可持续运作及维护</li>
</ul>
</li>
</ul>
<p><strong>简述一下你对HTML语义化的理解？</strong></p>
<ul>
<li>用正确的标签做正确的事情。</li>
<li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li>
<li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>
</ul>
<p><strong>Doctype作用？标准模式与兼容模式各有什么区别?</strong></p>
<ul>
<li><code>&lt;!DOCTYPE&gt;</code>声明位于位<code>于HTML</code>文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现</li>
<li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li>
</ul>
<p><strong>HTML5 为什么只需要写 <!DOCTYPE HTML>？</strong></p>
<ul>
<li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li>
<li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li>
</ul>
<p><strong>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</strong></p>
<ul>
<li>行内元素有：<code>a b span img input select strong</code>（强调的语气）</li>
<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li>
<li>常见的空元素:<code> &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>
</ul>
<p><strong>页面导入样式时，使用link和@import有什么区别？</strong></p>
<ul>
<li><code>link</code>属于<code>XHTML</code>标签，除了加载<code>CSS</code>外，还能用于定义<code>RSS</code>,定义<code>rel</code>连接属性等作用；而<code>@import</code>是<code>CSS</code>提供的，只能用于加载<code>CSS</code></li>
<li>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载</li>
<li><code>import</code>是<code>CSS2.1</code> 提出的，只在<code>IE5</code>以上才能被识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题</li>
</ul>
<p><strong>介绍一下你对浏览器内核的理解？</strong></p>
<ul>
<li>
<p>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</p>
</li>
<li>
<p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</p>
</li>
<li>
<p>JS引擎则：解析和执行javascript来实现网页的动态效果</p>
</li>
<li>
<p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</p>
</li>
</ul>
<p><strong>常见的浏览器内核有哪些？</strong></p>
<ul>
<li><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等。[又称MSHTML]</li>
<li><code>Gecko</code>内核：<code>Netscape6</code>及以上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</li>
<li><code>Presto</code>内核：<code>Opera7</code>及以上。      [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</li>
<li><code>Webkit</code>内核：<code>Safari,Chrome</code>等。   [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</li>
</ul>
<p><strong>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</strong></p>
<ul>
<li>
<p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p>
<ul>
<li>绘画 canvas</li>
<li>用于媒介回放的 video 和 audio 元素</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation</li>
</ul>
</li>
<li>
<p>移除的元素：</p>
</li>
<li>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u</p>
</li>
<li>
<p>对可用性产生负面影响的元素：frame，frameset，noframes</p>
</li>
<li>
<p>支持HTML5新标签：</p>
<ul>
<li>IE8/IE7/IE6支持通过document.createElement方法产生的标签</li>
<li>可以利用这一特性让这些浏览器支持HTML5新标签</li>
<li>浏览器支持新标签后，还需要添加标签默认的样式</li>
</ul>
</li>
<li>
<p>当然也可以直接使用成熟的框架、比如html5shim</p>
</li>
</ul>
<div><pre><code>&lt;!--[if lt IE 9]>
&lt;script> src="http://html5shim.googlecode.com
/svn/trunk/html5.js"&lt;/script>&lt;![endif]-->
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li>
</ul>
<p><strong>HTML5的离线储存怎么使用，工作原理能不能解释一下？</strong></p>
<ul>
<li>
<p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</p>
</li>
<li>
<p>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
</li>
<li>
<p>如何使用：</p>
<ul>
<li>页面头部像下面一样加入一个manifest的属性；</li>
<li>在cache.manifest文件的编写离线存储的资源</li>
<li>在离线状态时，操作window.applicationCache进行需求实现</li>
</ul>
</li>
</ul>
<div><pre><code>CACHE MANIFEST
    #v0.11
    CACHE:
    js/app.js
    css/style.css
    NETWORK:
    resourse/logo.png
    FALLBACK:
    / /offline.html
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</strong></p>
<ul>
<li>
<p>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p>
</li>
<li>
<p>离线的情况下，浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</strong></p>
<ul>
<li>
<p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p>
</li>
<li>
<p>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</p>
</li>
<li>
<p><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</p>
</li>
<li>
<p>存储大小：</p>
<ul>
<li><code>cookie</code>数据大小不能超过4k</li>
<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
</li>
<li>
<p>有期时间：</p>
<ul>
<li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li>
<li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<p><strong>iframe有那些缺点？</strong></p>
<ul>
<li>iframe会阻塞主页面的Onload事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>
</ul>
<p><strong>Label的作用是什么？是怎么用的？</strong></p>
<ul>
<li>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件</li>
</ul>
<p><strong>HTML5的form如何关闭自动完成功能？</strong></p>
<ul>
<li>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</li>
</ul>
<p><strong>如何实现浏览器内多个标签页之间的通信? (阿里)</strong></p>
<ul>
<li>WebSocket、SharedWorker</li>
<li>也可以调用localstorge、cookies等本地存储方式</li>
</ul>
<p><strong>webSocket如何兼容低浏览器？(阿里)</strong></p>
<ul>
<li>Adobe Flash Socket 、</li>
<li>ActiveX HTMLFile (IE) 、</li>
<li>基于 multipart 编码发送 XHR 、</li>
<li>基于长轮询的 XHR</li>
</ul>
<p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p>
<ul>
<li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li>
</ul>
<p><strong>如何在页面上实现一个圆形的可点击区域？</strong></p>
<ul>
<li>map+area或者svg</li>
<li>border-radius</li>
<li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
</ul>
<p><strong>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</strong></p>
<div><pre><code>&lt;div style="height:1px;overflow:hidden;background:red">&lt;/div>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p>
<ul>
<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>
<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>
</ul>
<p><strong>title与h1的区别、b与strong的区别、i与em的区别？</strong></p>
<ul>
<li><code>title</code>属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响</li>
<li><code>strong</code>是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，而<code>&lt;B&gt;</code>是展示强调内容</li>
<li>i内容展示为斜体，em表示强调的文本</li>
</ul>
<p><strong>页面导入样式时，使用 link 和 @import 有什么区别？</strong></p>
<ul>
<li>link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS</li>
<li>页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载</li>
<li>@import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题</li>
</ul>
<p><strong>介绍一下你对浏览器内核的理解？</strong></p>
<ul>
<li>浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎</li>
<li>渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机</li>
<li>JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互</li>
<li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</li>
</ul>
<p><strong>常见的浏览器内核有哪些？</strong></p>
<ul>
<li>Blink内核：新版 Chrome、新版 Opera</li>
<li>Webkit内核：Safari、原Chrome</li>
<li>Gecko内核：FireFox、Netscape6及以上版本</li>
<li>Trident内核（又称MSHTML内核）：IE、国产浏览器</li>
<li>Presto内核：原Opera7及以上</li>
</ul>
<p><strong>HTML5有哪些新特性？</strong></p>
<ul>
<li>新增选择器 document.querySelector、document.querySelectorAll</li>
<li>拖拽释放(Drag and drop) API</li>
<li>媒体播放的 video 和 audio</li>
<li>本地存储 localStorage 和 sessionStorage</li>
<li>离线应用 manifest</li>
<li>桌面通知 Notifications</li>
<li>语意化标签 article、footer、header、nav、section</li>
<li>增强表单控件 calendar、date、time、email、url、search</li>
<li>地理位置 Geolocation</li>
<li>多任务 webworker</li>
<li>全双工通信协议 websocket</li>
<li>历史管理 history</li>
<li>跨域资源共享(CORS) Access-Control-Allow-Origin</li>
<li>页面可见性改变事件 visibilitychange</li>
<li>跨窗口通信 PostMessage</li>
<li>Form Data 对象</li>
<li>绘画 canvas</li>
</ul>
<p><strong>HTML5移除了那些元素？</strong></p>
<ul>
<li>纯表现的元素：basefont、big、center、font、s、strike、tt、u</li>
<li>对可用性产生负面影响的元素：frame、frameset、noframes</li>
</ul>
<p><strong>如何处理HTML5新标签的浏览器兼容问题？</strong></p>
<ul>
<li>通过 document.createElement 创建新标签</li>
<li>使用垫片 html5shiv.js</li>
</ul>
<p><strong>如何区分 HTML 和 HTML5？</strong></p>
<ul>
<li>DOCTYPE声明、新增的结构元素、功能元素</li>
</ul>
<p><strong>HTML5的离线储存工作原理能不能解释一下，怎么使用？</strong></p>
<ul>
<li>
<p>HTML5的离线储存原理：</p>
<ul>
<li>用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容</li>
</ul>
</li>
<li>
<p>HTML5的离线储存使用：</p>
<ul>
<li>在文档的 html 标签设置 manifest 属性，如 manifest=&quot;/offline.appcache&quot;</li>
<li>在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache</li>
<li>在 web 服务器配置正确的 MIME-type，即 text/cache-manifest</li>
</ul>
</li>
</ul>
<p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的？</strong></p>
<ul>
<li>在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件</li>
<li>如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储</li>
<li>如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li>
<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
</ul>
<p><strong>iframe 有那些优点和缺点？</strong></p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
</li>
</ul>
<p><strong>label 的作用是什么？怎么使用的？</strong></p>
<ul>
<li>
<p>label标签来定义表单控件的关系：</p>
<ul>
<li>当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上</li>
</ul>
</li>
<li>
<p>使用方法1：</p>
<ul>
<li><code>&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;</code></li>
<li><code>&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</code></li>
</ul>
</li>
<li>
<p>使用方法2：</p>
<ul>
<li><code>&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>如何实现浏览器内多个标签页之间的通信？</strong></p>
<ul>
<li>iframe + contentWindow</li>
<li>postMessage</li>
<li>SharedWorker(Web Worker API)</li>
<li>storage 事件(localStorge API)</li>
<li>WebSocket</li>
</ul>
<p><strong>webSocket 如何兼容低浏览器？</strong></p>
<ul>
<li>Adobe Flash Socket</li>
<li>ActiveX HTMLFile (IE)</li>
<li>基于 multipart 编码发送 XHR</li>
<li>基于长轮询的 XHR</li>
</ul>
<p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p>
<ul>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li>
<li>当用户浏览其他页面，暂停网站首页幻灯自动播放</li>
<li>完成登陆后，无刷新自动同步其他页面的登录状态</li>
</ul>
<p><strong>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</strong></p>
<ul>
<li>title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响</li>
<li>strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b</li>
</ul>
<p><strong>是展示强调内容</strong></p>
<ul>
<li>i 内容展示为斜体，em 表示强调的文本</li>
<li>自然样式标签：b, i, u, s, pre</li>
<li>语义样式标签：strong, em, ins, del, code</li>
<li>应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP 基础</title>
      <link>https://0808200.xyz/Interview/base/HTTP.html</link>
      <guid>https://0808200.xyz/Interview/base/HTTP.html</guid>
      <source url="https://0808200.xyz/rss.xml">HTTP 基础</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>http状态码有那些？分别代表是什么意思？</strong></p>
<div><pre><code> 简单版
    [
        100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
        200  OK               正常返回信息
        201  Created          请求成功并且服务器创建了新的资源
        202  Accepted         服务器已接受请求，但尚未处理
        204  No Content       请求处理成功, 但无内容响应

        301  Moved Permanently   请求的网页已永久移动到新位置。
        302  Found               临时性重定向, GET请求时跟307相同，POST 请求一些旧客户端会转成 GET 请求。
        303  See Other           临时性重定向，且总是使用 GET 请求新的 URI。
        304  Not Modified        自从上次请求后，请求的网页未修改过。
        307  Temporary Redirect  临时性重定向, 请求方法和消息主体不会变化

        400  Bad Request   服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
        401  Unauthorized  请求未授权。
        403  Forbidden     禁止访问。
        404  Not Found     找不到如何与 URI 相匹配的资源。

        500  Internal Server Error   最常见的服务器端错误。
        502  Bad Gateway             网关从上游服务器接收到的响应无效, 上游服务器挂了或者响应超时等原因引起
        503  Service Unavailable     服务器端暂时无法处理请求（可能是过载或维护）。
    ]
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</strong></p>
<ul>
<li>
<p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，</p>
</li>
<li>
<p>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、</p>
</li>
<li>
<p>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p>
</li>
<li>
<p>详细版：</p>
<ul>
<li>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</li>
<li>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</li>
<li>通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</li>
<li>进行HTTP协议会话，客户端发送报头(请求报头);</li>
<li>进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</li>
<li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</li>
<li>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</li>
<li>浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</li>
<li>文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</li>
<li>页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</li>
</ul>
</li>
<li>
<p>简洁版：</p>
<ul>
<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li>
<li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ul>
</li>
</ul>
<p><strong>说说TCP传输的三次握手四次挥手策略</strong></p>
<ul>
<li>
<p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK</p>
</li>
<li>
<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
</li>
</ul>
<p><strong>断开一个TCP连接则需要“四次握手”：</strong></p>
<ul>
<li>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据</p>
</li>
<li>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</p>
</li>
<li>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</p>
</li>
<li>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p>
</li>
</ul>
<p><strong>TCP和UDP的区别</strong></p>
<ul>
<li>
<p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p>
</li>
<li>
<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</p>
</li>
</ul>
<p><strong>HTTP和HTTPS</strong></p>
<ul>
<li>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS</li>
<li>默认HTTP的端口号为80，HTTPS的端口号为443</li>
</ul>
<p><strong>为什么HTTPS安全</strong></p>
<ul>
<li>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</li>
</ul>
<p><strong>关于Http 2.0 你知道多少？</strong></p>
<ul>
<li>
<p>HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p>
</li>
<li>
<p>HTTP/2提供更多的加密支持</p>
</li>
<li>
<p>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。</p>
</li>
<li>
<p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽</p>
</li>
</ul>
<p><strong>GET和POST的区别，何时使用POST？</strong></p>
<ul>
<li>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</li>
<li>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>
<li>然而，在以下情况中，请使用 POST 请求：
<ul>
<li>
<p>无法使用缓存文件（更新服务器上的文件或数据库）</p>
</li>
<li>
<p>向服务器发送大量数据（POST 没有数据量限制）</p>
</li>
<li>
<p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
</li>
</ul>
</li>
</ul>
<p><strong>说说网络分层里七层模型是哪七层</strong></p>
<ul>
<li>
<p>应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</p>
</li>
<li>
<p>传输层（TCP和UDP）</p>
</li>
<li>
<p>网络层（IP）</p>
</li>
<li>
<p>物理和数据链路层（以太网）</p>
</li>
<li>
<p>每一层的作用如下：</p>
<ul>
<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
</li>
</ul>
<p><strong>讲讲304缓存的原理</strong></p>
<ul>
<li>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存</li>
<li>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</li>
<li>客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体</li>
</ul>
<p><strong>HTTP/2 与 HTTP/1.x 的关键区别</strong></p>
<ul>
<li>二进制协议代替文本协议，更加简洁高效</li>
<li>针对每个域只使用一个多路复用的连接</li>
<li>压缩头部信息减小开销</li>
<li>允许服务器主动推送应答到客户端的缓存中</li>
</ul>
<p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</strong></p>
<ul>
<li>01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器)</li>
<li>02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）</li>
<li>03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com）</li>
<li>04.浏览器跟踪重定向地址，请求另一个带 www 的网址</li>
<li>05.服务器处理请求（通过路由读取资源）</li>
<li>06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 'text/html'）</li>
<li>07.浏览器进 DOM 树构建</li>
<li>08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）</li>
<li>09.浏览器显示完成页面</li>
<li>10.浏览器发送异步请求</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>手写事件侦听器</title>
      <link>https://0808200.xyz/Interview/base/Handwritten-code.html</link>
      <guid>https://0808200.xyz/Interview/base/Handwritten-code.html</guid>
      <source url="https://0808200.xyz/rss.xml">手写事件侦听器</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>手写事件侦听器，并要求兼容浏览器</strong></p>
<div><pre><code>var eventUtil = {
  getEvent: function(event) {
      return event || window.event;
  },

  getTarget: function(event) {
      return event.target || event.srcElement;
  },

  addListener: function(element, type, hander) {
      if (element.addEventListener) {
          element.addEventListener(type, hander, false);
      } else if (element.attachEvent) {
          element.attachEvent('on' + type, hander);
      } else {
          element['on' + type] = hander;
      }
  },

  removeListener: function(element, type, hander) {
      if (element.removeEventListener) {
          element.removeEventListener(type, hander, false);
      } else if (element.deattachEvent) {
          element.detachEvent(type, hander);
      } else {
          element['on' + type] = null;
      }
  },

  preventDefault: function(event) {
      if (event.preventDefault) {
          event.preventDefault();
      } else {
          event.returnValue = false;
      }
  },

  stopPropagation: function(event) {
      if (event.stopPropagation) {
          event.stopPropagation();
      } else {
          event.cancelBubble = true;
      }
  }
};

// 调用
(function() {
  var btn = document.getElementById(&quot;btn&quot;);
  var link = document.getElementsByTagName(&quot;a&quot;)[0];

  eventUtil.addListener(btn, &quot;click&quot;, function(event) {
      var event = eventUtil.getEvent(event);
      var target = eventUtil.getTarget(event);
      alert(event.type);
      alert(target);
      eventUtil.stopPropagation(event);
  });

  eventUtil.addListener(link, &quot;click&quot;, function(event) {
      alert(&quot;prevent default event&quot;);
      var event = eventUtil.getEvent(event);
      eventUtil.preventDefault(event);
  });

  eventUtil.addListener(document.body, &quot;click&quot;, function() {
      alert(&quot;click body&quot;);
  });
})();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写事件模型</strong></p>
<div><pre><code>var Event = (function () {
    var list = {}, bind, trigger, remove;
    bind = function (key, fn) {
        if (!list[key]) {
            list[key] = [];
        }
        list[key].push(fn);
    };
    trigger = function () {
        var key = Array.prototype.shift.call(arguments);
        var fns = list[key];
        if (!fns || fns.length === 0) {
            return false;
        }
        for (var i = 0, fn; fn = fns[i++];) {
            fn.apply(this, arguments);
        }
    };
    remove = function (key, fn) {
        var fns = list[key];
        if (!fns) {
            return false;
        }
        if (!fn) {
            fns &amp; (fns.length = 0);
        } else {
            for (var i = fns.length - 1; i &gt;= 0; i--) {
                var _fn = fns[i];
                if (_fn === fn) {
                    fns.splice(i, 1);
                }
            }
        }
    };
    return {
        bind: bind,
        trigger: trigger,
        remove: remove
    }
})();

// 调用
Event.bind('Hit', function(){ console.log('bind event'); }); // 绑定事件
Event.trigger(&quot;Hit&quot;, function(){ console.log('trigger event'); }); // 触发事件
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写事件代理，并要求兼容浏览器</strong></p>
<div><pre><code>function delegateEvent(parentEl, selector, type, fn) {
    var handler = function(e){
          var e = e || window.event;
          var target = e.target || e.srcElement;
          if (matchSelector(target, selector)) {
              if(fn) {
                  fn.call(target, e);
              }
          }
    };
    if(parentEl.addEventListener){
        parentEl.addEventListener(type, handler);
    }else{
        parentEl.attachEvent(&quot;on&quot; + type, handler);
    }
}
/**
 * support #id, tagName, .className
 */
function matchSelector(ele, selector) {
    // if use id
    if (selector.charAt(0) === &quot;#&quot;) {
        return ele.id === selector.slice(1);
    }
    // if use class
    if (selector.charAt(0) === &quot;.&quot;) {
        return (&quot; &quot; + ele.className + &quot; &quot;).indexOf(&quot; &quot; + selector.slice(1) + &quot; &quot;) != -1;
    }
    // if use tagName
    return ele.tagName.toLowerCase() === selector.toLowerCase();
}

// 调用
var box = document.getElementById(&quot;box&quot;);
delegateEvent(box, &quot;a&quot;, &quot;click&quot;, function(){
    console.log(this.href);
})
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写事件触发器，并要求兼容浏览器</strong></p>
<div><pre><code>var fireEvent = function(element, event){
    if (document.createEventObject){
        var mockEvent = document.createEventObject();
        return element.fireEvent('on' + event, mockEvent)
    }else{
        var mockEvent = document.createEvent('HTMLEvents');
        mockEvent.initEvent(event, true, true);
        return element.dispatchEvent(mockEvent);
    }
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写 Function.bind 函数</strong></p>
<div><pre><code>if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== &quot;function&quot;) {
      throw new TypeError(&quot;'this' is not function&quot;);
    }

    // bind's default arguments, array without first element
    // first part arguments for the function
    var aBindArgs = Array.prototype.slice.call(arguments, 1);
    var fToBind = this; // the function will be binding
    var fNOP = function () {};
    var fBound = function () {
          // target this will be binding
          var oThis = this instanceof fNOP ? this : oThis || this;
          // last part arguments for the function
          var aCallArgs = Array.prototype.slice.call(arguments);
          // complete arguments for the function
          var aFuncArgs = aBindArgs.concat(aCallArgs);
          return fToBind.apply(oThis, aFuncArgs);
        };

    // fBound extends fToBind
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

// 调用
var add = function(a, b, c){ return a + b + c;};
var newAdd = add.bind(null, 1, 2);
var result = newAdd(3);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写数组快速排序</strong></p>
<div><pre><code>var quickSort = function(arr) {
    if (arr.length &lt;= 1) { return arr; }
    var pivotIndex = Math.floor(arr.length / 2);
    var pivot = arr.splice(pivotIndex, 1)[0];
    var left = [];
    var right = [];
    for (var i = 0, len = arr.length; i &lt; len; i++){
        if (arr[i] &lt; pivot) {
          left.push(arr[i]);
        } else {
          right.push(arr[i]);
        }
    }
    return quickSort(left).concat([pivot], quickSort(right));
};

// 调用
quickSort([9, 4, 2, 8, 1, 5, 3, 7]);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写数组冒泡排序</strong></p>
<div><pre><code>var bubble = function(arr){
    var maxIndex = arr.length - 1, temp, flag;
    for (var i = maxIndex; i &gt; 0; i--) {
        flag = true
        for (var j = 0; j &lt; i; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = false;
            }
        }
        if(! flag){
            break;
        }
    }
    return arr;
}
// 调用
var arr = bubble([13, 69, 28, 93, 55, 75, 34]);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>手写数组去重</strong></p>
<div><pre><code>Array.prototype.unique = function() { return [...new Set(this)];};
// 调用
[1, 2, 3, 3, 2, 1].unique();

function unique1(arr){
    var hash = {}, result = [];
    for(var i=0, len=arr.length; i&lt;len; i++){
        if(! hash[arr[i]]){
          result.push(arr[i]);
          hash[arr[i]] = true;
        }
    }
    return result;
}
// 调用
unique1([1, 2, 3, 3, 2, 1]);

Array.prototype.unique2 = function(){
    this.sort();
    var result = [this[0]];
    var len = this.length;
    for(var i = 0; i &lt; len; i++){
        if(this[i] !== result[result.length - 1]){
          result.push(this[i]);
        }
    }
    return result;
}
// 调用
[1, 2, 3, 3, 2, 1].unique2();

function unique3(arr){
    var result = [];
    for(var i=0; i&lt;arr.length; i++){
        if(result.indexOf(arr[i]) == -1){
          result.push(arr[i]);
        }
    }
    return result;
}

// 调用
unique3([1, 2, 3, 3, 2, 1]);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>将url的查询参数解析成字典对象</strong></p>
<div><pre><code>function parseQuery(url) {
  url = url == null ? window.location.href : url;
  var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1);
  var hash = {};
  var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g;
  search.replace(reg, function (match, $1, $2) {
      var name = decodeURIComponent($1);
      var val = decodeURIComponent($2);
      hash[name] = String(val);
      return match;
  });
  return hash;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>封装函数节流函数</strong></p>
<div><pre><code>var throttle = function(fn, delay, mustRunDelay){
  var timer = null;
  var t_start;
  return function(){
    var context = this, args = arguments, t_curr = +new Date();
    clearTimeout(timer);
    if(!t_start){
      t_start = t_curr;
    }
    if(t_curr - t_start &gt;= mustRunDelay){
      fn.apply(context, args);
      t_start = t_curr;
    } else {
      timer = setTimeout(function(){
        fn.apply(context, args);
      }, delay);
    }
  };
};

// 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次
window.onresize = throttle(myFunc, 50, 100);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>用JS实现千位分隔符</strong></p>
<div><pre><code>function test1(num){
  var str = (+ num) + '';
  var len = str.length;
  if(len &lt;= 3) return str;
  num = '';
  while(len &gt; 3){
      len -= 3;
      num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num){
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 基础</title>
      <link>https://0808200.xyz/Interview/base/JavaScript.html</link>
      <guid>https://0808200.xyz/Interview/base/JavaScript.html</guid>
      <source url="https://0808200.xyz/rss.xml">JavaScript 基础</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="javascript" tabindex="-1"> JavaScript</h3>
<hr>
<p><strong>JavaScript的组成</strong></p>
<ul>
<li>JavaScript 由以下三部分组成：
<ul>
<li>ECMAScript（核心）：JavaScript 语言基础</li>
<li>DOM（文档对象模型）：规定了访问HTML和XML的接口</li>
<li>BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li>
</ul>
</li>
</ul>
<p><strong>JS的基本数据类型和引用数据类型</strong></p>
<ul>
<li>基本数据类型：undefined、null、boolean、number、string、symbol</li>
<li>引用数据类型：object、array、function</li>
</ul>
<p><strong>检测浏览器版本版本有哪些方式？</strong></p>
<ul>
<li>根据 navigator.userAgent   //  UA.toLowerCase().indexOf('chrome')</li>
<li>根据 window 对象的成员       // 'ActiveXObject' in window</li>
</ul>
<p><strong>介绍JS有哪些内置对象？</strong></p>
<ul>
<li>数据封装类对象：Object、Array、Boolean、Number、String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
<li>ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>代码缩进，建议使用“四个空格”缩进</li>
<li>代码段使用花括号{}包裹</li>
<li>语句结束使用分号;</li>
<li>变量和函数在使用前进行声明</li>
<li>以大写字母开头命名构造函数，全大写命名常量</li>
<li>规范定义JSON对象，补全双引号</li>
<li>用{}和[]声明对象和数组</li>
</ul>
<p><strong>如何编写高性能的JavaScript？</strong></p>
<ul>
<li>遵循严格模式：&quot;use strict&quot;;</li>
<li>将js脚本放在页面底部，加快渲染页面</li>
<li>将js脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载js脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>尽量减少使用闭包</li>
<li>使用 window 对象属性方法时，省略 window</li>
<li>尽量减少对象成员嵌套</li>
<li>缓存 DOM 节点的访问</li>
<li>通过避免使用 eval() 和 Function() 构造器</li>
<li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘(repaint)和回流(reflow)</li>
</ul>
<p><strong>描述浏览器的渲染过程，DOM树和渲染树的区别？</strong></p>
<ul>
<li>
<p>浏览器的渲染过程：</p>
<ul>
<li>解析HTML构建 DOM(DOM树)，并行请求 css/image/js</li>
<li>CSS 文件下载完成，开始构建 CSSOM(CSS树)</li>
<li>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)</li>
<li>布局(Layout)：计算出每个节点在屏幕中的位置</li>
<li>显示(Painting)：通过显卡把页面画到屏幕上</li>
</ul>
</li>
<li>
<p>DOM树 和 渲染树 的区别：</p>
<ul>
<li>DOM树与HTML标签一一对应，包括head和隐藏元素</li>
<li>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</li>
</ul>
</li>
</ul>
<p><strong>重绘和回流（重排）的区别和关系？</strong></p>
<ul>
<li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li>
<li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流</li>
<li>注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值</li>
<li>回流必将引起重绘，而重绘不一定会引起回流</li>
</ul>
<p><strong>如何最小化重绘(repaint)和回流(reflow)？</strong></p>
<ul>
<li>需要要对元素进行复杂的操作时，可以先隐藏(display:&quot;none&quot;)，操作完成后再显示</li>
<li>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</li>
<li>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</li>
<li>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</li>
<li>避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</li>
<li>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</li>
<li>批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx</li>
</ul>
<p><strong>script 的位置是否会影响首屏显示时间？</strong></p>
<ul>
<li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。</li>
<li>浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则</li>
<li>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li>
</ul>
<p><strong>解释JavaScript中的作用域与变量声明提升？</strong></p>
<ul>
<li>
<p>JavaScript作用域：</p>
<ul>
<li>在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；</li>
<li>而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。</li>
</ul>
</li>
<li>
<p>JavaScript变量声明提升：</p>
<ul>
<li>在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。</li>
<li>声明语句中的赋值部分并不会被提升，只有名称被提升</li>
<li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li>
<li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li>
</ul>
</li>
</ul>
<p><strong>介绍JavaScript的原型，原型链？有什么特点？</strong></p>
<ul>
<li>
<p>原型：</p>
<ul>
<li>JavaScript的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型</li>
<li>JavaScript的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性</li>
<li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</li>
</ul>
</li>
<li>
<p>原型链：</p>
<ul>
<li>当一个对象调用的属性/方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找</li>
<li>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”</li>
</ul>
</li>
<li>
<p>原型特点：</p>
<ul>
<li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
</li>
</ul>
<p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗</strong></p>
<ul>
<li>原始数据类型（Undefined，Null，Boolean，Number、String）-- 栈</li>
<li>引用数据类型（对象、数组和函数）-- 堆</li>
<li>两种类型的区别是：存储位置不同：</li>
<li>原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li>
<li>引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li>
<li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li>
<li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p><strong>JavaScript如何实现一个类，怎么实例化这个类？</strong></p>
<ul>
<li>构造函数法（this + prototype） -- 用 new 关键字 生成实例对象
<ul>
<li>缺点：用到了 this 和 prototype，编写复杂，可读性差</li>
</ul>
</li>
</ul>
<div><pre><code>  <span>function</span> <span>Mobile</span><span>(</span><span>name<span>,</span> price</span><span>)</span><span>{</span>
     <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
     <span>this</span><span>.</span>price <span>=</span> price<span>;</span>
   <span>}</span>
   <span>Mobile</span><span>.</span>prototype<span>.</span><span>sell</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
      <span>alert</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"，售价 $"</span> <span>+</span> <span>this</span><span>.</span>price<span>)</span><span>;</span>
   <span>}</span>
   <span>var</span> iPhone7 <span>=</span> <span>new</span> <span>Mobile</span><span>(</span><span>"iPhone7"</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
   iPhone7<span>.</span><span>sell</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Object.create 法 -- 用 Object.create() 生成实例对象</li>
<li>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</li>
</ul>
<div><pre><code> <span>var</span> Person <span>=</span> <span>{</span>
     <span>firstname</span><span>:</span> <span>"Mark"</span><span>,</span>
     <span>lastname</span><span>:</span> <span>"Yun"</span><span>,</span>
     <span>age</span><span>:</span> <span>25</span><span>,</span>
     <span>introduce</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>
         <span>alert</span><span>(</span><span>'I am '</span> <span>+</span> Person<span>.</span>firstname <span>+</span> <span>' '</span> <span>+</span> Person<span>.</span>lastname<span>)</span><span>;</span>
     <span>}</span>
 <span>}</span><span>;</span>

 <span>var</span> person <span>=</span> Object<span>.</span><span>create</span><span>(</span>Person<span>)</span><span>;</span>
 person<span>.</span><span>introduce</span><span>(</span><span>)</span><span>;</span>

 <span>// Object.create 要求 IE9+，低版本浏览器可以自行部署：</span>
 <span>if</span> <span>(</span><span>!</span>Object<span>.</span>create<span>)</span> <span>{</span>
　   Object<span>.</span><span>create</span> <span>=</span> <span>function</span> <span>(</span><span>o</span><span>)</span> <span>{</span>
　　　 <span>function</span> <span>F</span><span>(</span><span>)</span> <span>{</span><span>}</span>
　　　 <span>F</span><span>.</span>prototype <span>=</span> o<span>;</span>
　　　 <span>return</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>
　　<span>}</span><span>;</span>
　<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>极简主义法（消除 this 和 prototype） -- 调用 createNew() 得到实例对象
<ul>
<li>优点：容易理解，结构清晰优雅，符合传统的&quot;面向对象编程&quot;的构造</li>
</ul>
</li>
</ul>
<div><pre><code> <span>var</span> Cat <span>=</span> <span>{</span>
   <span>age</span><span>:</span> <span>3</span><span>,</span> <span>// 共享数据 -- 定义在类对象内，createNew() 外</span>
   <span>createNew</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
     <span>var</span> cat <span>=</span> <span>{</span><span>}</span><span>;</span>
     <span>// var cat = Animal.createNew(); // 继承 Animal 类</span>
     cat<span>.</span>name <span>=</span> <span>"小咪"</span><span>;</span>
     <span>var</span> sound <span>=</span> <span>"喵喵喵"</span><span>;</span> <span>// 私有属性--定义在 createNew() 内，输出对象外</span>
     cat<span>.</span><span>makeSound</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
       <span>alert</span><span>(</span>sound<span>)</span><span>;</span>  <span>// 暴露私有属性</span>
     <span>}</span><span>;</span>
     cat<span>.</span><span>changeAge</span> <span>=</span> <span>function</span><span>(</span><span>num</span><span>)</span><span>{</span>
       Cat<span>.</span>age <span>=</span> num<span>;</span> <span>// 修改共享数据</span>
     <span>}</span><span>;</span>
     <span>return</span> cat<span>;</span> <span>// 输出对象</span>
   <span>}</span>
 <span>}</span><span>;</span>

 <span>var</span> cat <span>=</span> Cat<span>.</span><span>createNew</span><span>(</span><span>)</span><span>;</span>
 cat<span>.</span><span>makeSound</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>ES6 语法糖 class -- 用 new 关键字 生成实例对象</li>
</ul>
<div><pre><code>     <span>class</span> <span>Point</span> <span>{</span>
       <span>constructor</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
         <span>this</span><span>.</span>x <span>=</span> x<span>;</span>
         <span>this</span><span>.</span>y <span>=</span> y<span>;</span>
       <span>}</span>
       <span>toString</span><span>(</span><span>)</span> <span>{</span>
         <span>return</span> <span>'('</span> <span>+</span> <span>this</span><span>.</span>x <span>+</span> <span>', '</span> <span>+</span> <span>this</span><span>.</span>y <span>+</span> <span>')'</span><span>;</span>
       <span>}</span>
     <span>}</span>

  <span>var</span> point <span>=</span> <span>new</span> <span>Point</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li>
</ul>
<div><pre><code><span>function</span> <span>Cat</span><span>(</span><span>name<span>,</span>color</span><span>)</span><span>{</span>
 　<span>Animal</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span><span>;</span>
 　<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
 　<span>this</span><span>.</span>color <span>=</span> color<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>实例继承：将子对象的 prototype 指向父对象的一个实例</li>
</ul>
<div><pre><code><span>Cat</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>)</span><span>;</span>
<span>Cat</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Cat<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</li>
</ul>
<div><pre><code>    <span>function</span> <span>extend</span><span>(</span><span>Child<span>,</span> Parent</span><span>)</span> <span>{</span>
  　　　<span>var</span> p <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>
  　　　<span>var</span> c <span>=</span> <span>Child</span><span>.</span>prototype<span>;</span>
  　　　<span>for</span> <span>(</span><span>var</span> i <span>in</span> p<span>)</span> <span>{</span>
  　　　   c<span>[</span>i<span>]</span> <span>=</span> p<span>[</span>i<span>]</span><span>;</span>
  　　　<span>}</span>
  　　　c<span>.</span>uber <span>=</span> p<span>;</span>
  　 <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>原型继承：将子对象的 prototype 指向父对象的 prototype</li>
</ul>
<div><pre><code>    <span>function</span> <span>extend</span><span>(</span><span>Child<span>,</span> Parent</span><span>)</span> <span>{</span>
        <span>var</span> <span>F</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
      　<span>F</span><span>.</span>prototype <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>
      　Child<span>.</span>prototype <span>=</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>
      　Child<span>.</span>prototype<span>.</span>constructor <span>=</span> Child<span>;</span>
      　Child<span>.</span>uber <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>ES6 语法糖 extends：class ColorPoint extends Point {}</li>
</ul>
<div><pre><code>    <span>class</span> <span>ColorPoint</span> <span>extends</span> <span>Point</span> <span>{</span>
       <span>constructor</span><span>(</span><span>x<span>,</span> y<span>,</span> color</span><span>)</span> <span>{</span>
          <span>super</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span> <span>// 调用父类的constructor(x, y)</span>
          <span>this</span><span>.</span>color <span>=</span> color<span>;</span>
       <span>}</span>
       <span>toString</span><span>(</span><span>)</span> <span>{</span>
          <span>return</span> <span>this</span><span>.</span>color <span>+</span> <span>' '</span> <span>+</span> <span>super</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// 调用父类的toString()</span>
       <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链</li>
</ul>
<p><strong>谈谈this对象的理解</strong></p>
<ul>
<li>this 总是指向函数的直接调用者</li>
<li>如果有 new 关键字，this 指向 new 出来的实例对象</li>
<li>在事件中，this指向触发这个事件的对象</li>
<li>IE下 attachEvent 中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<p><strong>eval的功能是把对应的字符串解析成JS代码并运行</strong></p>
<ul>
<li>应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用 eval('('+ str +')');</li>
</ul>
<p><strong>什么是 Window 对象? 什么是 Document 对象?</strong></p>
<ul>
<li>Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。</li>
<li>我们创建的所有对象、函数、变量都是 Window 对象的成员。</li>
<li>Window 对象的方法和属性是在全局范围内有效的。</li>
<li>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）</li>
<li>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问</li>
<li>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问</li>
</ul>
<p><strong>介绍 DOM 的发展</strong></p>
<ul>
<li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li>
<li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms['login']</li>
<li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li>
<li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li>
<li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li>
</ul>
<p><strong>介绍DOM0，DOM2，DOM3事件处理方式区别</strong></p>
<ul>
<li>DOM0级事件处理方式：
<ul>
<li><code>btn.onclick = func;</code></li>
<li><code>btn.onclick = null;</code></li>
</ul>
</li>
<li>DOM2级事件处理方式：
<ul>
<li><code>btn.addEventListener('click', func, false);</code></li>
<li><code>btn.removeEventListener('click', func, false);</code></li>
<li><code>btn.attachEvent(&quot;onclick&quot;, func);</code></li>
<li><code>btn.detachEvent(&quot;onclick&quot;, func);</code></li>
</ul>
</li>
<li>DOM3级事件处理方式：
<ul>
<li><code>eventUtil.addListener(input, &quot;textInput&quot;, func);</code></li>
<li><code>eventUtil</code> 是自定义对象，<code>textInput</code> 是DOM3级事件</li>
</ul>
</li>
</ul>
<p><strong>事件的三个阶段</strong></p>
<ul>
<li>捕获、目标、冒泡</li>
</ul>
<p><strong>介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？</strong></p>
<ul>
<li>按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li>
<li>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数
<ul>
<li>注意1：前提是事件被确实触发</li>
<li>注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”</li>
</ul>
</li>
<li>事件执行顺序：判断的关键是否目标元素
<ul>
<li>非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序）</li>
<li>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）</li>
<li>最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡</li>
<li>注意：子元素事件执行前提    事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系</li>
</ul>
</li>
</ul>
<p><strong>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</strong></p>
<ul>
<li>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</li>
<li>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</li>
<li>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</li>
</ul>
<p><strong>事件的代理/委托</strong></p>
<ul>
<li>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件
<ul>
<li>优点：
<ul>
<li>可以减少事件注册，节省大量内存占用</li>
<li>可以将事件应用于动态添加的子元素上</li>
</ul>
</li>
<li>缺点：
使用不当会造成事件在不应该触发时触发</li>
<li>示例：</li>
</ul>
</li>
</ul>
<div><pre><code>ulEl.addEventListener('click', function(e){
    var target = event.target || event.srcElement;
    if(!!target &amp;&amp; target.nodeName.toUpperCase() === "LI"){
        console.log(target.innerHTML);
    }
}, false);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获</li>
</ul>
<p><strong>IE的事件处理和W3C的事件处理有哪些区别？</strong></p>
<ul>
<li>
<p>绑定事件</p>
<ul>
<li>W3C: targetEl.addEventListener('click', handler, false);</li>
<li>IE: targetEl.attachEvent('onclick', handler);</li>
</ul>
</li>
<li>
<p>删除事件</p>
<ul>
<li>W3C: targetEl.removeEventListener('click', handler, false);</li>
<li>IE: targetEl.detachEvent(event, handler);</li>
</ul>
</li>
<li>
<p>事件对象</p>
<ul>
<li>W3C: var e = arguments.callee.caller.arguments[0]</li>
<li>IE: window.event</li>
</ul>
</li>
<li>
<p>事件目标</p>
<ul>
<li>W3C: e.target</li>
<li>IE: window.event.srcElement</li>
</ul>
</li>
<li>
<p>阻止事件默认行为</p>
<ul>
<li>W3C: e.preventDefault()</li>
<li>IE: window.event.returnValue = false</li>
</ul>
</li>
<li>
<p>阻止事件传播</p>
<ul>
<li>W3C: e.stopPropagation()</li>
<li>IE: window.event.cancelBubble = true</li>
</ul>
</li>
</ul>
<p><strong>W3C事件的 target 与 currentTarget 的区别？</strong></p>
<ul>
<li>target 只会出现在事件流的目标阶段</li>
<li>currentTarget 可能出现在事件流的任何阶段</li>
<li>当事件流处在目标阶段时，二者的指向相同</li>
<li>当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)</li>
</ul>
<p><strong>如何派发事件(dispatchEvent)？（如何进行事件广播？）</strong></p>
<ul>
<li>W3C: 使用 dispatchEvent 方法</li>
<li>IE: 使用 fireEvent 方法</li>
</ul>
<div><pre><code><span>var</span> <span>fireEvent</span> <span>=</span> <span>function</span><span>(</span><span>element<span>,</span> event</span><span>)</span><span>{</span>
    <span>if</span> <span>(</span>document<span>.</span>createEventObject<span>)</span><span>{</span>
        <span>var</span> mockEvent <span>=</span> document<span>.</span><span>createEventObject</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> element<span>.</span><span>fireEvent</span><span>(</span><span>'on'</span> <span>+</span> event<span>,</span> mockEvent<span>)</span>
    <span>}</span><span>else</span><span>{</span>
        <span>var</span> mockEvent <span>=</span> document<span>.</span><span>createEvent</span><span>(</span><span>'HTMLEvents'</span><span>)</span><span>;</span>
        mockEvent<span>.</span><span>initEvent</span><span>(</span>event<span>,</span> <span>true</span><span>,</span> <span>true</span><span>)</span><span>;</span>
        <span>return</span> <span>!</span>element<span>.</span><span>dispatchEvent</span><span>(</span>mockEvent<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>什么是函数节流？介绍一下应用场景和原理？</strong></p>
<ul>
<li>
<p>函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。
只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。
但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）</p>
</li>
<li>
<p>函数节流用于 onresize, onscroll 等短时间内会多次触发的事件</p>
</li>
<li>
<p>函数节流的原理：使用定时器做时间节流。
当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。
如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，
再 setTimeout 一个新的定时器重复以上流程。</p>
</li>
<li>
<p>函数节流简单实现：</p>
</li>
</ul>
<div><pre><code><span>function</span> <span>throttle</span><span>(</span><span>method<span>,</span> context</span><span>)</span> <span>{</span>
     <span>clearTimeout</span><span>(</span>methor<span>.</span>tId<span>)</span><span>;</span>
     method<span>.</span>tId <span>=</span> <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
         <span>method</span><span>.</span><span>call</span><span>(</span>context<span>)</span><span>;</span>
     <span>}</span>， <span>100</span><span>)</span><span>;</span> <span>// 两次调用至少间隔 100ms</span>
<span>}</span>
<span>// 调用</span>
window<span>.</span><span>onresize</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    <span>throttle</span><span>(</span>myFunc<span>,</span> window<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</strong></p>
<ul>
<li>客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li>
<li>页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)</li>
<li>屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li>
</ul>
<p><strong>如何获得一个DOM元素的绝对位置？</strong></p>
<ul>
<li>elem.offsetLeft：返回元素相对于其定位父级左侧的距离</li>
<li>elem.offsetTop：返回元素相对于其定位父级顶部的距离</li>
<li>elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素</li>
</ul>
<p><strong>分析 ['1', '2', '3'].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>答案:[1, NaN, NaN]</li>
</ul>
<ul>
<li>parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析</li>
<li>map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引</li>
<li>因此，map 遍历 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]，相应 parseInt 接收参数如下</li>
</ul>
<div><pre><code>parseInt('1', 0);  // 1
parseInt('2', 1);  // NaN
parseInt('3', 2);  // NaN
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>所以，parseInt 参数 radix 不合法，导致返回值为 NaN</li>
</ul>
<p><strong>new 操作符具体干了什么？</strong></p>
<ul>
<li>创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<p><strong>用原生JavaScript的实现过什么功能吗？</strong></p>
<ul>
<li>封装选择器、调用第三方API、设置和获取样式</li>
</ul>
<p><strong>解释一下这段代码的意思吗？</strong></p>
<div><pre><code>  <span>[</span><span>]</span><span>.</span><span>forEach</span><span>.</span><span>call</span><span>(</span><span>$$</span><span>(</span><span>"*"</span><span>)</span><span>,</span> <span>function</span><span>(</span><span>el</span><span>)</span><span>{</span>
      el<span>.</span>style<span>.</span>outline <span>=</span> <span>"1px solid #"</span> <span>+</span> <span>(</span><span>~</span><span>~</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>*</span><span>(</span><span>1</span><span>&lt;&lt;</span><span>24</span><span>)</span><span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>16</span><span>)</span><span>;</span>
  <span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline)</li>
<li>
<ol>
<li><code>$$(sel)</code> // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>[].forEach.call(NodeLists)</code> // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表</li>
</ol>
</li>
<li>
<ol start="3">
<li><code>el.style.outline = &quot;1px solid #333&quot;</code> // 样式 outline 位于盒模型之外，不影响元素布局位置</li>
</ol>
</li>
<li>
<ol start="4">
<li><code>(1&lt;&lt;24)</code> // parseInt(&quot;ffffff&quot;, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216</li>
</ol>
</li>
<li>
<ol start="5">
<li><code>Math.random()*(1&lt;&lt;24)</code> // 表示一个位于 0 到 16777216 之间的随机浮点数</li>
</ol>
</li>
<li>
<ol start="6">
<li><code>~~Math.random()*(1&lt;&lt;24)</code> // <code>~~</code> 作用相当于 parseInt 取整</li>
</ol>
</li>
<li>
<ol start="7">
<li><code>(~~(Math.random()*(1&lt;&lt;24))).toString(16)</code> // 转换为一个十六进制-</li>
</ol>
</li>
</ul>
<p>** JavaScript实现异步编程的方法？**</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promises对象</li>
<li>Async函数[ES7]</li>
</ul>
<p><strong>web开发中会话跟踪的方法有哪些</strong></p>
<ul>
<li>cookie</li>
<li>session</li>
<li>url重写</li>
<li>隐藏input</li>
<li>ip地址</li>
</ul>
<p><strong>介绍js的基本数据类型</strong></p>
<ul>
<li>Undefined、Null、Boolean、Number、String</li>
</ul>
<p><strong>介绍js有哪些内置对象？</strong></p>
<ul>
<li>Object 是 JavaScript 中所有对象的父对象</li>
<li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>不要在同一行声明多个变量</li>
<li>请使用 ===/!==来比较true/false或者数值</li>
<li>使用对象字面量替代new Array这种形式</li>
<li>不要使用全局函数</li>
<li>Switch语句必须带有default分支</li>
<li>函数不应该有时候有返回值，有时候没有返回值</li>
<li>If语句必须使用大括号</li>
<li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污</li>
</ul>
<p><strong>JavaScript原型，原型链 ? 有什么特点？</strong></p>
<ul>
<li>
<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时</p>
</li>
<li>
<p>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</p>
</li>
<li>
<p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p>
</li>
<li>
<p>特点：</p>
<ul>
<li>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li>
</ul>
</li>
<li>
<p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</p>
</li>
<li>
<p>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p>
</li>
</ul>
<p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</strong></p>
<ul>
<li>
<p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</p>
</li>
<li>
<p>堆：引用数据类型（对象、数组和函数）</p>
</li>
<li>
<p>两种类型的区别是：存储位置不同；</p>
</li>
<li>
<p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
</li>
<li>
<p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</p>
</li>
<li>
<p>在栈中的地址，取得地址后从堆中获得实体</p>
</li>
</ul>
<p><img src="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt=""></p>
<p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li>
<p>构造继承</p>
</li>
<li>
<p>原型继承</p>
</li>
<li>
<p>实例继承</p>
</li>
<li>
<p>拷贝继承</p>
</li>
<li>
<p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</p>
</li>
</ul>
<div><pre><code> function Parent(){
        this.name = 'wang';
    }

    function Child(){
        this.age = 28;
    }
    Child.prototype = new Parent();//继承了Parent，通过原型

    var demo = new Child();
    alert(demo.age);
    alert(demo.name);//得到被继承的属性
  }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>javascript创建对象的几种方式？</strong></p>
<blockquote>
<p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</p>
</blockquote>
<ul>
<li>对象字面量的方式</li>
</ul>
<div><pre><code>person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>用function来模拟无参的构造函数</li>
</ul>
<div><pre><code> function Person(){}
    var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
        person.name="Mark";
        person.age="25";
        person.work=function(){
        alert(person.name+" hello...");
    }
person.work();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</li>
</ul>
<div><pre><code>function Pet(name,age,hobby){
       this.name=name;//this作用域：当前对象
       this.age=age;
       this.hobby=hobby;
       this.eat=function(){
          alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
       }
    }
    var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
    maidou.eat();//调用eat方法
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>用工厂方式来创建（内置对象）</li>
</ul>
<div><pre><code>var wcDog =new Object();
     wcDog.name="旺财";
     wcDog.age=3;
     wcDog.work=function(){
       alert("我是"+wcDog.name+",汪汪汪......");
     }
     wcDog.work();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>用原型方式来创建</li>
</ul>
<div><pre><code>function Dog(){

     }
     Dog.prototype.name="旺财";
     Dog.prototype.eat=function(){
     alert(this.name+"是个吃货");
     }
     var wangcai =new Dog();
     wangcai.eat();

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>用混合方式来创建</li>
</ul>
<div><pre><code> function Car(name,price){
      this.name=name;
      this.price=price; 
    }
     Car.prototype.sell=function(){
       alert("我是"+this.name+"，我现在卖"+this.price+"万元");
      }
    var camry =new Car("凯美瑞",27);
    camry.sell(); 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找</li>
<li>直至全局函数，这种组织形式就是作用域链</li>
</ul>
<p><strong>谈谈This对象的理解</strong></p>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）</li>
<li>如果有new关键字，this指向new出来的那个对象</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<ul>
<li>它的功能是把对应的字符串解析成JS代码并运行</li>
<li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')')</li>
</ul>
<p><strong>null，undefined 的区别？</strong></p>
<ul>
<li>
<p>undefined   表示不存在这个值。</p>
</li>
<li>
<p>undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</p>
</li>
<li>
<p>例如变量被声明了，但没有赋值时，就等于undefined</p>
</li>
<li>
<p>null 表示一个对象被定义了，值为“空值”</p>
</li>
<li>
<p>null : 是一个对象(空对象, 没有任何属性和方法)</p>
</li>
<li>
<p>例如作为函数的参数，表示该函数的参数不是对象；</p>
</li>
<li>
<p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>
</li>
</ul>
<p><strong>写一个通用的事件侦听器函数</strong></p>
<div><pre><code> // event(事件)工具集，来源：github.com/markyun
    markyun.Event = {
        // 页面加载完成后
        readyEvent : function(fn) {
            if (fn==null) {
                fn=document;
            }
            var oldonload = window.onload;
            if (typeof window.onload != 'function') {
                window.onload = fn;
            } else {
                window.onload = function() {
                    oldonload();
                    fn();
                };
            }
        },
        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
        // 参数： 操作的元素,事件名称 ,事件处理程序
        addEvent : function(element, type, handler) {
            if (element.addEventListener) {
                //事件类型、需要执行的函数、是否捕捉
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent('on' + type, function() {
                    handler.call(element);
                });
            } else {
                element['on' + type] = handler;
            }
        },
        // 移除事件
        removeEvent : function(element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.datachEvent) {
                element.detachEvent('on' + type, handler);
            } else {
                element['on' + type] = null;
            }
        },
        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
        stopPropagation : function(ev) {
            if (ev.stopPropagation) {
                ev.stopPropagation();
            } else {
                ev.cancelBubble = true;
            }
        },
        // 取消事件的默认行为
        preventDefault : function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        // 获取事件目标
        getTarget : function(event) {
            return event.target || event.srcElement;
        },
        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
        getEvent : function(e) {
            var ev = e || window.event;
            if (!ev) {
                var c = this.getEvent.caller;
                while (c) {
                    ev = c.arguments[0];
                    if (ev &amp;&amp; Event == ev.constructor) {
                        break;
                    }
                    c = c.caller;
                }
            }
            return ev;
        }
    };
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。</li>
<li>map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</li>
</ul>
<p><strong>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为</li>
<li>事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件</li>
<li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li>
</ul>
<p><strong>什么是闭包（closure），为什么要用它？</strong></p>
<ul>
<li>
<p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</p>
</li>
<li>
<p>闭包的特性：</p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<p><strong>javascript 代码中的&quot;use strict&quot;;是什么意思 ? 使用它区别是什么？</strong></p>
<ul>
<li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<p><strong>如何判断一个对象是否属于某个类？</strong></p>
<div><pre><code>// 使用instanceof （待完善）
   if(a instanceof Person){
       alert('yes');
   }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>new操作符具体干了什么呢?</strong></p>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 this 引用的对象中</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<div><pre><code>var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>js延迟加载的方式有哪些？</strong></p>
<ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
<p><strong>Ajax 是什么? 如何创建一个Ajax？</strong></p>
<blockquote>
<p>ajax的全称：Asynchronous Javascript And XML</p>
</blockquote>
<ul>
<li>
<p>异步传输+js+xml</p>
</li>
<li>
<p>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验</p>
</li>
<li>
<p>创建XMLHttpRequest对象,也就是创建一个异步调用对象</p>
</li>
<li>
<p>建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p>
</li>
<li>
<p>设置响应HTTP请求状态变化的函数</p>
</li>
<li>
<p>发送HTTP请求</p>
</li>
<li>
<p>获取异步调用返回的数据</p>
</li>
<li>
<p>用JavaScript和DOM实现局部刷新</p>
</li>
</ul>
<p><strong>同步和异步的区别?</strong></p>
<ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>defer，只支持IE</li>
<li>async：</li>
<li>创建script，插入到DOM中，加载完毕后callBack</li>
</ul>
<p><strong>documen.write和 innerHTML的区别</strong></p>
<ul>
<li>document.write只能重绘整个页面</li>
<li>innerHTML可以重绘页面的一部分</li>
</ul>
<p><strong>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</strong></p>
<ul>
<li>（1）创建新节点
<ul>
<li>createDocumentFragment() //创建一个DOM片段</li>
<li>createElement()   //创建一个具体的元素</li>
<li>createTextNode()   //创建一个文本节点</li>
</ul>
</li>
<li>（2）添加、移除、替换、插入
<ul>
<li>appendChild()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>insertBefore() //在已有的子节点前插入一个新的子节点</li>
</ul>
</li>
<li>（3）查找
<ul>
<li>getElementsByTagName()    //通过标签名称</li>
<li>getElementsByName()    // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
<li>getElementById()    //通过元素Id，唯一性</li>
</ul>
</li>
</ul>
<p><strong>那些操作会造成内存泄漏？</strong></p>
<ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ul>
<p><strong>渐进增强和优雅降级</strong></p>
<ul>
<li>
<p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
</li>
<li>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</p>
</li>
</ul>
<p><strong>Javascript垃圾回收方法</strong></p>
<ul>
<li>标记清除（mark and sweep）</li>
</ul>
<blockquote>
<ul>
<li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li>
<li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li>
</ul>
</blockquote>
<p><strong>引用计数(reference counting)</strong></p>
<blockquote>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p>
</blockquote>
<p><strong>js继承方式及其优缺点</strong></p>
<ul>
<li>
<p>原型链继承的缺点</p>
<ul>
<li>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</li>
</ul>
</li>
<li>
<p>借用构造函数（类式继承）</p>
<ul>
<li>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</li>
</ul>
</li>
<li>
<p>组合式继承</p>
<ul>
<li>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</li>
</ul>
</li>
</ul>
<p><strong>defer和async</strong></p>
<ul>
<li>defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</li>
</ul>
<p><strong>用过哪些设计模式？</strong></p>
<ul>
<li>工厂模式：
<ul>
<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</li>
<li>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例</li>
<li></li>
</ul>
</li>
</ul>
<div><pre><code>function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.profession = profession;
    obj.move = function () {
        return this.name + ' at ' + this.age + ' engaged in ' + this.profession;
    };
    return obj;
}
var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>构造函数模式</p>
<ul>
<li>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>
</ul>
</li>
<li>
<p>构造函数方法没有显示的创建对象 (new Object());</p>
</li>
<li>
<p>直接将属性和方法赋值给 this 对象;</p>
</li>
<li>
<p>没有 renturn 语句</p>
</li>
</ul>
<p><strong>说说你对闭包的理解</strong></p>
<ul>
<li>
<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
</li>
<li>
<p>闭包有三个特性：</p>
<ul>
<li>
<p>1.函数嵌套函数</p>
</li>
<li>
<p>2.函数内部可以引用外部的参数和变量</p>
</li>
<li>
<p>3.参数和变量不会被垃圾回收机制回收</p>
</li>
</ul>
</li>
</ul>
<p><strong>请解释一下 JavaScript 的同源策略</strong></p>
<ul>
<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>
<li>指一段脚本只能读取来自同一来源的窗口和文档的属性</li>
</ul>
<p><strong>为什么要有同源限制？</strong></p>
<ul>
<li>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li>
<li>缺点
<ul>
<li>现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li>
</ul>
</li>
</ul>
<p><strong>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</strong></p>
<div><pre><code>Object.prototype.clone = function(){

            var o = this.constructor === Array ? [] : {};

            for(var e in this){

                    o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];

            }

            return o;
    }
    
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>说说严格模式的限制</strong></p>
<ul>
<li>
<p>严格模式主要有以下限制：</p>
</li>
<li>
<p>变量必须声明后再使用</p>
</li>
<li>
<p>函数的参数不能有同名属性，否则报错</p>
</li>
<li>
<p>不能使用with语句</p>
</li>
<li>
<p>不能对只读属性赋值，否则报错</p>
</li>
<li>
<p>不能使用前缀0表示八进制数，否则报错</p>
</li>
<li>
<p>不能删除不可删除的属性，否则报错</p>
</li>
<li>
<p>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</p>
</li>
<li>
<p>eval不会在它的外层作用域引入变量</p>
</li>
<li>
<p>eval和arguments不能被重新赋值</p>
</li>
<li>
<p>arguments不会自动反映函数参数的变化</p>
</li>
<li>
<p>不能使用arguments.callee</p>
</li>
<li>
<p>不能使用arguments.caller</p>
</li>
<li>
<p>禁止this指向全局对象</p>
</li>
<li>
<p>不能使用fn.caller和fn.arguments获取函数调用的堆栈</p>
</li>
<li>
<p>增加了保留字（比如protected、static和interface）</p>
</li>
</ul>
<p><strong>如何删除一个cookie</strong></p>
<ul>
<li>将时间设为当前时间往前一点</li>
</ul>
<div><pre><code>var date = new Date();

date.setDate(date.getDate() - 1);//真正的删除
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>setDate()方法用于设置一个月的某一天</p>
<ul>
<li>expires的设置</li>
</ul>
<div><pre><code>  document.cookie = 'user='+ encodeURIComponent('name')  + ';expires = ' + new Date(0)
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>编写一个方法 求一个字符串的字节长度</strong></p>
<ul>
<li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</li>
</ul>
<div><pre><code>function GetBytes(str){

        var len = str.length;

        var bytes = len;

        for(var i=0; i&lt;len; i++){

            if (str.charCodeAt(i) > 255) bytes++;

        }

        return bytes;

    }

alert(GetBytes("你好,as"));

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>请解释什么是事件代理</strong></p>
<ul>
<li>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>
</ul>
<p><strong>attribute和property的区别是什么？</strong></p>
<ul>
<li>
<p>attribute是dom元素在文档中作为html标签拥有的属性；</p>
</li>
<li>
<p>property就是dom元素在js中作为对象拥有的属性。</p>
</li>
<li>
<p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的</p>
</li>
<li>
<p>但是对于自定义的属性来说，他们是不同步的</p>
</li>
</ul>
<p><strong>页面编码和被请求的资源编码如果不一致如何处理？</strong></p>
<ul>
<li>后端响应头设置 charset</li>
<li>前端页面<code>&lt;meta&gt;</code>设置 charset</li>
</ul>
<p><strong>把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</strong></p>
<ul>
<li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li>
<li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li>
<li>浏览器的容错机制会忽略<code>&lt;script&gt;</code>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code> 闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li>
</ul>
<p><strong>延迟加载JS的方式有哪些？</strong></p>
<ul>
<li>设置<code>&lt;script&gt;</code>属性 defer=&quot;defer&quot; （脚本将在页面完成解析时执行）</li>
<li>动态创建 script DOM：document.createElement('script');</li>
<li>XmlHttpRequest 脚本注入</li>
<li>延迟加载工具 LazyLoad</li>
</ul>
<p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>设置<code>&lt;script&gt;</code>属性 async=&quot;async&quot; （一旦脚本可用，则会异步执行）</li>
<li>动态创建 script DOM：document.createElement('script');</li>
<li>XmlHttpRequest 脚本注入</li>
<li>异步加载库 LABjs</li>
<li>模块加载器 Sea.js</li>
</ul>
<p><strong>JavaScript 中，调用函数有哪几种方式？</strong></p>
<ul>
<li>方法调用模式          Foo.foo(arg1, arg2);</li>
<li>函数调用模式          foo(arg1, arg2);</li>
<li>构造器调用模式        (new Foo())(arg1, arg2);</li>
<li>call/applay调用模式   Foo.foo.call(that, arg1, arg2);</li>
<li>bind调用模式          Foo.foo.bind(that)(arg1, arg2)();</li>
</ul>
<p><strong>简单实现 Function.bind 函数？</strong></p>
<div><pre><code>  <span>if</span> <span>(</span><span>!</span><span>Function</span><span>.</span>prototype<span>.</span>bind<span>)</span> <span>{</span>
    <span>Function</span><span>.</span>prototype<span>.</span><span>bind</span> <span>=</span> <span>function</span><span>(</span><span>that</span><span>)</span> <span>{</span>
      <span>var</span> func <span>=</span> <span>this</span><span>,</span> args <span>=</span> arguments<span>;</span>
      <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>func</span><span>.</span><span>apply</span><span>(</span>that<span>,</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>args<span>,</span> <span>1</span><span>)</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>// 只支持 bind 阶段的默认参数：</span>
  <span>func</span><span>.</span><span>bind</span><span>(</span>that<span>,</span> arg1<span>,</span> arg2<span>)</span><span>(</span><span>)</span><span>;</span>

  <span>// 不支持以下调用阶段传入的参数：</span>
  <span>func</span><span>.</span><span>bind</span><span>(</span>that<span>)</span><span>(</span>arg1<span>,</span> arg2<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>** 列举一下JavaScript数组和对象有哪些原生方法？**</p>
<ul>
<li>
<p>数组：</p>
<ul>
<li>arr.concat(arr1, arr2, arrn);</li>
<li>arr.join(&quot;,&quot;);</li>
<li>arr.sort(func);</li>
<li>arr.pop();</li>
<li>arr.push(e1, e2, en);</li>
<li>arr.shift();</li>
<li>unshift(e1, e2, en);</li>
<li>arr.reverse();</li>
<li>arr.slice(start, end);</li>
<li>arr.splice(index, count, e1, e2, en);</li>
<li>arr.indexOf(el);</li>
<li>arr.includes(el);   // ES6</li>
</ul>
</li>
<li>
<p>对象：</p>
<ul>
<li>object.hasOwnProperty(prop);</li>
<li>object.propertyIsEnumerable(prop);</li>
<li>object.valueOf();</li>
<li>object.toString();</li>
<li>object.toLocaleString();</li>
<li>Class.prototype.isPropertyOf(object);</li>
</ul>
</li>
</ul>
<p><strong>Array.splice() 与 Array.splice() 的区别？</strong></p>
<ul>
<li>
<p>slice -- “读取”数组指定的元素，不会对原数组进行修改</p>
<ul>
<li>语法：arr.slice(start, end)</li>
<li>start 指定选取开始位置（含）</li>
<li>end 指定选取结束位置（不含）</li>
</ul>
</li>
<li>
<p>splice</p>
<ul>
<li>“操作”数组指定的元素，会修改原数组，返回被删除的元素</li>
<li>语法：arr.splice(index, count, [insert Elements])</li>
<li>index 是操作的起始位置</li>
<li>count = 0 插入元素，count &gt; 0 删除元素</li>
<li>[insert Elements] 向数组新插入的元素</li>
</ul>
</li>
</ul>
<p><strong>JavaScript 对象生命周期的理解？</strong></p>
<ul>
<li>当创建一个对象时，JavaScript 会自动为该对象分配适当的内存</li>
<li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li>
<li>如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收</li>
</ul>
<p><strong>哪些操作会造成内存泄漏？</strong></p>
<ul>
<li>
<p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>
</li>
<li>
<p>未使用 var 声明的全局变量</p>
</li>
<li>
<p>闭包函数(Closures)</p>
</li>
<li>
<p>循环引用(两个对象相互引用)</p>
</li>
<li>
<p>控制台日志(console.log)</p>
</li>
<li>
<p>移除存在绑定事件的DOM元素(IE)</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" type="image/"/>
    </item>
    <item>
      <title>JSON和XML区别</title>
      <link>https://0808200.xyz/Interview/base/Json-XML.html</link>
      <guid>https://0808200.xyz/Interview/base/Json-XML.html</guid>
      <source url="https://0808200.xyz/rss.xml">JSON和XML区别</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>XML和JSON的区别？</strong></p>
<ul>
<li>
<p>数据体积方面</p>
<ul>
<li>JSON相对于XML来讲，数据的体积小，传递的速度更快些。</li>
</ul>
</li>
<li>
<p>数据交互方面</p>
<ul>
<li>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li>
<p>数据描述方面</p>
<ul>
<li>JSON对数据的描述性比XML较差</li>
</ul>
</li>
<li>
<p>传输速度方面</p>
<ul>
<li>JSON的速度要远远快于XML</li>
</ul>
</li>
</ul>
<p><strong>JSON 的了解？</strong></p>
<ul>
<li>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式</p>
</li>
<li>
<p>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</p>
</li>
<li>
<p>JSON字符串转换为JSON对象:</p>
</li>
</ul>
<div><pre><code>var obj =eval('('+ str +')');
var obj = str.parseJSON();
var obj = JSON.parse(str);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>JSON对象转换为JSON字符串：</li>
</ul>
<div><pre><code>var last=obj.toJSONString();
var last=JSON.stringify(obj);
</code></pre><div aria-hidden="true"><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>说说你对MVC和MVVM的理解</title>
      <link>https://0808200.xyz/Interview/base/MVC.html</link>
      <guid>https://0808200.xyz/Interview/base/MVC.html</guid>
      <source url="https://0808200.xyz/rss.xml">说说你对MVC和MVVM的理解</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>说说你对MVC和MVVM的理解</strong></p>
<ul>
<li>MVC
<ul>
<li>
<p>View 传送指令到 Controller</p>
</li>
<li>
<p>Controller 完成业务逻辑后，要求 Model 改变状态</p>
</li>
<li>
<p>Model 将新的数据发送到 View，用户得到反馈</p>
</li>
</ul>
</li>
</ul>
<p>所有通信都是单向的</p>
]]></content:encoded>
    </item>
    <item>
      <title>说说你对MVVM的理解</title>
      <link>https://0808200.xyz/Interview/base/MVVM.html</link>
      <guid>https://0808200.xyz/Interview/base/MVVM.html</guid>
      <source url="https://0808200.xyz/rss.xml">说说你对MVVM的理解</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>MVVM 由以下三个内容组成</strong></p>
<ul>
<li><code>View</code>：界面</li>
<li><code>Model</code>：数据模型</li>
<li><code>ViewModel</code>：作为桥梁负责沟通 <code>View</code> 和 <code>Model</code></li>
</ul>
<blockquote>
<ul>
<li>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合</li>
<li>在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel</li>
</ul>
</blockquote>
<ul>
<li>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持</li>
</ul>
<p><strong>脏数据检测</strong></p>
<ul>
<li>当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次</li>
<li>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数</li>
</ul>
<p><strong>数据劫持</strong></p>
<ul>
<li><code>Vue</code> 内部使用了 <code>Obeject.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get </code>的事件</li>
</ul>
<div><pre><code><span>var</span> data <span>=</span> <span>{</span> <span>name</span><span>:</span> <span>'yck'</span> <span>}</span>
<span>observe</span><span>(</span>data<span>)</span>
<span>let</span> name <span>=</span> data<span>.</span>name <span>// -> get value</span>
data<span>.</span>name <span>=</span> <span>'yyy'</span> <span>// -> change value</span>

<span>function</span> <span>observe</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>// 判断类型</span>
  <span>if</span> <span>(</span><span>!</span>obj <span>||</span> <span>typeof</span> obj <span>!==</span> <span>'object'</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  Object<span>.</span><span>keys</span><span>(</span>data<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
    <span>defineReactive</span><span>(</span>data<span>,</span> key<span>,</span> data<span>[</span>key<span>]</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
  <span>// 递归子属性</span>
  <span>observe</span><span>(</span>val<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'get value'</span><span>)</span>
      <span>return</span> val
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'change value'</span><span>)</span>
      val <span>=</span> newVal
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
    {{name}}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>在解析如上模板代码时，遇到 <code>{{name}}</code> 就会给属性 <code>name</code> 添加发布订阅</p>
</blockquote>
<div><pre><code><span>// 通过 Dep 解耦</span>
<span>class</span> <span>Dep</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs <span>=</span> <span>[</span><span>]</span>
  <span>}</span>
  <span>addSub</span><span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>// sub 是 Watcher 实例</span>
    <span>this</span><span>.</span>subs<span>.</span><span>push</span><span>(</span>sub<span>)</span>
  <span>}</span>
  <span>notify</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs<span>.</span><span>forEach</span><span>(</span><span>sub</span> <span>=></span> <span>{</span>
      sub<span>.</span><span>update</span><span>(</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>
<span>// 全局属性，通过该属性配置 Watcher</span>
Dep<span>.</span>target <span>=</span> <span>null</span>

<span>function</span> <span>update</span><span>(</span><span>value</span><span>)</span> <span>{</span>
  document<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span><span>.</span>innerText <span>=</span> value
<span>}</span>

<span>class</span> <span>Watcher</span> <span>{</span>
  <span>constructor</span><span>(</span><span>obj<span>,</span> key<span>,</span> cb</span><span>)</span> <span>{</span>
    <span>// 将 Dep.target 指向自己</span>
    <span>// 然后触发属性的 getter 添加监听</span>
    <span>// 最后将 Dep.target 置空</span>
    Dep<span>.</span>target <span>=</span> <span>this</span>
    <span>this</span><span>.</span>cb <span>=</span> cb
    <span>this</span><span>.</span>obj <span>=</span> obj
    <span>this</span><span>.</span>key <span>=</span> key
    <span>this</span><span>.</span>value <span>=</span> obj<span>[</span>key<span>]</span>
    Dep<span>.</span>target <span>=</span> <span>null</span>
  <span>}</span>
  <span>update</span><span>(</span><span>)</span> <span>{</span>
    <span>// 获得新值</span>
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span>obj<span>[</span><span>this</span><span>.</span>key<span>]</span>
    <span>// 调用 update 方法更新 Dom</span>
    <span>this</span><span>.</span><span>cb</span><span>(</span><span>this</span><span>.</span>value<span>)</span>
  <span>}</span>
<span>}</span>
<span>var</span> data <span>=</span> <span>{</span> <span>name</span><span>:</span> <span>'yck'</span> <span>}</span>
<span>observe</span><span>(</span>data<span>)</span>
<span>// 模拟解析到 `{{name}}` 触发的操作</span>
<span>new</span> <span>Watcher</span><span>(</span>data<span>,</span> <span>'name'</span><span>,</span> update<span>)</span>
<span>// update Dom innerText</span>
data<span>.</span>name <span>=</span> <span>'yyy'</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>接下来,对 defineReactive 函数进行改造</p>
</blockquote>
<div><pre><code><span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
  <span>// 递归子属性</span>
  <span>observe</span><span>(</span>val<span>)</span>
  <span>let</span> dp <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'get value'</span><span>)</span>
      <span>// 将 Watcher 添加到订阅</span>
      <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> <span>{</span>
        dp<span>.</span><span>addSub</span><span>(</span>Dep<span>.</span>target<span>)</span>
      <span>}</span>
      <span>return</span> val
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'change value'</span><span>)</span>
      val <span>=</span> newVal
      <span>// 执行 watcher 的 update 方法</span>
      dp<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加</p>
</blockquote>
<p><strong>Proxy 与 Obeject.defineProperty 对比</strong></p>
<ul>
<li><code>Obeject.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。
<ul>
<li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li>
<li>对于数组不能监听到数据的变化</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然 <code>Vue</code> 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code> 的办法，并且也是有缺陷的</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>模块化开发</title>
      <link>https://0808200.xyz/Interview/base/Modules.html</link>
      <guid>https://0808200.xyz/Interview/base/Modules.html</guid>
      <source url="https://0808200.xyz/rss.xml">模块化开发</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>说说你对AMD和Commonjs的理解</strong></p>
<ul>
<li>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数</li>
<li>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的</li>
</ul>
<p><strong>模块化开发怎么做？</strong></p>
<ul>
<li>立即执行函数,不暴露私有成员</li>
</ul>
<div><pre><code>var module1 = (function(){
　　　　var _count = 0;
　　　　var m1 = function(){
　　　　　　//...
　　　　};
　　　　var m2 = function(){
　　　　　　//...
　　　　};
　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};
　　})();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</strong></p>
<ul>
<li>Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中</li>
</ul>
<div><pre><code>// CMD
define(function(require, exports, module) {
    var a = require('./a')
    a.doSomething()
    // 此处略去 100 行
    var b = require('./b') // 依赖可以就近书写
    b.doSomething()
    // ...
})

// AMD 默认推荐
define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
    a.doSomething()
    // 此处略去 100 行
    b.doSomething()
    // ...
})
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>对前端模块化的认识</strong></p>
<ul>
<li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出</li>
<li>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出</li>
<li>AMD 是提前执行，CMD 是延迟执行</li>
<li>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>PS 图片相关</title>
      <link>https://0808200.xyz/Interview/base/PS.html</link>
      <guid>https://0808200.xyz/Interview/base/PS.html</guid>
      <source url="https://0808200.xyz/rss.xml">PS 图片相关</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="ps相关" tabindex="-1"> PS相关</h3>
<hr>
<p><strong>PNG,GIF,JPG的区别及如何选</strong></p>
<ul>
<li>
<p>GIF：</p>
<ul>
<li>8位像素，256色</li>
<li>无损压缩</li>
<li>支持简单动画</li>
<li>支持boolean透明</li>
<li>适合简单动画</li>
</ul>
</li>
<li>
<p>JPEG：</p>
<ul>
<li>颜色限于256</li>
<li>有损压缩</li>
<li>可控制压缩质量</li>
<li>不支持透明</li>
<li>适合照片</li>
</ul>
</li>
<li>
<p>PNG：</p>
<ul>
<li>有PNG8和truecolor PNG</li>
<li>PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画</li>
<li>适合图标、背景、按钮</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>基础版</title>
      <link>https://0808200.xyz/Interview/base/</link>
      <guid>https://0808200.xyz/Interview/base/</guid>
      <source url="https://0808200.xyz/rss.xml">基础版</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="fe-interview-questions" tabindex="-1"> FE-Interview-Questions</h1>
<blockquote>
<p>前端面试常考问题分类整理汇总</p>
</blockquote>
<p><a href="https://github.com/poetries/FE-Interview-Questions/issues/2" target="_blank" rel="noopener noreferrer">&gt;&gt; 面试问题答案综合版</a></p>
<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li><a href="/Interview/base/the_interview_questions_lite_version.html">面试题精简版本</a></li>
<li><a href="/Interview/base/HTML.html">HTML</a></li>
<li><a href="/Interview/base/CSS.html">CSS</a></li>
<li><a href="/Interview/base/JavaScript.html">JavaScript</a></li>
<li><a href="/Interview/base/jQuery.html">jQuery</a></li>
<li><a href="/Interview/base/Ajax.html">Ajax</a></li>
<li><a href="/Interview/base/HTTP.html">HTTP</a></li>
<li><a href="/Interview/base/Front-end-frame-relative.html">Front-end-frame-relative</a></li>
<li><a href="/Interview/base/Json-XML.html">Json-XML</a></li>
<li><a href="/Interview/base/localStorage.html">localStorage</a></li>
<li><a href="/Interview/base/mobile-terminal.html">mobile-terminal</a></li>
<li><a href="/Interview/base/Modules.html">Modules</a></li>
<li><a href="/Interview/base/performance-optimization.html">performance-optimization</a></li>
<li><a href="/Interview/base/PS.html">PS</a></li>
<li><a href="/Interview/base/SEO.html">SEO</a></li>
<li><a href="/Interview/base/ES6.html">ES6</a></li>
<li><a href="/Interview/base/cross-domain.html">cross-domain</a></li>
<li><a href="/Interview/base/cookie.html">cookie</a></li>
<li><a href="/Interview/base/MVC.html">MVC</a></li>
<li><a href="/Interview/base/Git.html">Git</a></li>
<li><a href="/Interview/base/data-structure.html">data-structure</a></li>
<li><a href="/Interview/base/dataBase.html">dataBase</a></li>
<li><a href="/Interview/base/Handwritten-code.html">Handwritten-code</a></li>
<li><a href="/Interview/base/computer-basic-knowledge.html">computer-basic-knowledge</a></li>
<li><a href="/Interview/base/other.html">other</a></li>
<li><a href="/Interview/base/comprehensive.html">comprehensive</a></li>
<li><a href="/Interview/base/vue.html">vue</a></li>
<li><a href="/Interview/base/react.html">react</a></li>
<li><a href="/Interview/base/MVVM.html">MVVM</a></li>
<li><a href="/Interview/base/the_browser.html">浏览器</a></li>
<li><a href="/Interview/base/performance.html">性能</a></li>
<li><a href="/Interview/base/CSRF_and_XSS.html">安全问题：CSRF和XSS</a></li>
<li><a href="/Interview/base/createObj_and_the_prototype_chain.html">创建对象和原型链</a></li>
<li><a href="/Interview/base/crossdomain_communication_class.html">跨域通信类</a></li>
<li><a href="/Interview/base/objectoriented.html">面向对象：类的定义和继承的几种方式</a></li>
<li><a href="/Interview/base/the_frontend_monitoring_errors.html">前端错误监控</a></li>
<li><a href="/Interview/base/the_page_layout.html">页面布局</a></li>
<li><a href="/Interview/base/CSS_box_and_BFC.html">CSS盒模型及BFC</a></li>
<li><a href="/Interview/base/dom_events_summary.html">DOM事件的总结</a></li>
<li><a href="/Interview/base/http_protocol.html">HTTP协议</a></li>
</ul>
<h2 id="综合版本" tabindex="-1"> 综合版本</h2>
<ul>
<li><a href="/Interview/base/question-version.html">Interview-Questions</a></li>
<li><a href="/Interview/base/question-and-answer-version.html">Front-end-Developer-Questions[question-and-answer-version]</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>前端需要注意哪些SEO</title>
      <link>https://0808200.xyz/Interview/base/SEO.html</link>
      <guid>https://0808200.xyz/Interview/base/SEO.html</guid>
      <source url="https://0808200.xyz/rss.xml">前端需要注意哪些SEO</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="前端需要注意哪些seo" tabindex="-1"> 前端需要注意哪些SEO</h3>
<hr>
<ul>
<li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li>
<li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>
<li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用js输出：爬虫不会执行js获取内容</li>
<li>少用iframe：搜索引擎不会抓取iframe中的内容</li>
<li>非装饰性图片必须加alt</li>
<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
</ul>
<p><strong>如何做SEO优化?</strong></p>
<ul>
<li>标题与关键词</li>
</ul>
<ul>
<li>设置有吸引力切合实际的标题，标题中要包含所做的关键词</li>
</ul>
<ul>
<li>网站结构目录</li>
</ul>
<ul>
<li>最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布</li>
</ul>
<ul>
<li>页面元素</li>
</ul>
<ul>
<li>给图片标注&quot;Alt&quot;可以让搜索引擎更友好的收录</li>
</ul>
<ul>
<li>网站内容</li>
</ul>
<ul>
<li>每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢</li>
</ul>
<ul>
<li>友情链接</li>
</ul>
<ul>
<li>对方一定要是正规网站，每天有专业的团队或者个人维护更新</li>
</ul>
<ul>
<li>内链的布置</li>
</ul>
<ul>
<li>使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接</li>
</ul>
<ul>
<li>流量分析</li>
</ul>
<ul>
<li>通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>开放性问题</title>
      <link>https://0808200.xyz/Interview/base/comprehensive.html</link>
      <guid>https://0808200.xyz/Interview/base/comprehensive.html</guid>
      <source url="https://0808200.xyz/rss.xml">开放性问题</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</strong></p>
<ul>
<li>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近
<ul>
<li>实现界面交互</li>
<li>提升用户体验</li>
<li>有了<code>Node.js</code>，前端可以实现服务端的一些事情</li>
</ul>
</li>
<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 <code>90</code>分进化到 <code>100</code> 分，甚至更好，</li>
<li>参与项目，快速高质量完成实现效果图，精确到<code>1px</code></li>
<li>与团队成员，<code>UI</code>设计，产品经理的沟通；</li>
<li>做好的页面结构，页面重构和用户体验；</li>
<li>处理<code>hack</code>，兼容、写出优美的代码格式；</li>
<li>针对服务器的优化、拥抱最新前端技术。</li>
</ul>
<p><strong>平时如何管理你的项目？</strong></p>
<ul>
<li>先期团队必须确定好全局样式（<code>globe.css</code>），编码模式(<code>utf-8</code>) 等；</li>
<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>
<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>
<li>页面进行标注（例如 页面 模块 开始和结束）；</li>
<li><code>CSS</code>跟<code>HTML</code> 分文件夹并行存放，命名都得统一（例如<code>style.css</code>）；</li>
<li><code>JS</code> 分文件夹存放 命名以该JS功能为准的英文翻译</li>
<li>图片采用整合的 <code>images.png</code> <code>png8</code> 格式文件使用</li>
<li>尽量整合在一起使用方便将来的管理</li>
</ul>
<h3 id="一些开放性题目" tabindex="-1"> 一些开放性题目</h3>
<ul>
<li>自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势</li>
<li>项目介绍</li>
<li>如何看待前端开发？</li>
<li>平时是如何学习前端开发的？</li>
<li>未来三到五年的规划是怎样的？</li>
</ul>
<p><strong>你觉得前端工程的价值体现在哪</strong></p>
<ul>
<li>为简化用户使用提供技术支持（交互部分）</li>
<li>为多个浏览器兼容性提供支持</li>
<li>为提高用户浏览速度（浏览器性能）提供支持</li>
<li>为跨平台或者其他基于<code>webkit</code>或其他渲染引擎的应用提供支持</li>
<li>为展示数据提供支持（数据接口）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>进程与线程</title>
      <link>https://0808200.xyz/Interview/base/computer-basic-knowledge.html</link>
      <guid>https://0808200.xyz/Interview/base/computer-basic-knowledge.html</guid>
      <source url="https://0808200.xyz/rss.xml">进程与线程</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>线程与进程的区别</strong></p>
<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存</li>
<li>线程不能够独立执行，必须应用程序提供多个线程执行控制</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>请你谈谈Cookie的弊端</title>
      <link>https://0808200.xyz/Interview/base/cookie.html</link>
      <guid>https://0808200.xyz/Interview/base/cookie.html</guid>
      <source url="https://0808200.xyz/rss.xml">请你谈谈Cookie的弊端</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>请你谈谈Cookie的弊端</strong></p>
<ul>
<li>
<p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</p>
</li>
<li>
<p>第一：每个特定的域名下最多生成20个cookie</p>
</li>
<li>
<p>1.IE6或更低版本最多20个cookie</p>
</li>
<li>
<p>2.IE7和之后的版本最后可以有50个cookie。</p>
</li>
<li>
<p>3.Firefox最多50个cookie</p>
</li>
<li>
<p>4.chrome和Safari没有做硬性限制</p>
</li>
</ul>
<p><strong>请你谈谈Cookie的弊端？</strong></p>
<ul>
<li>每个特定的域名下最多生成的 cookie 个数有限制</li>
<li>IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie</li>
<li>cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节</li>
<li>如果 cookie 被人拦截了，就可以取得所有的 session 信息</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>创建对象和原型链</title>
      <link>https://0808200.xyz/Interview/base/createObj_and_the_prototype_chain.html</link>
      <guid>https://0808200.xyz/Interview/base/createObj_and_the_prototype_chain.html</guid>
      <source url="https://0808200.xyz/rss.xml">创建对象和原型链</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-前言" tabindex="-1"> 1 前言</h2>
<h3 id="_1-1-面向对象的三大特性" tabindex="-1"> 1.1 面向对象的三大特性</h3>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h3 id="_1-2-原型链的知识" tabindex="-1"> 1.2 原型链的知识</h3>
<blockquote>
<p>原型链是面向对象的基础，是非常重要的部分。有以下几种知识：</p>
</blockquote>
<ul>
<li>创建对象有几种方法</li>
<li>原型、构造函数、实例、原型链</li>
<li><code>instanceof</code>的原理</li>
<li><code>new</code> 运算符</li>
</ul>
<h2 id="_2-创建对象有几种方法" tabindex="-1"> 2 创建对象有几种方法</h2>
<h3 id="_2-1-方式一-字面量" tabindex="-1"> 2.1 方式一：字面量</h3>
<div><pre><code>    <span>var</span> obj11 <span>=</span> <span>{</span><span>name</span><span>:</span> <span>'smyh'</span><span>}</span><span>;</span>
    <span>var</span> obj12 <span>=</span> <span>new</span> <span>Object</span><span>(</span>name<span>:</span> <span><span>`</span><span>smyh</span><span>`</span></span><span>)</span><span>;</span> <span>//内置对象（内置的构造函数）</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>上面的两种写法，效果是一样的。因为，第一种写法，<code>obj11</code>会指向<code>Object</code>。</p>
</blockquote>
<ul>
<li>第一种写法是：字面量的方式。</li>
<li>第二种写法是：内置的构造函数</li>
</ul>
<h3 id="_2-2-方式二-通过构造函数" tabindex="-1"> 2.2 方式二：通过构造函数</h3>
<div><pre><code>    <span>var</span> <span>M</span> <span>=</span> <span>function</span> <span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>var</span> obj3 <span>=</span> <span>new</span> <span>M</span><span>(</span><span>'smyhvae'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="_2-3-方法三-object-create" tabindex="-1"> 2.3 方法三：Object.create</h3>
<div><pre><code>    <span>var</span> p <span>=</span> <span>{</span><span>name</span><span>:</span><span>'smyhvae'</span><span>}</span><span>;</span>
    <span>var</span> obj3 <span>=</span> Object<span>.</span><span>create</span><span>(</span>p<span>)</span><span>;</span>  <span>//此方法创建的对象，是用原型链连接的</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>第三种方法，很少有人能说出来。这种方式里，<code>obj3</code>是实例，<code>p</code>是<code>obj3的``原型（</code>name<code>是p原型里的属性），构造函数是</code>Objecet` 。</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_1633.png" alt=""></p>
<h2 id="_3-原型、构造函数、实例-以及原型链" tabindex="-1"> 3 原型、构造函数、实例，以及原型链</h2>
<p><img src="http://img.smyhvae.com/20180306_1540.png" alt=""></p>
<blockquote>
<p>PS：任何一个函数，如果在前面加了<code>new</code>，那就是构造函数。</p>
</blockquote>
<h3 id="_3-1-原型、构造函数、实例三者之间的关系" tabindex="-1"> 3.1 原型、构造函数、实例三者之间的关系</h3>
<p><img src="http://img.smyhvae.com/20180306_2107.png" alt=""></p>
<ol>
<li>构造函数通过 <code>new</code> 生成实例</li>
<li>构造函数也是函数，构造函数的<code>prototype</code>指向原型。（所有的函数有<code>prototype</code>属性，但实例没有 <code>prototype</code>属性）</li>
<li>原型对象中有 <code>constructor</code>，指向该原型的构造函数。</li>
</ol>
<blockquote>
<p>上面的三行，代码演示：</p>
</blockquote>
<div><pre><code>  <span>var</span> <span>Foo</span> <span>=</span> <span>function</span> <span>(</span><span>name</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>

  <span>var</span> fn <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>'smyhvae'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>上面的代码中，<code>Foo.prototype.constructor === Foo</code>的结果是<code>true</code>：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_2120.png" alt=""></p>
<ol start="4">
<li>实例的<code>__proto__</code>指向原型。也就是说，<code>Foo.__proto__ === M.prototype</code>。</li>
</ol>
<blockquote>
<p>声明：所有的<strong>引用类型</strong>（数组、对象、函数）都有<code>__proto__</code>这个属性。</p>
</blockquote>
<p><code>Foo.__proto__ === Function.prototype</code>的结果为true，说明<code>Foo</code>这个普通的函数，是<code>Function</code>构造函数的一个实例。</p>
<h3 id="_3-2-原型链" tabindex="-1"> 3.2 原型链</h3>
<p><strong>原型链的基本原理</strong>：任何一个<strong>实例</strong>，通过原型链，找到它上面的<strong>原型</strong>，该原型对象中的方法和属性，可以被所有的原型实例共享。</p>
<blockquote>
<p><code>Object</code>是原型链的顶端。</p>
</blockquote>
<ul>
<li>原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：</li>
</ul>
<div><pre><code>  <span>//给Foo的原型添加 say 函数</span>
  <span>Foo</span><span>.</span>prototype<span>.</span><span>say</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>原型链的关键</strong>：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。</p>
<h3 id="_3-3-instanceof的原理" tabindex="-1"> 3.3 <code>instanceof</code>的原理</h3>
<p><img src="http://img.smyhvae.com/20180306_2209.png" alt=""></p>
<ul>
<li><code>instanceof</code>的<strong>作用</strong>：用于判断<strong>实例</strong>属于哪个<strong>构造函数</strong>。</li>
<li><code>instanceof</code>的<strong>原理</strong>：判断实例对象的<code>__proto__</code>属性，和构造函数的<code>prototype</code>属性，是否为同一个引用（是否指向同一个地址）。</li>
</ul>
<blockquote>
<ul>
<li><strong>注意1</strong>：虽然说，实例是由构造函数 new 出来的，但是实例的<code>__proto__</code>属性引用的是构造函数的<code>prototype</code>。也就是说，实例的<code>__proto__</code>属性与构造函数本身无关。</li>
<li><strong>注意2</strong>：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找<code>__proto__</code>属性。这条链上如果能找到， instanceof 的返回结果也是 true。</li>
</ul>
</blockquote>
<p>比如说：</p>
<ul>
<li><code>foo instance of Foo</code>的结果为true，因为<code>foo.__proto__ === M.prototype</code>为<code>true</code></li>
<li><strong><code>foo instance of Objecet</code>的结果也为true</strong>，为<code>Foo.prototype.__proto__ === Object.prototype</code>为<code>true</code>。</li>
</ul>
<blockquote>
<p>但我们不能轻易的说：<code>foo</code> 一定是 由<code>Object</code>创建的实例`。这句话是错误的。我们来看下一个问题就明白了。</p>
</blockquote>
<h3 id="_3-4-分析一个问题" tabindex="-1"> 3.4 分析一个问题</h3>
<p><strong>问题：<strong>已知A继承了B，B继承了C。怎么判断 a 是由A</strong>直接生成</strong>的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？</p>
<blockquote>
<p>分析：这就要用到原型的<code>constructor</code>属性了。</p>
</blockquote>
<ul>
<li><code>foo.__proto__.constructor === M</code>的结果为<code>true</code>，但是 <code>foo.__proto__.constructor === Object</code>的结果为<code>false</code>。</li>
<li>所以，用 <code>consturctor</code>判断就比用 <code>instanceof</code>判断，更为严谨。</li>
</ul>
<h2 id="_4-new-运算符" tabindex="-1"> 4 new 运算符</h2>
<blockquote>
<p>当<code>new Foo()</code>时发生了什么：</p>
</blockquote>
<ul>
<li>创建一个<strong>新的空对象实例</strong>。</li>
<li>将此空对象的隐式原型指向其构造函数的显示原型。</li>
<li>执行构造函数（传入相应的参数，如果没有参数就不用传），同时 <code>this</code> 指向这个新实例。</li>
<li>如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。</li>
</ul>
<div><pre><code></code></pre><div aria-hidden="true"></div></div>]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180306_1633.png" type="image/png"/>
    </item>
    <item>
      <title>如何解决跨域问题？</title>
      <link>https://0808200.xyz/Interview/base/cross-domain.html</link>
      <guid>https://0808200.xyz/Interview/base/cross-domain.html</guid>
      <source url="https://0808200.xyz/rss.xml">如何解决跨域问题？</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="如何解决跨域问题" tabindex="-1"> 如何解决跨域问题</h3>
<hr>
<p><strong>JSONP：</strong></p>
<ul>
<li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li>
<li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li>
<li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li>
<li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li>
</ul>
<div><pre><code>  <span>function</span> <span>createJs</span><span>(</span><span>sUrl</span><span>)</span><span>{</span>

      <span>var</span> oScript <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'script'</span><span>)</span><span>;</span>
      oScript<span>.</span>type <span>=</span> <span>'text/javascript'</span><span>;</span>
      oScript<span>.</span>src <span>=</span> sUrl<span>;</span>
      document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'head'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>appendChild</span><span>(</span>oScript<span>)</span><span>;</span>
  <span>}</span>

  <span>createJs</span><span>(</span><span>'jsonp.js'</span><span>)</span><span>;</span>

  <span>box</span><span>(</span><span>{</span>
     <span>'name'</span><span>:</span> <span>'test'</span>
  <span>}</span><span>)</span><span>;</span>

  <span>function</span> <span>box</span><span>(</span><span>json</span><span>)</span><span>{</span>
      <span>alert</span><span>(</span>json<span>.</span>name<span>)</span><span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>CORS</strong></p>
<ul>
<li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li>
</ul>
<p><strong>通过修改document.domain来跨子域</strong></p>
<ul>
<li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li>
</ul>
<p><strong>使用window.name来进行跨域</strong></p>
<ul>
<li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li>
</ul>
<p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p>
<ul>
<li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li>
</ul>
<p><strong>如何解决跨域问题?</strong></p>
<ul>
<li>
<p><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</p>
</li>
<li>
<p>如何解决跨域问题?</p>
<ul>
<li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li>
<li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li>
<li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li>
<li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code>  //兼容性 IE8+</li>
<li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li>
<li>服务器端设置代理请求：服务器端不受同源策略限制</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>跨域通信类</title>
      <link>https://0808200.xyz/Interview/base/crossdomain_communication_class.html</link>
      <guid>https://0808200.xyz/Interview/base/crossdomain_communication_class.html</guid>
      <source url="https://0808200.xyz/rss.xml">跨域通信类</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-前言" tabindex="-1"> 1 前言</h2>
<p>从本章起，对代码的要求没之前那么高了，但是，要求你对知识面的掌握要足够宽。</p>
<p><strong>前端通信类的问题，主要包括以下内容</strong>：</p>
<ol>
<li>什么是<strong>同源策略</strong>及限制</li>
</ol>
<blockquote>
<p>同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。</p>
</blockquote>
<ol start="2">
<li><strong>前后端如何通信</strong></li>
</ol>
<blockquote>
<p>如果你不准备，估计也就只能说出<code>ajax</code>。这个可以考察出知识面。</p>
</blockquote>
<ol start="3">
<li>如何创建<strong>Ajax</strong></li>
</ol>
<blockquote>
<p><code>Ajax</code>在前后端通信中经常用到。做业务时，可以借助第三方的库，比如<code>vue</code>框架里的库、<code>jQuery</code>也有封装好的方法。但如果让你用原生的<code>js</code>去实现，该怎么做？</p>
</blockquote>
<p>这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。</p>
<ol start="4">
<li><strong>跨域通信</strong>的几种方式</li>
</ol>
<blockquote>
<p>这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、<strong>跨域有几种方式</strong>。</p>
</blockquote>
<p>下面分别讲解。</p>
<h2 id="_2-同源策略的概念和具体限制" tabindex="-1"> 2 同源策略的概念和具体限制</h2>
<blockquote>
<p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）</p>
</blockquote>
<p><strong>具体解释：</strong></p>
<ol>
<li><code>源</code>包括三个部分：协议、域名、端口（<code>http</code>协议的默认端口是<code>80</code>）。如果有任何一个部分不同，则<code>源</code>不同，那就是跨域了。</li>
<li><code>限制</code>：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）</li>
</ol>
<ul>
<li><code>Cookie</code>、<code>LocalStorage</code>和<code>IndexDB</code>无法获取。</li>
<li>无法获取和操作<code>DOM</code>。</li>
<li>不能发送<code>Ajax</code>请求。我们要注意，<code>Ajax</code>只适合<strong>同源</strong>的通信。</li>
</ul>
<h2 id="_3-前后端如何通信" tabindex="-1"> 3 前后端如何通信</h2>
<p><strong>主要有以下几种方式：</strong></p>
<ul>
<li><code>Ajax</code>：不支持跨域。</li>
<li><code>WebSocket</code>：不受同源策略的限制，支持跨域</li>
<li><code>CORS</code>：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：<strong>同时支持同源和跨域的Ajax</strong>。</li>
</ul>
<h2 id="_4-如何创建ajax" tabindex="-1"> 4 如何创建Ajax</h2>
<blockquote>
<p>在回答 <code>Ajax</code> 的问题时，要回答以下几个方面：</p>
</blockquote>
<ol>
<li><code>XMLHttpRequest</code> 的工作原理</li>
<li>兼容性处理</li>
</ol>
<blockquote>
<p><code>XMLHttpRequest</code>只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。</p>
</blockquote>
<ol start="3">
<li>事件的触发条件</li>
<li>事件的触发顺序</li>
</ol>
<blockquote>
<p><code>XMLHttpRequest</code>有很多触发事件，每个事件是怎么触发的。</p>
</blockquote>
<h3 id="_4-1-发送-ajax-请求的五个步骤-xmlhttprequest的工作原理" tabindex="-1"> 4.1 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）</h3>
<ol>
<li>创建<code>XMLHttpRequest</code> 对象。</li>
<li>使用<code>open</code>方法设置请求的参数。`open(method, url, 是否异步)``。</li>
<li>发送请求。</li>
<li>注册事件。 注册<code>onreadystatechange</code>事件，状态改变时就会调用。</li>
</ol>
<blockquote>
<p>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</p>
</blockquote>
<ol start="5">
<li>获取返回的数据，更新UI。</li>
</ol>
<h3 id="_4-2-发送-get-请求和-post-请求" tabindex="-1"> 4.2 发送 get 请求和 post 请求</h3>
<blockquote>
<p><code>get</code>请求举例：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>h1</span><span>></span></span>Ajax 发送 get 请求<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>发送get_ajax请求<span>"</span></span> <span>id</span><span><span>=</span><span>'</span>btnAjax<span>'</span></span><span>></span></span>

<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>
    <span>// 绑定点击事件</span>
    document<span>.</span><span>querySelector</span><span>(</span><span>'#btnAjax'</span><span>)</span><span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 发送ajax 请求 需要 五步</span>

        <span>// （1）创建异步对象</span>
        <span>var</span> ajaxObj <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>

        <span>// （2）设置请求的参数。包括：请求的方法、请求的url。</span>
        ajaxObj<span>.</span><span>open</span><span>(</span><span>'get'</span><span>,</span> <span>'02-ajax.php'</span><span>)</span><span>;</span>

        <span>// （3）发送请求</span>
        ajaxObj<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>

        <span>//（4）注册事件。 onreadystatechange事件，状态改变时就会调用。</span>
        <span>//如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</span>
        ajaxObj<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>// 为了保证 数据 完整返回，我们一般会判断 两个值</span>
            <span>if</span> <span>(</span>ajaxObj<span>.</span>readyState <span>==</span> <span>4</span> <span>&amp;&amp;</span> ajaxObj<span>.</span>status <span>==</span> <span>200</span><span>)</span> <span>{</span>
                <span>// 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span>
                <span>// 5.在注册的事件中 获取 返回的 内容 并修改页面的显示</span>
                console<span>.</span><span>log</span><span>(</span><span>'数据返回成功'</span><span>)</span><span>;</span>

                <span>// 数据是保存在 异步对象的 属性中</span>
                console<span>.</span><span>log</span><span>(</span>ajaxObj<span>.</span>responseText<span>)</span><span>;</span>

                <span>// 修改页面的显示</span>
                document<span>.</span><span>querySelector</span><span>(</span><span>'h1'</span><span>)</span><span>.</span>innerHTML <span>=</span> ajaxObj<span>.</span>responseText<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>post</code> 请求举例：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>h1</span><span>></span></span>Ajax 发送 get 请求<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>发送put_ajax请求<span>"</span></span> <span>id</span><span><span>=</span><span>'</span>btnAjax<span>'</span></span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>

    <span>// 异步对象</span>
    <span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>

    <span>// 设置属性</span>
    xhr<span>.</span><span>open</span><span>(</span><span>'post'</span><span>,</span> <span>'02.post.php'</span><span>)</span><span>;</span>

    <span>// 如果想要使用post提交数据,必须添加此行</span>
    xhr<span>.</span><span>setRequestHeader</span><span>(</span><span>"Content-type"</span><span>,</span> <span>"application/x-www-form-urlencoded"</span><span>)</span><span>;</span>

    <span>// 将数据通过send方法传递</span>
    xhr<span>.</span><span>send</span><span>(</span><span>'name=fox&amp;age=18'</span><span>)</span><span>;</span>

    <span>// 发送并接受返回值</span>
    xhr<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 这步为判断服务器是否正确响应</span>
        <span>if</span> <span>(</span>xhr<span>.</span>readyState <span>==</span> <span>4</span> <span>&amp;&amp;</span> xhr<span>.</span>status <span>==</span> <span>200</span><span>)</span> <span>{</span>
            <span>alert</span><span>(</span>xhr<span>.</span>responseText<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_4-3-onreadystatechange-事件" tabindex="-1"> 4.3 onreadystatechange 事件</h3>
<blockquote>
<p>注册 <code>onreadystatechange</code> 事件后，每当 <code>readyState</code> 属性改变时，就会调用 <code>onreadystatechange</code> 函数。</p>
</blockquote>
<blockquote>
<p><code>readyState</code>：（存有 <code>XMLHttpRequest</code> 的状态。从 <code>0</code> 到 <code>4</code> 发生变化）</p>
</blockquote>
<ul>
<li><code>0</code>: 请求未初始化</li>
<li><code>1</code>: 服务器连接已建立</li>
<li><code>2</code>: 请求已接收</li>
<li><code>3</code>: 请求处理中</li>
<li><code>4</code>: 请求已完成，且响应已就绪</li>
</ul>
<h3 id="_4-4-事件的触发条件" tabindex="-1"> 4.4 事件的触发条件</h3>
<p><img src="http://img.smyhvae.com/20180307_1443.png" alt=""></p>
<h3 id="_4-5-事件的触发顺序" tabindex="-1"> 4.5 事件的触发顺序</h3>
<p><img src="http://img.smyhvae.com/20180307_1445.png" alt=""></p>
<h3 id="_4-6-实际开发中用的-原生ajax请求" tabindex="-1"> 4.6 实际开发中用的 原生Ajax请求</h3>
<div><pre><code>
    <span>var</span> util <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>//获取 ajax 请求之后的json</span>
    util<span>.</span><span>json</span> <span>=</span> <span>function</span> <span>(</span><span>options</span><span>)</span> <span>{</span>

        <span>var</span> opt <span>=</span> <span>{</span>
            <span>url</span><span>:</span> <span>''</span><span>,</span>
            <span>type</span><span>:</span> <span>'get'</span><span>,</span>
            <span>data</span><span>:</span> <span>{</span><span>}</span><span>,</span>
            <span>success</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>}</span><span>,</span>
            <span>error</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>}</span><span>,</span>

        <span>}</span><span>;</span>
        util<span>.</span><span>extend</span><span>(</span>opt<span>,</span> options<span>)</span><span>;</span>
        <span>if</span> <span>(</span>opt<span>.</span>url<span>)</span> <span>{</span>
            <span>//IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api</span>
            <span>var</span> xhr <span>=</span> XMLHttpRequest <span>?</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>window<span>.</span>ActiveXObject</span><span>(</span><span>'Microsoft.XMLHTTP'</span><span>)</span><span>;</span>

            <span>var</span> data <span>=</span> opt<span>.</span>data<span>,</span>
                url <span>=</span> opt<span>.</span>url<span>,</span>
                type <span>=</span> opt<span>.</span>type<span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
            dataArr <span>=</span> <span>[</span><span>]</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>var</span> key <span>in</span> data<span>)</span> <span>{</span>
            dataArr<span>.</span><span>push</span><span>(</span>key <span>+</span> <span>'='</span> <span>+</span> data<span>[</span>key<span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>type <span>===</span> <span>'GET'</span><span>)</span> <span>{</span>
            url <span>=</span> url <span>+</span> <span>'?'</span> <span>+</span> dataArr<span>.</span><span>join</span><span>(</span><span>'&amp;'</span><span>)</span><span>;</span>
            xhr<span>.</span><span>open</span><span>(</span>type<span>,</span> url<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\?$</span><span>/</span><span>g</span></span><span>,</span> <span>''</span><span>)</span><span>,</span> <span>true</span><span>)</span><span>;</span>
            xhr<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>type <span>===</span> <span>'POST'</span><span>)</span> <span>{</span>
            xhr<span>.</span><span>open</span><span>(</span>type<span>,</span> url<span>,</span> <span>true</span><span>)</span><span>;</span>
            <span>// 如果想要使用post提交数据,必须添加此行</span>
            xhr<span>.</span><span>setRequestHeader</span><span>(</span><span>"Content-type"</span><span>,</span> <span>"application/x-www-form-urlencoded"</span><span>)</span><span>;</span>
            xhr<span>.</span><span>send</span><span>(</span>dataArr<span>.</span><span>join</span><span>(</span><span>'&amp;'</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>xhr<span>.</span>status <span>===</span> <span>200</span> <span>||</span> xhr<span>.</span>status <span>===</span> <span>304</span><span>)</span> <span>{</span> <span>//304表示：用缓存即可。206表示获取媒体资源的前面一部分</span>
                <span>var</span> res<span>;</span>
                <span>if</span> <span>(</span>opt<span>.</span>success <span>&amp;&amp;</span> opt<span>.</span>success <span>instanceof</span> <span>Function</span><span>)</span> <span>{</span>
                    res <span>=</span> xhr<span>.</span>responseText<span>;</span>
                    <span>if</span> <span>(</span><span>typeof</span> res <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
                        res <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>res<span>)</span><span>;</span>  <span>//将字符串转成json</span>
                        opt<span>.</span><span>success</span><span>.</span><span>call</span><span>(</span>xhr<span>,</span> res<span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>if</span> <span>(</span>opt<span>.</span>error <span>&amp;&amp;</span> opt<span>.</span>error <span>instanceof</span> <span>Function</span><span>)</span> <span>{</span>
                    opt<span>.</span><span>error</span><span>.</span><span>call</span><span>(</span>xhr<span>,</span> res<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>;</span>
    <span>}</span>


</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_5-跨域通信的几种方式" tabindex="-1"> 5 跨域通信的几种方式</h2>
<blockquote>
<p>方式如下：</p>
</blockquote>
<ol>
<li><code>JSONP</code></li>
<li><code>WebSocket</code></li>
<li><code>CORS</code></li>
<li><code>Hash</code></li>
<li><code>postMessage</code></li>
</ol>
<blockquote>
<p>上面这五种方式，在面试时，都要说出来。</p>
</blockquote>
<h3 id="_5-1-jsonp" tabindex="-1"> 5.1 JSONP</h3>
<blockquote>
<p>面试会问：<code>JSONP</code>的原理是什么？怎么实现的？</p>
</blockquote>
<ul>
<li>在<code>CORS</code>和<code>postMessage</code>以前，我们一直都是通过<code>JSONP</code>来做跨域通信的。</li>
</ul>
<blockquote>
<p><strong>JSONP的原理</strong>：通过<code>&lt;script&gt;</code>标签的异步加载来实现的。比如说，实际开发中，我们发现，<code>head</code>标签里，可以通过<code>&lt;script&gt;</code>标签的<code>src</code>，里面放<code>url</code>，加载很多在线的插件。这就是用到了<code>JSONP</code>。</p>
</blockquote>
<p><strong>JSONP的实现：</strong></p>
<blockquote>
<p>比如说，客户端这样写：</p>
</blockquote>
<div><pre><code>    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>http://www.smyhvae.com/?data=name&amp;callback=myjsonp<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>上面的<code>src</code>中，<code>data=name</code>是get请求的参数，<code>myjsonp</code>是和后台约定好的函数名。
服务器端这样写：</p>
</blockquote>
<div><pre><code>  <span>myjsonp</span><span>(</span><span>{</span>
      <span>data</span><span>:</span> <span>{</span><span>}</span>

  <span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>于是，本地要求创建一个<code>myjsonp</code> 的<strong>全局函数</strong>，才能将返回的数据执行出来。</p>
</blockquote>
<p><strong>实际开发中，前端的JSONP是这样实现的：</strong></p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>

    <span>var</span> util <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>//定义方法：动态创建 script 标签</span>
    <span>/**
     * [function 在页面中注入js脚本]
     * <span>@param</span>  <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span> <span>url</span>     [description]
     * <span>@param</span>  <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span> <span>charset</span> [description]
     * <span>@return</span> <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span>         [description]
     */</span>
    util<span>.</span><span>createScript</span> <span>=</span> <span>function</span> <span>(</span><span>url<span>,</span> charset</span><span>)</span> <span>{</span>
        <span>var</span> script <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'script'</span><span>)</span><span>;</span>
        script<span>.</span><span>setAttribute</span><span>(</span><span>'type'</span><span>,</span> <span>'text/javascript'</span><span>)</span><span>;</span>
        charset <span>&amp;&amp;</span> script<span>.</span><span>setAttribute</span><span>(</span><span>'charset'</span><span>,</span> charset<span>)</span><span>;</span>
        script<span>.</span><span>setAttribute</span><span>(</span><span>'src'</span><span>,</span> url<span>)</span><span>;</span>
        script<span>.</span>async <span>=</span> <span>true</span><span>;</span>
        <span>return</span> script<span>;</span>
    <span>}</span><span>;</span>


    <span>/**
     * [function 处理jsonp]
     * <span>@param</span>  <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span> <span>url</span>      [description]
     * <span>@param</span>  <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span> <span>onsucess</span> [description]
     * <span>@param</span>  <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span> <span>onerror</span>  [description]
     * <span>@param</span>  <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span> <span>charset</span>  [description]
     * <span>@return</span> <span><span>{</span><span>[</span>type<span>]</span><span>}</span></span>          [description]
     */</span>
    util<span>.</span><span>jsonp</span> <span>=</span> <span>function</span> <span>(</span><span>url<span>,</span> onsuccess<span>,</span> onerror<span>,</span> charset</span><span>)</span> <span>{</span>
        <span>var</span> callbackName <span>=</span> util<span>.</span><span>getName</span><span>(</span><span>'tt_player'</span><span>)</span><span>;</span> <span>//事先约定好的 函数名</span>
        window<span>[</span>callbackName<span>]</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>      <span>//根据回调名称注册一个全局的函数</span>
            <span>if</span> <span>(</span>onsuccess <span>&amp;&amp;</span> util<span>.</span><span>isFunction</span><span>(</span>onsuccess<span>)</span><span>)</span> <span>{</span>
                <span>onsuccess</span><span>(</span>arguments<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        <span>var</span> script <span>=</span> util<span>.</span><span>createScript</span><span>(</span>url <span>+</span> <span>'&amp;callback='</span> <span>+</span> callbackName<span>,</span> charset<span>)</span><span>;</span>   <span>//动态创建一个script标签</span>
        script<span>.</span>onload <span>=</span> script<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>   <span>//监听加载成功的事件，获取数据</span>
            <span>if</span> <span>(</span><span>!</span>script<span>.</span>readyState <span>||</span> <span><span>/</span><span>loaded|complete</span><span>/</span></span><span>.</span><span>test</span><span>(</span>script<span>.</span>readyState<span>)</span><span>)</span> <span>{</span>
                script<span>.</span>onload <span>=</span> script<span>.</span>onreadystatechange <span>=</span> <span>null</span><span>;</span>
                <span>// 移除该script的 DOM 对象</span>
                <span>if</span> <span>(</span>script<span>.</span>parentNode<span>)</span> <span>{</span>
                    script<span>.</span>parentNode<span>.</span><span>removeChild</span><span>(</span>script<span>)</span><span>;</span>
                <span>}</span>
                <span>// 删除函数或变量</span>
                window<span>[</span>callbackName<span>]</span> <span>=</span> <span>null</span><span>;</span>  <span>//最后不要忘了删除</span>
            <span>}</span>
        <span>}</span><span>;</span>
        script<span>.</span><span>onerror</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>onerror <span>&amp;&amp;</span> util<span>.</span><span>isFunction</span><span>(</span>onerror<span>)</span><span>)</span> <span>{</span>
                <span>onerror</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'head'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>appendChild</span><span>(</span>script<span>)</span><span>;</span> <span>//往html中增加这个标签，目的是把请求发送出去</span>
    <span>}</span><span>;</span>

</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_5-2-websocket" tabindex="-1"> 5.2 WebSocket</h3>
<blockquote>
<p><code>WebSocket</code>的用法如下：</p>
</blockquote>
<div><pre><code>    <span>//</span>

    <span>var</span> ws <span>=</span> <span>new</span> <span>WebSocket</span><span>(</span><span>'wss://echo.websocket.org'</span><span>)</span><span>;</span> <span>//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。</span>

    <span>//把请求发出去</span>
    ws<span>.</span><span>onopen</span> <span>=</span> <span>function</span> <span>(</span><span>evt</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'Connection open ...'</span><span>)</span><span>;</span>
        ws<span>.</span><span>send</span><span>(</span><span>'Hello WebSockets!'</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>


    <span>//对方发消息过来时，我接收</span>
    ws<span>.</span><span>onmessage</span> <span>=</span> <span>function</span> <span>(</span><span>evt</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'Received Message: '</span><span>,</span> evt<span>.</span>data<span>)</span><span>;</span>
        ws<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>

    <span>//关闭连接</span>
    ws<span>.</span><span>onclose</span> <span>=</span> <span>function</span> <span>(</span><span>evt</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'Connection closed.'</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>面试一般不会让你写这个代码，一般是考察你是否了解 <code>WebSocket</code>概念，知道有这么回事即可。</p>
</blockquote>
<h3 id="_5-3-cors" tabindex="-1"> 5.3 CORS</h3>
<blockquote>
<p><code>CORS</code> 可以理解成是<strong>既可以同步、也可以异步</strong>的Ajax。</p>
</blockquote>
<ul>
<li>fetch<code> 是一个比较新的</code>API<code>，用来实现</code>CORS`通信。用法如下：</li>
</ul>
<div><pre><code>      <span>// url（必选），options（可选）</span>
      <span>fetch</span><span>(</span><span>'/some/url/'</span><span>,</span> <span>{</span>
          <span>method</span><span>:</span> <span>'get'</span><span>,</span>
      <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>  <span>//类似于 ES6中的promise</span>

      <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
        <span>// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span>
      <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>另外，如果面试官问：“CORS为什么支持跨域的通信？”</p>
</blockquote>
<blockquote>
<p>答案：跨域时，浏览器会拦截<code>Ajax</code>请求，并在<code>http</code>头中加<code>Origin</code>。</p>
</blockquote>
<h3 id="_5-4-hash" tabindex="-1"> 5.4 Hash</h3>
<ul>
<li><code>url</code>的<code>#</code>后面的内容就叫<code>Hash</code>。<strong>Hash的改变，页面不会刷新</strong>。这就是用 <code>Hash</code> 做跨域通信的基本原理。</li>
</ul>
<blockquote>
<p>补充：<code>url</code>的<code>?</code>后面的内容叫<code>Search</code>。<code>Search</code>的改变，会导致页面刷新，因此不能做跨域通信。</p>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><strong>场景</strong>：我的页面 <code>A</code> 通过<code>iframe</code>或<code>frame</code>嵌入了跨域的页面 <code>B</code>。</p>
<blockquote>
<p>现在，我这个<code>A</code>页面想给<code>B</code>页面发消息，怎么操作呢？</p>
</blockquote>
<ol>
<li>首先，在我的<code>A</code>页面中：</li>
</ol>
<div><pre><code>    <span>//伪代码</span>
    <span>var</span> <span>B</span> <span>=</span> document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'iframe'</span><span>)</span><span>;</span>
    <span>B</span><span>.</span>src <span>=</span> <span>B</span><span>.</span>src <span>+</span> <span>'#'</span> <span>+</span> <span>'jsonString'</span><span>;</span>  <span>//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ol start="2">
<li>然后，在<code>B</code>页面中：</li>
</ol>
<div><pre><code>    <span>// B中的伪代码</span>
    window<span>.</span><span>onhashchange</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>  <span>//通过onhashchange方法监听，url中的 hash 是否发生变化</span>
        <span>var</span> data <span>=</span> window<span>.</span>location<span>.</span>hash<span>;</span>
    <span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="_5-5-postmessage-方法" tabindex="-1"> 5.5 postMessage()方法</h3>
<blockquote>
<p><code>H5</code>中新增的`postMessage()``方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。</p>
</blockquote>
<p><strong>场景</strong>：窗口 A (<code>http:A.com</code>)向跨域的窗口 B (<code>http:B.com</code>)发送信息。步骤如下</p>
<ol>
<li>在<code>A</code>窗口中操作如下：向<code>B</code>窗口发送数据：</li>
</ol>
<div><pre><code>	<span>// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span>
 	Bwindow<span>.</span><span>postMessage</span><span>(</span><span>'data'</span><span>,</span> <span>'http://B.com'</span><span>)</span><span>;</span> <span>//这里强调的是B窗口里的window对象</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ol start="2">
<li>在<code>B</code>窗口中操作如下：</li>
</ol>
<div><pre><code>    <span>// 在窗口B中监听 message 事件</span>
    Awindow<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span> <span>(</span><span>event</span><span>)</span> <span>{</span>   <span>//这里强调的是A窗口里的window对象</span>
        console<span>.</span><span>log</span><span>(</span>event<span>.</span>origin<span>)</span><span>;</span>  <span>//获取 ：url。这里指：http://A.com</span>
        console<span>.</span><span>log</span><span>(</span>event<span>.</span>source<span>)</span><span>;</span>  <span>//获取：A window对象</span>
        console<span>.</span><span>log</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>    <span>//获取传过来的数据</span>
    <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180307_1443.png" type="image/png"/>
    </item>
    <item>
      <title>数据结构</title>
      <link>https://0808200.xyz/Interview/base/data-structure.html</link>
      <guid>https://0808200.xyz/Interview/base/data-structure.html</guid>
      <source url="https://0808200.xyz/rss.xml">数据结构</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>栈和队列的区别?</strong></p>
<ul>
<li>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</li>
<li>队列先进先出，栈先进后出。</li>
<li>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</li>
</ul>
<p><strong>栈和堆的区别？</strong></p>
<ul>
<li>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</li>
<li>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</li>
<li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li>
<li>栈（数据结构）：一种先进后出的数据结构</li>
</ul>
<p><strong>快速 排序的思想并实现一个快排？</strong></p>
<p>&quot;快速排序&quot;的思想很简单，整个排序过程只需要三步：</p>
<ul>
<li>（1）在数据集之中，找一个基准点</li>
<li>（2）建立两个数组，分别存储左边和右边的数组</li>
<li>（3）利用递归进行下次比较</li>
</ul>
<div><pre><code><span>function</span> <span>quickSort</span><span>(</span><span>arr</span><span>)</span><span>{</span>
    <span>if</span><span>(</span>arr<span>.</span>length<span>&lt;=</span><span>1</span><span>)</span><span>{</span>
        <span>return</span> arr<span>;</span><span>//如果数组只有一个数，就直接返回；</span>
    <span>}</span>

    <span>var</span> num <span>=</span> Math<span>.</span><span>floor</span><span>(</span>arr<span>.</span>length<span>/</span><span>2</span><span>)</span><span>;</span><span>//找到中间数的索引值，如果是浮点数，则向下取整</span>

    <span>var</span> numValue <span>=</span> arr<span>.</span><span>splice</span><span>(</span>num<span>,</span><span>1</span><span>)</span><span>;</span><span>//找到中间数的值</span>
    <span>var</span> left <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>var</span> right <span>=</span> <span>[</span><span>]</span><span>;</span>

    <span>for</span><span>(</span><span>var</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>arr<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
        <span>if</span><span>(</span>arr<span>[</span>i<span>]</span><span>&lt;</span>numValue<span>)</span><span>{</span>
            left<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span><span>//基准点的左边的数传到左边数组</span>
        <span>}</span>
        <span>else</span><span>{</span>
           right<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span><span>//基准点的右边的数传到右边数组</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>quickSort</span><span>(</span>left<span>)</span><span>.</span><span>concat</span><span>(</span><span>[</span>numValue<span>]</span><span>,</span><span>quickSort</span><span>(</span>right<span>)</span><span>)</span><span>;</span><span>//递归不断重复比较</span>
<span>}</span>

<span>alert</span><span>(</span><span>quickSort</span><span>(</span><span>[</span><span>32</span><span>,</span><span>45</span><span>,</span><span>37</span><span>,</span><span>16</span><span>,</span><span>2</span><span>,</span><span>87</span><span>]</span><span>)</span><span>)</span><span>;</span><span>//弹出“2,16,32,37,45,87”</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>数据库</title>
      <link>https://0808200.xyz/Interview/base/dataBase.html</link>
      <guid>https://0808200.xyz/Interview/base/dataBase.html</guid>
      <source url="https://0808200.xyz/rss.xml">数据库</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>说说mongoDB和MySQL的区别</strong></p>
<ul>
<li><code>MySQL</code>是传统的关系型数据库，MongoDB则是非关系型数据库</li>
<li><code>mongodb</code>以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。</li>
<li>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： ①弱一致性（最终一致），更能保证用户的访问速度： ②文档结构的存储方式，能够更便捷的获取数据</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>DOM事件总结</title>
      <link>https://0808200.xyz/Interview/base/dom_events_summary.html</link>
      <guid>https://0808200.xyz/Interview/base/dom_events_summary.html</guid>
      <source url="https://0808200.xyz/rss.xml">DOM事件总结</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>知识点主要包括以下几个方面：</strong></p>
<ul>
<li>基本概念：<code>DOM</code>事件的级别</li>
</ul>
<blockquote>
<p>面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用<code>DOM2</code> ....”。</p>
</blockquote>
<ul>
<li><code>DOM</code>事件模型、<code>DOM</code>事件流</li>
</ul>
<blockquote>
<p>面试官如果问你“<strong>DOM事件模型</strong>”，你不一定知道怎么回事。其实说的就是<strong>捕获和冒泡</strong>。</p>
</blockquote>
<p><strong>DOM事件流</strong>，指的是事件传递的<strong>三个阶段</strong>。</p>
<ul>
<li>描述<code>DOM</code>事件捕获的具体流程</li>
</ul>
<blockquote>
<p>讲的是事件的传递顺序。参数为<code>false</code>（默认）、参数为<code>true</code>，各自代表事件在什么阶段触发。</p>
</blockquote>
<p>能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。</p>
<ul>
<li><code>Event</code>对象的常见应用（<code>Event</code>的常用<code>api</code>方法）</li>
</ul>
<blockquote>
<p><code>DOM</code>事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，<code>Event</code>对象是非常重要的。</p>
</blockquote>
<p><strong>自定义事件（非常重要）</strong></p>
<blockquote>
<p>一般人可以讲出事件和注册事件，但是如果让你讲<strong>自定义事件</strong>，能知道的人，就更少了。</p>
</blockquote>
<p><strong>DOM事件的级别</strong></p>
<blockquote>
<p><code>DOM</code>事件的级别，准确来说，是<strong>DOM标准</strong>定义的级别。包括：</p>
</blockquote>
<p><strong>DOM0的写法：</strong></p>
<div><pre><code>  element<span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>

  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>上面的代码是在 <code>js</code> 中的写法；如果要在<code>html</code>中写，写法是：在<code>onclick</code>属性中，加 <code>js</code> 语句。</p>
</blockquote>
<p><strong>DOM2的写法：</strong></p>
<div><pre><code>  element<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>

  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>【重要】上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。如果不写，则默认为false。</p>
</blockquote>
<p><strong>DOM3的写法：</strong></p>
<div><pre><code>    element<span>.</span><span>addEventListener</span><span>(</span><span>'keyup'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>

    <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p><code>DOM3</code>中，增加了很多事件类型，比如鼠标事件、键盘事件等。</p>
</blockquote>
<blockquote>
<p>PS：为何事件没有<code>DOM1</code>的写法呢？因为，<code>DOM1</code>标准制定的时候，没有涉及与事件相关的内容。</p>
</blockquote>
<p><strong>总结</strong>：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。</p>
<p><strong>DOM事件模型</strong></p>
<blockquote>
<p><code>DOM</code>事件模型讲的就是<strong>捕获和冒泡</strong>，一般人都能回答出来。</p>
</blockquote>
<ul>
<li>捕获：从上往下。</li>
<li>冒泡：从下（目标元素）往上。</li>
</ul>
<p><strong>DOM事件流</strong></p>
<blockquote>
<p><code>DOM</code>事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p>
</blockquote>
<p><strong>完整的事件流，分三个阶段：</strong></p>
<ol>
<li>捕获：从 <code>window</code> 对象传到 目标元素。</li>
<li>目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</li>
<li>冒泡：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</li>
</ol>
<p><img src="http://img.smyhvae.com/20180306_1058.png" alt=""></p>
<p><img src="http://img.smyhvae.com/20180204_1218.jpg" alt=""></p>
<p><strong>描述DOM事件捕获的具体流程</strong></p>
<blockquote>
<p>很少有人能说完整。</p>
</blockquote>
<p><strong>捕获的流程</strong></p>
<p><img src="http://img.smyhvae.com/20180306_1103.png" alt=""></p>
<p><strong>说明</strong>：捕获阶段，事件依次传递的顺序是：<code>window</code> --&gt; <code>document</code> --&gt; <code>html</code>--&gt; <code>body</code> --&gt; 父元素、子元素、目标元素。</p>
<ul>
<li>PS1：第一个接收到事件的对象是 <strong>window</strong>（有人会说<code>body</code>，有人会说<code>html</code>，这都是错误的）。</li>
<li>PS2：<code>JS</code>中涉及到<code>DOM</code>对象时，有两个对象最常用：<code>window</code>、<code>doucument</code>。它们俩也是最先获取到事件的。</li>
</ul>
<p>代码如下：</p>
<div><pre><code>    window<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"捕获 window"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>

    document<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"捕获 document"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>

    document<span>.</span>documentElement<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"捕获 html"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>

    document<span>.</span>body<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"捕获 body"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>

    fatherBox<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"捕获 father"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>

    childBox<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"捕获 child"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>true</span><span>)</span><span>;</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>补充一个知识点：</strong></p>
<blockquote>
<p>在 <code>js</code>中：</p>
</blockquote>
<ul>
<li>如果想获取 <code>body</code> 节点，方法是：<code>document.body</code>；</li>
<li>但是，如果想获取 <code>html</code>节点，方法是<code>document.documentElement</code>。</li>
</ul>
<p><strong>冒泡的流程</strong></p>
<blockquote>
<p>与捕获的流程相反</p>
</blockquote>
<p><strong>Event对象的常见 api 方法</strong></p>
<blockquote>
<p>用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过<code>Event</code>对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：</p>
</blockquote>
<p><strong>方法一</strong></p>
<div><pre><code>    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>解释：阻止默认事件。</li>
<li>比如，已知<code>&lt;a&gt;</code>标签绑定了click事件，此时，如果给<code>&lt;a&gt;</code>设置了这个方法，就阻止了链接的默认跳转。</li>
</ul>
<p><strong>方法二：阻止冒泡</strong></p>
<blockquote>
<p>这个在业务中很常见。</p>
</blockquote>
<blockquote>
<p>有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件<code>A</code>，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件<code>A</code>。这个时候，就要用到阻止冒泡了。</p>
</blockquote>
<blockquote>
<p><code>w3c</code>的方法：（火狐、谷歌、<code>IE11</code>）</p>
</blockquote>
<div><pre><code>    event<span>.</span><span>stopPropagation</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p><code>IE10</code>以下则是：</p>
</blockquote>
<div><pre><code>	event<span>.</span>cancelBubble <span>=</span> <span>true</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>兼容代码如下：</p>
</blockquote>
<div><pre><code>   box3<span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>event</span><span>)</span> <span>{</span>

        <span>alert</span><span>(</span><span>"child"</span><span>)</span><span>;</span>

        <span>//阻止冒泡</span>
        event <span>=</span> event <span>||</span> window<span>.</span>event<span>;</span>

        <span>if</span> <span>(</span>event <span>&amp;&amp;</span> event<span>.</span>stopPropagation<span>)</span> <span>{</span>
            event<span>.</span><span>stopPropagation</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            event<span>.</span>cancelBubble <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>上方代码中，我们对<code>box3</code>进行了阻止冒泡，产生的效果是：事件不会继续传递到 <code>father</code>、<code>grandfather</code>、<code>body</code>了。</p>
</blockquote>
<p><strong>方法三：设置事件优先级</strong></p>
<div><pre><code>    event<span>.</span><span>stopImmediatePropagation</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个方法比较长，一般人没听说过。解释如下：</p>
<blockquote>
<p>比如说，我用<code>addEventListener</code>给某按钮同时注册了事件<code>A</code>、事件<code>B</code>。此时，如果我单击按钮，就会依次执行事件A和事件<code>B</code>。现在要求：单击按钮时，只执行事件A，不执行事件<code>B</code>。该怎么做呢？这是时候，就可以用到<code>stopImmediatePropagation</code>方法了。做法是：在事件A的响应函数中加入这句话。</p>
</blockquote>
<blockquote>
<p>大家要记住 <code>event</code> 有这个方法。</p>
</blockquote>
<p><strong>属性4、属性5（事件委托中用到）</strong></p>
<div><pre><code>
    event<span>.</span>currentTarget   <span>//当前所绑定的事件对象。在事件委托中，指的是【父元素】。</span>

    event<span>.</span>target  <span>//当前被点击的元素。在事件委托中，指的是【子元素】。</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面这两个属性，在事件委托中经常用到。</p>
<blockquote>
<p><strong>总结</strong>：上面这几项，非常重要，但是容易弄混淆。</p>
</blockquote>
<p><strong>自定义事件</strong></p>
<blockquote>
<p>自定义事件的代码如下：</p>
</blockquote>
<div><pre><code>    <span>var</span> myEvent <span>=</span> <span>new</span> <span>Event</span><span>(</span><span>'clickTest'</span><span>)</span><span>;</span>
    element<span>.</span><span>addEventListener</span><span>(</span><span>'clickTest'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'smyhvae'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

	<span>//元素注册事件</span>
    element<span>.</span><span>dispatchEvent</span><span>(</span>myEvent<span>)</span><span>;</span> <span>//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：</p>
</blockquote>
<div><pre><code>    <span>var</span> myEvent <span>=</span> <span>new</span> <span>Event</span><span>(</span><span>'clickTest'</span><span>)</span><span>;</span>

    element<span>.</span><span>addEventListener</span><span>(</span><span>'clickTest'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'smyhvae'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

    <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        element<span>.</span><span>dispatchEvent</span><span>(</span>myEvent<span>)</span><span>;</span> <span>//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180306_1058.png" type="image/png"/>
    </item>
    <item>
      <title>HTTP 协议</title>
      <link>https://0808200.xyz/Interview/base/http_protocol.html</link>
      <guid>https://0808200.xyz/Interview/base/http_protocol.html</guid>
      <source url="https://0808200.xyz/rss.xml">HTTP 协议</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>一面中，如果有笔试，考HTTP协议的可能性较大。</p>
<h2 id="_1-前言" tabindex="-1"> 1. 前言</h2>
<p>一面要讲的内容：</p>
<ul>
<li><code>HTTP</code>协议的主要特点</li>
<li><code>HTTP</code>报文的组成部分</li>
<li><code>HTTP</code>方法</li>
<li><code>get</code> 和 <code>post</code>的区别</li>
<li><code>HTTP</code>状态码</li>
<li>什么是持久连接</li>
<li>什么是管线化</li>
</ul>
<p>二面要讲的内容；</p>
<ul>
<li>缓存</li>
<li><code>CSRF</code>攻击</li>
</ul>
<h2 id="_2-http协议的主要特点" tabindex="-1"> 2. HTTP协议的主要特点</h2>
<ul>
<li>简单快速</li>
<li>灵活</li>
<li><strong>无连接</strong></li>
<li><strong>无状态</strong></li>
</ul>
<blockquote>
<p>通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：<strong>无连接、无状态</strong>。</p>
</blockquote>
<p>我们分别来解释一下。</p>
<h3 id="_2-1-简单快速" tabindex="-1"> 2.1 简单快速</h3>
<blockquote>
<p><strong>简单</strong>：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在<code>http</code>协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。</p>
</blockquote>
<h3 id="_2-2-灵活" tabindex="-1"> 2.2 灵活</h3>
<blockquote>
<p><code>http</code>协议的头部有一个<code>数据类型</code>，通过<code>http</code>协议，就可以完成不同数据类型的传输。</p>
</blockquote>
<h3 id="_2-3-无连接" tabindex="-1"> 2.3 无连接</h3>
<blockquote>
<p>连接一次，就会断开，不会继续保持连接。</p>
</blockquote>
<h3 id="_2-4-无状态" tabindex="-1"> 2.4 无状态</h3>
<blockquote>
<p>客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，<strong>服务器端并没有记住之前的状态</strong>，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。</p>
</blockquote>
<blockquote>
<p>有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 <code>session</code>）做到的，并不是<code>http</code>协议能做到的。</p>
</blockquote>
<h2 id="_3-http报文的组成部分" tabindex="-1"> 3 HTTP报文的组成部分</h2>
<p><img src="http://img.smyhvae.com/20180306_1400.png" alt=""></p>
<blockquote>
<p>在回答此问题时，我们要按照顺序回答：</p>
</blockquote>
<ul>
<li>先回答的是，<code>http</code>报文包括：<strong>请求报文</strong>和<strong>响应报文</strong>。</li>
<li>再回答的是，每个报文包含什么部分。</li>
<li>最后回答，每个部分的内容是什么</li>
</ul>
<h3 id="_3-1-请求报文包括" tabindex="-1"> 3.1 请求报文包括：</h3>
<p><img src="http://img.smyhvae.com/20180228_1505.jpg" alt=""></p>
<ul>
<li>请求行：包括请求方法、请求的<code>url</code>、<code>http</code>协议及版本。</li>
<li>请求头：一大堆的键值对。</li>
<li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体</li>
<li>请求体：数据部分。</li>
</ul>
<h3 id="_3-2-响应报文包括" tabindex="-1"> 3.2 响应报文包括：</h3>
<p><img src="http://img.smyhvae.com/20180228_1510.jpg" alt=""></p>
<ul>
<li>状态行：<code>http</code>协议及版本、状态码及状态描述。</li>
<li>响应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h2 id="_4-http方法" tabindex="-1"> 4 HTTP方法</h2>
<p>包括：</p>
<ul>
<li><code>GET</code>：获取资源</li>
<li><code>POST</code>：传输资源</li>
<li><code>put</code>：更新资源</li>
<li><code>DELETE</code>：删除资源</li>
<li><code>HEAD</code>：获得报文首部</li>
</ul>
<blockquote>
<p><code>HTTP</code>方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p>
</blockquote>
<ul>
<li><code>get</code> <code>和 </code>post` 比较常见。</li>
<li><code>put</code> 和 <code>delete</code> 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</li>
<li><code>head</code> 可能偶尔用的到。</li>
</ul>
<h2 id="_5-get-和-post的区别" tabindex="-1"> 5 get 和 post的区别</h2>
<p><img src="http://img.smyhvae.com/20180306_1415.png" alt=""></p>
<ul>
<li>区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。</li>
<li>有一点要强调，<strong>get是相对不隐私的，而post是相对隐私的</strong>。</li>
</ul>
<blockquote>
<p>我们大概要记住以下几点：</p>
</blockquote>
<ol>
<li>浏览器在回退时，<code>get</code> <strong>不会重新请求</strong>，但是<code>post</code>会重新请求。【重要】</li>
<li><code>get</code>请求会被浏览器<strong>主动缓存</strong>，而<code>post</code>不会。【重要】</li>
<li><code>get</code>请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而<code>post</code>不会。做业务时要注意。为了防止<code>CSRF</code>攻击，很多公司把<code>get</code>统一改成了<code>post</code></li>
<li><code>get</code>请求在<code>url</code>中<code>传递的参数有大小限制，基本是</code>2kb`，不同的浏览器略有不同。而post没有注意。</li>
<li><code>get</code>的参数是直接暴露在<code>url</code>上的，相对不安全。而<code>post</code>是放在请求体中的。</li>
</ol>
<h2 id="_6-http状态码" tabindex="-1"> 6 http状态码</h2>
<blockquote>
<p><code>http</code>状态码分类：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_1430.png" alt=""></p>
<blockquote>
<p>常见的<code>http</code>状态码：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180306_1431.png" alt=""></p>
<p><strong>部分解释</strong>：</p>
<ul>
<li><code>206</code>的应用：<code>range</code>指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到<code>206</code>。</li>
<li><code>301</code>：重定向（永久）。</li>
<li><code>302</code>：重定向（临时）。</li>
<li><code>304</code>：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。</li>
</ul>
<p><img src="http://img.smyhvae.com/20180306_1440.png" alt=""></p>
<ul>
<li><code>400</code>和<code>401</code>用的不多,未授权。<code>403</code>指的是请求被拒绝。<code>404</code>指的是资源不存在。</li>
</ul>
<h2 id="_7-持久链接-http长连接" tabindex="-1"> 7 持久链接/http长连接</h2>
<blockquote>
<p>如果你能答出持久链接，这是面试官很想知道的一个点。</p>
</blockquote>
<ul>
<li><strong>轮询</strong>：<code>http1.0</code>中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如<code>1</code>秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</li>
<li><strong>长连接</strong>：<code>HTTP1.1</code>中，通过使用<code>Connection:keep-alive</code>进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</li>
</ul>
<blockquote>
<p>注意，<code>HTTP 1.1</code>默认进行持久连接。在一次 <code>TCP</code> 连接中可以完成多个 <code>HTTP</code> 请求，但是对<strong>每个请求仍然要单独发 header</strong>，<code>Keep-Alive</code>不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如<code>Apache</code>）中设定这个时间。</p>
</blockquote>
<h2 id="_8-长连接中的管线化" tabindex="-1"> 8 长连接中的管线化</h2>
<blockquote>
<p>如果能答出<strong>管线化</strong>，则属于加分项。</p>
</blockquote>
<h3 id="_8-1-管线化的原理" tabindex="-1"> 8.1 管线化的原理</h3>
<blockquote>
<p>长连接时，<strong>默认</strong>的请求这样的：</p>
</blockquote>
<div><pre><code>	请求1 --> 响应1 -->请求2 --> 响应2 --> 请求3 --> 响应3
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。</p>
</blockquote>
<h3 id="_8-2-管线化的注意事项" tabindex="-1"> 8.2 管线化的注意事项</h3>
<blockquote>
<p>面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180306_1400.png" type="image/png"/>
    </item>
    <item>
      <title>JQuery 基础</title>
      <link>https://0808200.xyz/Interview/base/jQuery.html</link>
      <guid>https://0808200.xyz/Interview/base/jQuery.html</guid>
      <source url="https://0808200.xyz/rss.xml">JQuery 基础</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>你觉得jQuery或zepto源码有哪些写的好的地方</strong></p>
<ul>
<li>jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链</li>
</ul>
<div><pre><code> (function( window, undefined ) {

         //用一个函数域包起来，就是所谓的沙箱

         //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局

         //把当前沙箱需要的外部变量通过函数参数引入进来

         //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数

        window.jQuery = window.$ = jQuery;

    })( window );
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法</li>
<li>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度</li>
<li>jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>
</ul>
<p><strong>jQuery 的实现原理？</strong></p>
<ul>
<li>
<p><code>(function(window, undefined) {})(window);</code></p>
</li>
<li>
<p>jQuery 利用 JS 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题</p>
</li>
<li>
<p><code>window.jQuery = window.$ = jQuery;</code></p>
</li>
<li>
<p>在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量</p>
</li>
</ul>
<p><strong>jQuery.fn 的 init 方法返回的 this 指的是什么对象？ 为什么要返回 this？</strong></p>
<ul>
<li>jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象</li>
<li>用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法</li>
</ul>
<p><strong>jQuery.extend 与 jQuery.fn.extend 的区别？</strong></p>
<ul>
<li>$.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个方法</li>
<li>$.extend(object); // 为jQuery添加“静态方法”（工具方法）</li>
</ul>
<div><pre><code>$.extend({
　　min: function(a, b) { return a &lt; b ? a : b; },
　　max: function(a, b) { return a > b ? a : b; }
});
$.min(2,3); //  2
$.max(4,5); //  5
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>$.extend([true,] targetObject, object1[, object2]); // 对targt对象进行扩展</li>
</ul>
<div><pre><code>var settings = {validate:false, limit:5};
var options = {validate:true, name:"bar"};
$.extend(settings, options);  // 注意：不支持第一个参数传 false
// settings == {validate:true, limit:5, name:"bar"}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>$.fn.extend(json); // 为jQuery添加“成员函数”（实例方法）</li>
</ul>
<div><pre><code>
$.fn.extend({
   alertValue: function() {
      $(this).click(function(){
        alert($(this).val());
      });
   }
});

$("#email").alertValue();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</strong></p>
<ul>
<li>
<p>浅拷贝（只复制一份原始对象的引用）
<code>var newObject = $.extend({}, oldObject);</code></p>
</li>
<li>
<p>深拷贝（对原始对象属性所引用的对象进行进行递归拷贝）
<code>var newObject = $.extend(true, {}, oldObject);</code></p>
</li>
</ul>
<p><strong>jQuery 的队列是如何实现的？队列可以用在哪些地方？</strong></p>
<ul>
<li>jQuery 核心中有一组队列控制方法，由 queue()/dequeue()/clearQueue() 三个方法组成。</li>
<li>主要应用于 animate()，ajax，其他要按时间顺序执行的事件中</li>
</ul>
<div><pre><code><span>var</span> <span>func1</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>'事件1'</span><span>)</span><span>;</span><span>}</span>
<span>var</span> <span>func2</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>'事件2'</span><span>)</span><span>;</span><span>}</span>
<span>var</span> <span>func3</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>'事件3'</span><span>)</span><span>;</span><span>}</span>
<span>var</span> <span>func4</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>'事件4'</span><span>)</span><span>;</span><span>}</span>

<span>// 入栈队列事件</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>queue</span><span>(</span><span>"queue1"</span><span>,</span> func1<span>)</span><span>;</span>  <span>// push func1 to queue1</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>queue</span><span>(</span><span>"queue1"</span><span>,</span> func2<span>)</span><span>;</span>  <span>// push func2 to queue1</span>

<span>// 替换队列事件</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>queue</span><span>(</span><span>"queue1"</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>  <span>// delete queue1 with empty array</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>queue</span><span>(</span><span>"queue1"</span><span>,</span> <span>[</span>func3<span>,</span> func4<span>]</span><span>)</span><span>;</span>  <span>// replace queue1</span>

<span>// 获取队列事件（返回一个函数数组）</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>queue</span><span>(</span><span>"queue1"</span><span>)</span><span>;</span>  <span>// [func3(), func4()]</span>

<span>// 出栈队列事件并执行</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>dequeue</span><span>(</span><span>"queue1"</span><span>)</span><span>;</span> <span>// return func3 and do func3</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>dequeue</span><span>(</span><span>"queue1"</span><span>)</span><span>;</span> <span>// return func4 and do func4</span>

<span>// 清空整个队列</span>
<span>$</span><span>(</span><span>'#box'</span><span>)</span><span>.</span><span>clearQueue</span><span>(</span><span>"queue1"</span><span>)</span><span>;</span> <span>// delete queue1 with clearQueue</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>jQuery 中的 bind(), live(), delegate(), on()的区别？</strong></p>
<ul>
<li>bind 直接绑定在目标元素上</li>
<li>live 通过冒泡传播事件，默认document上，支持动态数据</li>
<li>delegate 更精确的小范围使用事件代理，性能优于 live</li>
<li>on 是最新的1.9版本整合了之前的三种方式的新事件绑定机制</li>
</ul>
<p><strong>是否知道自定义事件？ jQuery 里的 fire 函数是什么意思，什么时候用？</strong></p>
<ul>
<li>事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅”</li>
<li>JS 原生支持自定义事件，示例：</li>
</ul>
<div><pre><code>  document<span>.</span><span>createEvent</span><span>(</span>type<span>)</span><span>;</span> <span>// 创建事件</span>
  event<span>.</span><span>initEvent</span><span>(</span>eventType<span>,</span> canBubble<span>,</span> prevent<span>)</span><span>;</span> <span>// 初始化事件</span>
  target<span>.</span><span>addEventListener</span><span>(</span><span>'dataavailable'</span><span>,</span> handler<span>,</span> <span>false</span><span>)</span><span>;</span> <span>// 监听事件</span>
  target<span>.</span><span>dispatchEvent</span><span>(</span>e<span>)</span><span>;</span>  <span>// 触发事件</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>jQuery 里的 fire 函数用于调用 jQuery 自定义事件列表中的事件</li>
</ul>
<p><strong>jQuery 通过哪个方法和 Sizzle 选择器结合的？</strong></p>
<ul>
<li>Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的父节点</li>
<li>jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合</li>
</ul>
<p><strong>jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来？</strong></p>
<div><pre><code><span>// 通过原生 JSON.stringify/JSON.parse 扩展 jQuery 实现</span>
 $<span>.</span><span>array2json</span> <span>=</span> <span>function</span><span>(</span><span>array</span><span>)</span> <span>{</span>
    <span>return</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>array<span>)</span><span>;</span>
 <span>}</span>

 $<span>.</span><span>json2array</span> <span>=</span> <span>function</span><span>(</span><span>array</span><span>)</span> <span>{</span>
    <span>// $.parseJSON(array); // 3.0 开始，已过时</span>
    <span>return</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>array<span>)</span><span>;</span>
 <span>}</span>

 <span>// 调用</span>
 <span>var</span> json <span>=</span> $<span>.</span><span>array2json</span><span>(</span><span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span><span>)</span><span>;</span>
 <span>var</span> array <span>=</span> $<span>.</span><span>json2array</span><span>(</span>json<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>jQuery 一个对象可以同时绑定多个事件，这是如何实现的？</strong></p>
<div><pre><code>  <span>$</span><span>(</span><span>"#btn"</span><span>)</span><span>.</span><span>on</span><span>(</span><span>"mouseover mouseout"</span><span>,</span> func<span>)</span><span>;</span>

  <span>$</span><span>(</span><span>"#btn"</span><span>)</span><span>.</span><span>on</span><span>(</span><span>{</span>
      <span>mouseover</span><span>:</span> func1<span>,</span>
      <span>mouseout</span><span>:</span> func2<span>,</span>
      <span>click</span><span>:</span> func3
  <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>针对 jQuery 的优化方法？</strong></p>
<ul>
<li>缓存频繁操作DOM对象</li>
<li>尽量使用id选择器代替class选择器</li>
<li>总是从#id选择器来继承</li>
<li>尽量使用链式操作</li>
<li>使用时间委托 on 绑定事件</li>
<li>采用jQuery的内部函数data()来存储数据</li>
<li>使用最新版本的 jQuery</li>
</ul>
<p><strong>jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢?</strong></p>
<ul>
<li>在触发元素上的事件设置为延迟处理：使用 JS 原生 setTimeout 方法</li>
<li>在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：$('.tab').stop().slideUp();</li>
</ul>
<p><strong>jQuery UI 如何自定义组件？</strong></p>
<ul>
<li>通过向 $.widget() 传递组件名称和一个原型对象来完成</li>
<li><code>$.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype);</code></li>
</ul>
<p><strong>jQuery 与 jQuery UI、jQuery Mobile 区别？</strong></p>
<ul>
<li>
<p>jQuery 是 JS 库，兼容各种PC浏览器，主要用作更方便地处理 DOM、事件、动画、AJAX</p>
</li>
<li>
<p>jQuery UI 是建立在 jQuery 库上的一组用户界面交互、特效、小部件及主题</p>
</li>
<li>
<p>jQuery Mobile 以 jQuery 为基础，用于创建“移动Web应用”的框架</p>
</li>
</ul>
<p><strong>jQuery 和 Zepto 的区别？ 各自的使用场景？</strong></p>
<ul>
<li>jQuery 主要目标是PC的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 jQuery Mobile</li>
<li>Zepto 从一开始就定位移动设备，相对更轻量级。它的 API 基本兼容 jQuery，但对PC浏览器兼容不理想</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器存储</title>
      <link>https://0808200.xyz/Interview/base/localStorage.html</link>
      <guid>https://0808200.xyz/Interview/base/localStorage.html</guid>
      <source url="https://0808200.xyz/rss.xml">浏览器存储</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>浏览器本地存储</strong></p>
<ul>
<li>在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage</li>
<li>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage</li>
<li>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</li>
<li>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>
</ul>
<p><strong>web storage和cookie的区别</strong></p>
<ul>
<li>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用</li>
<li>除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</li>
<li>但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</li>
<li>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage</li>
<li>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</li>
</ul>
<p><strong>cookie 和session 的区别：</strong></p>
<ul>
<li>
<p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
</li>
<li>
<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
<ul>
<li>考虑到安全应当使用session。</li>
</ul>
</li>
<li>
<p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</p>
<ul>
<li>考虑到减轻服务器性能方面，应当使用COOKIE。</li>
</ul>
</li>
<li>
<p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
</li>
<li>
<p>5、所以个人建议：</p>
<ul>
<li>
<p>将登陆信息等重要信息存放为SESSION</p>
</li>
<li>
<p>其他信息如果需要保留，可以放在COOKIE中</p>
</li>
</ul>
</li>
</ul>
<p><strong>描述 cookies、sessionStorage 和 localStorage 的区别？</strong></p>
<ul>
<li>
<p>与服务器交互：</p>
<ul>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）</li>
<li>cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li>
</ul>
</li>
<li>
<p>存储大小：</p>
</li>
</ul>
<ul>
<li>cookie 数据根据不同浏览器限制，大小一般不能超过 4k</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
<ul>
<li>有期时间：
<ul>
<li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li>sessionStorage  数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie           设置的cookie过期时间之前一直有效，与浏览器是否关闭无关</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>移动端</title>
      <link>https://0808200.xyz/Interview/base/mobile-terminal.html</link>
      <guid>https://0808200.xyz/Interview/base/mobile-terminal.html</guid>
      <source url="https://0808200.xyz/rss.xml">移动端</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>移动端（Android、IOS）怎么做好用户体验?</strong></p>
<ul>
<li>清晰的视觉纵线</li>
<li>信息的分组、极致的减法</li>
<li>利用选择代替输入</li>
<li>标签及文字的排布方式</li>
<li>依靠明文确认密码</li>
<li>合理的键盘利用</li>
</ul>
<p><strong>前端页面有哪三层构成，分别是什么？作用是什么？</strong></p>
<ul>
<li>结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题</li>
<li>表示层：由 CSS 负责，解决页面“如何显示内容”的问题</li>
<li>行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>面向对象：类的定义和继承的几种方式</title>
      <link>https://0808200.xyz/Interview/base/objectoriented.html</link>
      <guid>https://0808200.xyz/Interview/base/objectoriented.html</guid>
      <source url="https://0808200.xyz/rss.xml">面向对象：类的定义和继承的几种方式</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-前言" tabindex="-1"> 1 前言</h2>
<blockquote>
<p>类与实例：</p>
</blockquote>
<ul>
<li>类的声明</li>
<li>生成实例</li>
</ul>
<p><strong>类与继承：</strong></p>
<ul>
<li>如何实现继承：继承的本质就是原型链</li>
<li>继承的几种方式</li>
</ul>
<h2 id="_2-类的定义、实例化" tabindex="-1"> 2 类的定义、实例化</h2>
<h3 id="_2-1-类的定义-类的声明" tabindex="-1"> 2.1 类的定义/类的声明</h3>
<p><strong>方式一</strong>：用构造函数模拟类（传统写法）</p>
<div><pre><code>    <span>function</span> <span>Animal1</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> <span>'smyhvae'</span><span>;</span> <span>//通过this，表明这是一个构造函数</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>方式二</strong>：用 class 声明（<code>ES6</code>的写法）</p>
<div><pre><code>    <span>class</span> <span>Animal2</span> <span>{</span>
        <span>constructor</span><span>(</span><span>)</span> <span>{</span>  <span>//可以在构造函数里写属性</span>
            <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>控制台的效果：</p>
<p><img src="http://img.smyhvae.com/20180307_0957.png" alt=""></p>
<h3 id="_2-2-实例化" tabindex="-1"> 2.2 实例化</h3>
<p>类的实例化很简单，直接 <code>new</code> 出来即可。</p>
<div><pre><code>    console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Animal1</span><span>(</span><span>)</span><span>,</span><span>new</span> <span>Animal2</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//实例化。如果括号里没有参数，则括号可以省略</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><img src="http://img.smyhvae.com/20180307_1000.png" alt=""></p>
<h2 id="_3-继承的几种方式" tabindex="-1"> 3 继承的几种方式</h2>
<blockquote>
<p>继承的本质就是原型链。</p>
</blockquote>
<p><strong>继承的方式有几种？每种形式的优缺点是</strong>？这些问题必问的。其实就是考察你对原型链的掌握程度。</p>
<h3 id="_3-1-方式一-借助构造函数" tabindex="-1"> 3.1 方式一：借助构造函数</h3>
<div><pre><code>    <span>function</span> <span>Parent1</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> <span>'parent1 的属性'</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>Child1</span><span>(</span><span>)</span> <span>{</span>
        <span>Parent1</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>         <span>//【重要】此处用 call 或 apply 都行：改变 this 的指向</span>
        <span>this</span><span>.</span>type <span>=</span> <span>'child1 的属性'</span><span>;</span>
    <span>}</span>

    console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Child1</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了<code>Parent1.call(this);</code>，意思是：<strong>让Parent的构造函数在child的构造函数中执行</strong>。发生的变化是：<strong>改变this的指向</strong>，parent的实例 --&gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。</p>
</blockquote>
<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180307_1015.png" alt=""></p>
<blockquote>
<p>上方结果表明：<code>child</code>先有了 <code>parent</code> 实例的属性（继承得以实现），再有了<code>child</code> 实例的属性。</p>
</blockquote>
<p><strong>分析</strong>：</p>
<blockquote>
<p>这种方式，虽然改变了 <code>this</code> 的指向，但是，<strong>Child1 无法继承 <code>Parent1</code> 的原型</strong>。也就是说，如果我给 <code>Parent1</code> 的原型增加一个方法：</p>
</blockquote>
<div><pre><code>    <span>Parent1</span><span>.</span>prototype<span>.</span><span>say</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>上面这个方法是无法被 <code>Child1</code> 继承的。如下：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180307_1030.png" alt=""></p>
<h3 id="_3-2-方法二-通过原型链实现继承" tabindex="-1"> 3.2 方法二：通过原型链实现继承</h3>
<div><pre><code>    <span>/*
    通过原型链实现继承
     */</span>
    <span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> <span>'Parent 的属性'</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>Child</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>type <span>=</span> <span>'Child 的属性'</span><span>;</span>
    <span>}</span>

    <span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>)</span><span>;</span> <span>//【重要】</span>

    console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Child</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180307_1109.png" alt=""></p>
<blockquote>
<p>【重要】上方代码中，最重要的那行：每个函数都有<code>prototype</code>属性，于是，构造函数也有这个属性，这个属性是一个对象。现在，<strong>我们把<code>Parent</code>的实例赋值给了<code>Child</code>的<code>prototye</code></strong>，从而实现<strong>继承</strong>。此时，<code>Child</code>构造函数、<code>Parent</code>的实例、<code>Child</code>的实例构成一个三角关系。于是：</p>
</blockquote>
<ul>
<li><code>new Child.__proto__ === new Parent()</code>的结果为<code>true</code></li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li>这种继承方式，<strong>Child 可以继承 Parent 的原型</strong>，但有个缺点：</li>
</ul>
<blockquote>
<p>缺点是：<strong>如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变</strong>。</p>
</blockquote>
<p>如下：</p>
<p><img src="http://img.smyhvae.com/20180307_1123.png" alt=""></p>
<blockquote>
<p>上面的代码中， <code>child1</code>修改了<code>arr</code>属性，却发现，<code>child2</code>的<code>arr</code>属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。</p>
</blockquote>
<blockquote>
<p>造成这种缺点的原因是：<code>child1</code>和<code>child2</code>共用原型。即：<code>chi1d1.__proto__ === child2__proto__</code>是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。</p>
</blockquote>
<h3 id="_3-3-方式三-组合的方式-构造函数-原型链" tabindex="-1"> 3.3 方式三：组合的方式：构造函数 + 原型链</h3>
<p>就是把上面的两种方式组合起来：</p>
<div><pre><code>    <span>/*
    组合方式实现继承：构造函数、原型链
     */</span>
    <span>function</span> <span>Parent3</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> <span>'Parent 的属性'</span><span>;</span>
        <span>this</span><span>.</span>arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>Child3</span><span>(</span><span>)</span> <span>{</span>
        <span>Parent3</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>//【重要1】执行 parent方法</span>
        <span>this</span><span>.</span>type <span>=</span> <span>'Child 的属性'</span><span>;</span>
    <span>}</span>
    <span>Child3</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent3</span><span>(</span><span>)</span><span>;</span> <span>//【重要2】第二次执行parent方法</span>

    <span>var</span> child <span>=</span> <span>new</span> <span>Child3</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。</li>
<li>这种方式的缺点是：让父亲<code>Parent</code>的构造方法执行了两次。</li>
<li><code>ES6</code>中的继承方式，一带而过即可，重点是要掌握<code>ES5</code>中的继承。</li>
</ul>
]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180307_0957.png" type="image/png"/>
    </item>
    <item>
      <title>谈谈你对重构的理解</title>
      <link>https://0808200.xyz/Interview/base/other.html</link>
      <guid>https://0808200.xyz/Interview/base/other.html</guid>
      <source url="https://0808200.xyz/rss.xml">谈谈你对重构的理解</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>如何评价AngularJS和BackboneJS</strong></p>
<ul>
<li>
<p>backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto)就比一个AngularJS 多出了2 次HTTP请求.</p>
</li>
<li>
<p>Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新</p>
</li>
<li>
<p>AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令</p>
</li>
</ul>
<p><strong>谈谈你对重构的理解</strong></p>
<ul>
<li>
<p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI</p>
</li>
<li>
<p>对于传统的网站来说重构通常是：</p>
<ul>
<li>
<p>表格(table)布局改为DIV+CSS</p>
</li>
<li>
<p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</p>
</li>
<li>
<p>对于移动平台的优化</p>
</li>
<li>
<p>针对于SEO进行优化</p>
</li>
<li>
<p>深层次的网站重构应该考虑的方面</p>
</li>
</ul>
</li>
</ul>
<p><strong>说说你对前端架构师的理解</strong></p>
<ul>
<li>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训</li>
</ul>
<p><strong>什么样的前端代码是好的</strong></p>
<ul>
<li>高复用低耦合，这样文件小，好维护，而且好扩展。</li>
</ul>
<p><strong>谈谈你对webpack的看法</strong></p>
<blockquote>
<p>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源</p>
</blockquote>
<p><strong>页面重构怎么操作？</strong></p>
<ul>
<li>
<p>网站重构：不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>
</li>
<li>
<p>页面重构可以考虑的方面：</p>
<ul>
<li>升级第三方依赖</li>
<li>使用HTML5、CSS3、ES6 新特性</li>
<li>加入响应式布局</li>
<li>统一代码风格规范</li>
<li>减少代码间的耦合</li>
<li>压缩/合并静态资源</li>
<li>程序的性能优化</li>
<li>采用CDN来加速资源加载</li>
<li>对于JS DOM的优化</li>
<li>HTTP服务器的文件缓存</li>
</ul>
</li>
</ul>
<p><strong>列举IE与其他浏览器不一样的特性？</strong></p>
<ul>
<li>IE 的渲染引擎是 Trident 与 W3C 标准差异较大：例如盒子模型的怪异模式</li>
<li>JS 方面有很多独立的方法，例如事件处理不同：绑定/删除事件，阻止冒泡，阻止默认事件等</li>
<li>CSS 方面也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式</li>
</ul>
<p><strong>是否了解公钥加密和私钥加密？</strong></p>
<ul>
<li>私钥用于对数据进行签名，公钥用于对签名进行验证</li>
<li>网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密</li>
</ul>
<p><strong>WEB应用从服务器主动推送Data到客户端有那些方式？</strong></p>
<ul>
<li>AJAX 轮询</li>
<li>html5 服务器推送事件
<code>(new EventSource(SERVER_URL)).addEventListener(&quot;message&quot;, func);</code></li>
<li>html5 Websocket</li>
</ul>
<ul>
<li><code>(new WebSocket(SERVER_URL)).addEventListener(&quot;message&quot;, func);</code></li>
</ul>
<p><strong>你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）</strong></p>
<ul>
<li>
<p>Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装</p>
<ul>
<li>优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端</li>
<li>缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等）</li>
</ul>
</li>
<li>
<p>Hybrid App(混合开发)：UI WebView，需要下载安装</p>
<ul>
<li>优点：接近 Native App 的体验，部分支持离线功能</li>
<li>缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟</li>
</ul>
</li>
<li>
<p>Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用</p>
<ul>
<li>优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）</li>
<li>缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核</li>
</ul>
</li>
</ul>
<p><strong>Web 前端开发的注意事项？</strong></p>
<ul>
<li>特别设置 meta 标签 viewport</li>
<li>百分比布局宽度，结合 box-sizing: border-box;</li>
<li>使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算</li>
<li>使用 css3 新特性。弹性盒模型、多列布局、媒体查询等</li>
<li>多机型、多尺寸、多系统覆盖测试</li>
</ul>
<p><strong>在设计 Web APP 时，应当遵循以下几点</strong></p>
<ul>
<li>简化不重要的动画/动效/图形文字样式</li>
<li>少用手势，避免与浏览器手势冲突</li>
<li>减少页面内容，页面跳转次数，尽量在当前页面显示</li>
<li>增强 Loading 趣味性，增强页面主次关系</li>
</ul>
<p><strong>平时如何管理你的项目？</strong></p>
<ul>
<li>规定全局样式、公共脚本</li>
<li>严格要求代码注释(html/js/css)</li>
<li>严格要求静态资源存放路径</li>
<li>Git 提交必须填写说明</li>
</ul>
<p><strong>如何设计突发大规模并发架构？</strong></p>
<ul>
<li>及时响应(NoSQL缓存)</li>
<li>数据安全(数据备份)</li>
<li>负载均衡</li>
</ul>
<p><strong>说说最近最流行的一些东西吧？</strong></p>
<ul>
<li>ES6、Node、React、Webpack</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>如何进行网站性能优化</title>
      <link>https://0808200.xyz/Interview/base/performance-optimization.html</link>
      <guid>https://0808200.xyz/Interview/base/performance-optimization.html</guid>
      <source url="https://0808200.xyz/rss.xml">如何进行网站性能优化</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="性能优化" tabindex="-1"> 性能优化</h3>
<hr>
<p><strong>如何进行网站性能优化</strong></p>
<ul>
<li>
<p>content方面</p>
<ul>
<li>减少HTTP请求：合并文件、CSS精灵、inline Image</li>
<li>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询</li>
<li>避免重定向：多余的中间访问</li>
<li>使Ajax可缓存</li>
<li>非必须组件延迟加载</li>
<li>未来所需组件预加载</li>
<li>减少DOM元素数量</li>
<li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li>
<li>减少iframe数量</li>
<li>不要404</li>
</ul>
</li>
<li>
<p>Server方面</p>
<ul>
<li>使用CDN</li>
<li>添加Expires或者Cache-Control响应头</li>
<li>对组件使用Gzip压缩</li>
<li>配置ETag</li>
<li>Flush Buffer Early</li>
<li>Ajax使用GET进行请求</li>
<li>避免空src的img标签</li>
</ul>
</li>
<li>
<p>Cookie方面</p>
<ul>
<li>减小cookie大小</li>
<li>引入资源的域名不要包含cookie</li>
</ul>
</li>
<li>
<p>css方面</p>
<ul>
<li>将样式表放到页面顶部</li>
<li>不使用CSS表达式</li>
<li>不使用IE的Filter</li>
</ul>
</li>
<li>
<p>Javascript方面</p>
<ul>
<li>将脚本放到页面底部</li>
<li>将javascript和css从外部引入</li>
<li>压缩javascript和css</li>
<li>删除不需要的脚本</li>
<li>减少DOM访问</li>
<li>合理设计事件监听器</li>
</ul>
</li>
<li>
<p>图片方面</p>
<ul>
<li>优化图片：根据实际颜色需要选择色深、压缩</li>
<li>优化css精灵</li>
<li>不要在HTML中拉伸图片</li>
<li>保证favicon.ico小并且可缓存</li>
</ul>
</li>
<li>
<p>移动方面</p>
<ul>
<li>保证组件小于25k</li>
<li><code>Pack Components into a Multipart Document</code></li>
</ul>
</li>
</ul>
<p><strong>你有用过哪些前端性能优化的方法？</strong></p>
<ul>
<li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li>
<li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li>
<li>当需要设置的样式很多时设置className而不是直接操作style</li>
<li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li>
<li>避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳</li>
<li>避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</li>
</ul>
<p><strong>谈谈性能优化问题</strong></p>
<ul>
<li>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器</li>
<li>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</li>
<li>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载</li>
<li>请求带宽：压缩文件，开启GZIP</li>
</ul>
<p><strong>代码层面的优化</strong></p>
<ul>
<li>
<p>用hash-table来优化查找</p>
</li>
<li>
<p>少用全局变量</p>
</li>
<li>
<p>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</p>
</li>
<li>
<p>用setTimeout来避免页面失去响应</p>
</li>
<li>
<p>缓存DOM节点查找的结果</p>
</li>
<li>
<p>避免使用CSS Expression</p>
</li>
<li>
<p>避免全局查询</p>
</li>
<li>
<p>避免使用with(with会创建自己的作用域，会增加作用域链长度)</p>
</li>
<li>
<p>多个变量声明合并</p>
</li>
<li>
<p>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</p>
</li>
<li>
<p>尽量避免写在HTML标签中写Style属性</p>
</li>
</ul>
<p><strong>前端性能优化最佳实践？</strong></p>
<ul>
<li>性能评级工具（PageSpeed 或 YSlow）</li>
<li>合理设置 HTTP 缓存：Expires 与 Cache-control</li>
<li>静态资源打包，开启 Gzip 压缩（节省响应流量）</li>
<li>CSS3 模拟图像，图标base64（降低请求数）</li>
<li>模块延迟(defer)加载/异步(async)加载</li>
<li>Cookie 隔离（节省请求流量）</li>
<li>localStorage（本地存储）</li>
<li>使用 CDN 加速（访问最近服务器）</li>
<li>启用 HTTP/2（多路复用，并行加载）</li>
<li>前端自动化（gulp/webpack）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>页面性能优化</title>
      <link>https://0808200.xyz/Interview/base/performance.html</link>
      <guid>https://0808200.xyz/Interview/base/performance.html</guid>
      <source url="https://0808200.xyz/rss.xml">页面性能优化</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一、网络相关" tabindex="-1"> 一、网络相关</h2>
<h3 id="_1-1-dns-预解析" tabindex="-1"> 1.1 DNS 预解析</h3>
<ul>
<li>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>dns-prefetch<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>//yuchengkai.cn<span>"</span></span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="_1-2-缓存" tabindex="-1"> 1.2 缓存</h3>
<ul>
<li>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度</li>
<li>通常浏览器缓存策略分为两种：强缓存和协商缓存</li>
</ul>
<p><strong>强缓存</strong></p>
<blockquote>
<p>实现强缓存可以通过两种响应头实现：<code>Expires </code>和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code </code>为 <code>200</code></p>
</blockquote>
<div><pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>
</blockquote>
<div><pre><code>Cache-control: max-age=30
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求</p>
</blockquote>
<p><strong>协商缓存</strong></p>
<ul>
<li>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304</li>
<li>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式</li>
</ul>
<p>Last-Modified 和 If-Modified-Since</p>
<ul>
<li><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified </code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</li>
<li>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li>
</ul>
<p>ETag 和 If-None-Match</p>
<ul>
<li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高</li>
</ul>
<p><strong>选择合适的缓存策略</strong></p>
<blockquote>
<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>
</blockquote>
<ul>
<li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li>
<li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>
<li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li>
</ul>
<h3 id="_1-3-使用-http-2-0" tabindex="-1"> 1.3 使用 HTTP / 2.0</h3>
<ul>
<li>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间</li>
<li>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小</li>
</ul>
<h3 id="_1-4-预加载" tabindex="-1"> 1.4 预加载</h3>
<ul>
<li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载</li>
<li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>preload<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>http://example.com<span>"</span></span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好</p>
</blockquote>
<h3 id="_1-5-预渲染" tabindex="-1"> 1.5 预渲染</h3>
<blockquote>
<p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>prerender<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>http://example.com<span>"</span></span><span>></span></span> 
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</li>
</ul>
<h2 id="二、优化渲染过程" tabindex="-1"> 二、优化渲染过程</h2>
<h3 id="_2-1-懒执行" tabindex="-1"> 2.1 懒执行</h3>
<ul>
<li>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒</li>
</ul>
<h3 id="_2-2-懒加载" tabindex="-1"> 2.2 懒加载</h3>
<ul>
<li>懒加载就是将不关键的资源延后加载</li>
</ul>
<blockquote>
<p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载</p>
</blockquote>
<ul>
<li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>面试带答案版本</title>
      <link>https://0808200.xyz/Interview/base/question-and-answer-version.html</link>
      <guid>https://0808200.xyz/Interview/base/question-and-answer-version.html</guid>
      <source url="https://0808200.xyz/rss.xml">面试带答案版本</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="前端开发知识点" tabindex="-1"> 前端开发知识点</h3>
<hr>
<ul>
<li>
<p>HTML&amp;CSS</p>
<ul>
<li>对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、HTML5、CSS3、Flexbox</li>
</ul>
</li>
<li>
<p>JavaScript：</p>
<ul>
<li>数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript</li>
</ul>
</li>
<li>
<p>其他：</p>
<ul>
<li>移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力</li>
</ul>
</li>
<li>
<p>DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。</p>
</li>
<li>
<p>DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。</p>
</li>
<li>
<p>事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。</p>
</li>
<li>
<p>XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。</p>
</li>
<li>
<p>严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。</p>
</li>
<li>
<p>盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型</p>
</li>
<li>
<p>块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们</p>
</li>
<li>
<p>浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。</p>
</li>
<li>
<p>HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。</p>
</li>
<li>
<p>JSON —— 作用、用途、设计结构</p>
</li>
</ul>
<h3 id="html" tabindex="-1"> HTML</h3>
<hr>
<p><strong>Doctype作用？标准模式与兼容模式各有什么区别?</strong></p>
<ul>
<li><code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现</li>
<li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li>
</ul>
<p><strong>HTML5 为什么只需要写 <!DOCTYPE HTML>？</strong></p>
<ul>
<li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li>
<li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li>
</ul>
<p><strong>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</strong></p>
<ul>
<li>
<p>首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素</p>
</li>
<li>
<p>行内元素有：a b span img input select strong（强调的语气）</p>
</li>
<li>
<p>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</p>
</li>
<li>
<p>常见的空元素：<br> <hr> <img> <input> <link> <meta></p>
</li>
</ul>
<p><strong>页面导入样式时，使用link和@import有什么区别？</strong></p>
<ul>
<li>link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</li>
<li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li>
<li>import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</li>
</ul>
<p><strong>介绍一下你对浏览器内核的理解？</strong></p>
<ul>
<li>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</li>
<li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</li>
<li>JS引擎则：解析和执行javascript来实现网页的动态效果</li>
<li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</li>
</ul>
<p><strong>常见的浏览器内核有哪些？</strong></p>
<ul>
<li>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>
<li>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>
<li>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</li>
<li>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</li>
</ul>
<p><strong>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？</strong></p>
<ul>
<li>
<p>HTML5 现在已经不是 SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加</p>
</li>
<li>
<p>新增功能</p>
<ul>
<li>绘画 canvas;</li>
<li>用于媒介回放的 video 和 audio 元素;</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除;</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section;</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation</li>
</ul>
</li>
<li>
<p>移除的元素：</p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes</li>
</ul>
</li>
<li>
<p>支持HTML5新标签：</p>
<ul>
<li>IE8/IE7/IE6支持通过document.createElement方法产生的标签，</li>
<li>可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式</li>
<li>当然也可以直接使用成熟的框架、比如html5shim</li>
</ul>
</li>
</ul>
<div><pre><code>&lt;!--[if lt IE 9]>
	&lt;script> src="http://html5shim.googlecode.com/svn
	/trunk/html5.js"&lt;/script>
 &lt;![endif]-->
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li>
</ul>
<p><strong>简述一下你对HTML语义化的理解？</strong></p>
<ul>
<li>用正确的标签做正确的事情。</li>
<li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li>
<li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>
</ul>
<p><strong>HTML5的离线储存怎么使用，工作原理能不能解释一下？</strong></p>
<ul>
<li>
<p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</p>
</li>
<li>
<p>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
</li>
<li>
<p>如何使用：</p>
<ul>
<li>页面头部像下面一样加入一个manifest的属性</li>
<li>在cache.manifest文件的编写离线存储的资源</li>
<li>在离线状态时，操作window.applicationCache进行需求实现</li>
</ul>
</li>
</ul>
<div><pre><code>CACHE MANIFEST
#v0.11
CACHE:
js/app.js
css/style.css
NETWORK:
resourse/logo.png
FALLBACK:
/ /offline.html
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</strong></p>
<ul>
<li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li>
<li>离线的情况下，浏览器就直接使用离线存储的资源</li>
</ul>
<p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</strong></p>
<ul>
<li>
<p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</p>
</li>
<li>
<p>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</p>
</li>
<li>
<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</p>
</li>
<li>
<p>存储大小：</p>
<ul>
<li>cookie数据大小不能超过4k。</li>
<li>sessionStorage和localStorage</li>
<li>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
</ul>
</li>
<li>
<p>有期时间：</p>
<ul>
<li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>
<li>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</li>
<li>cookie   设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<p><strong>iframe有那些缺点？</strong></p>
<ul>
<li>iframe会阻塞主页面的Onload事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
<li>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript</li>
<li>动态给iframe添加src属性值，这样可以绕开以上两个问题</li>
</ul>
<p><strong>Label的作用是什么？是怎么用的？</strong></p>
<ul>
<li>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上</li>
</ul>
<div><pre><code>&lt;label for="Name">Number:&lt;/label>
&lt;input type="text" name="Name" id="Name"/>

&lt;label>Date:&lt;input type="text" name="B"/>&lt;/label>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>HTML5的form如何关闭自动完成功能？</strong></p>
<ul>
<li>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</li>
</ul>
<p><strong>如何实现浏览器内多个标签页之间的通信? (阿里)</strong></p>
<ul>
<li>WebSocket、SharedWorker</li>
<li>也可以调用localstorge、cookies等本地存储方式</li>
<li>localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件,我们通过监听事件，控制它的值来进行页面信息通信；</li>
<li>注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</li>
</ul>
<p><strong>webSocket如何兼容低浏览器？(阿里)</strong></p>
<ul>
<li>Adobe Flash Socket 、</li>
<li>ActiveX HTMLFile (IE) 、</li>
<li>基于 multipart 编码发送 XHR 、</li>
<li>基于长轮询的 XHR</li>
</ul>
<p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p>
<ul>
<li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li>
</ul>
<p><strong>如何在页面上实现一个圆形的可点击区域？</strong></p>
<ul>
<li>map+area或者svg</li>
<li>border-radius</li>
<li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
</ul>
<p><strong>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</strong></p>
<ul>
<li><code>&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></li>
</ul>
<p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p>
<ul>
<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>
<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>
</ul>
<p><strong>title与h1的区别、b与strong的区别、i与em的区别？</strong></p>
<ul>
<li>
<p>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响</p>
</li>
<li>
<p>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，而<code>&lt;B&gt;</code>是展示强调内容</p>
</li>
<li>
<p>i内容展示为斜体，em表示强调的文本；</p>
</li>
<li>
<p>Physical Style Elements -- 自然样式标签 b, i, u, s, pre</p>
</li>
<li>
<p>Semantic Style Elements -- 语义样式标签 strong, em, ins, del, code</p>
</li>
</ul>
<h3 id="css" tabindex="-1"> CSS</h3>
<hr>
<p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p>
<ul>
<li>有两种， IE 盒子模型、W3C 盒子模型；</li>
<li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li>
<li>区 别： IE的content部分把 border 和 padding计算了进去;</li>
</ul>
<p><strong>CSS选择符有哪些？哪些属性可以继承？</strong></p>
<ul>
<li>
<p>id选择器（ # myid）</p>
</li>
<li>
<p>类选择器（.myclassname）</p>
</li>
<li>
<p>标签选择器（div, h1, p）</p>
</li>
<li>
<p>相邻选择器（h1 + p）</p>
</li>
<li>
<p>子选择器（ul &gt; li）</p>
</li>
<li>
<p>后代选择器（li a）</p>
</li>
<li>
<p>通配符选择器（ * ）</p>
</li>
<li>
<p>属性选择器（a[rel = &quot;external&quot;]）</p>
</li>
<li>
<p>伪类选择器（a:hover, li:nth-child）</p>
</li>
<li>
<p>可继承的样式： font-size font-family color, UL LI DL DD DT</p>
</li>
<li>
<p>不可继承的样式：border padding margin width height</p>
</li>
</ul>
<p><strong>CSS优先级算法如何计算？</strong></p>
<ul>
<li>
<p>优先级就近原则，同权重情况下样式定义最近者为准</p>
</li>
<li>
<p>载入样式以最后载入的定位为准</p>
</li>
<li>
<p>优先级为:</p>
<ul>
<li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li>
<li>!important &gt;  id &gt; class &gt; tag</li>
<li>important 比 内联优先级高</li>
</ul>
</li>
</ul>
<p><strong>CSS3新增伪类有那些？</strong></p>
<ul>
<li>
<p>p:first-of-type	选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</p>
</li>
<li>
<p>p:last-of-type	选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</p>
</li>
<li>
<p>p:only-of-type	选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</p>
</li>
<li>
<p>p:only-child		选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</p>
</li>
<li>
<p>p:nth-child(2)	选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</p>
</li>
<li>
<p>:after			在元素之前添加内容,也可以用来做清除浮动。</p>
</li>
<li>
<p>:before			在元素之后添加内容</p>
</li>
<li>
<p>:enabled</p>
</li>
<li>
<p>:disabled 		控制表单控件的禁用状态。</p>
</li>
<li>
<p>:checked        单选框或复选框被选中</p>
</li>
</ul>
<p><strong>如何居中div？</strong></p>
<ul>
<li>水平居中：给div设置一个宽度，然后添加margin:0 auto属性</li>
</ul>
<div><pre><code>div{
	width:200px;
	margin:0 auto;
 }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>让绝对定位的div居中</li>
</ul>
<div><pre><code>div {
	position: absolute;
	width: 300px;
	height: 300px;
	margin: auto;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	background-color: pink;	/* 方便看效果 */
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>水平垂直居中一
<ul>
<li>确定容器的宽高 宽500 高 300 的层</li>
<li>设置层的外边距</li>
</ul>
</li>
</ul>
<div><pre><code>div {
	position: relative;		/* 相对定位或绝对定位均可 */
	width:500px;
	height:300px;
	top: 50%;
	left: 50%;
	margin: -150px 0 0 -250px;     	/* 外边距为自身宽高的一半 */
	background-color: pink;	 	/* 方便看效果 */

 }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>水平垂直居中二
<ul>
<li>未知容器的宽高，利用 <code>transform</code> 属性</li>
</ul>
</li>
</ul>
<div><pre><code>div {
	position: absolute;		/* 相对定位或绝对定位均可 */
	width:500px;
	height:300px;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background-color: pink;	 	/* 方便看效果 */

}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>水平垂直居中三</p>
<ul>
<li>利用 flex 布局</li>
<li>实际使用时应考虑兼容性</li>
</ul>
</li>
</ul>
<div><pre><code>.container {
	display: flex;
	align-items: center; 		/* 垂直居中 */
	justify-content: center;	/* 水平居中 */

}
.container div {
	width: 100px;
	height: 100px;
	background-color: pink;		/* 方便看效果 */
}  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>display有哪些值？说明他们的作用。</strong></p>
<ul>
<li>block       	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li>
<li>none        	缺省值。象行内元素类型一样显示。</li>
<li>inline      	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示</li>
<li>inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。</li>
<li>list-item   	象块类型元素一样显示，并添加样式列表标记。</li>
<li>table       	此元素会作为块级表格来显示。</li>
<li>inherit     	规定应该从父元素继承 display 属性的值</li>
</ul>
<p><strong>position的值relative和absolute定位原点是？</strong></p>
<ul>
<li>absolute
<ul>
<li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li>
</ul>
</li>
<li>fixed （老IE不支持）
<ul>
<li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
</ul>
</li>
<li>relative
<ul>
<li>生成相对定位的元素，相对于其正常位置进行定位。</li>
</ul>
</li>
<li>static
<ul>
<li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</li>
</ul>
</li>
<li>inherit
<ul>
<li>规定从父元素继承 position 属性的值</li>
</ul>
</li>
</ul>
<p><strong>CSS3有哪些新特性？</strong></p>
<ul>
<li>新增各种CSS选择器	（: not(.input)：所有 class 不是“input”的节点）</li>
<li>圆角		    （border-radius:8px）</li>
<li>多列布局	    （multi-column layout）</li>
<li>阴影和反射	（Shadow\Reflect）</li>
<li>文字特效		（text-shadow、）</li>
<li>文字渲染		（Text-decoration）</li>
<li>线性渐变		（gradient）</li>
<li>旋转		 	（transform）</li>
<li>缩放,定位,倾斜,动画,多背景</li>
<li>例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</li>
</ul>
<p><strong>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</strong></p>
<ul>
<li>一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间</li>
<li>较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现</li>
<li>采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。</li>
<li>它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;</li>
<li>常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应</li>
<li>在布局上有了比以前更加灵活的空间</li>
</ul>
<p><strong>用纯CSS创建一个三角形的原理是什么？</strong></p>
<ul>
<li>把上、左、右三条边隐藏掉（颜色设为 transparent）</li>
</ul>
<div><pre><code>#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>一个满屏 品 字布局 如何设计?</strong></p>
<ul>
<li>简单的方式：
<ul>
<li>上面的div宽100%，</li>
<li>下面的两个div分别宽50%，</li>
<li>然后用float或者inline使其不换行即可</li>
</ul>
</li>
</ul>
<p><strong>css多列等高如何实现？</strong></p>
<ul>
<li>利用padding-bottom|margin-bottom正负值相抵；</li>
<li>设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度</li>
<li>当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度</li>
<li>其他比这列矮的列会用它们的padding-bottom补偿这部分高度差</li>
</ul>
<p><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧</strong></p>
<ul>
<li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8</li>
<li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</li>
<li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大</li>
<li>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}</li>
<li>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</li>
<li>渐进识别的方式，从总体中逐渐排除局部</li>
<li>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。</li>
<li>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别</li>
</ul>
<div><pre><code>.bb{
      background-color:red;/*所有识别*/
      background-color:#00deff\9; /*IE6、7、8识别*/
      +background-color:#a200ff;/*IE6、7识别*/
      _background-color:#1e0bd1;/*IE6识别*/
  }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</p>
</li>
<li>
<p>Firefox下,只能使用getAttribute()获取自定义属性</p>
</li>
<li>
<p>解决方法:统一通过getAttribute()获取自定义属性。</p>
</li>
<li>
<p>IE下,even对象有x,y属性,但是没有pageX,pageY属性</p>
</li>
<li>
<p>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</p>
</li>
<li>
<p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
</li>
<li>
<p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,</p>
</li>
<li>
<p>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p>
</li>
<li>
<p>超链接访问过后hover样式就不出现了。被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</p>
</li>
<li>
<p><code>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</code></p>
</li>
</ul>
<p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p>
<ul>
<li>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</li>
</ul>
<p><strong>为什么要初始化CSS样式</strong></p>
<ul>
<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</li>
<li>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</li>
<li>最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）</li>
</ul>
<p><strong>absolute的containing block(容器块)计算方式跟正常流有什么不同？</strong></p>
<ul>
<li>
<p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p>
</li>
<li>
<p>1、若此元素为 inline 元素，则 containing block为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</p>
</li>
<li>
<p>2、否则,则由这个祖先元素的 padding box 构成。如果都找不到，则为 initial containing block。</p>
</li>
<li>
<p>补充：</p>
<ul>
<li>
<ol>
<li>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</li>
</ol>
</li>
<li>
<ol start="2">
<li>absolute: 向上找最近的定位为absolute/relative的元素</li>
</ol>
</li>
<li>
<ol start="3">
<li>fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</strong></p>
<ul>
<li>对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.</li>
<li>如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.</li>
<li>仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</li>
</ul>
<p><strong>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</strong></p>
<ul>
<li>如果元素的display为none,那么元素不被渲染,position,float不起作用,</li>
<li>如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.</li>
<li>如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠</li>
</ul>
<p><strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong></p>
<ul>
<li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li>
</ul>
<p><strong>css定义的权重</strong></p>
<ul>
<li>以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值</li>
</ul>
<div><pre><code>
/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</li>
</ul>
<p><strong>请解释一下为什么需要清除浮动？清除浮动的方式</strong></p>
<ul>
<li>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示</li>
<li>父级div定义height</li>
<li>父级div 也一起浮动；</li>
<li>常规的使用一个class；</li>
</ul>
<div><pre><code>.clearfix:before, .clearfix:after {
    content: " ";
    display: table;
}
.clearfix:after {
    clear: both;
}
.clearfix {
    *zoom: 1;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>SASS编译的时候，浮动元素的父级div定义伪类:after</li>
</ul>
<div><pre><code>&amp;:after,&amp;:before{
    content: " ";
    visibility: hidden;
    display: block;
    height: 0;
    clear: both;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>解析原理：</p>
<ul>
<li>display:block 使生成的元素以块级元素显示,占满剩余空间</li>
<li>height:0 避免生成内容破坏原有布局的高度。</li>
<li>visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互</li>
<li>通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙</li>
<li>zoom：1 触发IE hasLayout</li>
</ul>
</li>
<li>
<p>通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0</p>
</li>
</ul>
<p><strong>什么是外边距合并？</strong></p>
<ul>
<li>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距</li>
<li>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</li>
</ul>
<p><strong>zoom:1的清除浮动原理?</strong></p>
<ul>
<li>清除浮动，触发hasLayout；</li>
<li>Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug</li>
<li>譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等</li>
</ul>
<p><strong>移动端的布局用过媒体查询吗？</strong></p>
<ul>
<li>
<p>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p>
</li>
<li>

<ul>
<li>当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。</li>
<li>当媒体查询返回假， <link> 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）</li>
</ul>
</li>
<li>
<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />
</li>
<li>

<ul>
<li>包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式</li>
<li>CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围</li>
</ul>
</li>
</ul>
<div><pre><code>&lt;style>
@media (min-width: 700px) and (orientation: landscape){
  .sidebar {
    display: none;
  }
}
&lt;/style>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>使用 CSS 预处理器吗？喜欢那个？</strong></p>
<ul>
<li>SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</li>
</ul>
<p><strong>CSS优化、提高性能的方法有哪些？</strong></p>
<ul>
<li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；</li>
<li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；</li>
<li>提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;</li>
<li>使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）</li>
</ul>
<p><strong>浏览器是怎样解析CSS选择器的？</strong></p>
<ul>
<li>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素</li>
<li>只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则</li>
</ul>
<p><strong>margin和padding分别适合什么场景使用？</strong></p>
<ul>
<li>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。</li>
<li>margin用于布局分开元素使元素与元素互不相干；</li>
<li>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</li>
</ul>
<p><strong>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</strong></p>
<ul>
<li>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</li>
<li>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法</li>
<li>比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</li>
<li>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。</li>
<li>如果按堆栈视角，::after生成的内容会在::before生成的内容之上</li>
</ul>
<p><strong>如何修改chrome记住密码后自动填充表单的黄色背景 ？</strong></p>
<div><pre><code>input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {
  background-color: rgb(250, 255, 189); /* #FAFFBD; */
  background-image: none;
  color: rgb(0, 0, 0);
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>设置元素浮动后，该元素的display值是多少？</strong></p>
<ul>
<li>自动变成了 display:block</li>
</ul>
<p><strong>怎么让Chrome支持小于12px 的文字？</strong></p>
<ul>
<li>用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观</li>
<li>使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜</li>
<li>继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑</li>
<li>使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</li>
</ul>
<p><strong>让页面里的字体变清晰，变细用CSS怎么做？</strong></p>
<ul>
<li>-webkit-font-smoothing: antialiased;</li>
</ul>
<p><strong>font-style属性可以让它赋值为“oblique” oblique是什么意思？</strong></p>
<ul>
<li>倾斜的字体样式</li>
</ul>
<p><strong>position:fixed;在android下无效怎么处理？</strong></p>
<ul>
<li>fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，</li>
<li>所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></li>
</ul>
<p><strong>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</strong></p>
<ul>
<li>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</li>
</ul>
<p><strong>display:inline-block 什么时候会显示间隙？(携程)</strong></p>
<ul>
<li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li>
</ul>
<p><strong>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</strong></p>
<ul>
<li>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。</li>
<li>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的</li>
<li>同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。</li>
</ul>
<p><strong>什么是CSS 预处理器 / 后处理器？</strong></p>
<ul>
<li>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</li>
<li>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</li>
</ul>
<h3 id="javascript" tabindex="-1"> JavaScript</h3>
<hr>
<p><strong>介绍js的基本数据类型</strong></p>
<ul>
<li>Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li>
</ul>
<p><strong>介绍js有哪些内置对象？</strong></p>
<ul>
<li>Object 是 JavaScript 中所有对象的父对象</li>
<li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
</ul>
<p><strong>说几条写JavaScript的基本规范？</strong></p>
<ul>
<li>1.不要在同一行声明多个变量。</li>
<li>2.请使用 ===/!==来比较true/false或者数值</li>
<li>3.使用对象字面量替代new Array这种形式</li>
<li>4.不要使用全局函数。</li>
<li>5.Switch语句必须带有default分支</li>
<li>6.函数不应该有时候有返回值，有时候没有返回值。</li>
<li>7.For循环必须使用大括号</li>
<li>8.If语句必须使用大括号</li>
<li>9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</li>
</ul>
<p><strong>JavaScript原型，原型链 ? 有什么特点？</strong></p>
<ul>
<li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li>
<li>关系：instance.constructor.prototype = instance.<strong>proto</strong></li>
<li>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li>
<li>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话， 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</li>
</ul>
<div><pre><code>function Func(){}
Func.prototype.name = "Sean";
Func.prototype.getInfo = function() {
  return this.name;
}
var person = new Func();//现在可以参考var person = Object.create(oldObject);
console.log(person.getInfo());//它拥有了Func的属性和方法
//"Sean"
console.log(Func.prototype);
// Func { name="Sean", getInfo=function()}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</strong></p>
<ul>
<li>
<p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</p>
</li>
<li>
<p>堆：引用数据类型（对象、数组和函数）</p>
</li>
<li>
<p>两种类型的区别是：存储位置不同；</p>
<ul>
<li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
</ul>
</li>
<li>
<p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
</li>
</ul>
<p><strong>如何将字符串转化为数字，例如'12.3b'?</strong></p>
<ul>
<li>parseFloat('12.3b');</li>
<li>正则表达式，'12.3b'.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已</li>
</ul>
<p><strong>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</strong></p>
<div><pre><code>function commafy(num){
	return num &amp;&amp; num
		.toString()
		.replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
			return $2 + ',';
		});
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>如何实现数组的随机排序？</strong></p>
<ul>
<li>方法一：</li>
</ul>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>]</span><span>;</span>
<span>function</span> <span>randSort1</span><span>(</span><span>arr</span><span>)</span><span>{</span>
	<span>for</span><span>(</span><span>var</span> i <span>=</span> <span>0</span><span>,</span>len <span>=</span> arr<span>.</span>length<span>;</span>i <span>&lt;</span> len<span>;</span> i<span>++</span> <span>)</span><span>{</span>
		<span>var</span> rand <span>=</span> <span>parseInt</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>*</span>len<span>)</span><span>;</span>
		<span>var</span> temp <span>=</span> arr<span>[</span>rand<span>]</span><span>;</span>
		arr<span>[</span>rand<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
		arr<span>[</span>i<span>]</span> <span>=</span> temp<span>;</span>
	<span>}</span>
	<span>return</span> arr<span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>randSort1</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>方法二：</li>
</ul>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>]</span><span>;</span>
<span>function</span> <span>randSort2</span><span>(</span><span>arr</span><span>)</span><span>{</span>
	<span>var</span> mixedArray <span>=</span> <span>[</span><span>]</span><span>;</span>
	<span>while</span><span>(</span>arr<span>.</span>length <span>></span> <span>0</span><span>)</span><span>{</span>
		<span>var</span> randomIndex <span>=</span> <span>parseInt</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>*</span>arr<span>.</span>length<span>)</span><span>;</span>
		mixedArray<span>.</span><span>push</span><span>(</span>arr<span>[</span>randomIndex<span>]</span><span>)</span><span>;</span>
		arr<span>.</span><span>splice</span><span>(</span>randomIndex<span>,</span> <span>1</span><span>)</span><span>;</span>
	<span>}</span>
	<span>return</span> mixedArray<span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>randSort2</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>方法三：</li>
</ul>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>]</span><span>;</span>
arr<span>.</span><span>sort</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
	<span>return</span> Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>-</span> <span>0.5</span><span>;</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>arr<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>Javascript如何实现继承？</strong></p>
<ul>
<li>
<p>构造继承</p>
</li>
<li>
<p>原型继承</p>
</li>
<li>
<p>实例继承</p>
</li>
<li>
<p>拷贝继承</p>
</li>
<li>
<p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</p>
</li>
</ul>
<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>)</span><span>{</span>
	<span>this</span><span>.</span>name <span>=</span> <span>'wang'</span><span>;</span>
<span>}</span>

<span>function</span> <span>Child</span><span>(</span><span>)</span><span>{</span>
	<span>this</span><span>.</span>age <span>=</span> <span>28</span><span>;</span>
<span>}</span>
<span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>)</span><span>;</span><span>//继承了Parent，通过原型</span>

<span>var</span> demo <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>
<span>alert</span><span>(</span>demo<span>.</span>age<span>)</span><span>;</span>
<span>alert</span><span>(</span>demo<span>.</span>name<span>)</span><span>;</span><span>//得到被继承的属性</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>javascript创建对象的几种方式？</strong></p>
<ul>
<li>
<p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</p>
</li>
<li>
<p>1、对象字面量的方式</p>
<ul>
<li><code>person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};</code></li>
</ul>
</li>
<li>
<p>2、用function来模拟无参的构造函数</p>
</li>
</ul>
<div><pre><code>function Person(){}
//定义一个function，如果使用new"实例化",该function可以看作是一个Class
person.name="Mark";
var person=new Person();
person.age="25";
person.work=function(){
alert(person.name+" hello...");
}
person.work();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</li>
</ul>
<div><pre><code>function Pet(name,age,hobby){
   this.name=name;//this作用域：当前对象
   this.age=age;
   this.hobby=hobby;
   this.eat=function(){
      alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
   }
}
var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
maidou.eat();//调用eat方法
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>4、用工厂方式来创建（内置对象）</li>
</ul>
<div><pre><code>var wcDog =new Object();
 wcDog.name="旺财";
 wcDog.age=3;
 wcDog.work=function(){
   alert("我是"+wcDog.name+",汪汪汪......");
 }
 wcDog.work();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>5、用原型方式来创建</li>
</ul>
<div><pre><code>function Dog(){

 }
 Dog.prototype.name="旺财";
 Dog.prototype.eat=function(){
 alert(this.name+"是个吃货");
 }
 var wangcai =new Dog();
 wangcai.eat();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>6、用混合方式来创建</li>
</ul>
<div><pre><code>function Car(name,price){
  this.name=name;
  this.price=price;
}
 Car.prototype.sell=function(){
   alert("我是"+this.name+"，我现在卖"+this.price+"万元");
  }
var camry =new Car("凯美瑞",27);
camry.sell();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>Javascript作用链域?</strong></p>
<ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。</li>
<li>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链</li>
</ul>
<p><strong>谈谈This对象的理解。</strong></p>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）；</li>
<li>如果有new关键字，this指向new出来的那个对象；</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</li>
</ul>
<p><strong>eval是做什么的？</strong></p>
<ul>
<li>它的功能是把对应的字符串解析成JS代码并运行；</li>
<li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');</li>
</ul>
<p><strong>什么是window对象? 什么是document对象?</strong></p>
<ul>
<li>window对象是指浏览器打开的窗口。</li>
<li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性</li>
</ul>
<p><strong>null，undefined 的区别？</strong></p>
<ul>
<li>
<p>null 		表示一个对象是“没有值”的值，也就是值为“空”；</p>
</li>
<li>
<p>undefined 	表示一个变量声明了没有初始化(赋值)；</p>
</li>
<li>
<p>undefined不是一个有效的JSON，而null是；</p>
</li>
<li>
<p>undefined的类型(typeof)是undefined；</p>
</li>
<li>
<p>null的类型(typeof)是object；</p>
</li>
<li>
<p>Javascript将未赋值的变量默认值设为undefined；</p>
</li>
<li>
<p>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的</p>
</li>
<li>
<p>typeof undefined</p>
<ul>
<li>undefined :
<ul>
<li>是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；</li>
<li>例如变量被声明了，但没有赋值时，就等于undefined</li>
</ul>
</li>
</ul>
</li>
<li>
<p>typeof null //&quot;object&quot;</p>
<ul>
<li>null : 是一个对象(空对象, 没有任何属性和方法)；</li>
<li>例如作为函数的参数，表示该函数的参数不是对象；</li>
</ul>
</li>
<li>
<p>注意：</p>
<ul>
<li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li>
<li>null == undefined // true</li>
<li>null === undefined // false</li>
</ul>
</li>
</ul>
<p><strong>写一个通用的事件侦听器函数。</strong></p>
<div><pre><code>// event(事件)工具集，来源：github.com/markyun
markyun.Event = {
	// 页面加载完成后
	readyEvent : function(fn) {
		if (fn==null) {
			fn=document;
		}
		var oldonload = window.onload;
		if (typeof window.onload != 'function') {
			window.onload = fn;
		} else {
			window.onload = function() {
				oldonload();
				fn();
			};
		}
	},
	// 视能力分别使用dom0||dom2||IE方式 来绑定事件
	// 参数： 操作的元素,事件名称 ,事件处理程序
	addEvent : function(element, type, handler) {
		if (element.addEventListener) {
			//事件类型、需要执行的函数、是否捕捉
			element.addEventListener(type, handler, false);
		} else if (element.attachEvent) {
			element.attachEvent('on' + type, function() {
				handler.call(element);
			});
		} else {
			element['on' + type] = handler;
		}
	},
	// 移除事件
	removeEvent : function(element, type, handler) {
		if (element.removeEventListener) {
			element.removeEventListener(type, handler, false);
		} else if (element.datachEvent) {
			element.detachEvent('on' + type, handler);
		} else {
			element['on' + type] = null;
		}
	},
	// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
	stopPropagation : function(ev) {
		if (ev.stopPropagation) {
			ev.stopPropagation();
		} else {
			ev.cancelBubble = true;
		}
	},
	// 取消事件的默认行为
	preventDefault : function(event) {
		if (event.preventDefault) {
			event.preventDefault();
		} else {
			event.returnValue = false;
		}
	},
	// 获取事件目标
	getTarget : function(event) {
		return event.target || event.srcElement;
	},
	// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
	getEvent : function(e) {
		var ev = e || window.event;
		if (!ev) {
			var c = this.getEvent.caller;
			while (c) {
				ev = c.arguments[0];
				if (ev &amp;&amp; Event == ev.constructor) {
					break;
				}
				c = c.caller;
			}
		}
		return ev;
	}
};
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少？</strong></p>
<ul>
<li>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数</li>
</ul>
<div><pre><code>function parseInt(str, radix) {
    return str+'-'+radix;
};
var a=["1", "2", "3"];
a.map(parseInt);  // ["1-0", "2-1", "3-2"] 不能大于radix
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN所以[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案也就是：[1, NaN, NaN]</li>
</ul>
<p><strong>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p>
<ul>
<li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为</li>
<li>事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件</li>
<li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li>
</ul>
<p><strong>什么是闭包（closure），为什么要用它？</strong></p>
<ul>
<li>
<p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部</p>
</li>
<li>
<p>闭包的特性：</p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<div><pre><code>//li节点的onclick事件都能正确的弹出当前被点击的li索引
 &lt;ul id="testUL">
    &lt;li> index = 0&lt;/li>
    &lt;li> index = 1&lt;/li>
    &lt;li> index = 2&lt;/li>
    &lt;li> index = 3&lt;/li>
&lt;/ul>
&lt;script type="text/javascript">
  	var nodes = document.getElementsByTagName("li");
	for(i = 0;i&lt;nodes.length;i+= 1){
	    nodes[i].onclick = (function(i){
	              return function() {
	                 console.log(i);
	              } //不用闭包的话，值每次都是4
	            })(i);
	}
&lt;/script>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在</li>
<li>使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源</li>
<li>因为say667()的内部函数的执行需要依赖say667()中的变量</li>
<li>这是对闭包作用的非常直白的描述</li>
</ul>
<div><pre><code>function say667() {
	// Local variable that ends up within closure
	var num = 666;
	var sayAlert = function() {
		alert(num);
	}
	num++;
	return sayAlert;
}

 var sayAlert = say667();
 sayAlert()//执行结果应该弹出的667
 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>javascript 代码中的&quot;use strict&quot;;是什么意思 ? 使用它区别是什么？</strong></p>
<ul>
<li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</li>
<li>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</li>
<li>默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;</li>
<li>全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</li>
<li>提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。</li>
</ul>
<p><strong>如何判断一个对象是否属于某个类？</strong></p>
<div><pre><code>if(a instanceof Person){
       alert('yes');
   }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>new操作符具体干了什么呢?</strong></p>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
</ul>
<div><pre><code>var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</strong></p>
<ul>
<li>javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员</li>
<li>使用方法： object.hasOwnProperty(proName)</li>
<li>其中参数object是必选项。一个对象的实例。</li>
<li>proName是必选项。一个属性名称的字符串值。</li>
<li>如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</li>
</ul>
<p><strong>JSON 的了解？</strong></p>
<ul>
<li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</li>
<li>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</li>
<li>如：{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</li>
<li>JSON字符串转换为JSON对象:</li>
</ul>
<div><pre><code>var obj =eval('('+ str +')');
var obj = str.parseJSON();
var obj = JSON.parse(str);

JSON对象转换为JSON字符串：
var last=obj.toJSONString();
var last=JSON.stringify(obj);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>js延迟加载的方式有哪些？</strong></p>
<ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
<p><strong>Ajax 是什么? 如何创建一个Ajax？</strong></p>
<ul>
<li>
<p>ajax的全称：Asynchronous Javascript And XML。</p>
</li>
<li>
<p>异步传输+js+xml</p>
</li>
<li>
<p>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验</p>
</li>
<li>
<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象</p>
</li>
<li>
<p>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p>
</li>
<li>
<p>(3)设置响应HTTP请求状态变化的函数</p>
</li>
<li>
<p>(4)发送HTTP请求</p>
</li>
<li>
<p>(5)获取异步调用返回的数据</p>
</li>
<li>
<p>(6)使用JavaScript和DOM实现局部刷新</p>
</li>
</ul>
<p><strong>Ajax 解决浏览器缓存问题？</strong></p>
<ul>
<li>
<p>1、在ajax发送请求前加上      anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。</p>
</li>
<li>
<p>2、在ajax发送请求前加上    anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。</p>
</li>
<li>
<p>3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。</p>
</li>
<li>
<p>4、在URL后面加上时间搓：&quot;nowtime=&quot; + new Date().getTime();。</p>
</li>
<li>
<p>5、如果是使用jQuery，直接这样就可以了    $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录</p>
</li>
</ul>
<p><strong>同步和异步的区别?</strong></p>
<ul>
<li>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</li>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<p><strong>如何解决跨域问题?</strong></p>
<ul>
<li>jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</li>
</ul>
<p><strong>模块化开发怎么做？</strong></p>
<ul>
<li>不暴露私有成员</li>
</ul>
<div><pre><code>var module1 = (function(){
　　　　var _count = 0;
　　　　var m1 = function(){
　　　　　　//...
　　　　};
　　　　var m2 = function(){
　　　　　　//...
　　　　};
　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};
　　})();
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</strong></p>
<ul>
<li>Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中</li>
<li>区别：
<ul>
<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible</li>
<li>CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：</li>
</ul>
</li>
</ul>
<div><pre><code>// CMD
define(function(require, exports, module) {
    var a = require('./a')
    a.doSomething()
    // 此处略去 100 行
    var b = require('./b') // 依赖可以就近书写
    b.doSomething()
    // ...
})

// AMD 默认推荐
define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
    a.doSomething()
    // 此处略去 100 行
    b.doSomething()
    // ...
})
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>异步加载JS的方式有哪些？</strong></p>
<ul>
<li>
<p>(1) defer，只支持IE</p>
</li>
<li>
<p>(2) async：</p>
</li>
<li>
<p>(3) 创建script，插入到DOM中，加载完毕后callBack</p>
</li>
</ul>
<p><strong>documen.write和 innerHTML的区别</strong></p>
<ul>
<li>document.write只能重绘整个页面</li>
<li>innerHTML可以重绘页面的一部分</li>
</ul>
<p><strong>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</strong></p>
<ul>
<li>（1）创建新节点
<ul>
<li>createDocumentFragment()    //创建一个DOM片段</li>
<li>createElement()   //创建一个具体的元素</li>
<li>createTextNode()   //创建一个文本节点</li>
</ul>
</li>
<li>（2）添加、移除、替换、插入
<ul>
<li>appendChild()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>insertBefore() //在已有的子节点前插入一个新的子节点</li>
</ul>
</li>
<li>（3）查找
<ul>
<li>getElementsByTagName()    //通过标签名称</li>
<li>getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
<li>getElementById()    //通过元素Id，唯一性</li>
</ul>
</li>
</ul>
<p><strong>.call() 和 .apply() 的区别？</strong></p>
<ul>
<li>例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);</li>
<li>注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</li>
</ul>
<div><pre><code>
function add(a,b)
{
    alert(a+b);
}

function sub(a,b)
{
    alert(a-b);
}

add.call(sub,3,1);
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>jquery.extend 与 jquery.fn.extend的区别？</strong></p>
<ul>
<li>jquery.extend 为jquery类添加类方法，可以理解为添加静态方法</li>
<li>jquery.fn.extend:源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数
使用：</li>
<li>jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用</li>
</ul>
<p><strong>Jquery与jQuery UI 有啥区别？</strong></p>
<ul>
<li>jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等</li>
<li>jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件</li>
<li>提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</li>
</ul>
<p><strong>jquery 中如何将数组转化为json字符串，然后再转化回来？</strong></p>
<ul>
<li>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</li>
</ul>
<div><pre><code>$.fn.stringifyArray = function(array) {
    return JSON.stringify(array)
}

$.fn.parseArray = function(array) {
    return JSON.parse(array)
}

然后调用：
$("").stringifyArray(array)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>针对 jQuery 的优化方法？</strong></p>
<ul>
<li>基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</li>
<li>频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好
<ul>
<li>比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;);</li>
</ul>
</li>
<li>for (var i = size; i &lt; arr.length; i++) {}
<ul>
<li>for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</li>
<li>for (var i = size, length = arr.length; i &lt; length; i++) {}</li>
</ul>
</li>
</ul>
<p><strong>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</strong></p>
<ul>
<li>this === window ? 'browser' : 'node';</li>
<li>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</li>
</ul>
<p><strong>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</strong></p>
<ul>
<li>jquery stop(): 如：$(&quot;#div&quot;).stop().animate({width:&quot;100px&quot;},100);</li>
</ul>
<p><strong>那些操作会造成内存泄漏？</strong></p>
<ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环)</li>
</ul>
<p><strong>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</strong></p>
<ul>
<li>多个事件同一个函数：<code>$(&quot;div&quot;).on(&quot;click mouseover&quot;, function(){});</code></li>
<li>多个事件不同函数</li>
</ul>
<div><pre><code>$("div").on({
	click: function(){},
	mouseover: function(){}
});
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</strong></p>
<ul>
<li>Chrome,Safari浏览器内核</li>
</ul>
<p><strong>检测浏览器版本版本有哪些方式？</strong></p>
<ul>
<li>功能检测、userAgent特征检测</li>
<li>比如：navigator.userAgent</li>
</ul>
<div><pre><code>//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36
		  (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36"
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><strong>What is a Polyfill?</strong></p>
<ul>
<li>polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们</li>
<li>例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象</li>
<li>所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发</li>
<li>一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</li>
</ul>
<p><strong>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</strong></p>
<ul>
<li>比如： html5shiv、Geolocation、Placeholder</li>
</ul>
<p><strong>使用JS实现获取文件扩展名？</strong></p>
<div><pre><code>function getFileExtension(filename) {
  return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
}

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>String.lastIndexOf()</p>
<ul>
<li>方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;)</li>
<li>将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变</li>
</ul>
</li>
<li>
<p>String.prototype.slice()</p>
<ul>
<li>从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;</li>
</ul>
</li>
</ul>
<h3 id="ecmascript6-相关" tabindex="-1"> ECMAScript6 相关</h3>
<hr>
<p><strong>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</strong></p>
<ul>
<li>两等号判等，会在比较时进行类型转换；</li>
<li>三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；</li>
<li>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true</li>
<li>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</li>
</ul>
<h3 id="其他问题" tabindex="-1"> 其他问题</h3>
<hr>
<p><strong>页面重构怎么操作？</strong></p>
<ul>
<li>
<p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI</p>
</li>
<li>
<p>对于传统的网站来说重构通常是：</p>
<ul>
<li>
<p>表格(table)布局改为DIV+CSS</p>
</li>
<li>
<p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</p>
</li>
<li>
<p>对于移动平台的优化</p>
</li>
<li>
<p>针对于SEO进行优化</p>
</li>
<li>
<p>深层次的网站重构应该考虑的方面</p>
</li>
<li>
<p>减少代码间的耦合</p>
</li>
<li>
<p>让代码保持弹性</p>
</li>
<li>
<p>严格按规范编写代码</p>
</li>
<li>
<p>设计可扩展的API</p>
</li>
<li>
<p>代替旧有的框架、语言(如VB)</p>
</li>
<li>
<p>增强用户体验</p>
</li>
<li>
<p>通常来说对于速度的优化也包含在重构中</p>
</li>
<li>
<p>压缩JS、CSS、image等前端资源(通常是由服务器来解决)</p>
</li>
<li>
<p>程序的性能优化(如数据读写)</p>
</li>
<li>
<p>采用CDN来加速资源加载</p>
</li>
<li>
<p>对于JS DOM的优化</p>
</li>
<li>
<p>HTTP服务器的文件缓存</p>
</li>
</ul>
</li>
</ul>
<p><strong>列举IE与其他浏览器不一样的特性？</strong></p>
<ul>
<li>事件不同之处：
<ul>
<li>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；</li>
<li>获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；</li>
<li>阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；</li>
<li>停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()</li>
</ul>
</li>
</ul>
<p><strong>什么叫优雅降级和渐进增强？</strong></p>
<ul>
<li>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用</li>
<li>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</li>
<li>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验</li>
</ul>
<p><strong>是否了解公钥加密和私钥加密</strong></p>
<ul>
<li>一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;</li>
<li>HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密</li>
</ul>
<p><strong>WEB应用从服务器主动推送Data到客户端有那些方式？</strong></p>
<ul>
<li>html5提供的Websocket</li>
<li>不可见的iframe</li>
<li>WebSocket通过Flash</li>
<li>XHR长时间连接</li>
<li>XHR Multipart Streaming</li>
<li><code>&lt;script&gt;</code>标签的长时间连接(可跨域)</li>
</ul>
<p><strong>对Node的优点和缺点提出了自己的看法？</strong></p>
<ul>
<li>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</li>
<li>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</li>
</ul>
<p><strong>你有用过哪些前端性能优化的方法？</strong></p>
<ul>
<li>
<p>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>
</li>
<li>
<p>（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
</li>
<li>
<p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>
</li>
<li>
<p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p>
</li>
<li>
<p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
</li>
<li>
<p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>
</li>
<li>
<p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳</p>
</li>
<li>
<p>（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</p>
</li>
<li>
<p>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的</p>
</li>
</ul>
<p><strong>http状态码有那些？分别代表是什么意思？</strong></p>
<ul>
<li>
<p>100  Continue	继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</p>
</li>
<li>
<p>200  OK 		正常返回信息</p>
</li>
<li>
<p>201  Created  	请求成功并且服务器创建了新的资源</p>
</li>
<li>
<p>202  Accepted 	服务器已接受请求，但尚未处理</p>
</li>
<li>
<p>301  Moved Permanently  请求的网页已永久移动到新位置。</p>
</li>
<li>
<p>302 Found  		临时性重定向。</p>
</li>
<li>
<p>303 See Other  	临时性重定向，且总是使用 GET 请求新的 URI。</p>
</li>
<li>
<p>304  Not Modified 自从上次请求后，请求的网页未修改过。</p>
</li>
<li>
<p>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p>
</li>
<li>
<p>401 Unauthorized 请求未授权。</p>
</li>
<li>
<p>403 Forbidden  	禁止访问。</p>
</li>
<li>
<p>404 Not Found  	找不到如何与 URI 相匹配的资源。</p>
</li>
<li>
<p>500 Internal Server Error  最常见的服务器端错误。</p>
</li>
<li>
<p>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</p>
</li>
</ul>
<p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</strong></p>
<blockquote>
<p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等</p>
</blockquote>
<ul>
<li>
<p>详细版：</p>
</li>
<li>
<p>1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</p>
</li>
<li>
<p>2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</p>
</li>
<li>
<p>3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</p>
</li>
<li>
<p>4、进行HTTP协议会话，客户端发送报头(请求报头);</p>
</li>
<li>
<p>5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</p>
</li>
<li>
<p>6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</p>
</li>
<li>
<p>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</p>
</li>
<li>
<p>8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</p>
</li>
<li>
<p>9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</p>
</li>
<li>
<p>10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
</li>
<li>
<p>简洁版：</p>
<ul>
<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li>
<li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li>
<li>载入解析到的资源文件，渲染页面，完成</li>
</ul>
</li>
</ul>
<p><strong>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</strong></p>
<ul>
<li>Sublime Text 3 + 相关插件编写前端代码</li>
<li>Google chrome 、Mozilla Firefox浏览器 +firebug - 兼容测试和预览页面UI、动画效果和交互功能</li>
<li>Node.js+Gulp</li>
<li>git 用于版本控制和Code Review</li>
</ul>
<p><strong>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</strong></p>
<ul>
<li>
<p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p>
<ul>
<li>1、实现界面交互</li>
<li>2、提升用户体验</li>
<li>3、有了Node.js，前端可以实现服务端的一些事情</li>
</ul>
</li>
<li>
<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p>
</li>
<li>
<p>参与项目，快速高质量完成实现效果图，精确到1px；</p>
</li>
<li>
<p>与团队成员，UI设计，产品经理的沟通</p>
</li>
<li>
<p>做好的页面结构，页面重构和用户体验</p>
</li>
<li>
<p>处理hack，兼容、写出优美的代码格式</p>
</li>
<li>
<p>针对服务器的优化、拥抱最新前端技术</p>
</li>
</ul>
<p><strong>平时如何管理你的项目？</strong></p>
<ul>
<li>
<p>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p>
</li>
<li>
<p>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</p>
</li>
<li>
<p>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</p>
</li>
<li>
<p>页面进行标注（例如 页面 模块 开始和结束）；</p>
</li>
<li>
<p>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</p>
</li>
<li>
<p>JS 分文件夹存放 命名以该JS功能为准的英文翻译。</p>
</li>
<li>
<p>图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理</p>
</li>
</ul>
<p><strong>说说最近最流行的一些东西吧？常去哪些网站？</strong></p>
<ul>
<li>ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化</li>
</ul>
<p><strong>移动端（Android IOS）怎么做好用户体验?</strong></p>
<ul>
<li>清晰的视觉纵线、</li>
<li>信息的分组、极致的减法、</li>
<li>利用选择代替输入、</li>
<li>标签及文字的排布方式、</li>
<li>依靠明文确认密码、</li>
<li>合理的键盘利用、</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>面试纯问题版本</title>
      <link>https://0808200.xyz/Interview/base/question-version.html</link>
      <guid>https://0808200.xyz/Interview/base/question-version.html</guid>
      <source url="https://0808200.xyz/rss.xml">面试纯问题版本</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="html" tabindex="-1"> HTML</h3>
<hr>
<ul>
<li>Doctype作用？严格模式与混杂模式如何区分？它们有何意义?</li>
<li>HTML5 为什么只需要写 <!DOCTYPE HTML>？</li>
<li>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</li>
<li>页面导入样式时，使用link和@import有什么区别？</li>
<li>介绍一下你对浏览器内核的理解？</li>
<li>常见的浏览器内核有哪些？</li>
<li>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</li>
<li>简述一下你对HTML语义化的理解？</li>
<li>HTML5的离线储存怎么使用，工作原理能不能解释一下？</li>
<li>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</li>
<li>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</li>
<li>iframe有那些缺点？</li>
<li>Label的作用是什么？是怎么用的？（加 for 或 包裹）</li>
<li>HTML5的form如何关闭自动完成功能？</li>
<li>如何实现浏览器内多个标签页之间的通信? (阿里)</li>
<li>webSocket如何兼容低浏览器？(阿里)</li>
<li>页面可见性（Page Visibility）API 可以有哪些用途？</li>
<li>如何在页面上实现一个圆形的可点击区域？</li>
<li>实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。</li>
<li>网页验证码是干嘛的，是为了解决什么安全问题？</li>
<li>tite与h1的区别、b与strong的区别、i与em的区别？</li>
</ul>
<h3 id="css" tabindex="-1"> CSS</h3>
<hr>
<ul>
<li>
<p>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</p>
</li>
<li>
<p>CSS选择符有哪些？哪些属性可以继承？</p>
</li>
<li>
<p>CSS优先级算法如何计算？</p>
</li>
<li>
<p>CSS3新增伪类有那些？</p>
</li>
<li>
<p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>
</li>
<li>
<p>display有哪些值？说明他们的作用。</p>
</li>
<li>
<p>position的值relative和absolute定位原点是？</p>
</li>
<li>
<p>CSS3有哪些新特性？</p>
</li>
<li>
<p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p>
</li>
<li>
<p>用纯CSS创建一个三角形的原理是什么？</p>
</li>
<li>
<p>一个满屏 品 字布局 如何设计?</p>
</li>
<li>
<p>常见兼容性问题？</p>
</li>
<li>
<p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>
</li>
<li>
<p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p>
</li>
<li>
<p>为什么要初始化CSS样式。</p>
</li>
<li>
<p>absolute的containing block计算方式跟正常流有什么不同？</p>
</li>
<li>
<p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p>
</li>
<li>
<p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p>
</li>
<li>
<p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p>
</li>
<li>
<p>CSS权重优先级是如何计算的？</p>
</li>
<li>
<p>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式</p>
</li>
<li>
<p>移动端的布局用过媒体查询吗？</p>
</li>
<li>
<p>使用 CSS 预处理器吗？喜欢那个？</p>
</li>
<li>
<p>CSS优化、提高性能的方法有哪些？</p>
</li>
<li>
<p>浏览器是怎样解析CSS选择器的？</p>
</li>
<li>
<p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>
</li>
<li>
<p>margin和padding分别适合什么场景使用？</p>
</li>
<li>
<p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p>
</li>
<li>
<p>元素竖向的百分比设定是相对于容器的高度吗？</p>
</li>
<li>
<p>全屏滚动的原理是什么？用到了CSS的那些属性？</p>
</li>
<li>
<p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p>
</li>
<li>
<p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p>
</li>
<li>
<p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>
</li>
<li>
<p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p>
</li>
<li>
<p>你对line-height是如何理解的？</p>
</li>
<li>
<p>设置元素浮动后，该元素的display值是多少？（自动变成display:block）</p>
</li>
<li>
<p>怎么让Chrome支持小于12px 的文字？</p>
</li>
<li>
<p>让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）</p>
</li>
<li>
<p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p>
</li>
<li>
<p>position:fixed;在android下无效怎么处理？</p>
</li>
<li>
<p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p>
</li>
<li>
<p>display:inline-block 什么时候会显示间隙？(携程)</p>
</li>
<li>
<p>overflow: scroll时不能平滑滚动的问题怎么处理？</p>
</li>
<li>
<p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p>
</li>
<li>
<p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p>
</li>
<li>
<p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p>
</li>
<li>
<p>style标签写在body后与body前有什么区别？</p>
</li>
</ul>
<h3 id="javascript" tabindex="-1"> JavaScript</h3>
<hr>
<ul>
<li>
<p>介绍JavaScript的基本数据类型。</p>
</li>
<li>
<p>说说写JavaScript的基本规范？</p>
</li>
<li>
<p>JavaScript原型，原型链 ? 有什么特点？</p>
</li>
<li>
<p>JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？</p>
</li>
<li>
<p>Javascript如何实现继承？</p>
</li>
<li>
<p>Javascript创建对象的几种方式？</p>
</li>
<li>
<p>Javascript作用链域?</p>
</li>
<li>
<p>谈谈This对象的理解。</p>
</li>
<li>
<p>eval是做什么的？</p>
</li>
<li>
<p>什么是window对象? 什么是document对象?</p>
</li>
<li>
<p>null，undefined的区别？</p>
</li>
<li>
<p>写一个通用的事件侦听器函数(机试题)。</p>
</li>
<li>
<p>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少？</p>
</li>
<li>
<p>关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
</li>
<li>
<p>什么是闭包（closure），为什么要用它？</p>
</li>
<li>
<p>javascript 代码中的&quot;use strict&quot;;是什么意思 ? 使用它区别是什么？</p>
</li>
<li>
<p>如何判断一个对象是否属于某个类？</p>
</li>
<li>
<p>new操作符具体干了什么呢?</p>
</li>
<li>
<p>用原生JavaScript的实现过什么功能吗？</p>
</li>
<li>
<p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>
</li>
<li>
<p>对JSON的了解？</p>
</li>
<li>
<p>[].forEach.call($$(&quot;<em>&quot;),function(a){ a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16) }) - 能解释一下这段代码的意思吗？</p>
</li>
<li>
<p>js延迟加载的方式有哪些？</p>
</li>
<li>
<p>Ajax 是什么? 如何创建一个Ajax？</p>
</li>
<li>
<p>同步和异步的区别?</p>
</li>
<li>
<p>如何解决跨域问题?</p>
</li>
<li>
<p>页面编码和被请求的资源编码如果不一致如何处理？</p>
</li>
<li>
<p>模块化开发怎么做？</p>
</li>
<li>
<p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p>
</li>
<li>
<p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</p>
</li>
<li>
<p>让你自己设计实现一个requireJS，你会怎么做？</p>
</li>
<li>
<p>谈一谈你对ECMAScript6的了解？</p>
</li>
<li>
<p>ECMAScript6 怎么写class么，为什么会出现class这种东西?</p>
</li>
<li>
<p>异步加载的方式有哪些？</p>
</li>
<li>
<p>documen.write和 innerHTML的区别?</p>
</li>
<li>
<p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>
</li>
<li>
<p>.call() 和 .apply() 的含义和区别？</p>
</li>
<li>
<p>数组和对象有哪些原生方法，列举一下？</p>
</li>
<li>
<p>JS 怎么实现一个类。怎么实例化这个类</p>
</li>
<li>
<p>JavaScript中的作用域与变量声明提升？</p>
</li>
<li>
<p>如何编写高性能的Javascript？</p>
</li>
<li>
<p>那些操作会造成内存泄漏？</p>
</li>
<li>
<p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p>
</li>
<li>
<p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p>
</li>
<li>
<p>jquery中如何将数组转化为json字符串，然后再转化回来？</p>
</li>
<li>
<p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</p>
</li>
<li>
<p>jquery.extend 与 jquery.fn.extend的区别？</p>
</li>
<li>
<p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p>
</li>
<li>
<p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p>
</li>
<li>
<p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
</li>
<li>
<p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p>
</li>
<li>
<p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p>
</li>
<li>
<p>针对 jQuery性能的优化方法？</p>
</li>
<li>
<p>Jquery与jQuery UI有啥区别？</p>
</li>
<li>
<p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p>
</li>
<li>
<p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p>
</li>
<li>
<p>jQuery和Zepto的区别？各自的使用场景？</p>
</li>
<li>
<p>针对 jQuery 的优化方法？</p>
</li>
<li>
<p>Zepto的点透问题如何解决？</p>
</li>
<li>
<p>jQueryUI如何自定义组件?</p>
</li>
<li>
<p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p>
</li>
<li>
<p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p>
</li>
<li>
<p>移动端最小触控区域是多大？</p>
</li>
<li>
<p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p>
</li>
<li>
<p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p>
</li>
<li>
<p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p>
</li>
<li>
<p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout...)么? 能讲出他们各自的优点和缺点么?</p>
</li>
<li>
<p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p>
</li>
<li>
<p>解释JavaScript中的作用域与变量声明提升？</p>
</li>
<li>
<p>那些操作会造成内存泄漏？</p>
</li>
<li>
<p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
</li>
<li>
<p>Node.js的适用场景？</p>
</li>
<li>
<p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p>
</li>
<li>
<p>解释一下 Backbone 的 MVC 实现方式？</p>
</li>
<li>
<p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p>
</li>
<li>
<p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p>
</li>
<li>
<p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? - 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p>
</li>
<li>
<p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p>
</li>
<li>
<p>简述一下 Handlebars 的基本用法？</p>
</li>
<li>
<p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p>
</li>
<li>
<p>用js实现千位分隔符?(来源：前端农民工，提示：正则+replace)</p>
</li>
<li>
<p>检测浏览器版本版本有哪些方式？</p>
</li>
<li>
<p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获]</p>
</li>
</ul>
<h3 id="其他问题" tabindex="-1"> 其他问题</h3>
<hr>
<ul>
<li>
<p>原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？</p>
</li>
<li>
<p>你遇到过比较难的技术问题是？你是如何解决的？</p>
</li>
<li>
<p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p>
</li>
<li>
<p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p>
</li>
<li>
<p>页面重构怎么操作？</p>
</li>
<li>
<p>列举IE与其他浏览器不一样的特性？</p>
</li>
<li>
<p>99%的网站都需要被重构是那本书上写的？</p>
</li>
<li>
<p>什么叫优雅降级和渐进增强？</p>
</li>
<li>
<p>是否了解公钥加密和私钥加密。</p>
</li>
<li>
<p>WEB应用从服务器主动推送Data到客户端有那些方式？</p>
</li>
<li>
<p>对Node的优点和缺点提出了自己的看法？</p>
</li>
<li>
<p>你有用过哪些前端性能优化的方法？</p>
</li>
<li>
<p>http状态码有那些？分别代表是什么意思？</p>
</li>
<li>
<p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p>
</li>
<li>
<p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p>
</li>
<li>
<p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p>
</li>
<li>
<p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p>
</li>
<li>
<p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p>
</li>
<li>
<p>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</p>
</li>
<li>
<p>你怎么看待Web App 、hybrid App、Native App？</p>
</li>
<li>
<p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p>
</li>
<li>
<p>你对加班的看法？</p>
</li>
<li>
<p>平时如何管理你的项目？</p>
</li>
<li>
<p>说说最近最流行的一些东西吧？常去哪些网站？</p>
</li>
<li>
<p>如何设计突发大规模并发架构？</p>
</li>
<li>
<p>说说最近最流行的一些东西吧？常去哪些网站？</p>
</li>
<li>
<p>是否了解开源的工具 bower、npm、yeoman、grunt、gulp，一个 npm 的包里的 package.json 具备的必要的字段都有哪些？（名称、版本号，依赖）</p>
</li>
<li>
<p>每个模块的代码结构都应该比较简单，且每个模块之间的关系也应该非常清晰，随着功能和迭代次数越来越多，你会如何去保持这个状态的？</p>
</li>
<li>
<p>Git知道branch, diff, merge么?</p>
</li>
<li>
<p>如何设计突发大规模并发架构？</p>
</li>
<li>
<p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p>
</li>
<li>
<p>说说最近最流行的一些东西吧？平时常去哪些网站？</p>
</li>
<li>
<p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p>
</li>
<li>
<p>移动端（Android IOS）怎么做好用户体验?</p>
</li>
<li>
<p>简单描述一下你做过的移动APP项目研发流程？</p>
</li>
<li>
<p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p>
</li>
<li>
<p>你认为怎样才是全端工程师（Full Stack developer）？</p>
</li>
<li>
<p>介绍一个你最得意的作品吧？</p>
</li>
<li>
<p>你有自己的技术博客吗，用了哪些技术？</p>
</li>
<li>
<p>对前端安全有什么看法？</p>
</li>
<li>
<p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>
</li>
<li>
<p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p>
</li>
<li>
<p>最近在学什么东西？</p>
</li>
<li>
<p>你的优点是什么？缺点是什么？</p>
</li>
<li>
<p>如何管理前端团队?</p>
</li>
<li>
<p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>React 相关问题</title>
      <link>https://0808200.xyz/Interview/base/react.html</link>
      <guid>https://0808200.xyz/Interview/base/react.html</guid>
      <source url="https://0808200.xyz/rss.xml">React 相关问题</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="react-中-keys-的作用是什么" tabindex="-1"> React 中 keys 的作用是什么？</h2>
<blockquote>
<p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p>
</blockquote>
<ul>
<li>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性</li>
</ul>
<h2 id="传入-setstate-函数的第二个参数的作用是什么" tabindex="-1"> 传入 setState 函数的第二个参数的作用是什么？</h2>
<blockquote>
<p>该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：</p>
</blockquote>
<div><pre><code>this.setState(
  { username: 'tylermcginnis33' },
  () => console.log('setState has finished and the component has re-rendered.')
)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code>this.setState((prevState, props) => {
  return {
    streak: prevState.streak + props.count
  }
})
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="react-中-refs-的作用是什么" tabindex="-1"> React 中 refs 的作用是什么</h2>
<ul>
<li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄</li>
<li>可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回</li>
</ul>
<h2 id="在生命周期中的哪一步你应该发起-ajax-请求" tabindex="-1"> 在生命周期中的哪一步你应该发起 AJAX 请求</h2>
<blockquote>
<p>我们应当将AJAX 请求放到 <code>componentDidMount</code> 函数中执行，主要原因有下</p>
</blockquote>
<ul>
<li>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</li>
<li>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题</li>
</ul>
<h2 id="shouldcomponentupdate-的作用" tabindex="-1"> shouldComponentUpdate 的作用</h2>
<blockquote>
<p>shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新</p>
</blockquote>
<h2 id="如何告诉-react-它应该编译生产环境版" tabindex="-1"> 如何告诉 React 它应该编译生产环境版</h2>
<blockquote>
<p>通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息</p>
</blockquote>
<h2 id="概述下-react-中的事件处理逻辑" tabindex="-1"> 概述下 React 中的事件处理逻辑</h2>
<blockquote>
<p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的</p>
</blockquote>
<h2 id="createelement-与-cloneelement-的区别是什么" tabindex="-1"> createElement 与 cloneElement 的区别是什么</h2>
<blockquote>
<p>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props</p>
</blockquote>
<h2 id="redux中间件" tabindex="-1"> redux中间件</h2>
<blockquote>
<p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能</p>
</blockquote>
<ul>
<li><code>redux-logger</code>：提供日志输出</li>
<li><code>redux-thunk</code>：处理异步操作</li>
<li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li>
</ul>
<h2 id="redux有什么缺点" tabindex="-1"> redux有什么缺点</h2>
<ul>
<li>一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的<code>shouldComponentUpdate</code>进行判断。</li>
</ul>
<h2 id="react组件的划分业务组件技术组件" tabindex="-1"> react组件的划分业务组件技术组件？</h2>
<ul>
<li>根据组件的职责通常把组件分为UI组件和容器组件。</li>
<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>
<li>两者通过<code>React-Redux</code> 提供<code>connect</code>方法联系起来</li>
</ul>
<h2 id="react生命周期函数" tabindex="-1"> react生命周期函数</h2>
<p><strong>初始化阶段</strong></p>
<ul>
<li><code>getDefaultProp</code>s:获取实例的默认属性</li>
<li><code>getInitialState</code>:获取每个实例的初始化状态</li>
<li><code>componentWillMount</code>：组件即将被装载、渲染到页面上</li>
<li><code>render</code>:组件在这里生成虚拟的DOM节点</li>
<li><code>omponentDidMount</code>:组件真正在被装载之后</li>
</ul>
<p><strong>运行中状态</strong></p>
<ul>
<li><code>componentWillReceiveProps</code>:组件将要接收到属性的时候调用</li>
<li><code>shouldComponentUpdate</code>:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止<code>render</code>调用，后面的函数不会被继续执行了）</li>
<li><code>componentWillUpdate</code>:组件即将更新不能修改属性和状态</li>
<li><code>render</code>:组件重新描绘</li>
<li><code>componentDidUpdate</code>:组件已经更新</li>
</ul>
<p><strong>销毁阶段</strong></p>
<ul>
<li><code>componentWillUnmount</code>:组件即将销毁</li>
</ul>
<h2 id="react性能优化是哪个周期函数" tabindex="-1"> react性能优化是哪个周期函数</h2>
<blockquote>
<p>shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</p>
</blockquote>
<h2 id="为什么虚拟dom会提高性能" tabindex="-1"> 为什么虚拟dom会提高性能</h2>
<blockquote>
<p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能</p>
</blockquote>
<p><strong>具体实现步骤如下</strong></p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新</li>
</ul>
<h2 id="diff算法" tabindex="-1"> diff算法?</h2>
<ul>
<li>把树形结构按照层级分解，只比较同级元素。</li>
<li>给列表结构的每个单元添加唯一的key属性，方便比较。</li>
<li>React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）</li>
<li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li>
<li>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能</li>
</ul>
<h2 id="react性能优化方案" tabindex="-1"> react性能优化方案</h2>
<ul>
<li>重写<code>shouldComponentUpdate</code>来避免不必要的dom操作</li>
<li>使用 production 版本的react.js</li>
<li>使用key来帮助React识别列表中所有子组件的最小变化</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器运行原理</title>
      <link>https://0808200.xyz/Interview/base/the_browser.html</link>
      <guid>https://0808200.xyz/Interview/base/the_browser.html</guid>
      <source url="https://0808200.xyz/rss.xml">浏览器运行原理</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一、事件机制" tabindex="-1"> 一、事件机制</h2>
<h3 id="_1-1-事件触发三阶段" tabindex="-1"> 1.1 事件触发三阶段</h3>
<ul>
<li>document 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 document 传播，遇到注册的冒泡事件会触发</li>
</ul>
<blockquote>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p>
</blockquote>
<div><pre><code>// 以下会先打印冒泡然后是捕获
node.addEventListener('click',(event) =>{
	console.log('冒泡')
},false);
node.addEventListener('click',(event) =>{
	console.log('捕获 ')
},true)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_1-2-注册事件" tabindex="-1"> 1.2 注册事件</h3>
<ul>
<li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> 。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li>
<li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li>
</ul>
<div><pre><code>node<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span><span>(</span><span>event</span><span>)</span> <span>=></span><span>{</span>
	event<span>.</span><span>stopImmediatePropagation</span><span>(</span><span>)</span>
	console<span>.</span><span>log</span><span>(</span><span>'冒泡'</span><span>)</span>
<span>}</span><span>,</span><span>false</span><span>)</span><span>;</span>
<span>// 点击 node 只会执行上面的函数，该函数不会执行</span>
node<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span><span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>
	console<span>.</span><span>log</span><span>(</span><span>'捕获 '</span><span>)</span>
<span>}</span><span>,</span><span>true</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_1-3-事件代理" tabindex="-1"> 1.3 事件代理</h3>
<blockquote>
<p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>id</span><span><span>=</span><span>"</span>ul<span>"</span></span><span>></span></span>
	<span><span><span>&lt;</span>li</span><span>></span></span>1<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span>2<span><span><span>&lt;/</span>li</span><span>></span></span>
	<span><span><span>&lt;</span>li</span><span>></span></span>3<span><span><span>&lt;/</span>li</span><span>></span></span>
	<span><span><span>&lt;</span>li</span><span>></span></span>4<span><span><span>&lt;/</span>li</span><span>></span></span>
	<span><span><span>&lt;</span>li</span><span>></span></span>5<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
	<span>let</span> ul <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'##ul'</span><span>)</span>
	ul<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span>event<span>.</span>target<span>)</span><span>;</span>
	<span>}</span><span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p>
</blockquote>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h2 id="二、跨域" tabindex="-1"> 二、跨域</h2>
<blockquote>
<p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败</p>
</blockquote>
<h3 id="_2-1-jsonp" tabindex="-1"> 2.1 JSONP</h3>
<blockquote>
<p>JSONP 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    <span>function</span> <span>jsonp</span><span>(</span><span>data</span><span>)</span> <span>{</span>
    	console<span>.</span><span>log</span><span>(</span>data<span>)</span>
	<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>JSONP 使用简单且兼容性不错，但是只限于 get 请求</li>
</ul>
<h3 id="_2-2-cors" tabindex="-1"> 2.2 CORS</h3>
<ul>
<li><code>CORS</code>需要浏览器和后端同时支持</li>
<li>浏览器会自动进行 <code>CORS</code> 通信，实现CORS通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li>
<li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</li>
</ul>
<h3 id="_2-3-document-domain" tabindex="-1"> 2.3 document.domain</h3>
<ul>
<li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li>
<li>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</li>
</ul>
<h3 id="_2-4-postmessage" tabindex="-1"> 2.4 postMessage</h3>
<blockquote>
<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
</blockquote>
<div><pre><code><span>// 发送消息端</span>
window<span>.</span>parent<span>.</span><span>postMessage</span><span>(</span><span>'message'</span><span>,</span> <span>'http://test.com'</span><span>)</span><span>;</span>

<span>// 接收消息端</span>
<span>var</span> mc <span>=</span> <span>new</span> <span>MessageChannel</span><span>(</span><span>)</span><span>;</span>
mc<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>
    <span>var</span> origin <span>=</span> event<span>.</span>origin <span>||</span> event<span>.</span>originalEvent<span>.</span>origin<span>;</span> 
    <span>if</span> <span>(</span>origin <span>===</span> <span>'http://test.com'</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'验证通过'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="三、event-loop" tabindex="-1"> 三、Event loop</h2>
<h3 id="_3-1-js中的event-loop" tabindex="-1"> 3.1 JS中的event loop</h3>
<blockquote>
<p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p>
</blockquote>
<ul>
<li>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为</li>
</ul>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'script start'</span><span>)</span><span>;</span>

<span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>'script end'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p>
</blockquote>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'script start'</span><span>)</span><span>;</span>

<span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>

<span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Promise'</span><span>)</span>
    <span>resolve</span><span>(</span><span>)</span>
<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'promise1'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'promise2'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>'script end'</span><span>)</span><span>;</span>
<span>// script start => Promise => script end => promise1 => promise2 => setTimeout</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p>
</blockquote>
<p><strong>微任务</strong></p>
<ul>
<li><code>process.nextTick</code></li>
<li><code>promise</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code></li>
</ul>
<p><strong>宏任务</strong></p>
<ul>
<li><code>script </code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval </code></li>
<li><code>setImmediate </code></li>
<li><code>I/O </code></li>
<li><code>UI rendering</code></li>
</ul>
<blockquote>
<p>宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p>
</blockquote>
<p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li>
</ul>
<blockquote>
<p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p>
</blockquote>
<h3 id="_3-2-node-中的-event-loop" tabindex="-1"> 3.2 Node 中的 Event loop</h3>
<ul>
<li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li>
<li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li>
</ul>
<div><pre><code>┌───────────────────────┐
┌─<span>></span>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     <span>I</span><span>/</span><span>O</span> callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle<span>,</span> prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming<span>:</span>   │
│  │         poll          │<span>&lt;</span>──connections───     │
│  └──────────┬────────────┘      │   data<span>,</span> etc<span>.</span>  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>timer</strong></p>
<ul>
<li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li>
<li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li>
</ul>
<p><strong>I/O</strong></p>
<ul>
<li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li>
</ul>
<p>idle, prepare
idle, prepare 阶段内部实现</p>
<p><strong>poll</strong></p>
<ul>
<li>
<p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p>
<ul>
<li>执行到点的定时器</li>
<li>执行 <code>poll</code> 队列中的事件</li>
</ul>
</li>
<li>
<p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li>
<li>如果 poll 队列为空，会有两件事发生</li>
<li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li>
<li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li>
<li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li>
</ul>
</li>
</ul>
<p><strong>check</strong></p>
<ul>
<li><code>check</code> 阶段执行 <code>setImmediate</code></li>
</ul>
<p><strong>close callbacks</strong></p>
<ul>
<li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li>
<li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li>
</ul>
<div><pre><code><span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>setImmediate</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'setImmediate'</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
<span>// 这里可能会输出 setTimeout，setImmediate</span>
<span>// 可能也会相反的输出，这取决于性能</span>
<span>// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span>
<span>// 否则会执行 setTimeout</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行</p>
</blockquote>
<div><pre><code><span>setTimeout</span><span>(</span><span>(</span><span>)</span><span>=></span><span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'timer1'</span><span>)</span>

    Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'promise1'</span><span>)</span>
    <span>}</span><span>)</span>
<span>}</span><span>,</span> <span>0</span><span>)</span>

<span>setTimeout</span><span>(</span><span>(</span><span>)</span><span>=></span><span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'timer2'</span><span>)</span>

    Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'promise2'</span><span>)</span>
    <span>}</span><span>)</span>
<span>}</span><span>,</span> <span>0</span><span>)</span>

<span>// 以上代码在浏览器和 node 中打印情况是不同的</span>
<span>// 浏览器中一定打印 timer1, promise1, timer2, promise2</span>
<span>// node 中可能打印 timer1, timer2, promise1, promise2</span>
<span>// 也可能打印 timer1, promise1, timer2, promise2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p>
</blockquote>
<div><pre><code><span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
 console<span>.</span><span>log</span><span>(</span><span>"timer1"</span><span>)</span><span>;</span>

 Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
   console<span>.</span><span>log</span><span>(</span><span>"promise1"</span><span>)</span><span>;</span>
 <span>}</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>

process<span>.</span><span>nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
 console<span>.</span><span>log</span><span>(</span><span>"nextTick"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>// nextTick, timer1, promise1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="四、service-worker" tabindex="-1"> 四、Service Worker</h2>
<blockquote>
<p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</p>
</blockquote>
<p><strong>目前该技术通常用来做缓存文件，提高首屏速度</strong></p>
<div><pre><code><span>// index.js</span>
<span>if</span> <span>(</span>navigator<span>.</span>serviceWorker<span>)</span> <span>{</span>
  navigator<span>.</span>serviceWorker
    <span>.</span><span>register</span><span>(</span><span>"sw.js"</span><span>)</span>
    <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>registration</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>"service worker 注册成功"</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>
    <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>"servcie worker 注册失败"</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span>
<span>// sw.js</span>
<span>// 监听 `install` 事件，回调中缓存所需文件</span>
self<span>.</span><span>addEventListener</span><span>(</span><span>"install"</span><span>,</span> <span>e</span> <span>=></span> <span>{</span>
  e<span>.</span><span>waitUntil</span><span>(</span>
    caches<span>.</span><span>open</span><span>(</span><span>"my-cache"</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>cache</span><span>)</span> <span>{</span>
      <span>return</span> cache<span>.</span><span>addAll</span><span>(</span><span>[</span><span>"./index.html"</span><span>,</span> <span>"./index.js"</span><span>]</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>
  <span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 拦截所有请求事件</span>
<span>// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span>
self<span>.</span><span>addEventListener</span><span>(</span><span>"fetch"</span><span>,</span> <span>e</span> <span>=></span> <span>{</span>
  e<span>.</span><span>respondWith</span><span>(</span>
    caches<span>.</span><span>match</span><span>(</span>e<span>.</span>request<span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>response</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>response<span>)</span> <span>{</span>
        <span>return</span> response<span>;</span>
      <span>}</span>
      console<span>.</span><span>log</span><span>(</span><span>"fetch source"</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>
  <span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?w=1770&amp;h=722&amp;f=png&amp;s=192277" alt=""></p>
<blockquote>
<p>在 Cache 中也可以发现我们所需的文件已被缓存</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26?w=1118&amp;h=728&amp;f=png&amp;s=85610" alt=""></p>
<p>当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的</p>
<h2 id="五、渲染机制" tabindex="-1"> 五、渲染机制</h2>
<p><strong>浏览器的渲染机制一般分为以下几个步骤</strong></p>
<ul>
<li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li>
<li>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</li>
<li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/11/162b2ab2ec70ac5b?w=900&amp;h=352&amp;f=png&amp;s=49983" alt=""></p>
<ul>
<li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</li>
<li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM</li>
</ul>
<h3 id="_5-1-图层" tabindex="-1"> 5.1 图层</h3>
<blockquote>
<p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用</p>
</blockquote>
<p><strong>通过以下几个常用属性可以生成新图层</strong></p>
<ul>
<li>3D 变换：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>will-change</code></li>
<li><code>video</code>、<code>iframe</code> 标签</li>
<li>通过动画实现的 <code>opacity</code> 动画转换</li>
<li><code>position: fixed</code></li>
</ul>
<h3 id="_5-2-重绘-repaint-和回流-reflow" tabindex="-1"> 5.2 重绘（Repaint）和回流（Reflow）</h3>
<ul>
<li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li>
<li>回流是布局或者几何属性需要改变就称为回流</li>
</ul>
<blockquote>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p>
</blockquote>
<p><strong>所以以下几个动作可能会导致性能问题</strong>：</p>
<ul>
<li>改变 window 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p>
<ul>
<li>当 Event loop 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz </code>的刷新率，每 <code>16ms </code>才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了<code> media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code> 回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li>
</ul>
<p><strong>减少重绘和回流</strong></p>
<ul>
<li>使用 <code>translate</code> 替代 <code>top</code></li>
<li>使用 <code>visibility</code> 替换<code> display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video </code>标签，浏览器会自动将该节点变为图层</li>
</ul>
]]></content:encoded>
      <enclosure url="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?w=1770&h=722&f=png&s=192277" type="image/"/>
    </item>
    <item>
      <title>前端错误监控</title>
      <link>https://0808200.xyz/Interview/base/the_frontend_monitoring_errors.html</link>
      <guid>https://0808200.xyz/Interview/base/the_frontend_monitoring_errors.html</guid>
      <source url="https://0808200.xyz/rss.xml">前端错误监控</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-前言" tabindex="-1"> 1 前言</h2>
<blockquote>
<p>错误监控包含的内容是：</p>
</blockquote>
<ul>
<li>前端错误的分类</li>
<li>每种错误的捕获方式</li>
<li>上报错误的基本原理</li>
</ul>
<blockquote>
<p>面试时，可能有两种问法：</p>
</blockquote>
<ul>
<li>如何监测 <code>js</code> 错误？（开门见山的方式）</li>
<li>如何保证<strong>产品质量</strong>？（其实问的也是错误监控）</li>
</ul>
<h2 id="_2-前端错误的分类" tabindex="-1"> 2 前端错误的分类</h2>
<p>包括两种：</p>
<ul>
<li>即时运行错误（代码错误）</li>
<li>资源加载错误</li>
</ul>
<h2 id="_3-每种错误的捕获方式" tabindex="-1"> 3 每种错误的捕获方式</h2>
<h3 id="_3-1-即时运行错误的捕获方式" tabindex="-1"> 3.1 即时运行错误的捕获方式</h3>
<p><strong>方式1</strong>：<code>try ... catch</code>。</p>
<blockquote>
<p>这种方式要部署在代码中。</p>
</blockquote>
<p><strong>方式2：</strong><code>window.onerror</code>函数。这个函数是全局的。</p>
<div><pre><code>	window<span>.</span><span>onerror</span> <span>=</span> <span>function</span><span>(</span><span>msg<span>,</span> url<span>,</span> row<span>,</span> col<span>,</span> error</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>参数解释：</p>
</blockquote>
<ul>
<li><code>msg</code>为异常基本信息</li>
<li><code>source</code>为发生异常<code>Javascript</code>文件的<code>url</code></li>
<li><code>row</code>为发生错误的行号</li>
</ul>
<blockquote>
<p>方式二中的<code>window.onerror</code>是属于DOM0的写法，我们也可以用DOM2的写法：<code>window.addEventListener(&quot;error&quot;, fn);</code>也可以。</p>
</blockquote>
<p><strong>问题延伸1：</strong></p>
<p><code>window.onerror</code>默认无法捕获<strong>跨域</strong>的<code>js</code>运行错误。捕获出来的信息如下：（基本属于无效信息）</p>
<blockquote>
<p>比如说，我们的代码想引入<code>B</code>网站的<code>b.js</code>文件，怎么捕获它的异常呢？</p>
</blockquote>
<p><strong>解决办法</strong>：在方法二的基础之上，做如下操作：</p>
<ol>
<li>在<code>b.js</code>文件里，加入如下 <code>response</code> <code>header</code>，表示允许跨域：（或者世界给静态资源<code>b.js</code>加这个 response header）</li>
</ol>
<div><pre><code>	Access<span>-</span>Control<span>-</span>Allow<span>-</span>Origin<span>:</span> <span>*</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ol start="2">
<li>引入第三方的文件<code>b.js</code>时，在<code>&lt;script&gt;</code>标签中增加<code>crossorigin</code>属性；</li>
</ol>
<p><strong>问题延伸2：</strong></p>
<blockquote>
<p>只靠方式二中的<code>window.onerror</code>是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把<strong>堆栈</strong>信息作为msg打印出来，堆栈里很详细。</p>
</blockquote>
<h3 id="_3-2-资源加载错误的捕获方式" tabindex="-1"> 3.2 资源加载错误的捕获方式</h3>
<blockquote>
<p>上面的<code>window.onerror</code>只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，<code>object.onerror</code>捕获后就会终止（不会冒泡给<code>window</code>），所以<code>window.onerror</code>并不能捕获资源加载错误。</p>
</blockquote>
<ul>
<li><strong>方式1</strong>：<code>object.onerror</code>。<code>img</code>标签、<code>script</code>标签等节点都可以添加<code>onerror</code>事件，用来捕获资源加载的错误。</li>
<li><strong>方式2</strong>：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。</li>
</ul>
<p>举例：</p>
<blockquote>
<p>浏览器打开一个网站，在<code>Console</code>控制台下，输入：</p>
</blockquote>
<div><pre><code>	performance<span>.</span><span>getEntries</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>item</span><span>)</span><span>{</span>console<span>.</span><span>log</span><span>(</span>item<span>.</span>name<span>)</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>或者输入：</p>
<div><pre><code>	performance<span>.</span><span>getEntries</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>item</span><span>=></span><span>{</span>console<span>.</span><span>log</span><span>(</span>item<span>.</span>name<span>)</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>上面这个<code>api</code>，返回的是数组，既然是数组，就可以用<code>forEach</code>遍历。打印出来的资源就是<strong>已经成功加载</strong>的资源。；</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180311_2030.png" alt=""></p>
<blockquote>
<p>再入<code>document.getElementsByTagName('img')</code>，就会显示出所有<strong>需要加载</strong>的的img集合。</p>
</blockquote>
<blockquote>
<p>于是，<code>document.getElementsByTagName('img')</code>获取的资源数组减去通过<code>performance.getEntries()</code>获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。</p>
</blockquote>
<p>这种方式非常有用，一定要记住。</p>
<p>**方式3；**Error事件捕获。</p>
<blockquote>
<p>源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180311_2040.png" alt=""></p>
<blockquote>
<p>**总结：**如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。</p>
</blockquote>
<h2 id="_4-错误上报的两种方式" tabindex="-1"> 4 错误上报的两种方式</h2>
<ul>
<li><strong>方式一</strong>：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式）</li>
<li>**方式二：**利用Image对象上报（推荐。网站的监控体系都是采用的这种方式）</li>
</ul>
<blockquote>
<p>方式二的实现方式如下：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Title<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
	<span>//通过Image对象进行错误上报</span>
    <span>(</span><span>new</span> <span>Image</span><span>(</span><span>)</span><span>)</span><span>.</span>src <span>=</span> <span>'http://smyhvae.com/myPath?badjs=msg'</span><span>;</span>   <span>// myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>打开浏览器，效果如下：</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180311_2055.png" alt=""></p>
<p>上图中，红色那一栏表明，我的请求已经发出去了。点进去看看：</p>
<p><img src="http://img.smyhvae.com/20180311_2057.png" alt=""></p>
<blockquote>
<p>这种方式，不需要借助第三方的库，一行代码即可搞定。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180311_2030.png" type="image/png"/>
    </item>
    <item>
      <title>面试精简版本</title>
      <link>https://0808200.xyz/Interview/base/the_interview_questions_lite_version.html</link>
      <guid>https://0808200.xyz/Interview/base/the_interview_questions_lite_version.html</guid>
      <source url="https://0808200.xyz/rss.xml">面试精简版本</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一、css相关" tabindex="-1"> 一、CSS相关</h2>
<h3 id="_1-1-左边定宽-右边自适应方案-float-margin-float-calc" tabindex="-1"> 1.1 左边定宽，右边自适应方案：float + margin，float + calc</h3>
<div><pre><code><span>/* 方案1 */</span> 
<span>.left</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>
<span>.right</span> <span>{</span>
  <span>margin-left</span><span>:</span> 120px<span>;</span>
<span>}</span>
<span>/* 方案2 */</span> 
<span>.left</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>
<span>.right</span> <span>{</span>
  <span>width</span><span>:</span> <span>calc</span><span>(</span>100% - 120px<span>)</span><span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_1-2-左右两边定宽-中间自适应-float-float-calc-圣杯布局-设置bfc-margin负值法-flex" tabindex="-1"> 1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex</h3>
<div><pre><code><span>.wrap</span> <span>{</span>
  <span>width</span><span>:</span> 100%<span>;</span>
  <span>height</span><span>:</span> 200px<span>;</span>
<span>}</span>
<span>.wrap > div</span> <span>{</span>
  <span>height</span><span>:</span> 100%<span>;</span>
<span>}</span>
<span>/* 方案1 */</span>
<span>.left</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>
<span>.right</span> <span>{</span>
  <span>float</span><span>:</span> right<span>;</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>
<span>.center</span> <span>{</span>
  <span>margin</span><span>:</span> 0 120px<span>;</span> 
<span>}</span>
<span>/* 方案2 */</span>
<span>.left</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>
<span>.right</span> <span>{</span>
  <span>float</span><span>:</span> right<span>;</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>
<span>.center</span> <span>{</span>
  <span>width</span><span>:</span> <span>calc</span><span>(</span>100% - 240px<span>)</span><span>;</span>
  <span>margin-left</span><span>:</span> 120px<span>;</span>
<span>}</span>
<span>/* 方案3 */</span>
<span>.wrap</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>
<span>.left</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>
<span>.right</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>
<span>.center</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_1-3-左右居中" tabindex="-1"> 1.3 左右居中</h3>
<ul>
<li>行内元素: <code>text-align: center</code></li>
<li>定宽块状元素: 左右 <code>margin</code> 值为 <code>auto</code></li>
<li>不定宽块状元素: <code>table</code>布局，<code>position + transform</code></li>
</ul>
<div><pre><code><span>/* 方案1 */</span>
<span>.wrap</span> <span>{</span>
  <span>text-align</span><span>:</span> center
<span>}</span>
<span>.center</span> <span>{</span>
  <span>display</span><span>:</span> inline<span>;</span>
  <span>/* or */</span>
  <span>/* display: inline-block; */</span>
<span>}</span>
<span>/* 方案2 */</span>
<span>.center</span> <span>{</span>
  <span>width</span><span>:</span> 100px<span>;</span>
  <span>margin</span><span>:</span> 0 auto<span>;</span>
<span>}</span>
<span>/* 方案2 */</span>
<span>.wrap</span> <span>{</span>
  <span>position</span><span>:</span> relative<span>;</span>
<span>}</span>
<span>.center</span> <span>{</span>
  <span>position</span><span>:</span> absulote<span>;</span>
  <span>left</span><span>:</span> 50%<span>;</span>
  <span>transform</span><span>:</span> <span>translateX</span><span>(</span>-50%<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_1-4-上下垂直居中" tabindex="-1"> 1.4 上下垂直居中</h3>
<ul>
<li>定高：<code>margin</code>，<code>position + margin</code>(负值)</li>
<li>不定高：<code>position</code> + <code>transform</code>，<code>flex</code>，<code>IFC + vertical-align:middle</code></li>
</ul>
<div><pre><code><span>/* 定高方案1 */</span>
<span>.center</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
  <span>margin</span><span>:</span> 50px 0<span>;</span>   
<span>}</span>
<span>/* 定高方案2 */</span>
<span>.center</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
  <span>position</span><span>:</span> absolute<span>;</span>
  <span>top</span><span>:</span> 50%<span>;</span>
  <span>margin-top</span><span>:</span> -25px<span>;</span>
<span>}</span>
<span>/* 不定高方案1 */</span>
<span>.center</span> <span>{</span>
  <span>position</span><span>:</span> absolute<span>;</span>
  <span>top</span><span>:</span> 50%<span>;</span>
  <span>transform</span><span>:</span> <span>translateY</span><span>(</span>-50%<span>)</span><span>;</span>
<span>}</span>
<span>/* 不定高方案2 */</span>
<span>.wrap</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>align-items</span><span>:</span> center<span>;</span>
<span>}</span>
<span>.center</span> <span>{</span>
  <span>width</span><span>:</span> 100%<span>;</span>
<span>}</span>
<span>/* 不定高方案3 */</span>
<span>/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */</span>
<span>.wrap::before</span> <span>{</span>
  <span>content</span><span>:</span> <span>''</span><span>;</span>
  <span>height</span><span>:</span> 100%<span>;</span>
  <span>display</span><span>:</span> inline-block<span>;</span>
  <span>vertical-align</span><span>:</span> middle<span>;</span>
<span>}</span>
<span>.wrap</span> <span>{</span>
  <span>text-align</span><span>:</span> center<span>;</span>
<span>}</span>
<span>.center</span> <span>{</span>
  <span>display</span><span>:</span> inline-block<span>;</span>  
  <span>vertical-align</span><span>:</span> middle<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_1-5-盒模型-content-元素内容-padding-内边距-border-边框-margin-外边距" tabindex="-1"> 1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</h3>
<blockquote>
<p>延伸： <code>box-sizing</code></p>
</blockquote>
<ul>
<li><code>content-box</code>：默认值，总宽度 = <code>margin</code> + <code>border</code> + <code>padding</code> + <code>width</code></li>
<li><code>border-box</code>：盒子宽度包含 <code>padding</code> 和 <code>border</code>，<code>总宽度 = margin + width</code></li>
<li><code>inherit</code>：从父元素继承 <code>box-sizing</code> 属性</li>
</ul>
<h3 id="_1-6-bfc、ifc、gfc、ffc-fc-formatting-contexts-格式化上下文" tabindex="-1"> 1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文</h3>
<blockquote>
<p><code>BFC</code>：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 <code>BFC</code>)。产生 <code>BFC</code> 方式如下</p>
</blockquote>
<ul>
<li><code>float</code> 的值不为 <code>none</code>。</li>
<li><code>overflow</code> 的值不为 <code>visible</code>。</li>
<li><code>position</code> 的值不为 <code>relative</code> 和 <code>static</code>。</li>
<li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code>中的任何一个</li>
</ul>
<blockquote>
<p>用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行</p>
</blockquote>
<blockquote>
<p><code>IFC</code>：内联格式化上下文，<code>IFC</code> 的 <code>line</code> <code>box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p>
</blockquote>
<blockquote>
<p><code>IFC</code>中的<code>line box</code>一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 IFC 与 <code>line box</code> 之间，使得 <code>line box</code> 宽度缩短。 同个 <code>ifc</code> 下的多个 <code>line box</code> 高度会不同。 <code>IFC</code>中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div </code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code> ，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</p>
</blockquote>
<p>用处？</p>
<ul>
<li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生<code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li>
<li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align</code>: <code>middle</code>，其他行内元素则可以在此父元素下垂直居中</li>
</ul>
<blockquote>
<ul>
<li><strong>GFC</strong>：网格布局格式化上下文（<code>display: grid</code>）</li>
<li><strong>FFC</strong>：自适应格式化上下文（<code>display: flex</code>）</li>
</ul>
</blockquote>
<h2 id="二、js-基础-es5" tabindex="-1"> 二、JS 基础（ES5）</h2>
<h3 id="_2-1-原型" tabindex="-1"> 2.1 原型</h3>
<blockquote>
<p>这里可以谈很多，只要围绕 <code>[[ prototype ]]</code> 谈，都没啥问题</p>
</blockquote>
<h3 id="_2-2-闭包" tabindex="-1"> 2.2 闭包</h3>
<blockquote>
<p>牵扯作用域，可以两者联系起来一起谈</p>
</blockquote>
<h3 id="_2-3-作用域" tabindex="-1"> 2.3 作用域</h3>
<blockquote>
<p>词法作用域，动态作用域</p>
</blockquote>
<h3 id="_2-4-this" tabindex="-1"> 2.4 this</h3>
<blockquote>
<p>不同情况的调用，<code>this</code>指向分别如何。顺带可以提一下 <code>es6</code> 中箭头函数没有 <code>this</code>, <code>arguments</code>, <code>super</code> 等，这些只依赖包含箭头函数最接近的函数</p>
</blockquote>
<h3 id="_2-5-call-apply-bind-三者用法和区别" tabindex="-1"> 2.5 call，apply，bind 三者用法和区别</h3>
<blockquote>
<p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（<code>call</code>，<code>apply</code> 立即执行，<code>bind</code> 是<code>return</code> 出一个 <code>this</code> “固定”的函数，这也是为什么 <code>bind</code> 是强绑定的一个原因）</p>
</blockquote>
<blockquote>
<p>注：“固定”这个词的含义，它指的固定是指只要传进去了 <code>context</code>，则 <code>bind</code> 中 <code>return</code> 出来的函数 <code>this</code> 便一直指向 <code>context</code>，除非 <code>context</code> 是个变量</p>
</blockquote>
<h3 id="_2-6-变量声明提升" tabindex="-1"> 2.6 变量声明提升</h3>
<blockquote>
<p><code>js</code> 代码在运行前都会进行 <code>AST</code> 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 <code>AST</code> 解析，这里也可以说是形成词法作用域的主要原因</p>
</blockquote>
<h2 id="三、js-基础-es6" tabindex="-1"> 三、JS 基础（ES6）</h2>
<h3 id="_3-1-let-const" tabindex="-1"> 3.1 let，const</h3>
<blockquote>
<p><code>let</code> 产生块级作用域（通常配合 <code>for</code> 循环或者 <code>{}</code> 进行使用产生块级作用域），<code>const</code> 申明的变量是常量（内存地址不变）</p>
</blockquote>
<h3 id="_3-2-promise" tabindex="-1"> 3.2 Promise</h3>
<blockquote>
<p>这里你谈 <code>promise</code>的时候，除了将他解决的痛点以及常用的 <code>API</code> 之外，最好进行拓展把 <code>eventloop</code> 带进来好好讲一下，<code>microtask</code>(微任务)、<code>macrotask</code>(任务) 的执行顺序，如果看过 <code>promise</code> 源码，最好可以谈一谈 原生 <code>Promise</code> 是如何实现的。<code>Promise</code> 的关键点在于<code>callback</code> 的两个参数，一个是 <code>resovle</code>，一个是 <code>reject</code>。还有就是 <code>Promise</code> 的链式调用（<code>Promise.then()</code>，每一个 <code>then</code> 都是一个责任人）</p>
</blockquote>
<h3 id="_3-3-generator" tabindex="-1"> 3.3 Generator</h3>
<blockquote>
<p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p>
</blockquote>
<ul>
<li><code>function</code> 关键字与函数名之间有一个星号；</li>
<li>函数体内部使用 <code>yield</code>表达式，定义不同的内部状态；</li>
<li><code>next </code>指针移向下一个状态</li>
</ul>
<blockquote>
<p>这里你可以说说 <code>Generator</code>的异步编程，以及它的语法糖 <code>async</code> 和 <code>awiat</code>，传统的异步编程。<code>ES6</code> 之前，异步编程大致如下</p>
</blockquote>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
</ul>
<blockquote>
<p>传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。</p>
</blockquote>
<h3 id="_3-4-async、await" tabindex="-1"> 3.4 async、await</h3>
<blockquote>
<p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p>
</blockquote>
<ul>
<li><code>async =&gt; *</code></li>
<li><code>await =&gt; yield</code></li>
</ul>
<div><pre><code><span>// 基本用法</span>

<span>async</span> <span>function</span> <span>timeout</span> <span>(</span><span>ms</span><span>)</span> <span>{</span>
  <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span>resolve<span>,</span> ms<span>)</span>    
  <span>}</span><span>)</span>
<span>}</span>
<span>async</span> <span>function</span> <span>asyncConsole</span> <span>(</span><span>value<span>,</span> ms</span><span>)</span> <span>{</span>
  <span>await</span> <span>timeout</span><span>(</span>ms<span>)</span>
  console<span>.</span><span>log</span><span>(</span>value<span>)</span>
<span>}</span>
<span>asyncConsole</span><span>(</span><span>'hello async and await'</span><span>,</span> <span>1000</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>注：最好把2，3，4 连到一起讲</p>
</blockquote>
<h3 id="_3-5-amd-cmd-commonjs-es6-module-解决原始无模块化的痛点" tabindex="-1"> 3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点</h3>
<ul>
<li><strong>AMD</strong>：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li>
<li><strong>CMD</strong>：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li>
<li><strong>CommonJs</strong>：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li>
<li><strong>ES6 Module</strong>：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<h2 id="四、框架相关" tabindex="-1"> 四、框架相关</h2>
<h3 id="_4-1-数据双向绑定原理-常见数据绑定的方案" tabindex="-1"> 4.1 数据双向绑定原理：常见数据绑定的方案</h3>
<ul>
<li><code>Object.defineProperty（vue）</code>：劫持数据的 <code>getter</code> 和 <code>setter</code></li>
<li>脏值检测（<code>angularjs</code>）：通过特定事件进行轮循
发布/订阅模式：通过消息发布并将消息进行订阅</li>
</ul>
<h3 id="_4-2-vdom-三个-part" tabindex="-1"> 4.2 VDOM：三个 part</h3>
<ul>
<li>虚拟节点类，将真实 <code>DOM </code>节点用 <code>js</code> 对象的形式进行展示，并提供 <code>render</code> 方法，将虚拟节点渲染成真实 <code>DOM</code></li>
<li>节点 <code>diff</code> 比较：对虚拟节点进行 <code>js</code> 层面的计算，并将不同的操作都记录到 <code>patch</code> 对象</li>
<li><code>re-render</code>：解析 <code>patch</code> 对象，进行 <code>re-render</code></li>
</ul>
<p><strong>补充1：VDOM 的必要性？</strong></p>
<ul>
<li><strong>创建真实DOM的代价高</strong>：真实的 <code>DOM</code> 节点 <code>node</code> 实现的属性很多，而 <code>vnode</code> 仅仅实现一些必要的属性，相比起来，创建一个 <code>vnode</code> 的成本比较低。</li>
<li><strong>触发多次浏览器重绘及回流</strong>：使用 <code>vnode</code> ，相当于加了一个缓冲，让一次数据变动所带来的所有 <code>node</code> 变化，先在 <code>vnode</code> 中进行修改，然后 <code>diff</code> 之后对所有产生差异的节点集中一次对 <code>DOM tree</code> 进行修改，以减少浏览器的重绘及回流。</li>
</ul>
<p><strong>补充2：vue 为什么采用 vdom？</strong></p>
<blockquote>
<p>引入 <code>Virtual DOM</code> 在性能方面的考量仅仅是一方面。</p>
</blockquote>
<ul>
<li>性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 <code>Virtual DOM</code> 哪个的性能更好还真不是一个容易下定论的问题。</li>
<li><code>Vue</code> 之所以引入了 <code>Virtual DOM</code>，更重要的原因是为了解耦 <code>HTML</code>依赖，这带来两个非常重要的好处是：</li>
</ul>
<blockquote>
<ul>
<li>不再依赖 <code>HTML</code> 解析器进行模版解析，可以进行更多的 <code>AOT</code> 工作提高运行时效率：通过模版 <code>AOT</code> 编译，<code>Vue</code> 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</li>
<li>可以渲染到 <code>DOM</code> 以外的平台，实现 <code>SSR</code>、同构渲染这些高级特性，<code>Weex</code>等框架应用的就是这一特性。</li>
</ul>
</blockquote>
<blockquote>
<p>综上，<code>Virtual DOM</code> 在性能上的收益并不是最主要的，更重要的是它使得 <code>Vue</code> 具备了现代框架应有的高级特性。</p>
</blockquote>
<h3 id="_4-3-vue-和-react-区别" tabindex="-1"> 4.3 vue 和 react 区别</h3>
<ul>
<li>相同点：都支持 <code>ssr</code>，都有 <code>vdom</code>，组件化开发，实现 <code>webComponents</code> 规范，数据驱动等</li>
<li>不同点：<code>vue</code> 是双向数据流（当然为了实现单数据流方便管理组件状态，<code>vuex</code> 便出现了），<code>react</code> 是单向数据流。<code>vue </code>的 <code>vdom</code> 是追踪每个组件的依赖关系，不会渲染整个组件树，<code>react</code> 每当应该状态被改变时，全部子组件都会 <code>re-render</code></li>
</ul>
<h3 id="_4-4-为什么用-vue" tabindex="-1"> 4.4 为什么用 vue</h3>
<blockquote>
<p>简洁、轻快、舒服</p>
</blockquote>
<h2 id="五、网络基础类" tabindex="-1"> 五、网络基础类</h2>
<h3 id="_5-1-跨域" tabindex="-1"> 5.1 跨域</h3>
<blockquote>
<p>很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 <code>jsonp</code>、<code>iframe</code>、<code>cors</code>、<code>img</code>、H<code>TML5 postMessage</code>等等。其中用到 <code>html</code> 标签进行跨域的原理就是 <code>html</code> 不受同源策略影响。但只是接受 <code>Get</code> 的请求方式，这个得清楚。</p>
</blockquote>
<blockquote>
<p><strong>延伸1：img iframe script 来发送跨域请求有什么优缺点？</strong></p>
</blockquote>
<p><strong>1. <code>iframe</code></strong></p>
<ul>
<li>优点：跨域完毕之后<code>DOM</code>操作和互相之间的<code>JavaScript</code>调用都是没有问题的</li>
<li>缺点：1.若结果要以<code>URL</code>参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是<code>iframe</code>本身带来的，母页面和<code>iframe</code>本身的交互本身就有安全性限制。</li>
</ul>
<p><strong>2. script</strong></p>
<ul>
<li>优点：可以直接返回<code>json</code>格式的数据，方便处理</li>
<li>缺点：只接受<code>GET</code>请求方式</li>
</ul>
<p><strong>3. 图片ping</strong></p>
<ul>
<li>优点：可以访问任何<code>url</code>，一般用来进行点击追踪，做页面分析常用的方法</li>
<li>缺点：不能访问响应文本，只能监听是否响应</li>
</ul>
<blockquote>
<p><strong>延伸2：配合 webpack 进行反向代理？</strong></p>
</blockquote>
<p><code>webpack</code> 在 <code>devServer</code> 选项里面提供了一个 <code>proxy</code> 的参数供开发人员进行反向代理</p>
<div><pre><code><span>'/api'</span><span>:</span> <span>{</span>
  <span>target</span><span>:</span> <span>'http://www.example.com'</span><span>,</span> <span>// your target host</span>
  <span>changeOrigin</span><span>:</span> <span>true</span><span>,</span> <span>// needed for virtual hosted sites</span>
  <span>pathRewrite</span><span>:</span> <span>{</span>
    <span>'^/api'</span><span>:</span> <span>''</span>  <span>// rewrite path</span>
  <span>}</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>然后再配合 <code>http-proxy-middleware</code> 插件对 <code>api</code> 请求地址进行代理</p>
</blockquote>
<div><pre><code><span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>const</span> proxy <span>=</span> <span>require</span><span>(</span><span>'http-proxy-middleware'</span><span>)</span><span>;</span>
<span>// proxy api requests</span>
<span>const</span> exampleProxy <span>=</span> <span>proxy</span><span>(</span>options<span>)</span><span>;</span> <span>// 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项</span>

<span>// mount `exampleProxy` in web server</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span><span>'/api'</span><span>,</span> exampleProxy<span>)</span><span>;</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>然后再用 <code>nginx</code> 把允许跨域的源地址添加到报头里面即可</p>
</blockquote>
<blockquote>
<p>说到 <code>nginx</code> ，可以再谈谈 <code>CORS</code> 配置，大致如下</p>
</blockquote>
<div><pre><code>location <span>/</span> <span>{</span>
  <span>if</span> <span>(</span>$request_method <span>=</span> <span>'OPTIONS'</span><span>)</span> <span>{</span>
    add_header <span>'Access-Control-Allow-Origin'</span> <span>'*'</span><span>;</span>  
    add_header <span>'Access-Control-Allow-Methods'</span> <span>'GET, POST, OPTIONS'</span><span>;</span> 
    add_header <span>'Access-Control-Allow-Credentials'</span> <span>'true'</span><span>;</span>
    add_header <span>'Access-Control-Allow-Headers'</span> <span>'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'</span><span>;</span>  
    add_header <span>'Access-Control-Max-Age'</span> <span>86400</span><span>;</span>  
    add_header <span>'Content-Type'</span> <span>'text/plain charset=UTF-8'</span><span>;</span>  
    add_header <span>'Content-Length'</span> <span>0</span><span>;</span>  
    <span>return</span> <span>200</span><span>;</span>  
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_5-2-http-无状态无连接" tabindex="-1"> 5.2 http 无状态无连接</h3>
<ul>
<li><code>http</code> 协议对于事务处理没有记忆能力</li>
<li>对同一个<code>url</code>请求没有上下文关系</li>
<li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li>
<li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li>
<li>人生若只如初见，请求过的资源下一次会继续进行请求</li>
</ul>
<p><strong>http协议无状态中的 状态 到底指的是什么？！</strong></p>
<ul>
<li>【状态】的含义就是：客户端和服务器在某次会话中产生的数据</li>
<li>那么对应的【无状态】就意味着：这些数据不会被保留</li>
<li>通过增加<code>cookie</code>和<code>session</code>机制，现在的网络请求其实是有状态的</li>
<li>在没有状态的<code>http</code>协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li>
</ul>
<h3 id="_5-3-http-cache-就是-http-缓存" tabindex="-1"> 5.3 http-cache：就是 http 缓存</h3>
<p><strong>1. 首先得明确 http 缓存的好处</strong></p>
<ul>
<li>减少了冗余的数据传输，减少网费</li>
<li>减少服务器端的压力</li>
<li><code>Web</code> 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间</li>
<li>加快客户端加载网页的速度</li>
</ul>
<p><strong>2. 常见 http 缓存的类型</strong></p>
<ul>
<li>私有缓存（一般为本地浏览器缓存）</li>
<li>代理缓存</li>
</ul>
<p><strong>3. 然后谈谈本地缓存</strong></p>
<blockquote>
<p>本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是</p>
</blockquote>
<ul>
<li>第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是<code>200 OK</code>，浏览器收到资源后，把资源和对应的响应头一起缓存下来</li>
<li>第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的<code>Cache-Control</code>，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去<code>Cache-Control</code>的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器</li>
<li>如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。</li>
</ul>
<blockquote>
<p>与本地缓存相关的头有：<code>Cache-Control</code>、<code>Expires</code>，<code>Cache-Control</code>有多个可选值代表不同的意义，而<code>Expires</code>就是一个日期格式的绝对值。</p>
</blockquote>
<p><strong>3.1 Cache-Control</strong></p>
<blockquote>
<p><code>Cache-Control</code>是<code>HTPP</code>缓存策略中最重要的头，它是<code>HTTP/1.1</code>中出现的，它由如下几个值</p>
</blockquote>
<ul>
<li><code>no-cache</code>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在<code>ETag</code>，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载</li>
<li><code>no-store</code>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源</li>
<li><code>public</code>：可以被所有的用户缓存，包括终端用户和<code>CDN</code>等中间代理服务器。</li>
<li><code>private</code>：只能被终端用户的浏览器缓存，不允许<code>CDN</code>等中继缓存服务器对其缓存。</li>
<li><code>max-age</code>：从当前请求开始，允许获取的响应被重用的最长时间（秒）。</li>
</ul>
<div><pre><code><span># 例如：</span>

Cache-Control: public, max-age<span>=</span><span>1000</span> 
<span># 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>3.2 Expires</strong></p>
<blockquote>
<p><code>Expires</code>是<code>HTTP/1.0</code>出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如<code>Mon, 10 Jun 2015 21:31:12 GMT</code>，只要发送请求时间是在<code>Expires</code>之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现<code>Cache-Control：max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。他们可以这样组合使用</p>
</blockquote>
<div><pre><code>Cache-Control: public
Expires: Wed, Jan 10 2018 00:27:04 GMT
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><strong>3.3 所谓的缓存协商</strong></p>
<blockquote>
<p>当第一次请求时服务器返回的响应头中存在以下情况时</p>
</blockquote>
<ul>
<li>没有 <code>Cache-Control</code> 和 <code>Expires</code></li>
<li><code>Cache-Control</code> 和 <code>Expires</code> 过期了</li>
<li><code>Cache-Control</code> 的属性设置为 <code>no-cache</code> 时</li>
</ul>
<blockquote>
<p>那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回<code>304 Not Modified</code> 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是<code>200 Ok</code>，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据<code>HTTP</code>的另外两组头信息，分别是：<code>Last-Modified/If-Modified-Since</code> 与 <code>ETag/If-None-Match</code>。</p>
</blockquote>
<p><strong>Last-Modified 与 If-Modified-Since</strong></p>
<ul>
<li>浏览器第一次请求资源时，服务器会把资源的最新修改时间<code>Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT</code>放在响应头中返回给浏览器</li>
<li>第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头<code>If-Modified-Since:Thu, 29 Dec 2011 18:23:55</code>发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比</li>
</ul>
<blockquote>
<p>如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时<code>Last-Modified</code>头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同<code>Last-Modified</code>头一起返回</p>
</blockquote>
<div><pre><code><span># 第一次请求返回的响应头</span>
Cache-Control:max-age<span>=</span><span>3600</span>
Expires: Fri, Jan <span>12</span> <span>2018</span> 00:27:04 GMT
Last-Modified: Wed, Jan <span>10</span> <span>2018</span> 00:27:04 GMT
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># 第二次请求的请求头信息</span>
If-Modified-Since: Wed, Jan <span>10</span> <span>2018</span> 00:27:04 GMT
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 <code>ETag</code> 与 <code>If-None-Match</code></p>
</blockquote>
<p><strong>ETag与If-None-Match</strong></p>
<blockquote>
<p><code>ETag/If-None-Match</code>与<code>Last-Modified/If-Modified-Since</code>的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如<code>MD5 hash</code>）来判断</p>
</blockquote>
<blockquote>
<p>浏览器发送第二次请求时，会把第一次的响应头信息<code>ETag</code>的值放在<code>If-None-Match</code>的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用<code>ETag</code>的好处是如果因为某种原因到时资源的修改时间没改变，那么用<code>ETag</code>就能区分资源是不是有被更新。</p>
</blockquote>
<div><pre><code><span># 第一次请求返回的响应头：</span>

Cache-Control: public, max-age<span>=</span><span>31536000</span>
ETag: <span>"15f0fff99ed5aae4edffdd6496d7131f"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># 第二次请求的请求头信息：</span>

If-None-Match: <span>"15f0fff99ed5aae4edffdd6496d7131f"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="_5-4-cookie-和-session" tabindex="-1"> 5.4 cookie 和 session</h3>
<ul>
<li><code>session</code>： 是一个抽象概念，开发者为了实现中断和继续等操作，将 <code>user agent </code>和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念</li>
<li><code>cookie</code>：它是一个世纪存在的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段，可以认为是 <code>session</code> 的一种后端无状态实现</li>
</ul>
<blockquote>
<p>现在我们常说的 <code>session</code>，是为了绕开 <code>cookie</code> 的各种限制，通常借助 <code>cookie</code>本身和后端存储实现的，一种更高级的会话状态实现</p>
</blockquote>
<p><code>session</code> 的常见实现要借助<code>cookie</code>来发送 <code>sessionID</code></p>
<h3 id="_5-5-安全问题-如-xss-和-csrf" tabindex="-1"> 5.5 安全问题，如 XSS 和 CSRF</h3>
<ul>
<li><code>XSS</code>：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动</li>
</ul>
<blockquote>
<p>防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义</p>
</blockquote>
<ul>
<li><code>CSRF</code>：跨站请求伪造，也称 <code>XSRF</code>，是一种挟制用户在当前已登录的<code>Web</code>应用程序上执行非本意的操作的攻击方法。与 <code>XSS</code> 相比，<code>XSS</code>利用的是用户对指定网站的信任，<code>CSRF</code>利用的是网站对用户网页浏览器的信任。</li>
</ul>
<blockquote>
<p>防范：用户操作验证（验证码），额外验证机制（<code>token</code>使用）等</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>页面布局方式</title>
      <link>https://0808200.xyz/Interview/base/the_page_layout.html</link>
      <guid>https://0808200.xyz/Interview/base/the_page_layout.html</guid>
      <source url="https://0808200.xyz/rss.xml">页面布局方式</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="页面布局" tabindex="-1"> 页面布局</h2>
<blockquote>
<p>问题：假设高度默认<code>100px</code> ，请写出三栏布局，其中左栏、右栏各为<code>300px</code>，中间自适应。</p>
</blockquote>
<p><img src="http://img.smyhvae.com/20180305_1520.png" alt=""></p>
<p>分析：</p>
<p>初学者想到的答案有两种：</p>
<ul>
<li>方法1：浮动</li>
<li>方法2：绝对定位</li>
</ul>
<blockquote>
<p>但要求你能至少写出三四种方法，才算及格。剩下的方法如下：</p>
</blockquote>
<ul>
<li>方法3：<code>flexbox</code>。移动开发里经常用到。</li>
<li>方法4：表格布局<code> table</code>。虽然已经淘汰了，但也应该了解。</li>
<li>方法5：网格布局 <code>grid</code></li>
</ul>
<p><strong>方法1、浮动：</strong></p>
<blockquote>
<p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p>
</blockquote>
<p><strong>方法2、绝对定位：</strong></p>
<blockquote>
<p>左侧设置为绝对定位， <code> left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。中间设置为绝对定位，<code>left </code>和<code>right</code> 都为<code>300px</code>，即可。中间的宽度会自适应。</p>
</blockquote>
<blockquote>
<p>使用<code>article</code>标签作为容器，包裹左、中、右三个部分。</p>
</blockquote>
<blockquote>
<p>方法1 和方法2 的代码如下：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
        <span>html *</span> <span>{</span>
            <span>padding</span><span>:</span> 0px<span>;</span>
            <span>margin</span><span>:</span> 0px<span>;</span>
        <span>}</span>

        <span>.layout</span> <span>{</span>
            <span>margin-bottom</span><span>:</span> 150px<span>;</span>
        <span>}</span>


        <span>.layout article div</span> <span>{</span> <span>/*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/</span>
            <span>height</span><span>:</span> 100px<span>;</span>
        <span>}</span>

        <span>/* 方法一 start */</span>

        <span>.layout.float .left</span> <span>{</span>
            <span>float</span><span>:</span> left<span>;</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

        <span>.layout.float .right</span> <span>{</span>
            <span>float</span><span>:</span> right<span>;</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> blue<span>;</span>
        <span>}</span>

        <span>.layout.float .center</span> <span>{</span>
            <span>background</span><span>:</span> green<span>;</span>

        <span>}</span>

        <span>/* 方法一 end */</span>


        <span>/* 方法二 start */</span>
        <span>.layout.absolute .left-center-right</span> <span>{</span>
            <span>position</span><span>:</span> relative<span>;</span>
        <span>}</span>

        <span>.layout.absolute .left</span> <span>{</span>
            <span>position</span><span>:</span> absolute<span>;</span>
            <span>left</span><span>:</span> 0<span>;</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

        <span>/* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */</span>
        <span>.layout.absolute .center</span> <span>{</span>
            <span>position</span><span>:</span> absolute<span>;</span>
            <span>left</span><span>:</span> 300px<span>;</span>
            <span>right</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> green<span>;</span>
        <span>}</span>

        <span>.layout.absolute .right</span> <span>{</span>
            <span>position</span><span>:</span> absolute<span>;</span>
            <span>right</span><span>:</span> 0<span>;</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> blue<span>;</span>
        <span>}</span>


        <span>/* 方法二 end */</span>
    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>

    <span>&lt;!-- 方法一：浮动 start --></span>
    <span>&lt;!-- 输入 section.layout.float，即可生成  --></span>
    <span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>layout float<span>"</span></span><span>></span></span>
        <span>&lt;!-- 用  article 标签包裹左、中、右三个部分 --></span>
        <span><span><span>&lt;</span>article</span> <span>class</span><span><span>=</span><span>"</span>left-right-center<span>"</span></span><span>></span></span>
            <span>&lt;!-- 输入 div.left+div.right+div.center，即可生成 --></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>left<span>"</span></span><span>></span></span>
                我是 left
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span><span>></span></span>
                我是 right
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>center<span>"</span></span><span>></span></span>
                浮动解决方案
                我是 center
            <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;/</span>article</span><span>></span></span>

    <span><span><span>&lt;/</span>section</span><span>></span></span>
    <span>&lt;!-- 方法一：浮动 end --></span>

    <span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>layout absolute<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>article</span> <span>class</span><span><span>=</span><span>"</span>left-center-right<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>left<span>"</span></span><span>></span></span>
                我是 left
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span><span>></span></span>
                我是 right
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>center<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>h1</span><span>></span></span>绝对定位解决方案<span><span><span>&lt;/</span>h1</span><span>></span></span>
                我是 center
            <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>article</span><span>></span></span>
    <span><span><span>&lt;/</span>section</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180305_1640.gif" alt=""></p>
<p><strong>方法3、flexbox布局</strong></p>
<blockquote>
<p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
        <span>html *</span> <span>{</span>
            <span>padding</span><span>:</span> 0<span>;</span>
            <span>margin</span><span>:</span> 0<span>;</span>
        <span>}</span>

        <span>.layout article div</span> <span>{</span>
            <span>height</span><span>:</span> 100px<span>;</span>
        <span>}</span>

        <span>.left-center-right</span> <span>{</span>
            <span>display</span><span>:</span> flex<span>;</span>
        <span>}</span>

        <span>.layout.flex .left</span> <span>{</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

        <span>.layout.flex .center</span> <span>{</span>
            <span>flex</span><span>:</span> 1<span>;</span>
            <span>background</span><span>:</span> green<span>;</span>
        <span>}</span>

        <span>.layout.flex .right</span> <span>{</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> blue<span>;</span>
        <span>}</span>
    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>layout flex<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>article</span> <span>class</span><span><span>=</span><span>"</span>left-center-right-<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>left<span>"</span></span><span>></span></span>
                我是 left
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>center<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>h1</span><span>></span></span>flex布局解决方案<span><span><span>&lt;/</span>h1</span><span>></span></span>
                我是 center
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span><span>></span></span>
                我是 right
            <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;/</span>article</span><span>></span></span>
    <span><span><span>&lt;/</span>section</span><span>></span></span>

<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;/</span>html</span><span>></span></span>


</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180305_1700.gif" alt=""></p>
<p><strong>方法4、表格布局 table</strong></p>
<blockquote>
<p>设置整个容器的宽度为<code>100%</code>，设置三个部分均为表格，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
        <span>html *</span> <span>{</span>
            <span>padding</span><span>:</span> 0<span>;</span>
            <span>margin</span><span>:</span> 0<span>;</span>
        <span>}</span>

        <span>.layout.table div</span> <span>{</span>
            <span>height</span><span>:</span> 100px<span>;</span>
        <span>}</span>

        <span>/* 重要：设置容器为表格布局，宽度为100% */</span>
        <span>.layout.table .left-center-right</span> <span>{</span>
            <span>width</span><span>:</span> 100%<span>;</span>
            <span>display</span><span>:</span> table<span>;</span>
            <span>height</span><span>:</span> 100px<span>;</span>

        <span>}</span>

        <span>.layout.table .left-center-right div</span> <span>{</span>
            <span>display</span><span>:</span> table-cell<span>;</span> <span>/* 重要：设置三个模块为表格里的单元*/</span>
        <span>}</span>

        <span>.layout.table .left</span> <span>{</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

        <span>.layout.table .center</span> <span>{</span>
            <span>background</span><span>:</span> green<span>;</span>
        <span>}</span>

        <span>.layout.table .right</span> <span>{</span>
            <span>width</span><span>:</span> 300px<span>;</span>
            <span>background</span><span>:</span> blue<span>;</span>
        <span>}</span>
    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>layout table<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>article</span> <span>class</span><span><span>=</span><span>"</span>left-center-right<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>left<span>"</span></span><span>></span></span>
                我是 left
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>center<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>h1</span><span>></span></span>表格布局解决方案<span><span><span>&lt;/</span>h1</span><span>></span></span>
                我是 center
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span><span>></span></span>
                我是 right
            <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;/</span>article</span><span>></span></span>
    <span><span><span>&lt;/</span>section</span><span>></span></span>

<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;/</span>html</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://img.smyhvae.com/20180305_1855.gif" alt=""></p>
<p><strong>方法5、网格布局 grid</strong></p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
        <span>html *</span> <span>{</span>
            <span>padding</span><span>:</span> 0<span>;</span>
            <span>margin</span><span>:</span> 0<span>;</span>
        <span>}</span>

        <span>/* 重要：设置容器为网格布局，宽度为100% */</span>
        <span>.layout.grid .left-center-right</span> <span>{</span>
            <span>display</span><span>:</span> grid<span>;</span>
            <span>width</span><span>:</span> 100%<span>;</span>
            <span>grid-template-rows</span><span>:</span> 100px<span>;</span>
            <span>grid-template-columns</span><span>:</span> 300px auto 300px<span>;</span>  <span>/* 重要：设置网格为三列，并设置每列的宽度。即可。*/</span>

        <span>}</span>

        <span>.layout.grid .left</span> <span>{</span>
            <span>background</span><span>:</span> red<span>;</span>
        <span>}</span>

        <span>.layout.grid .center</span> <span>{</span>
            <span>background</span><span>:</span> green<span>;</span>
        <span>}</span>

        <span>.layout.grid .right</span> <span>{</span>
            <span>background</span><span>:</span> blue<span>;</span>
        <span>}</span>
    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>section</span> <span>class</span><span><span>=</span><span>"</span>layout grid<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>article</span> <span>class</span><span><span>=</span><span>"</span>left-center-right<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>left<span>"</span></span><span>></span></span>
                我是 left
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>center<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>h1</span><span>></span></span>网格布局解决方案<span><span><span>&lt;/</span>h1</span><span>></span></span>
                我是 center
            <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>right<span>"</span></span><span>></span></span>
                我是 right
            <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;/</span>article</span><span>></span></span>
    <span><span><span>&lt;/</span>section</span><span>></span></span>

<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>效果：</p>
<p><img src="http://img.smyhvae.com/20180305_1920.gif" alt=""></p>
<p><strong>延伸：五种方法的对比</strong></p>
<blockquote>
<p>五种方法的优缺点</p>
</blockquote>
<ul>
<li>考虑中间模块的高度问题</li>
<li>兼容性问题：实际开发中，哪个最实用？</li>
</ul>
<p>方法1：浮动：</p>
<ul>
<li>优点：兼容性好。</li>
<li>缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。</li>
</ul>
<p>方法:2：绝对定位</p>
<ul>
<li>优点：快捷。</li>
<li>缺点：导致子元素也脱离了标准文档流，可实用性差。</li>
</ul>
<p>方法3：flex 布局（CSS3中出现的）</p>
<ul>
<li>优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。</li>
</ul>
<p>方法4：表格布局</p>
<ul>
<li>优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局</li>
<li>缺点：因为三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。</li>
</ul>
<blockquote>
<p>什么时候用 <code>flex </code>布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。</p>
</blockquote>
<p>方法5：网格布局</p>
<ul>
<li>CSS3中引入的布局，很好用。代码量简化了很多。</li>
</ul>
<blockquote>
<p>PS：面试提到网格布局，说明我们对新技术是有追求的。</p>
</blockquote>
<p><strong>延伸：如果题目中去掉高度已知</strong></p>
<blockquote>
<p>问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？</p>
</blockquote>
<p>分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。</p>
<blockquote>
<p>答案是：<strong>flex 布局和表格布局可以通用</strong>，其他三个布局都不能用了。</p>
</blockquote>
<p><strong>总结</strong></p>
<blockquote>
<p>涉及到的知识点：</p>
</blockquote>
<ul>
<li>语义化掌握到位：每个区域用<code>section</code>、<code>article</code>代表容器、<code>div</code>代表块儿。如果通篇都用 div，那就是语义化没掌握好。</li>
<li>页面布局理解深刻。</li>
<li><code>CSS</code>基础知识扎实。</li>
<li>思维灵活且积极上进。题目中可以通过<code>网格布局</code>来体现。</li>
<li>代码书写规范。注意命名。上面的代码中，没有一行代码是多的。</li>
</ul>
]]></content:encoded>
      <enclosure url="http://img.smyhvae.com/20180305_1520.png" type="image/png"/>
    </item>
    <item>
      <title>Vue 相关问题</title>
      <link>https://0808200.xyz/Interview/base/vue.html</link>
      <guid>https://0808200.xyz/Interview/base/vue.html</guid>
      <source url="https://0808200.xyz/rss.xml">Vue 相关问题</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是mvvm" tabindex="-1"> 什么是mvvm？</h2>
<blockquote>
<p>MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象</p>
</blockquote>
<ul>
<li>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</li>
<li>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</li>
</ul>
<h2 id="vue的优点是什么" tabindex="-1"> vue的优点是什么？</h2>
<ul>
<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变</li>
<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>
</ul>
<h2 id="请详细说下你对vue生命周期的理解" tabindex="-1"> 请详细说下你对vue生命周期的理解</h2>
<blockquote>
<p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p>
</blockquote>
<ul>
<li>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有</li>
<li>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</li>
<li>更新前/后：当data变化时，会触发beforeUpdate和updated方法</li>
<li>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</li>
</ul>
<h2 id="组件之间的传值" tabindex="-1"> 组件之间的传值？</h2>
<p><strong>父组件与子组件传值</strong></p>
<div><pre><code>//父组件通过标签上面定义传值
&lt;template>
    &lt;Main :obj="data">&lt;/Main>
&lt;/template>
&lt;script>
    //引入子组件
    import Main form "./main"
    
    exprot default{
        name:"parent",
        data(){
            return {
                data:"我要向子组件传递数据"
            }
        },
        //初始化组件
        components:{
            Main
        }
    }
&lt;/script>


//子组件通过props方法接受数据

&lt;template>
    &lt;div>{{data}}&lt;/div>
&lt;/template>
&lt;script>
    exprot default{
        name:"son",
        //接受父组件传值
        props:["data"]
    }
&lt;/script>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>子组件向父组件传递数据</strong></p>
<div><pre><code>//子组件通过$emit方法传递参数
&lt;template>
   &lt;div v-on:click="events">&lt;/div>
&lt;/template>
&lt;script>
    //引入子组件
    import Main form "./main"
    
    exprot default{
        methods:{
            events:function(){
                
            }
        }
    }
&lt;/script>


//

&lt;template>
    &lt;div>{{data}}&lt;/div>
&lt;/template>
&lt;script>
    exprot default{
        name:"son",
        //接受父组件传值
        props:["data"]
    }
&lt;/script>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="路由之间跳转" tabindex="-1"> 路由之间跳转？</h2>
<p><strong>声明式（标签跳转）</strong></p>
<div><pre><code>&lt;router-link :to="index">
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>编程式（ js跳转）</strong></p>
<div><pre><code>router.push('index')
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="vuex是什么-怎么使用-哪种功能场景使用它" tabindex="-1"> vuex是什么？怎么使用？哪种功能场景使用它？</h2>
<blockquote>
<p>vue框架中状态管理。在main.js引入store，注入。新建了一个目录<code>store</code>，….. <code>export</code> 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
</blockquote>
<h2 id="实现-vue-ssr" tabindex="-1"> 实现 Vue SSR</h2>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/vue-ssr.jpg" alt=""></p>
<p><strong>其基本实现原理</strong></p>
<ul>
<li>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。</li>
<li>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。</li>
<li>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。</li>
<li>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__ </code>发送到客户端</li>
</ul>
<blockquote>
<p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的</p>
</blockquote>
<ul>
<li><code>Vue SSR </code>需要做的事多点（输出完整 HTML），除了<code> complier -&gt; vnode</code>，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。
相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点</li>
</ul>
<h2 id="vue-组件-data-为什么必须是函数" tabindex="-1"> Vue 组件 data 为什么必须是函数</h2>
<ul>
<li>每个组件都是 Vue 的实例。</li>
<li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他</li>
</ul>
<h2 id="vue-computed-实现" tabindex="-1"> Vue computed 实现</h2>
<ul>
<li>建立与其他属性（如：data、 Store）的联系；</li>
<li>属性改变后，通知计算属性重新计算</li>
</ul>
<blockquote>
<p>实现时，主要如下</p>
</blockquote>
<ul>
<li>初始化 data， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li>
<li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。</li>
<li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li>
<li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集</li>
</ul>
<h2 id="vue-complier-实现" tabindex="-1"> Vue complier 实现</h2>
<ul>
<li>模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。</li>
<li>总的来说，Vue complier 是将 template 转化成一个 render 字符串。</li>
</ul>
<blockquote>
<p>可以简单理解成以下步骤：</p>
</blockquote>
<ul>
<li>parse 过程，将 template 利用正则转化成 AST 抽象语法树。</li>
<li>optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。</li>
<li>generate 过程，生成 render 字符串</li>
</ul>
<h2 id="怎么快速定位哪个组件出现性能问题" tabindex="-1"> 怎么快速定位哪个组件出现性能问题</h2>
<blockquote>
<p>用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://7xq6al.com1.z0.glb.clouddn.com/vue-ssr.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>常见web 安全及防护原理</title>
      <link>https://0808200.xyz/Interview/base/web-security.html</link>
      <guid>https://0808200.xyz/Interview/base/web-security.html</guid>
      <source url="https://0808200.xyz/rss.xml">常见web 安全及防护原理</source>
      <category>Interview</category>
      <pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>常见web安全及防护原理</strong></p>
<ul>
<li>
<p>sql注入原理</p>
<ul>
<li>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li>
</ul>
</li>
<li>
<p>总的来说有以下几点</p>
<ul>
<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等</li>
<li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>
<li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息</li>
</ul>
</li>
</ul>
<p><strong>XSS原理及防范</strong></p>
<ul>
<li>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li>
</ul>
<p><strong>XSS防范方法</strong></p>
<ul>
<li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li>
</ul>
<p><strong>XSS与CSRF有什么区别吗？</strong></p>
<ul>
<li>
<p>XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤</p>
</li>
<li>
<p>登录受信任网站A，并在本地生成Cookie</p>
</li>
<li>
<p>在不登出A的情况下，访问危险网站B</p>
</li>
</ul>
<p><strong>CSRF的防御</strong></p>
<ul>
<li>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li>
<li>通过验证码的方法</li>
</ul>
<p><strong>是否了解 Web 注入攻击（最常见 XSS 和 CSRF）？</strong></p>
<ul>
<li>
<p>SQL注入</p>
<ul>
<li>把SQL命令插入到表单或输入URL查询字符串提交，欺骗服务器达到执行恶意的SQL目的</li>
</ul>
</li>
<li>
<p>XSS(Cross Site Script)，跨站脚本攻击</p>
<ul>
<li>攻击者在页面里插入恶意代码，当用户浏览该页之时，执行嵌入的恶意代码达到攻击目的</li>
</ul>
</li>
<li>
<p>CSRF(Cross Site Request Forgery)，跨站点伪造请求</p>
<ul>
<li>伪造合法请求，让用户在不知情的情况下以登录的身份访问，利用用户信任达到攻击目的</li>
</ul>
</li>
</ul>
<p><strong>如何防范 Web 前端攻击？</strong></p>
<ul>
<li>
<p>不要信任任何外部传入的数据</p>
<ul>
<li>针对用户输入作相关的格式检查、过滤等操作</li>
</ul>
</li>
<li>
<p>不要信任在任何传入的第三方数据</p>
<ul>
<li>使用 CORS，设置 Access-Control-Allow-Origin</li>
</ul>
</li>
<li>
<p>更安全地使用 Cookie</p>
<ul>
<li>设置Cookie为HttpOnly，禁止了JavaScript操作Cookie</li>
</ul>
</li>
<li>
<p>防止网页被其他网站内嵌为iframe</p>
<ul>
<li>服务器端设置 X-Frame-Options 响应头，防止页面被内嵌</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>透视 Http 协议</title>
      <link>https://0808200.xyz/bedstone/perspective-http-protocol/</link>
      <guid>https://0808200.xyz/bedstone/perspective-http-protocol/</guid>
      <source url="https://0808200.xyz/rss.xml">透视 Http 协议</source>
      <pubDate>Fri, 30 Dec 2022 06:53:41 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>专栏介绍</p>
<p>打牢基础，进阶大厂</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Chrome V8 让你更懂JavaScript</title>
      <link>https://0808200.xyz/bedstone/google-v8/</link>
      <guid>https://0808200.xyz/bedstone/google-v8/</guid>
      <source url="https://0808200.xyz/rss.xml">Chrome V8 让你更懂JavaScript</source>
      <category>google-v8</category>
      <pubDate>Fri, 30 Dec 2022 02:40:14 GMT</pubDate>
      <content:encoded><![CDATA[<p><img src="@source/bedstone/google-v8/images/posts/arts/Chrome-V8.png?raw=true" alt="V8">
  V8 是由 Google 开发的开源 <strong>JavaScript 引擎</strong>，也被称为<strong>虚拟机</strong>，模拟实际计算机各种功能来<strong>实现代码的编译和执行</strong>。</p>
<h2 id="记得那年花下-深夜-初识谢娘时" tabindex="-1"> 记得那年花下，深夜，初识谢娘时</h2>
<h3 id="为什么需要-javascript-引擎" tabindex="-1"> 为什么需要 JavaScript 引擎</h3>
<p>  我们写的 JavaScript 代码直接交给浏览器或者 Node 执行时，底层的 CPU 是不认识的，也没法执行。<strong>CPU 只认识自己的指令集，指令集对应的是汇编代码</strong>。写汇编代码是一件很痛苦的事情。并且<strong>不同类型的 CPU 的指令集是不一样的，那就意味着需要给每一种 CPU 重写汇编代码</strong>。<br>
  JavaScirpt 引擎可以将 JS 代码编译为不同 CPU(Intel, ARM 以及 MIPS 等)对应的汇编代码，这样我们就不需要去翻阅每个 CPU 的指令集手册来编写汇编代码了。当然，<strong>JavaScript 引擎的工作也不只是编译代码，它还要负责执行代码、分配内存以及垃圾回收</strong>。</p>
<div><pre><code># 将一个寄存器中的数据移动到另外一个寄存器中
1000100111011000  #机器指令
mov ax,bx         #汇编指令
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>资料拓展： <a href="http://www.ruanyifeng.com/blog/2018/01/" target="_blank" rel="noopener noreferrer">汇编语言入门教程</a></p>
</blockquote>
<h3 id="热门-javascript-引擎" tabindex="-1"> 热门 JavaScript 引擎</h3>
<ul>
<li><a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">V8 (Google)</a>，用 C++编写，开放源代码，由 Google 丹麦开发，是 Google Chrome 的一部分，也用于 Node.js。</li>
<li><a href="https://developer.apple.com/documentation/javascriptcore?language=objc" target="_blank" rel="noopener noreferrer">JavaScriptCore (Apple)</a>，开放源代码，用于 webkit 型浏览器，如 Safari ，2008 年实现了编译器和字节码解释器，升级为了 SquirrelFish。苹果内部代号为“Nitro”的 JavaScript 引擎也是基于 JavaScriptCore 引擎的。</li>
<li>Rhino，由 Mozilla 基金会管理，开放源代码，完全以 Java 编写，用于 HTMLUnit</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener noreferrer">SpiderMonkey (Mozilla)</a>，第一款 JavaScript 引擎，早期用于 Netscape Navigator，现时用于 Mozilla Firefox。</li>
<li>Chakra (JScript 引擎)，用于 Internet Explorer。</li>
<li>Chakra (JavaScript 引擎)，用于 Microsoft Edge。</li>
<li>KJS，KDE 的 ECMAScript／JavaScript 引擎，最初由哈里·波顿开发，用于 KDE 项目的 Konqueror 网页浏览器中。</li>
<li>JerryScript — 三星推出的适用于嵌入式设备的小型 JavaScript 引擎。</li>
<li>其他：Nashorn、<a href="https://bellard.org/quickjs/" target="_blank" rel="noopener noreferrer">QuickJS</a> 、 <a href="https://hermesengine.dev/" target="_blank" rel="noopener noreferrer">Hermes</a></li>
</ul>
<h3 id="v8" tabindex="-1"> V8</h3>
<p>  <a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">Google V8</a> 引擎是用 C ++编写的开源高性能 JavaScript 和 <a href="https://www.jianshu.com/p/bff8aa23fe4d" target="_blank" rel="noopener noreferrer">WebAssembly</a> 引擎，它已被用于 Chrome 和 Node.js 等。可以运行在 Windows 7+，macOS 10.12+和使用 x64，IA-32，ARM 或 MIPS 处理器的 Linux 系统上。 <strong>V8 最早被开发用以嵌入到 Google 的开源浏览器 Chrome 中</strong>，第一个版本随着第一版<a href="https://baike.baidu.com/item/Google%20Chrome/5638378?fr=aladdin" target="_blank" rel="noopener noreferrer">Chrome</a>于 2008 年 9 月 2 日发布。<strong>但是 V8 是一个可以独立运行的模块，完全可以嵌入到任何 C ++应用程序中</strong>。著名的 Node.js( 一个异步的服务器框架，可以在服务端使用 JavaScript 写出高效的网络服务器 ) 就是基于 V8 引擎的，Couchbase, MongoDB 也使用了 V8 引擎。</p>
<p>  和<a href="https://baike.baidu.com/item/javascript%E5%BC%95%E6%93%8E/5356108?fr=aladdin" target="_blank" rel="noopener noreferrer">其他 JavaScript 引擎</a>一样，<strong>V8 会编译 / 执行 JavaScript 代码，管理内存，负责垃圾回收，与宿主语言的交互等。通过暴露宿主对象 ( 变量，函数等 ) 到 JavaScript，JavaScript 可以访问宿主环境中的对象，并在脚本中完成对宿主对象的操作</strong>。</p>
<p><img src="@source/bedstone/google-v8/images/posts/arts/how-v8-works.png?raw=true" alt="V8"></p>
<blockquote>
<p>资料拓展：<a href="https://v8.dev/logo" target="_blank" rel="noopener noreferrer">v8 logo</a> | <a href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" target="_blank" rel="noopener noreferrer">V8 (JavaScript engine)</a> | <a href="https://static001.geekbang.org/con/31/pdf/229180902/file/GMTC2018-%E3%80%8AV8%E3%80%81JavaScript+%E7%9A%84%E7%8E%B0%E5%9C%A8%E4%B8%8E%E6%9C%AA%E6%9D%A5%E3%80%8B-%E8%BF%B7%E6%B8%A1.pdf" target="_blank" rel="noopener noreferrer">《V8、JavaScript+的现在与未来》</a> | <a href="https://www.jianshu.com/p/bff8aa23fe4d" target="_blank" rel="noopener noreferrer">几张图让你看懂 WebAssembly</a></p>
</blockquote>
<blockquote>
<p>V8 一词最早见于“V-8 engine”，即<a href="https://baike.baidu.com/item/V8%E5%8F%91%E5%8A%A8%E6%9C%BA" target="_blank" rel="noopener noreferrer">V8 发动机</a>，一般使用在中高端车辆上。8 个气缸分成两组，每组 4 个，成 V 型排列。是高层次汽车运动中最常见的发动机结构，尤其在美国，IRL，ChampCar 和 NASCAR 都要求使用 V8 发动机。</p>
</blockquote>
<h2 id="与君初相识-犹如故人归" tabindex="-1"> 与君初相识，犹如故人归</h2>
<h3 id="什么是-d8" tabindex="-1"> 什么是 D8</h3>
<p>  d8 是一个非常有用的调试工具，你可以把它看成是 <strong>debug for V8</strong> 的缩写。我们<strong>可以使用 d8 来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如作用域、AST、字节码、优化的二进制代码、垃圾回收的状态，还可以使用 d8 提供的私有 API 查看一些内部信息</strong>。</p>
<blockquote>
<p>V8 源码编译出来的可执行程序名为 d8。d8 作为 V8 引擎在命令行中可以使用的交互 shell 存在。Google 官方已经不记得 d8 这个名字的由来，但是做为&quot;delveloper shell&quot;的缩写，用首字母 d 和 8 结合，恰到好处。
还有一种说法是 d8 最初叫<code>developer shell</code>，因为 d 后面有 8 个字符，因此简写为 d8，类似于<a href="http://i18njs.com/" target="_blank" rel="noopener noreferrer">i18n</a>(internationalization)这样的简写。
参考：<a href="https://v8.dev/docs/d8" target="_blank" rel="noopener noreferrer">Using d8</a></p>
</blockquote>
<h3 id="安装-d8" tabindex="-1"> 安装 D8</h3>
<ul>
<li>
<p>方法一：自行下载编译</p>
<ul>
<li><a href="https://time.geekbang.org/column/article/219418" target="_blank" rel="noopener noreferrer">v8 google 下载及编译使用</a></li>
<li>官方文档：<a href="https://v8.dev/docs/d8" target="_blank" rel="noopener noreferrer">Using d8</a></li>
</ul>
</li>
<li>
<p>方法二：使用编译好的 d8 工具</p>
<ul>
<li><a href="https://storage.googleapis.com/chromium-v8/official/canary/v8-mac64-dbg-8.4.109.zip" target="_blank" rel="noopener noreferrer">mac 平台</a></li>
<li><a href="https://storage.googleapis.com/chromium-v8/official/canary/v8-linux32-dbg-8.4.109.zip" target="_blank" rel="noopener noreferrer">linux32 平台</a></li>
<li><a href="https://storage.googleapis.com/chromium-v8/official/canary/v8-linux64-dbg-8.4.109.zip" target="_blank" rel="noopener noreferrer">linux64 平台</a></li>
<li><a href="https://storage.googleapis.com/chromium-v8/official/canary/v8-win32-dbg-8.4.109.zip" target="_blank" rel="noopener noreferrer">win32 平台</a></li>
<li><a href="https://storage.googleapis.com/chromium-v8/official/canary/v8-win64-dbg-8.4.109.zip" target="_blank" rel="noopener noreferrer">win64 平台</a></li>
</ul>
<div><pre><code><span>// 解压文件，点击d8打开（mac安全策略限制的话，按住control，再点击，弹出菜单中选择打开）</span>
  <span>V8</span> version <span>8.4</span><span>.109</span>
  d8<span>></span> <span>1</span> <span>+</span> <span>2</span>
    <span>3</span>
  d8<span>></span> <span>2</span> <span>+</span> <span>'4'</span>
    <span>"24"</span>
  d8<span>></span> console<span>.</span><span>log</span><span>(</span><span>23</span><span>)</span>
    <span>23</span>
    <span>undefined</span>
  d8<span>></span> <span>var</span> a <span>=</span> <span>1</span>
    <span>undefined</span>
  d8<span>></span> a <span>+</span> <span>2</span>
    <span>3</span>
  d8<span>></span> <span>this</span>
    <span>[</span>object global<span>]</span>
  d8<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>本文后续用于 demo 演示时的文件目录结构：</p>
<div><pre><code>　V8：
    # d8可执行文件
    d8
    icudtl.dat
    libc++.dylib
    libchrome_zlib.dylib
    libicui18n.dylib
    libicuuc.dylib
    libv8.dylib
    libv8_debug_helper.dylib
    libv8_for_testing.dylib
    libv8_libbase.dylib
    libv8_libplatform.dylib
    obj
    snapshot_blob.bin
    v8_build_config.json
    # 新建的js示例文件
    test.js
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>方法三：mac</p>
<div><pre><code>  # 如果已有HomeBrew，忽略第一条命令
  ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
  brew install v8
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
<li>
<p>方法四：<strong>使用 node 代替</strong>，比如可以用<code>node --print-bytecode ./test.js</code>，打印出 Ignition（解释器）生成的 Bytecode（字节码）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="d8-命令查看" tabindex="-1"> d8 命令查看</h3>
<ul>
<li>
<p>查看 d8 命令</p>
<div><pre><code>  # 如果不想使用./d8这种方式进行调试，可将d8加入环境变量，之后就可以直接`d8 --help`了
  ./d8 --help
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
<li>
<p>过滤特定的命令</p>
<div><pre><code>  # 如果是 Windows 系统，可能缺少 grep 程序，请自行下载安装并添加环境变量
  ./d8 --help |grep print
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如：</p>
<ul>
<li>print-bytecode 查看生成的字节码</li>
<li>print-opt-code 查看优化后的代码</li>
<li>print-ast 查看中间生成的 AST</li>
<li>print-scopes 查看中间生成的作用域</li>
<li>trace-gc 查看这段代码的内存回收状态</li>
<li>trace-opt 查看哪些代码被优化了</li>
<li>trace-deopt 查看哪些代码被反优化了</li>
<li>turbofan-stats 是打印出来优化编译器的一些统计数据的命令</li>
</ul>
</li>
</ul>
<h3 id="使用-d8-进行调试" tabindex="-1"> 使用 d8 进行调试</h3>
<div><pre><code><span>// test.js</span>
<span>function</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>{</span>
  <span>var</span> b <span>=</span> <span>6</span><span>;</span>
  <span>return</span> a <span>+</span> <span>6</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>sum</span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>  # d8 后面跟上文件名和要执行的命令，如执行下面这行命令，就会打印出 test.js 文件所生成的字节码。
  ./d8 ./test.js --print-bytecode
  # 执行以下命令，输出9
  ./d8 ./test.js
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="内部方法" tabindex="-1"> 内部方法</h3>
<p>  你还可以使用 V8 所提供的一些<strong>内部方法</strong>，只需要在启动 V8 时传入 <code>--allow-natives-syntax</code> 命令，你就可以在 test.js 中使用诸如<code>HasFastProperties</code>（检查一个对象是否拥有快属性）的内部方法。</p>
<div><pre><code><span>function</span> <span>Foo</span><span>(</span><span>property_num<span>,</span> element_num</span><span>)</span> <span>{</span>
  <span>//添加可索引属性</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> element_num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>this</span><span>[</span>i<span>]</span> <span>=</span> <span><span>`</span><span>element</span><span><span>${</span>i<span>}</span></span><span>`</span></span><span>;</span>
  <span>}</span>
  <span>//添加常规属性</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> property_num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> ppt <span>=</span> <span><span>`</span><span>property</span><span><span>${</span>i<span>}</span></span><span>`</span></span><span>;</span>
    <span>this</span><span>[</span>ppt<span>]</span> <span>=</span> ppt<span>;</span>
  <span>}</span>
<span>}</span>
<span>var</span> bar <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>10</span><span>,</span> <span>10</span><span>)</span><span>;</span>
<span>// 检查一个对象是否拥有快属性</span>
console<span>.</span><span>log</span><span>(</span><span>%</span><span>HasFastProperties</span><span>(</span>bar<span>)</span><span>)</span><span>;</span>
<span>delete</span> bar<span>.</span>property2<span>;</span>
console<span>.</span><span>log</span><span>(</span><span>%</span><span>HasFastProperties</span><span>(</span>bar<span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>  ./d8 --allow-natives-syntax ./test.js
  # 依次打印：true false
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="心似双丝网-中有千千结" tabindex="-1"> 心似双丝网，中有千千结</h2>
<p><img src="@source/bedstone/google-v8/images/posts/arts/google-v8.jpg?raw=true" alt="V8知识图谱"></p>
<h3 id="v8-引擎的内部结构" tabindex="-1"> V8 引擎的内部结构</h3>
<p>  V8 是一个非常复杂的项目，有超过 100 万行 C++代码。它由许多子模块构成，其中这 4 个模块是最重要的：</p>
<ul>
<li>
<p><a href="https://v8.dev/blog/scanner" target="_blank" rel="noopener noreferrer">Parser</a>：负责将 JavaScript 源码转换为 Abstract Syntax Tree (AST)</p>
<blockquote>
<p>确切的说，在“Parser”将 JavaScript 源码转换为 AST 前，还有一个叫”Scanner“的过程，具体流程如下：
<img src="@source/bedstone/google-v8/images/posts/arts/overview.png?raw=true" alt="Scanner"></p>
</blockquote>
</li>
<li>
<p><a href="https://v8.dev/docs/ignition" target="_blank" rel="noopener noreferrer">Ignition</a>：interpreter，即解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；解释器执行时主要有四个模块，内存中的字节码、寄存器、栈、堆。</p>
<blockquote>
<p><strong>通常有两种类型的解释器，基于栈 (Stack-based)和基于寄存器 (Register-based)</strong>，基于栈的解释器使用栈来保存函数参数、中间运算结果、变量等；基于寄存器的虚拟机则支持寄存器的指令操作，使用寄存器来保存参数、中间计算结果。通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其<strong>区别体现在它们提供的指令集体系</strong>。<strong>大多数解释器都是基于栈的</strong>，比如 Java 虚拟机，.Net 虚拟机，还有早期的 V8 虚拟机。基于堆栈的虚拟机在处理函数调用、解决递归问题和切换上下文时简单明快。而<strong>现在的 V8 虚拟机则采用了基于寄存器的设计</strong>，它将一些中间数据保存到寄存器中。<br>
<strong>基于寄存器的解释器架构</strong>：<img src="@source/bedstone/google-v8/images/posts/arts/register.jpg?raw=true" alt="基于寄存器的解释器架构">
资料参考：<a href="https://time.geekbang.org/column/article/224908" target="_blank" rel="noopener noreferrer">解释器是如何解释执行字节码的？</a></p>
</blockquote>
</li>
<li>
<p><a href="https://v8.dev/docs/turbofan" target="_blank" rel="noopener noreferrer">TurboFan</a>：compiler，即编译器，利用 Ignition 所收集的类型信息，将 Bytecode 转换为优化的汇编代码；</p>
</li>
<li>
<p><a href="https://v8.dev/blog/trash-talk" target="_blank" rel="noopener noreferrer">Orinoco</a>：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收。</p>
</li>
</ul>
<p>  其中，Parser，Ignition 以及 TurboFan 可以将 JS 源码编译为汇编代码，其流程图如下：</p>
<p><img src="@source/bedstone/google-v8/images/posts/arts/ignition-turbofan-pipeline.jpeg?raw=true" alt="V8流程"></p>
<p>  简单地说，Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。</p>
<ul>
<li>如果函数没有被调用，则 V8 不会去编译它。</li>
<li>如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。</li>
<li>如果函数被调用多次，则它有可能会被识别为<strong>热点函数</strong>，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。</li>
</ul>
<p>  图片中的红色虚线是逆向的，也就是说 Optimized Machine Code 会被还原为 Bytecode，这个过程叫做 <strong>Deoptimization</strong>。这是因为 Ignition 收集的信息可能是错误的，比如 add 函数的参数之前是整数，后来又变成了字符串。生成的 Optimized Machine Code 已经假定 add 函数的参数是整数，那当然是错误的，于是需要进行 Deoptimization。</p>
<div><pre><code><span>function</span> <span>add</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span>

<span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>
<span>add</span><span>(</span><span>'1'</span><span>,</span> <span>'2'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>  在运行 C、C++以及 Java 等程序之前，需要进行编译，不能直接执行源码；但对于 JavaScript 来说，我们可以直接执行源码(比如：node test.js)，它是在运行的时候先编译再执行，这种方式被称为<strong>即时编译(Just-in-time compilation)</strong>，简称为 JIT。因此，V8 也属于 <strong>JIT 编译器</strong>。</p>
<blockquote>
<p>资料拓展参考：<a href="https://www.cnblogs.com/fundebug/archive/2019/07/16/how-does-v8-work.html" target="_blank" rel="noopener noreferrer">V8 引擎是如何工作的？</a></p>
</blockquote>
<h3 id="v8-是怎么执行一段-javascript-代码的" tabindex="-1"> V8 是怎么执行一段 JavaScript 代码的</h3>
<ul>
<li>
<p>在 <strong>V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因</strong>。而 V8 率先引入了<strong>即时编译（JIT）<strong>的</strong>双轮驱动</strong>的设计（混合使用编译器和解释器的技术），这是一种权衡策略，<strong>混合编译执行和解释执行这两种手段</strong>，给 JavaScript 的执行速度带来了极大的提升。V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以目前市面上 JavaScript 虚拟机都有着类似的架构。另外，<strong>V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率</strong>。</p>
</li>
<li>
<p>V8 执行一段 JavaScript 的流程图：
<img src="@source/bedstone/google-v8/images/posts/arts/v8.jpg?raw=true" alt="V8执行一段JavaScript流程图"></p>
<blockquote>
<p>资料拓展：<a href="https://time.geekbang.org/column/article/211682" target="_blank" rel="noopener noreferrer">V8 是如何执行一段 JavaScript 代码的？</a></p>
</blockquote>
</li>
<li>
<p><strong>V8 本质上是一个虚拟机</strong>，因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段：</p>
<ul>
<li>第一种是将高级代码转换为二进制代码，再让计算机去执行；</li>
<li>另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。</li>
</ul>
</li>
<li>
<p>解释执行和编译执行都有各自的优缺点，<strong>解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快</strong>。为了充分地利用解释执行和编译执行的优点，规避其缺点，<strong>V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码</strong>。</p>
</li>
<li>
<p>总结：</p>
<p><strong>V8 执行一段 JavaScript 代码所经历的主要流程</strong>包括：</p>
<ul>
<li>初始化基础环境；</li>
<li>解析源码生成 AST 和作用域；</li>
<li>依据 AST 和作用域生成字节码；</li>
<li>解释执行字节码；</li>
<li>监听热点代码；</li>
<li>优化热点代码为二进制的机器代码；</li>
<li>反优化生成的二进制机器代码。</li>
</ul>
</li>
</ul>
<h3 id="一等公民与闭包" tabindex="-1"> 一等公民与闭包</h3>
<h4 id="一等公民的定义" tabindex="-1"> 一等公民的定义</h4>
<ul>
<li>在编程语言中，<strong>一等公民</strong>可以作为函数参数，可以作为函数返回值，也可以赋值给变量。</li>
<li><strong>如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民</strong>。例如，字符串在几乎所有编程语言中都是一等公民，字符串可以做为函数参数，字符串可以作为函数返回值，字符串也可以赋值给变量。对于各种编程语言来说，函数就不一定是一等公民了，比如 Java 8 之前的版本。</li>
<li>对于 JavaScript 来说，函数可以赋值给变量，也可以作为函数参数，还可以作为函数返回值，因此 <strong>JavaScript 中函数是一等公民</strong>。</li>
</ul>
<h4 id="动态作用域与静态作用域" tabindex="-1"> 动态作用域与静态作用域</h4>
<ul>
<li>如果一门语言的作用域是<strong>静态作用域</strong>，那么符号之间的引用关系能够根据程序代码在编译时就确定清楚，在运行时不会变。某个函数是在哪声明的，就具有它所在位置的作用域。它能够访问哪些变量，那么就跟这些变量绑定了，在运行时就一直能访问这些变量。即静态作用域可以由程序代码决定，在编译时就能完全确定。大多数语言都是静态作用域的。</li>
<li><strong>动态作用域（Dynamic Scope）</strong>。也就是说，变量引用跟变量声明不是在编译时就绑定死了的。在运行时，它是在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，就是动态作用域的。</li>
</ul>
<h4 id="闭包的三个基础特性" tabindex="-1"> 闭包的三个基础特性</h4>
<ul>
<li>JavaScript 语言允许在函数内部定义新的函数</li>
<li>可以在内部函数中访问父函数中定义的变量</li>
<li>因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值</li>
</ul>
<div><pre><code><span>// 闭包（静态作用域，一等公民，调用栈的矛盾体）</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> d <span>=</span> <span>20</span><span>;</span>
  <span>return</span> <span>function</span> <span>inner</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
    <span>const</span> c <span>=</span> a <span>+</span> b <span>+</span> d<span>;</span>
    <span>return</span> c<span>;</span>
  <span>}</span><span>;</span>
<span>}</span>
<span>const</span> f <span>=</span> <span>foo</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>  关于闭包，可参考我以前的<a href="https://segmentfault.com/a/1190000021586767" target="_blank" rel="noopener noreferrer">一篇文章</a>，在此不再赘述，在此主要谈下闭包给 Chrome V8 带来的问题及其解决策略。</p>
<h4 id="惰性解析" tabindex="-1"> 惰性解析</h4>
<p>  所谓<strong>惰性解析</strong>是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p>
<ul>
<li>在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：
<ul>
<li>首先，<strong>如果一次解析和编译所有的 JavaScript 代码</strong>，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到<strong>卡顿</strong>。因为有时候一个页面的 JavaScript 代码很大，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</li>
<li>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直<strong>占用内存</strong>。</li>
</ul>
</li>
<li>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。</li>
<li><strong>闭包给惰性解析带来的问题</strong>：上文的 d 不能随着 foo 函数的执行上下文被销毁掉。</li>
</ul>
<h4 id="预解析器" tabindex="-1"> 预解析器</h4>
<p>  V8 引入<strong>预解析器</strong>，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析。</p>
<ul>
<li><strong>判断当前函数是不是存在一些语法上的错误</strong>，发现了语法错误，那么就会向 V8 抛出语法错误；</li>
<li><strong>检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题</strong>。</li>
</ul>
<h3 id="v8-内部是如何存储对象的-快属性和慢属性" tabindex="-1"> V8 内部是如何存储对象的：快属性和慢属性</h3>
<p>下面的代码会输出什么：</p>
<div><pre><code><span>// test.js</span>
<span>function</span> <span>Foo</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>[</span><span>200</span><span>]</span> <span>=</span> <span>'test-200'</span><span>;</span>
  <span>this</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>'test-1'</span><span>;</span>
  <span>this</span><span>[</span><span>100</span><span>]</span> <span>=</span> <span>'test-100'</span><span>;</span>
  <span>this</span><span>[</span><span>'B'</span><span>]</span> <span>=</span> <span>'bar-B'</span><span>;</span>
  <span>this</span><span>[</span><span>50</span><span>]</span> <span>=</span> <span>'test-50'</span><span>;</span>
  <span>this</span><span>[</span><span>9</span><span>]</span> <span>=</span> <span>'test-9'</span><span>;</span>
  <span>this</span><span>[</span><span>8</span><span>]</span> <span>=</span> <span>'test-8'</span><span>;</span>
  <span>this</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>'test-3'</span><span>;</span>
  <span>this</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>'test-5'</span><span>;</span>
  <span>this</span><span>[</span><span>'D'</span><span>]</span> <span>=</span> <span>'bar-D'</span><span>;</span>
  <span>this</span><span>[</span><span>'C'</span><span>]</span> <span>=</span> <span>'bar-C'</span><span>;</span>
<span>}</span>
<span>var</span> bar <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>;</span>

<span>for</span> <span>(</span>key <span>in</span> bar<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>index:</span><span><span>${</span>key<span>}</span></span><span>  value:</span><span><span>${</span>bar<span>[</span>key<span>]</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>}</span>
<span>//输出：</span>
<span>// index:1  value:test-1</span>
<span>// index:3  value:test-3</span>
<span>// index:5  value:test-5</span>
<span>// index:8  value:test-8</span>
<span>// index:9  value:test-9</span>
<span>// index:50  value:test-50</span>
<span>// index:100  value:test-100</span>
<span>// index:200  value:test-200</span>
<span>// index:B  value:bar-B</span>
<span>// index:D  value:bar-D</span>
<span>// index:C  value:bar-C</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>  在 ECMAScript 规范中定义了<strong>数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列</strong>。在这里我们把对象中的数字属性称为<strong>排序属性</strong>，在 V8 中被称为 elements，字符串属性就被称为<strong>常规属性</strong>，在 V8 中被称为 properties。在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。同时 v8 将部分常规属性直接存储到对象本身，我们把这称为<strong>对象内属性 (in-object properties)</strong>，不过对象内属性的数量是固定的，默认是 10 个。</p>
<div><pre><code><span>function</span> <span>Foo</span><span>(</span><span>property_num<span>,</span> element_num</span><span>)</span> <span>{</span>
  <span>//添加可索引属性</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> element_num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>this</span><span>[</span>i<span>]</span> <span>=</span> <span><span>`</span><span>element</span><span><span>${</span>i<span>}</span></span><span>`</span></span><span>;</span>
  <span>}</span>
  <span>//添加常规属性</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> property_num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> ppt <span>=</span> <span><span>`</span><span>property</span><span><span>${</span>i<span>}</span></span><span>`</span></span><span>;</span>
    <span>this</span><span>[</span>ppt<span>]</span> <span>=</span> ppt<span>;</span>
  <span>}</span>
<span>}</span>
<span>var</span> bar <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>10</span><span>,</span> <span>10</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>  可以通过 Chrome 开发者工具的 Memory 标签，捕获查看当前的<strong>内存快照</strong>。通过增大第一个参数来查看存储变化。（Console 面板运行以上代码，打开 Memory 面板，通过点击<code>Take heap snapshot</code>记录内存快照，点击快照，筛选出 Foo 进行查看。可参考<a href="https://zhuanlan.zhihu.com/p/80792297" target="_blank" rel="noopener noreferrer">使用 chrome-devtools Memory 面板</a>了解 Memory 面板。）</p>
<p>  我们将保存在线性数据结构中的属性称之为“<strong>快属性</strong>”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是<strong>如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销</strong>。因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“<strong>慢属性</strong>”策略，但慢属性的对象内部会有独立的非线性数据结构 (字典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。</p>
<p>v8 属性存储：
<img src="@source/bedstone/google-v8/images/posts/arts/properties.jpg?raw=true" alt="v8属性存储"></p>
<p>总结：</p>
<p>  因为 JavaScript 中的对象是由一组组属性和值组成的，所以最简单的方式是使用一个字典来保存属性和值，但是由于字典是非线性结构，所以如果使用字典，读取效率会大大降低。为了提升查找效率，<strong>V8 在对象中添加了两个隐藏属性，排序属性和常规属性</strong>，element 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性。properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存常规属性。</p>
<p>  通过引入这两个属性，加速了 V8 查找属性的速度，为了更加进一步提升查找效率，V8 还实现了内置内属性的策略，当常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。</p>
<p>  但是<strong>如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度</strong>。</p>
<blockquote>
<p>资料拓展：<a href="https://time.geekbang.org/column/article/213250" target="_blank" rel="noopener noreferrer">快属性和慢属性：V8 是怎样提升对象属性访问速度的？</a></p>
</blockquote>
<h3 id="堆空间和栈空间" tabindex="-1"> 堆空间和栈空间</h3>
<h4 id="栈空间" tabindex="-1"> 栈空间</h4>
<ul>
<li>现代语言都是基于函数的，每个函数在执行过程中，都有自己的生命周期和作用域，当函数执行结束时，其作用域也会被销毁，因此，我们会使用栈这种数据结构来管理函数的调用过程，我们也把管理函数调用过程的栈结构称之为<strong>调用栈</strong>。</li>
<li><strong>栈空间</strong>主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。</li>
<li><strong>栈空间的最大的特点是空间连续</strong>，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。</li>
<li>栈的优势和缺点：
<ul>
<li>栈的结构非常适合函数调用过程。</li>
<li>在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。</li>
<li>虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，因此栈空间是有限的。</li>
</ul>
</li>
</ul>
<div><pre><code><span>function</span> <span>factorial</span><span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>===</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> n <span>*</span> <span>factorial</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>factorial</span><span>(</span><span>50000</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="堆空间" tabindex="-1"> 堆空间</h4>
<ul>
<li><strong>堆空间</strong>是一种树形的存储结构，用来存储对象类型的离散的数据，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。</li>
<li>宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。</li>
</ul>
<h3 id="继承" tabindex="-1"> 继承</h3>
<p>  <strong>继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性</strong>。</p>
<p>  JavaScript 的每个对象都包含了一个隐藏属性 <code>__proto__</code> ，我们就把该隐藏属性 <code>__proto__</code> 称之为该对象的原型 (prototype)，<code>__proto__</code> 指向了内存中的另外一个对象，我们就把 <code>__proto__</code> 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。</p>
<p>  JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。</p>
<h4 id="隐藏属性-proto" tabindex="-1"> 隐藏属性<code>__proto__</code></h4>
<div><pre><code><span>var</span> animal <span>=</span> <span>{</span>
  <span>type</span><span>:</span> <span>'Default'</span><span>,</span>
  <span>color</span><span>:</span> <span>'Default'</span><span>,</span>
  <span>getInfo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>Type is: </span><span><span>${</span><span>this</span><span>.</span>type<span>}</span></span><span>，color is </span><span><span>${</span><span>this</span><span>.</span>color<span>}</span></span><span>.</span><span>`</span></span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
<span>var</span> dog <span>=</span> <span>{</span>
  <span>type</span><span>:</span> <span>'Dog'</span><span>,</span>
  <span>color</span><span>:</span> <span>'Black'</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>利用<code>__proto__</code>实现继承：</p>
<div><pre><code>dog<span>.</span>__proto__ <span>=</span> animal<span>;</span>
dog<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>  通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 <code>__proto__</code>，但是在实际项目中，我们不应该直接通过 <code>__proto__</code> 来访问或者修改该属性，其主要原因有两个：</p>
<ul>
<li>首先，<strong>这是隐藏属性，并不是标准定义的</strong>;</li>
<li>其次，<strong>使用该属性会造成严重的性能问题</strong>。因为 JavaScript 通过隐藏类优化了很多原有的对象结构，所以通过直接修改<code>__proto__</code>会直接破坏现有已经优化的结构，触发 V8 重构该对象的隐藏类！</li>
</ul>
<h4 id="构造函数是怎么创建对象的" tabindex="-1"> 构造函数是怎么创建对象的？</h4>
<p>  在 JavaScript 中，使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式<strong>隐含的语义过于隐晦</strong>。其实是 JavaScript 为了吸引 Java 程序员、在语法层面去蹭 Java 热点，所以就被硬生生地强制加入了非常不协调的关键字 new。</p>
<div><pre><code><span>function</span> <span>DogFactory</span><span>(</span><span>type<span>,</span> color</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>type <span>=</span> type<span>;</span>
  <span>this</span><span>.</span>color <span>=</span> color<span>;</span>
<span>}</span>
<span>var</span> dog <span>=</span> <span>new</span> <span>DogFactory</span><span>(</span><span>'Dog'</span><span>,</span> <span>'Black'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>  其实当 V8 执行上面这段代码时，V8 在背后悄悄地做了以下几件事情：</p>
<div><pre><code><span>var</span> dog <span>=</span> <span>{</span><span>}</span><span>;</span>
dog<span>.</span>__proto__ <span>=</span> <span>DogFactory</span><span>.</span>prototype<span>;</span>
<span>DogFactory</span><span>.</span><span>call</span><span>(</span>dog<span>,</span> <span>'Dog'</span><span>,</span> <span>'Black'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="机器码、字节码" tabindex="-1"> 机器码、字节码</h3>
<h4 id="v8-为什么要引入字节码" tabindex="-1"> V8 为什么要引入字节码</h4>
<ul>
<li>
<p><strong>早期的 V8</strong> 为了提升代码的<strong>执行速度</strong>，直接将 JavaScript 源代码编译成了<strong>没有优化的二进制机器代码</strong>，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为<strong>热点代码</strong>，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。</p>
</li>
<li>
<p>随着移动设备的普及，V8 团队逐渐发现将 JavaScript 源码直接编译成二进制代码存在两个致命的问题：</p>
<ul>
<li><strong>时间问题</strong>：编译时间过久，影响代码启动速度；</li>
<li><strong>空间问题</strong>：缓存编译后的二进制代码占用更多的内存。</li>
</ul>
</li>
<li>
<p>这两个问题无疑会阻碍 V8 在移动设备上的普及，于是 V8 团队大规模重构代码，引入了中间的字节码。字节码的优势有如下三点：</p>
<ul>
<li><strong>解决启动问题</strong>：生成字节码的时间很短；</li>
<li><strong>解决空间问题</strong>：字节码虽然占用的空间比原始的 JavaScript 多，但是相较于机器代码，字节码还是小了太多，缓存字节码会大大降低内存的使用。</li>
<li><strong>代码架构清晰</strong>：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。</li>
</ul>
</li>
<li>
<p><strong>Bytecode 某种程度上就是汇编语言，只是它没有对应特定的 CPU，或者说它对应的是虚拟的 CPU</strong>。这样的话，生成 Bytecode 时简单很多，无需为不同的 CPU 生产不同的代码。要知道，V8 支持 9 种不同的 CPU，引入一个中间层 Bytecode，可以简化 V8 的编译流程，提高可扩展性。</p>
</li>
<li>
<p>如果我们在不同硬件上去生成 Bytecode，会发现生成代码的指令是一样的。</p>
</li>
</ul>
<h4 id="如何查看字节码" tabindex="-1"> 如何查看字节码</h4>
<div><pre><code><span>// test.js</span>
<span>function</span> <span>add</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>var</span> z <span>=</span> x <span>+</span> y<span>;</span>
  <span>return</span> z<span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行<code>./d8 ./test.js --print-bytecode</code>:</p>
<div><pre><code>[generated bytecode for function: add (0x01000824fe59 &lt;SharedFunctionInfo add&gt;)]
Parameter count 3 #三个参数，包括了显式地传入的 x 和 y，还有一个隐式地传入的 this
Register count 1
Frame size 8
         0x10008250026 @    0 : 25 02             Ldar a1 #将a1寄存器中的值加载到累加器中，LoaD Accumulator from Register
         0x10008250028 @    2 : 34 03 00          Add a0, [0]
         0x1000825002b @    5 : 26 fb             Star r0 #Store Accumulator to Register，把累加器中的值保存到r0寄存器中
         0x1000825002d @    7 : aa                Return  #结束当前函数的执行，并将控制权传回给调用方
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 0)
3
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>常用字节码指令</strong>：</p>
<ul>
<li>Ldar：表示将寄存器中的值加载到累加器中，你可以把它理解为 LoaD Accumulator from Register，就是把某个寄存器中的值，加载到累加器中。</li>
<li>Star：表示 Store Accumulator Register， 你可以把它理解为 Store Accumulator to Register，就是把累加器中的值保存到某个寄存器中</li>
<li>Add：<code>Add a0, [0]</code>是从 a0 寄存器加载值并将其与累加器中的值相加，然后将结果再次放入累加器。
<blockquote>
<p>add a0 后面的[0]称之为 feedback vector slot，又叫<strong>反馈向量槽</strong>，它是一个数组，解释器将解释执行过程中的一些数据类型的分析信息都保存在这个反馈向量槽中了，目的是为了给 TurboFan 优化编译器提供优化信息，很多字节码都会为反馈向量槽提供运行时信息。</p>
</blockquote>
</li>
<li>LdaSmi：将小整数（Smi）加载到累加器寄存器中</li>
<li>Return：结束当前函数的执行，并将控制权传回给调用方。返回的值是累加器中的值。</li>
</ul>
<p><img src="@source/bedstone/google-v8/images/posts/arts/bytecode-ignition.jpg?raw=true" alt="bytecode-ignition"></p>
<blockquote>
<p><a href="https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h" target="_blank" rel="noopener noreferrer">V8 中的字节码指令集</a> | <a href="https://zhuanlan.zhihu.com/p/28590489" target="_blank" rel="noopener noreferrer">理解 V8 的字节码「译」</a></p>
</blockquote>
<h3 id="隐藏类和内联缓存" tabindex="-1"> 隐藏类和内联缓存</h3>
<p>  <strong>JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存</strong>。</p>
<h4 id="为什么静态语言的效率更高" tabindex="-1"> 为什么静态语言的效率更高?</h4>
<p>  静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。可以直接通过<strong>偏移量</strong>查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。</p>
<p>  JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。</p>
<h4 id="将静态的特性引入到-v8" tabindex="-1"> 将静态的特性引入到 V8</h4>
<ul>
<li><strong>V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的</strong>。</li>
<li>具体地讲，V8 对每个对象做如下两点假设：
<ul>
<li>对象创建好了之后就不会添加新的属性；</li>
<li>对象创建好了之后也不会删除属性。</li>
</ul>
</li>
<li>符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：
<ul>
<li>对象中所包含的所有的属性；</li>
<li>每个属性相对于对象的偏移量。</li>
</ul>
</li>
<li>有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。</li>
<li>在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类；</li>
<li>map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。</li>
</ul>
<h4 id="通过-d8-查看隐藏类" tabindex="-1"> 通过 d8 查看隐藏类</h4>
<div><pre><code><span>// test.js</span>
<span>let</span> point1 <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>100</span><span>,</span> <span>y</span><span>:</span> <span>200</span> <span>}</span><span>;</span>
<span>let</span> point2 <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>200</span><span>,</span> <span>y</span><span>:</span> <span>300</span> <span>}</span><span>;</span>
<span>let</span> point3 <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>100</span> <span>}</span><span>;</span>
<span>%</span><span>DebugPrint</span><span>(</span>point1<span>)</span><span>;</span>
<span>%</span><span>DebugPrint</span><span>(</span>point2<span>)</span><span>;</span>
<span>%</span><span>DebugPrint</span><span>(</span>point3<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code> ./d8 --allow-natives-syntax ./test.js
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code># ===============
DebugPrint: 0x1ea3080c5bc5: [JS_OBJECT_TYPE]
# V8 为 point1 对象创建的隐藏类
 - map: 0x1ea308284ce9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
 - elements: 0x1ea3080406e9 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
 - properties: 0x1ea3080406e9 &lt;FixedArray[0]&gt; {
    #x: 100 (const data field 0)
    #y: 200 (const data field 1)
 }
0x1ea308284ce9: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 20
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x1ea308284cc1 &lt;Map(HOLEY_ELEMENTS)&gt;
 - prototype_validity cell: 0x1ea3081c0451 &lt;Cell value= 1&gt;
 - instance descriptors (own) #2: 0x1ea3080c5bf5 &lt;DescriptorArray[2]&gt;
 - prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
 - constructor: 0x1ea3082413b1 &lt;JSFunction Object (sfi = 0x1ea3081c557d)&gt;
 - dependent code: 0x1ea3080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0

# ===============
DebugPrint: 0x1ea3080c5c1d: [JS_OBJECT_TYPE]
# V8 为 point2 对象创建的隐藏类
 - map: 0x1ea308284ce9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
 - elements: 0x1ea3080406e9 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
 - properties: 0x1ea3080406e9 &lt;FixedArray[0]&gt; {
    #x: 200 (const data field 0)
    #y: 300 (const data field 1)
 }
0x1ea308284ce9: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 20
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x1ea308284cc1 &lt;Map(HOLEY_ELEMENTS)&gt;
 - prototype_validity cell: 0x1ea3081c0451 &lt;Cell value= 1&gt;
 - instance descriptors (own) #2: 0x1ea3080c5bf5 &lt;DescriptorArray[2]&gt;
 - prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
 - constructor: 0x1ea3082413b1 &lt;JSFunction Object (sfi = 0x1ea3081c557d)&gt;
 - dependent code: 0x1ea3080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0

# ===============
DebugPrint: 0x1ea3080c5c31: [JS_OBJECT_TYPE]
# V8 为 point3 对象创建的隐藏类
 - map: 0x1ea308284d39 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
 - elements: 0x1ea3080406e9 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
 - properties: 0x1ea3080406e9 &lt;FixedArray[0]&gt; {
    #x: 100 (const data field 0)
 }
0x1ea308284d39: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 16
 - inobject properties: 1
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x1ea308284d11 &lt;Map(HOLEY_ELEMENTS)&gt;
 - prototype_validity cell: 0x1ea3081c0451 &lt;Cell value= 1&gt;
 - instance descriptors (own) #1: 0x1ea3080c5c41 &lt;DescriptorArray[1]&gt;
 - prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
 - constructor: 0x1ea3082413b1 &lt;JSFunction Object (sfi = 0x1ea3081c557d)&gt;
 - dependent code: 0x1ea3080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="多个对象共用一个隐藏类" tabindex="-1"> 多个对象共用一个隐藏类</h4>
<ul>
<li>在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：
<ul>
<li>减少隐藏类的创建次数，也间接加速了代码的执行速度；</li>
<li>减少了隐藏类的存储空间。</li>
</ul>
</li>
<li>那么，什么情况下两个对象的形状是相同的，要满足以下两点：
<ul>
<li>相同的属性名称；</li>
<li>相等的属性个数。</li>
</ul>
</li>
</ul>
<h4 id="重新构建隐藏类" tabindex="-1"> 重新构建隐藏类</h4>
<ul>
<li>给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。</li>
</ul>
<div><pre><code><span>// test.js</span>
<span>let</span> point <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>%</span><span>DebugPrint</span><span>(</span>point<span>)</span><span>;</span>
point<span>.</span>x <span>=</span> <span>100</span><span>;</span>
<span>%</span><span>DebugPrint</span><span>(</span>point<span>)</span><span>;</span>
point<span>.</span>y <span>=</span> <span>200</span><span>;</span>
<span>%</span><span>DebugPrint</span><span>(</span>point<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code># ./d8 --allow-natives-syntax ./test.js
DebugPrint: 0x32c7080c5b2d: [JS_OBJECT_TYPE]
 - map: 0x32c7082802d9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 ...

DebugPrint: 0x32c7080c5b2d: [JS_OBJECT_TYPE]
 - map: 0x32c708284cc1 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 ...

DebugPrint: 0x32c7080c5b2d: [JS_OBJECT_TYPE]
 - map: 0x32c708284ce9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 ...
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>每次给对象添加了一个新属性之后，该对象的隐藏类的地址都会改变，这也就意味着隐藏类也随着改变了；如果删除对象的某个属性，那么对象的形状也就随着发生了改变，这时 V8 也会重建该对象的隐藏类；</li>
<li><strong>最佳实践</strong>
<ul>
<li>使用字面量初始化对象时，要保证属性的顺序是一致的；</li>
<li>尽量使用字面量一次性初始化完整对象属性；</li>
<li>尽量避免使用 delete 方法。</li>
</ul>
</li>
</ul>
<h4 id="通过内联缓存来提升函数执行效率" tabindex="-1"> 通过内联缓存来提升函数执行效率</h4>
<p>  虽然隐藏类能够加速查找对象的速度，但是在 V8 查找对象属性值的过程中，依然有查找对象的隐藏类和根据隐藏类来查找对象属性值的过程。如果一个函数中利用了对象的属性，并且这个函数会被多次执行：</p>
<div><pre><code><span>function</span> <span>loadX</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>return</span> obj<span>.</span>x<span>;</span>
<span>}</span>
<span>var</span> obj <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>1</span><span>,</span> <span>y</span><span>:</span> <span>3</span> <span>}</span><span>;</span>
<span>var</span> obj1 <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>3</span><span>,</span> <span>y</span><span>:</span> <span>6</span> <span>}</span><span>;</span>
<span>var</span> obj2 <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>3</span><span>,</span> <span>y</span><span>:</span> <span>6</span><span>,</span> <span>z</span><span>:</span> <span>8</span> <span>}</span><span>;</span>
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>90000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>// 对比时间差异</span>
  console<span>.</span><span>time</span><span>(</span><span><span>`</span><span>---</span><span><span>${</span>i<span>}</span></span><span>----</span><span>`</span></span><span>)</span><span>;</span>
  <span>loadX</span><span>(</span>obj<span>)</span><span>;</span>
  console<span>.</span><span>timeEnd</span><span>(</span><span><span>`</span><span>---</span><span><span>${</span>i<span>}</span></span><span>----</span><span>`</span></span><span>)</span><span>;</span>
  <span>loadX</span><span>(</span>obj1<span>)</span><span>;</span>
  <span>// 产生多态</span>
  <span>loadX</span><span>(</span>obj2<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>通常 V8 获取 obj.x 的流程</strong>：</p>
<ul>
<li>找对象 obj 的隐藏类；</li>
<li>再通过隐藏类查找 x 属性偏移量；</li>
<li>然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 obj.x 的流程也需要反复被执行；</li>
</ul>
<p><strong>内联缓存及其原理</strong>：</p>
<ul>
<li>函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是<strong>内联缓存 (Inline Cache)</strong>，简称为 IC；</li>
<li><strong>IC 的原理</strong>：在 V8 执行函数的过程中，会观察函数中一些<strong>调用点 (CallSite)</strong> 上的关键中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。</li>
<li>IC 会为每个函数维护一个<strong>反馈向量 (FeedBack Vector)</strong>，反馈向量记录了函数在执行过程中的一些关键的中间数据。</li>
<li>反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。</li>
<li>当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return obj.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 obj.x 的属性值了。这样就大大提升了 V8 的执行效率。</li>
</ul>
<p><strong>单态、多态和超态</strong>：</p>
<ul>
<li>如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；</li>
<li>如果一个插槽中包含了 2 ～ 4 个隐藏类，那我们称这种状态为多态 (polymorphic)；</li>
<li>如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。</li>
<li>单态的性能优于多态和超态，所以我们需要稍微避免多态和超态的情况。要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(obj) 的函数，那么当传递参数时，尽量不要使用多个不同形状的 obj 对象。</li>
</ul>
<p><strong>总结：</strong><br>
  V8 引入了内联缓存（IC），<strong>IC 会监听每个函数的执行过程，并在一些关键的地方埋下监听点</strong>，这些包括了加载对象属性 (Load)、给对象属性赋值 (Store)、还有函数调用 (Call)，V8 会将监听到的数据写入一个称为反馈向量 (FeedBack Vector) 的结构中，同时 V8 会为每个执行的函数维护一个反馈向量。有了反馈向量缓存的临时数据，V8 就可以缩短对象属性的查找路径，从而提升执行效率。但是针对函数中的同一段代码，如果对象的隐藏类是不同的，那么反馈向量也会记录这些不同的隐藏类，这就出现了多态和超态的情况。我们在实际项目中，要尽量避免出现多态或者超态的情况。</p>
<h3 id="异步编程与消息队列" tabindex="-1"> 异步编程与消息队列</h3>
<h4 id="v8-是如何执行回调函数的" tabindex="-1"> V8 是如何执行回调函数的</h4>
<p>  回调函数有两种类型：同步回调和异步回调，同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。<br>
  通用 UI 线程宏观架构：
<img src="@source/bedstone/google-v8/images/posts/arts/v8-ui.jpg?raw=true" alt="通用UI线程架构">
  UI 线程提供一个<strong>消息队列</strong>，并将待执行的事件添加到消息队列中，然后 UI 线程会不断循环地从消息队列中取出事件、执行事件。关于异步回调，这里也有两种不同的类型，其典型代表是 setTimeout 和 XMLHttpRequest：</p>
<ul>
<li>setTimeout 的执行流程其实是比较简单的，在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。</li>
<li>XMLHttpRequest 稍微复杂一点，因为下载过程需要放到单独的一个线程中去执行，所以执行 XMLHttpRequest.send 的时候，宿主会将实际请求转发给网络线程，然后 send 函数退出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。</li>
</ul>
<h4 id="宏任务和微任务" tabindex="-1"> 宏任务和微任务</h4>
<ul>
<li>
<p>调用栈：调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。主线程在执行任务的过程中，如果函数的调用层次过深，可能造成栈溢出的错误，我们可以使用 setTimeout 来解决栈溢出的问题。setTimeout 的本质是将同步函数调用改成异步函数调用，这里的异步调用是将回调函数封装成宏任务，并将其添加进消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个宏任务。</p>
</li>
<li>
<p>宏任务：就是指消息队列中的等待被主线程执行的事件。每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。</p>
</li>
<li>
<p>微任务：你可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
</li>
<li>
<p>JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。另外使用微任务，可以改变我们现在的异步编程模型，使得我们可以使用同步形式的代码来编写异步调用。</p>
</li>
<li>
<p>微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async 等现代前端经常使用的一些技术。</p>
<p><img src="@source/bedstone/google-v8/images/posts/arts/microtask.jpg?raw=true" alt="微任务技术栈"></p>
<div><pre><code><span>// 不会使浏览器卡死</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span>foo<span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>
<span>foo</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="@source/bedstone/google-v8/images/posts/arts/stack.jpg?raw=true" alt="调用栈、主线程、消息队列">
微任务：</p>
</li>
</ul>
<div><pre><code><span>// 浏览器console控制台可使浏览器卡死（无法响应鼠标事件等）</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span>foo<span>)</span><span>;</span>
<span>}</span>
<span>foo</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张；</li>
<li>和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。因此在函数内部触发的微任务，一定比在函数内部触发的宏任务要优先执行。</li>
<li>微任务依然是在当前的任务中执行的，所以如果在微任务中循环触发新的微任务，那么将导致消息队列中的其他任务没有机会被执行。</li>
</ul>
<h4 id="前端异步编程方案史" tabindex="-1"> 前端异步编程方案史</h4>
<p><img src="@source/bedstone/google-v8/images/posts/arts/async.jpg?raw=true" alt="前端异步编程方案史"></p>
<ul>
<li>Callback 模式的异步编程模型需要实现大量的回调函数，大量的回调函数会打乱代码的正常逻辑，使得代码变得不线性、不易阅读，这就是我们所说的<strong>回调地狱问题</strong>。</li>
<li>Promise 能很好地解决回调地狱的问题，我们可以按照线性的思路来编写代码，这个过程是线性的，非常符合人的直觉。</li>
<li>但是这种方式<strong>充满了 Promise 的 then() 方法</strong>，如果处理流程比较复杂的话，那么整段代码将<strong>充斥着大量的 then，语义化不明显，代码不能很好地表示执行流程</strong>。我们想要通过<strong>线性的方式</strong>来编写异步代码，要实现这个理想，<strong>最关键的是要能实现函数暂停和恢复执行的功能</strong>。而<strong>生成器</strong>就可以实现函数暂停和恢复，我们可以在生成器中使用同步代码的逻辑来异步代码 (实现该逻辑的核心是协程)。</li>
<li>但是在生成器之外，我们还需要一个<strong>触发器</strong>来驱动生成器的执行。前端的最终方案就是 async/await，async 是一个可以暂停和恢复执行的函数，在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。因此，使用 async/await 可以实现以同步的方式编写异步代码这一目标。和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程。</li>
</ul>
<blockquote>
<p><strong>协程</strong>是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>
</blockquote>
<blockquote>
<p><strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</strong>。每一时刻，该线程只能执行其中某一个协程。最重要的是，<strong>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</strong>。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
</blockquote>
<blockquote>
<p>资料拓展：<a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="noopener noreferrer">co 函数库的含义和用法</a></p>
</blockquote>
<h3 id="垃圾回收" tabindex="-1"> 垃圾回收</h3>
<h4 id="垃圾数据" tabindex="-1"> 垃圾数据</h4>
<p>  从“<strong>GC Roots</strong>”对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。</p>
<h4 id="垃圾回收算法" tabindex="-1"> 垃圾回收算法</h4>
<p>垃圾回收大致可以分为以下几个步骤：</p>
<ul>
<li>
<p>第一步，<strong>通过 GC Root 标记空间中活动对象和非活动对象</strong>。目前 V8 采用的<strong>可访问性（reachability）算法</strong>来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 GC Root 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：</p>
<ul>
<li>通过 GC Root 遍历到的对象，我们就认为该对象是<strong>可访问的（reachable）</strong>，那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为<strong>活动对象</strong>；</li>
<li>通过 GC Roots 没有遍历到的对象，则是<strong>不可访问的（unreachable）</strong>，那么这些不可访问的对象就可能被回收，我们称不可访问的对象为<strong>非活动对象</strong>。</li>
<li>在<strong>浏览器环境中，GC Root 有很多</strong>，通常包括了以下几种 (但是不止于这几种)：
<ul>
<li>全局的 window 对象（位于每个 iframe 中）；</li>
<li>文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；</li>
<li>存放栈上变量。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第二步，<strong>回收非活动对象所占据的内存</strong>。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
</li>
<li>
<p>第三步，<strong>做内存整理</strong>。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片(比如副垃圾回收器)。</p>
</li>
</ul>
<h4 id="垃圾回收-1" tabindex="-1"> 垃圾回收</h4>
<ul>
<li>V8 依据<strong>代际假说</strong>，将堆内存划分为<strong>新生代和老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。代际假说有两个特点：
<ul>
<li>第一个是大部分对象都是“<strong>朝生夕死</strong>”的，也就是说<strong>大部分对象在内存中存活的时间很短</strong>，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是<strong>不死的对象，会活得更久</strong>，比如全局的 window、DOM、Web API 等对象。</li>
</ul>
</li>
<li>为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。
<ul>
<li><strong>主垃圾回收器</strong>负责收集老生代中的垃圾数据，<strong>副垃圾回收器</strong>负责收集新生代中的垃圾数据。</li>
<li><strong>副垃圾回收器采用了 Scavenge 算法</strong>，是把新生代空间对半划分为两个区域（有些地方也称作 From 和 To 空间），一半是对象区域，一半是空闲区域。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。
<ul>
<li>这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</li>
<li>副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般<strong>新生区的空间会被设置得比较小</strong>。</li>
<li>副垃圾回收器还会采用<strong>对象晋升策略</strong>，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。</li>
</ul>
</li>
<li>主垃圾回收器回收器主要负责<strong>老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程</strong>。
<ul>
<li>主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。</li>
<li>老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="stop-the-world" tabindex="-1"> Stop-The-World</h4>
<p>  由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<ul>
<li>V8 最开始的垃圾回收器有两个特点：
<ul>
<li>第一个是垃圾回收在主线程上执行，</li>
<li>第二个特点是一次执行一个完整的垃圾回收流程。</li>
</ul>
</li>
<li>由于这两个原因，很容易造成主线程卡顿，所以 V8 采用了很多优化执行效率的方案。
<ul>
<li>第一个方案是<strong>并行回收</strong>，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。</li>
<li>第二个方案是<strong>增量式垃圾回收</strong>，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。</li>
<li>第三个方案是<strong>并发回收</strong>，回收线程在执行 JavaScript 的过程，辅助线程能够在后台完成的执行垃圾回收的操作。
<blockquote>
<p>资料参考：<a href="https://www.oschina.net/translate/v8-javascript-engine" target="_blank" rel="noopener noreferrer">深入解读 V8 引擎的「并发标记」技术</a></p>
</blockquote>
</li>
<li>主垃圾回收器就综合采用了所有的方案（并发标记，增量标记，辅助清理），副垃圾回收器也采用了部分方案。</li>
</ul>
</li>
</ul>
<h2 id="似此星辰非昨夜-为谁风露立中宵" tabindex="-1"> 似此星辰非昨夜，为谁风露立中宵</h2>
<h3 id="breaking-the-javascript-speed-limit-with-v8" tabindex="-1"> Breaking the JavaScript Speed Limit with V8</h3>
<p>  Daniel Clifford 在 <a href="https://zh.wikipedia.org/wiki/Google_I/O" target="_blank" rel="noopener noreferrer">Google I/O</a> 2012 上做了一个精彩的演讲“<strong>Breaking the JavaScript Speed Limit with V8</strong>”。在演讲中，他深入解释了 13 个简单的代码优化方法，可以让你的 JavaScript 代码在 Chrome V8 引擎编译/运行时更加快速。在演讲中，他介绍了怎么优化，并解释了原因。下面简明的列出了<strong>13 个 JavaScript 性能提升技巧</strong>：</p>
<ol>
<li>在构造函数里初始化所有对象的成员(所以这些实例之后不会改变其隐藏类)；</li>
<li>总是以相同的次序初始化对象成员；</li>
<li>尽量使用可以用 31 位有符号整数表示的数；</li>
<li>为数组使用从 0 开始的连续的主键；</li>
<li>别预分配大数组(比如大于 64K 个元素)到其最大尺寸，令其尺寸顺其自然发展就好；</li>
<li>别删除数组里的元素，尤其是数字数组；</li>
<li>别加载未初始化或已删除的元素；</li>
<li>对于固定大小的数组，使用”array literals“初始化（初始化小额定长数组时，用字面量进行初始化）；</li>
<li>小数组(小于 64k)在使用之前先预分配正确的尺寸；</li>
<li>请勿在数字数组中存放非数字的值(对象)；</li>
<li>尽量使用单一类型（monomorphic）而不是多类型（polymorphic）（如果通过非字面量进行初始化小数组时，切勿触发类型的重新转换）；</li>
<li>不要使用 <code>try{} catch{}</code>（如果存在 <code>try/catch</code> 代码快，则将性能敏感的代码放到一个嵌套的函数中）；</li>
<li>在优化后避免在方法中修隐藏的类。</li>
</ol>
<blockquote>
<p>演讲资料参考： <a href="https://www.html5rocks.com/en/tutorials/speed/v8/" target="_blank" rel="noopener noreferrer">Performance Tips for JavaScript in V8</a> | <a href="https://www.dazhuanlan.com/2019/12/07/5deb7aee6b870" target="_blank" rel="noopener noreferrer">译文</a> | <a href="https://v.youku.com/v_show/id_XNDk3NzA2Mjg0.html" target="_blank" rel="noopener noreferrer">内网视频</a> | <a href="https://www.youtube.com/watch?v=UJPdhx5zTaw&amp;ab_channel=GoogleDevelopers" target="_blank" rel="noopener noreferrer">YouTube</a></p>
</blockquote>
<h3 id="在-v8-引擎里-5-个优化代码的技巧" tabindex="-1"> 在 V8 引擎里 5 个优化代码的技巧</h3>
<ol>
<li><strong>对象属性的顺序</strong>: 在实例化你的对象属性的时候一定要使用相同的顺序，这样隐藏类和随后的优化代码才能共享；</li>
<li><strong>动态属性</strong>: 在对象实例化之后再添加属性会强制使得隐藏类变化，并且会减慢为旧隐藏类所优化的代码的执行。所以，要在对象的构造函数中完成所有属性的分配；</li>
<li><strong>方法</strong>: 重复执行相同的方法会运行的比不同的方法只执行一次要快 (因为内联缓存)；</li>
<li><strong>数组</strong>: 避免使用 keys 不是递增的数字的稀疏数组，这种 key 值不是递增数字的稀疏数组其实是一个 hash 表。在这种数组中每一个元素的获取都是昂贵的代价。同时，要避免提前申请大数组。最好的做法是随着你的需要慢慢的增大数组。最后，不要删除数组中的元素，因为这会使得 keys 变得稀疏；</li>
<li><strong>标记值 (Tagged values)</strong>: V8 用 32 位来表示对象和数字。它使用一位来区分它是对象 (flag = 1) 还是一个整型 (flag = 0)，也被叫做小整型(SMI)，因为它只有 31 位。然后，如果一个数值大于 31 位，V8 将会对其进行 <strong>box 操作</strong>，然后将其转换成 double 型，并且创建一个新的对象来装这个数。所以，为了避免代价很高的 box 操作，尽量使用 31 位的有符号数。</li>
</ol>
<blockquote>
<p>资料参考：<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener noreferrer">How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</a> | <a href="https://juejin.im/post/6844903512237670414" target="_blank" rel="noopener noreferrer">译文</a></p>
</blockquote>
<blockquote>
<p><strong>box 操作</strong>参考：<a href="https://time.geekbang.org/column/article/78884" target="_blank" rel="noopener noreferrer">JavaScript 类型：关于类型，有哪些你不知道的细节？</a> | <a href="https://mp.weixin.qq.com/s/QDHJBCP9E8GyKPlMOExwAA" target="_blank" rel="noopener noreferrer">JavaScript 的装箱和拆箱</a> | <a href="https://juejin.im/post/6844903859765133320" target="_blank" rel="noopener noreferrer">谈谈 JavaScript 中装箱和拆箱</a></p>
</blockquote>
<h3 id="javascript-启动性能瓶颈分析与解决方案" tabindex="-1"> JavaScript 启动性能瓶颈分析与解决方案</h3>
<blockquote>
<p>资料参考： <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener noreferrer">JavaScript Start-up Performance</a> | <a href="https://zhuanlan.zhihu.com/p/25221314" target="_blank" rel="noopener noreferrer">JavaScript 启动性能瓶颈分析与解决方案</a></p>
</blockquote>
<h2 id="天长地久有时尽-v8-绵绵无绝期" tabindex="-1"> 天长地久有时尽，V8 绵绵无绝期</h2>
<ul>
<li><a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">v8</a></li>
<li><a href="https://time.geekbang.org/column/intro/296" target="_blank" rel="noopener noreferrer"><strong>图解 Google V8</strong></a></li>
<li><a href="https://time.geekbang.org/column/intro/216" target="_blank" rel="noopener noreferrer"><strong>浏览器工作原理与实践</strong></a></li>
<li><a href="https://www.zhihu.com/column/v8core" target="_blank" rel="noopener noreferrer">V8、Chrome、Node.js【知乎专栏】</a></li>
<li><a href="https://mp.weixin.qq.com/s/qFVxdN2J3qYbBo8_q93SAA" target="_blank" rel="noopener noreferrer">JavaScript 引擎 V8 执行流程概述</a></li>
<li><a href="https://juejin.im/post/6844903510538993671" target="_blank" rel="noopener noreferrer">[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述</a></li>
<li><a href="https://juejin.im/post/6844903518319411207" target="_blank" rel="noopener noreferrer">[译] JavaScript 如何工作的: 事件循环和异步编程的崛起 + 5 个关于如何使用 async/await 编写更好的技巧</a></li>
</ul>
<h2 id="番外篇" tabindex="-1"> 番外篇</h2>
<ul>
<li><a href="https://github.com/pd4d10/console-importer" target="_blank" rel="noopener noreferrer">Console Importer</a>：Easily import JS and CSS resources from Chrome console. （可以在浏览器控制台安装 loadsh、moment、jQuery 等库，在控制台直接验证、使用这些库。）<br>
效果图：<br>
<img src="@source/bedstone/google-v8/images/posts/arts/js.gif?raw=true" alt="Console Importer"></li>
</ul>

<h2 id="发布链接及部分转载" tabindex="-1"> 发布链接及部分转载</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000037435824" target="_blank" rel="noopener noreferrer">思否：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/266708344" target="_blank" rel="noopener noreferrer">知乎 1：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/265001795" target="_blank" rel="noopener noreferrer">知乎 2：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://mp.weixin.qq.com/s/E-c9gsk-kxIwnwY4R5z_3Q" target="_blank" rel="noopener noreferrer">《奇舞周刊》：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://mp.weixin.qq.com/s/ASwOPvsKSVSzxHM0FOKKVA" target="_blank" rel="noopener noreferrer">code 秘密花园：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://mp.weixin.qq.com/s/0OxNG1AWrkTIVK6N36wk4A" target="_blank" rel="noopener noreferrer">前端大全：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://mp.weixin.qq.com/s/3Sy_ajvoHPSFAJeKogAdUg" target="_blank" rel="noopener noreferrer">前端 Q：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
<li><a href="https://mp.weixin.qq.com/s/GbNeEgu-1IBr4O_s8c_58g" target="_blank" rel="noopener noreferrer">Nodejs 技术栈：浏览器是如何工作的：Chrome V8 让你更懂 JavaScript</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>前端基石</title>
      <link>https://0808200.xyz/bedstone/</link>
      <guid>https://0808200.xyz/bedstone/</guid>
      <source url="https://0808200.xyz/rss.xml">前端基石</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>专栏介绍</p>
<p>打牢基础，进阶大厂</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>设计模式之美</title>
      <link>https://0808200.xyz/bedstone/beauty-of-design-pattern/</link>
      <guid>https://0808200.xyz/bedstone/beauty-of-design-pattern/</guid>
      <source url="https://0808200.xyz/rss.xml">设计模式之美</source>
      <category>设计模式</category>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
    </item>
    <item>
      <title>浏览器工作原理与实践</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/</guid>
      <source url="https://0808200.xyz/rss.xml">浏览器工作原理与实践</source>
      <category>浏览器</category>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="宏观视角上的浏览器" tabindex="-1"> 宏观视角上的浏览器</h2>
<div><p>章节速览</p>
<p>Chrome架构：仅仅打开了1个页面，为什么有4个进程</p>
<p>TCP协议：如何保证页面文件能被完整送达浏览器</p>
<p>HTTP请求流程：为什么很多站点第二次打开速度会很快</p>
<p>导航流程：从输入URL到页面展示这中间发生了什么</p>
<p>渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的</p>
<p>渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的</p>
</div>
<h2 id="浏览器中的javascript执行机制" tabindex="-1"> 浏览器中的JavaScript执行机制</h2>
<div><p>章节速览</p>
<p>变量提升：JavaScript代码是按顺序执行的吗</p>
<p>调用栈：为什么JavaScript代码会出现栈溢出</p>
<p>块级作用域：var缺陷以及为什么要引入let和const</p>
<p>作用域链和闭包：代码中出现相同的变量，JavaScript引擎如何选择</p>
<p>this：从JavaScript执行上下文视角讲this</p>
</div>
<h2 id="v8工作原理" tabindex="-1"> V8工作原理</h2>
<div><p>章节速览</p>
<p>栈空间和堆空间：数据是如何存储的</p>
<p>垃圾回收：垃圾数据如何自动回收</p>
<p>编译器和解析器：V8如何执行一段JavaScript代码的</p>
</div>
<h2 id="浏览器中的页面循环系统" tabindex="-1"> 浏览器中的页面循环系统</h2>
<div><p>章节速览</p>
<p>消息队列和事件循环：页面是怎么活起来的</p>
<p>Webapi：setTimeout是怎么实现的</p>
<p>Webapi：XMLHttpRequest是怎么实现的</p>
<p>宏任务和微任务：不是所有的任务都是一个待遇</p>
<p>使用Promise告别回调函数</p>
<p>async await使用同步方式写异步代码</p>
</div>
<h2 id="浏览器中的页面" tabindex="-1"> 浏览器中的页面</h2>
<div><p>章节速览</p>
<p>页面性能分析：利用chrome做web性能分析</p>
<p>DOM树：JavaScript是如何影响DOM树构建的</p>
<p>渲染流水线：CSS如何影响首次加载时的白屏时间？</p>
<p>分层和合成机制：为什么css动画比JavaScript高效</p>
<p>页面性能：如何系统优化页面</p>
<p>虚拟DOM：虚拟DOM和实际DOM有何不同</p>
<p>PWA：解决了web应用哪些问题</p>
<p>webComponent：像搭积木一样构建web应用</p>
</div>
<h2 id="浏览器中的网络" tabindex="-1"> 浏览器中的网络</h2>
<div><p>章节速览</p>
<p>HTTP1：HTTP性能优化</p>
<p>HTTP2：如何提升网络速度</p>
<p>HTTP3：甩掉TCP、TCL包袱 构建高效网络</p>
<p>同源策略：为什么XMLHttpRequst不能跨域请求资源</p>
<p>跨站脚本攻击XSS：为什么cookie中有httpOnly属性</p>
<p>CSRF攻击：陌生链接不要随便点</p>
<p>沙盒：页面和系统之间的隔离墙</p>
<p>HTTPS：让数据传输更安全</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>计算机内存机制</title>
      <link>https://0808200.xyz/bedstone/computer-memory-detail/</link>
      <guid>https://0808200.xyz/bedstone/computer-memory-detail/</guid>
      <source url="https://0808200.xyz/rss.xml">计算机内存机制</source>
      <category>内存</category>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>程序是在内存中运行的，一名合格的程序员必须了解内存，一名不了解内存的程序员，注定不能让自己的编程水平有一个质的飞越，只能雾里看花，知其然不知其所以然。</p>
<h2 id="_1、一个程序在计算机中到底是如何运行的" tabindex="-1"> 1、一个程序在计算机中到底是如何运行的？</h2>
<p>程序是保存在硬盘中的，要载入内存才能运行，CPU也被设计为只能从内存中读取数据和指令。</p>
<p>对于CPU来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能，例如要计算 a = b + c，必须将 a、b、c 都读取到CPU内部才能进行加法运算。为了了解具体的运算过程，我们不妨先来看一下CPU的结构。</p>
<p>CPU是一个复杂的计算机部件，它内部又包含很多小零件，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/7ce095f844204c06969fd55e644da2a1.png" alt="在这里插入图片描述"></p>
<p>运算单元是CPU的大脑，负责加减乘除、比较、位移等运算工作，每种运算都有对应的电路支持，速度很快。</p>
<p><code>寄存器（Register）</code>是CPU内部非常小、非常快速的存储部件，它的容量很有限，对于32位的CPU，每个寄存器一般能存储32位（4个字节）的数据，对于64位的CPU，每个寄存器一般能存储64位（8个字节）的数据。为了完成各种复杂的功能，现代CPU都内置了几十个甚至上百个的寄存器，嵌入式系统功能单一，寄存器数量较少。</p>
<p>我们经常听说多少位的CPU，指的就是寄存器的的位数。现在个人电脑使用的CPU已经进入了64位时代，例如 Intel 的 Core i3、i5、i7 等。</p>
<p>寄存器在程序的执行过程中至关重要，不可或缺，它们可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记CPU运行状态等。</p>
<p>例如：<code>EIP（Extern Instruction Pointer ）寄存器</code>的值是下一条指令的地址，CPU执行完当前指令后，会根据 EIP 的值找到下一条指令，改变 EIP 的值，就会改变程序的执行流程；<code>CR3 寄存器</code>保存着当前进程页目录的物理地址，切换进程就会改变 CR3 的值，这将在《》中讲解；EBP、ESP 寄存器用来指向栈的底部和顶部，函数调用会改变 EBP 和 ESP 的值，这将在《》中讲解。</p>
<p>那么， <strong>在CPU内部为什么又要设置缓存呢？</strong></p>
<p>虽然内存的读取速度已经很快了，但是和CPU比起来，还是有很大差距的，不是一个数量级的，如果每次都从内存中读取数据，会严重拖慢CPU的运行速度，CPU经常处于等待状态，无事可做。在CPU内部设置一个缓存，可以将使用频繁的数据暂时读取到缓存，需要同一地址上的数据时，就不用大老远地再去访问内存，直接从缓存中读取即可。</p>
<p><img src="https://img-blog.csdnimg.cn/25dfbda1b732462982d731ffb08e9c4f.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>大家在购买CPU时，也会经常关心缓存容量，例如 Intel Core i7 3770K 的三级缓存为 8MB，二级缓存为 256KB，一级缓存为 32KB。容量越大，CPU越强悍。</p>
</blockquote>
<p>缓存的容量是有限的，CPU只能从缓存中读取到部分数据，对于使用不是很频繁的数据，会绕过缓存，直接到内存中读取。所以不是每次都能从缓存中得到数据，这就是缓存的命中率，能够从缓存中读取就命中，否则就没命中。关于缓存的命中率又是一门学问，哪些数据保留在缓存，哪些数据不保留，都有复杂的算法。</p>
<p>CPU指令
要想让CPU工作，必须借助特定的指令，例如 add 用于加法运算，sub 用于除法运算，cmp 用于比较两个数的大小，这称为<code>CPU的指令集（Instruction Set）</code>。我们的C语言代码最终也会编译成一条一条的CPU指令。不同型号的CPU支持的指令集会有所差异，但绝大部分是相同的。</p>
<blockquote>
<p>本节我们讲解了CPU的简单构造以及CPU指令，重点是让大家认识寄存器这个小而快速的存储部件，它在程序运行过程中起着至关重要的作用，CPU就是用它来记录程序的运行状态，然后根据它的值再决定下一步的操作。</p>
</blockquote>
<h2 id="_2、虚拟内存到底是什么" tabindex="-1"> 2、虚拟内存到底是什么？</h2>
<p>在C语言中，指针变量的值就是一个内存地址，<code>&amp;</code>运算符的作用也是取变量的内存地址，请看下面的代码：</p>
<p><img src="https://img-blog.csdnimg.cn/ac651c5569fc468d8509c329fe325742.png" alt="在这里插入图片描述"></p>
<p>代码中的 a、b 是全局变量，它们的内存地址在链接时就已经决定了，以后再也不能改变，该程序无论在何时运行，结果都是一样的。</p>
<p><strong>那么问题来了，如果物理内存中的这两个地址被其他程序占用了怎么办，我们的程序岂不是无法运行了？</strong></p>
<p>幸运的是，这些内存地址都是假的，不是真实的物理内存地址，而是虚拟地址。虚拟地址通过CPU的转换才能对应到物理地址，而且每次程序运行时，操作系统都会重新安排虚拟地址和物理地址的对应关系，哪一段物理内存空闲就使用哪一段。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/3a24fce2fc014e188c1d674d4c7cbd8e.png" alt="在这里插入图片描述"></p>
<h3 id="虚拟地址" tabindex="-1"> 虚拟地址</h3>
<p>虚拟地址的整个想法是这样的：把程序给出的地址看做是一种<code>虚拟地址（Virtual Address）</code>，然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。</p>
<p>例如，上面代码中变量 a 的地址是 0X404038，第一次运行时它对应的物理内存地址可能是 0X12ED90AA，第二次运行时可能又对应 0XED90，而我们的程序不需要关心这些，这些繁杂的内存管理工作交给操作系统处理即可。</p>
<p>让我们回到程序的运行本质上来。用户程序在运行时不希望介入到这些复杂的内存管理过程中，作为普通的程序，它需要的是一个简单的执行环境，有自己的内存，有自己的CPU，好像整个程序占有整个计算机而不用关心其他的程序。</p>
<p>除了在编程时可以使用固定的内存地址，给程序员带来方便外，使用虚拟地址还能够使不同程序的地址空间相互隔离，提高内存使用效率。</p>
<p><strong>使不同程序的地址空间相互隔离</strong></p>
<p>如果所有程序都直接使用物理内存，那么程序所使用的地址空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意、但是有 Bug 的程序也可能会不小心修改其他程序的数据，导致其他程序崩溃。</p>
<p>这对于需要安全稳定的计算机环境的用户来说是不能容忍的，用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他任务。</p>
<p>使用了虚拟地址后，程序A和程序B虽然都可以访问同一个地址，但它们对应的物理地址是不同的，无论如何操作，都不会修改对方的内存。</p>
<p><strong>提高内存使用效率</strong></p>
<p>使用虚拟地址后，操作系统会更多地介入到内存管理工作中，这使得控制内存权限成为可能。例如，我们希望保存数据的内存没有执行权限，保存代码的内存没有修改权限，操作系统占用的内存普通程序没有读取权限等。</p>
<p>另外，当物理内存不足时，操作系统能够更加灵活地控制换入换出的粒度，磁盘 I/O 是非常耗时的工作，这能够从很大程度上提高程序性能。</p>
<p>以上两点我们将在《》和《》中进行详细讲解。</p>
<h3 id="中间层思想" tabindex="-1"> 中间层思想</h3>
<p>在计算机中，为了让操作更加直观、易于理解、增强用户体验，开发者经常会使用一件法宝——<code>增加中间层</code>，即使用一种间接的方式来屏蔽复杂的底层细节，只给用户提供简单的接口。虚拟地址是使用中间层的一个典型例子。</p>
<p>实际上，计算机的整个发展过程就是不断引入新的中间层：</p>
<ul>
<li>计算机的早期，程序都是直接运行在硬件之上，自己负责硬件的管理工作；程序员也使用二进制进行编程，需要处理各种边界条件和安全问题。</li>
<li>后来人们不能忍受了，于是开发出了操作系统，让它来管理各种硬件，同时发明了汇编语言，减轻程序员的负担。</li>
<li>随着软件规模的不断增大，使用汇编语言编程开始变得捉襟见肘，不仅学习成本高，开发效率也很低，于是C语言诞生了。C语言编译器先将C代码翻译为汇编代码，再由汇编器将汇编代码翻译成机器指令。</li>
<li>随着计算机的发展，硬件越来越强大，软件越来越复杂，人们又不满足于使用C语言了，于是 C++、Java、C#、PHP 等现代化的编程语言诞生了。</li>
</ul>
<h2 id="_3、虚拟地址空间以及编译模式" tabindex="-1"> 3、虚拟地址空间以及编译模式</h2>
<p>所谓虚拟地址空间，就是程序可以使用的虚拟地址的有效范围。虚拟地址和物理地址的映射关系由操作系统决定，相应地，虚拟地址空间的大小也由操作系统决定，但还会受到编译模式的影响。</p>
<p>这节我们先讲解CPU，再讲解编译模式，让大家了解编译器是如何配合CPU来提高程序运行速度的。</p>
<h3 id="cpu的数据处理能力" tabindex="-1"> CPU的数据处理能力</h3>
<p>CPU是计算机的核心，决定了计算机的数据处理能力和寻址能力，也即决定了计算机的性能。CPU一次（一个时钟内）能处理的数据的大小由寄存器的位数和数据总线的宽度（也即有多少根数据总线）决定，我们通常所说的多少位的CPU，除了可以理解为寄存器的位数，也可以理解数据总线的宽度，通常情况下它们是相等的。</p>
<p>数据总线位于主板之上，不在CPU中，也不由CPU决定，严格来讲，这里应该说CPU能够支持的数据总线的最大根数，也即能够支持的最大数据处理能力，为了表达方便，本文才使用“CPU的数据总线”这一说法。</p>
<p>数据总线和主频都是CPU的重要指标：数据总线决定了CPU单次的数据处理能力，主频决定了CPU单位时间内的数据处理次数，它们的乘积就是CPU单位时间内的数据处理量。</p>
<p>我们常常听说，CPU主频在计算机的发展过程中飞速提升，从最初的几十 KHz，到后来的几百 MHz，再到现在的 4GHz，终于因为硅晶体的物理特性很难再提升，只能向多核方向发展。在这个过程中，CPU的数据总线宽度也在成倍增长，从早期的8位、16位，到后来的32位，现在我们计算机大部分都在使用64位CPU。</p>
<p>需要注意的是，数据总线和地址总线不是一回事，数据总线用于在CPU和内存之间传输数据，地址总线用于在内存上定位数据，它们之间没有必然的联系，宽度并不一定相等。实际情况是，地址总线的宽度往往随着数据总线的宽度而增长，以访问更大的内存。</p>
<p><strong>16位CPU</strong>
早期的CPU是16位的，一次能处理 16Bit（2个字节）的数据。这个时候计算机产业还处在早期，个人电脑也没有进入千家万户，也没有提出虚拟地址的概念，程序还是直接运行在物理内存上，操作系统对内存的管理非常简陋，程序员轻易就能编写一个恶意程序去修改其他程序的内存。</p>
<p>学过汇编的同学应该知道，典型的16位处理器是 Intel 8086，它的数据总线有16根，地址总线有20根，寻址能力为 2^20 = 1MB。</p>
<p><strong>32位CPU</strong>
随着计算机产业的进步，出现了32位的CPU，一次能处理 32Bit（4个字节）的数据。这个时候就提出了虚拟地址的概念，并被应用到CPU和操作系统中，由它们共同完成虚拟地址和物理地址的映射，这使得程序编写更加容易，运行更加安全。</p>
<p>典型的32位处理器是 Intel 的 80386 和 Intel Pentium 4（奔腾4）：80386 的数据总线和地址总线宽度都是32位，寻址能力达4GB；Pentium 4的地址总线宽度是36位，理论寻址能力达64GB。</p>
<p><strong>64位CPU</strong>
现代计算机都使用64位的CPU，它们一次能处理64Bit（8个字节）的数据。典型的64位处理器是 Intel 的 Core i3、i5、i7 等，它们的地址总线宽度为 40~50 位左右。64位CPU的出现使个人电脑再次发生了质的飞跃。</p>
<p><strong>实际支持的物理内存</strong>
CPU支持的物理内存只是理论上的数据，实际应用中还会受到操作系统的限制，例如，Win7  64位家庭版最大仅支持8GB或16GB的物理内存，Win7 64位专业版或企业版能够支持到192GB的物理内存。</p>
<p>Windows Server 2003 数据中心版专为大型企业或国家机构而设计，可以处理海量数据，分为32位版和64位版，32位版最高支持512GB的物理内存，这显然超出了32位CPU的寻址能力，可以通过两次寻址来实现。</p>
<h3 id="编译模式" tabindex="-1"> 编译模式</h3>
<p>为了兼容不同的平台，现代编译器大都提供两种编译模式：32位模式和64位模式。</p>
<h4 id="_32位编译模式" tabindex="-1"> 32位编译模式</h4>
<p>在32位模式下，一个指针或地址占用4个字节的内存，共有32位，理论上能够访问的虚拟内存空间大小为 <code>2^32 = 0X100000000</code> Bytes，即4GB，有效虚拟地址范围是 <code>0 ~ 0XFFFFFFFF</code>。</p>
<p>也就是说，对于32位的编译模式，不管实际物理内存有多大，程序能够访问的有效虚拟地址空间的范围就是<code>0 ~ 0XFFFFFFFF</code>，也即虚拟地址空间的大小是 4GB。换句话说，程序能够使用的最大内存为 4GB，跟物理内存没有关系。</p>
<p>如果程序需要的内存大于物理内存，或者内存中剩余的空间不足以容纳当前程序，那么操作系统会将内存中暂时用不到的一部分数据写入到磁盘，等需要的时候再读取回来。而我们的程序只管使用 4GB 的内存，不用关心硬件资源够不够。</p>
<p>如果物理内存大于 4GB，例如目前很多PC机都配备了8GB的内存，那么程序也无能为力，它只能够使用其中的 4GB。</p>
<h4 id="_64位编译模式" tabindex="-1"> 64位编译模式</h4>
<p>在64位编译模式下，一个指针或地址占用8个字节的内存，共有64位，理论上能够访问的虚拟内存空间大小为 <code>2^64</code>。这是一个很大的值，几乎是无限的，就目前的技术来讲，不但物理内存不可能达到这么大，CPU的寻址能力也没有这么大，实现64位长的虚拟地址只会增加系统的复杂度和地址转换的成本，带不来任何好处，所以 Windows 和 Linux 都对虚拟地址进行了限制，仅使用虚拟地址的低48位（6个字节），总的虚拟地址空间大小为 <code>2^48</code> = 256TB。</p>
<p>需要注意的是：</p>
<ul>
<li>32位的操作系统只能运行32位的程序（也即以32位模式编译的程序），64位操作系统可以同时运行32位的程序（为了向前兼容，保留已有的大量的32位应用程序）和64位的程序（也即以64位模式编译的程序）。</li>
<li>64位的CPU运行64位的程序才能发挥它的最大性能，运行32位的程序会白白浪费一部分资源。</li>
<li>目前计算机可以说已经进入了64位的时代，之所以还要提供32位编译模式，是为了兼容一些老的硬件平台和操作系统，或者某些场合下32位的环境已经足够，使用64位环境会增大成本，例如嵌入式系统、单片机、工控等。</li>
</ul>
<blockquote>
<p>这里所说的32位环境是指：32位的CPU + 32位的操作系统 + 32位的程序。</p>
</blockquote>
<p>另外需要说明的是，32位环境拥有非常经典的设计，易于理解，适合教学，现有的很多资料都是以32位环境为基础进行讲解的。本教程也是如此，除非特别指明，否则都是针对32位环境。相比于32位环境，64位环境的设计思路并没有发生质的变化，理解了32环境很容易向64位环境迁移。</p>
<h2 id="_4、内存对齐-提高寻址效率" tabindex="-1"> 4、内存对齐，提高寻址效率</h2>
<p>计算机内存是以字节（Byte）为单位划分的，理论上CPU可以访问任意编号的字节，但实际情况并非如此。</p>
<p>CPU 通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据。32 位的 CPU 一次可以处理4个字节的数据，那么每次就从内存读取4个字节的数据；少了浪费主频，多了没有用。64位的处理器也是这个道理，每次读取8个字节。</p>
<p>以32位的CPU为例，实际寻址的步长为4个字节，也就是只对编号为 4 的倍数的内存寻址，例如 0、4、8、12、1000 等，而不会对编号为 1、3、11、1001 的内存寻址。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/a7db420a4f434a7c9e2eb07dc922657b.png" alt="在这里插入图片描述"></p>
<p>这样做可以以最快的速度寻址：不遗漏一个字节，也不重复对一个字节寻址。</p>
<p>对于程序来说，一个变量最好位于一个寻址步长的范围内，这样一次就可以读取到变量的值；如果跨步长存储，就需要读取两次，然后再拼接数据，效率显然降低了。</p>
<p>例如一个 int 类型的数据，如果地址为 8，那么很好办，对编号为 8 的内存寻址一次就可以。如果编号为 10，就比较麻烦，CPU需要先对编号为 8 的内存寻址，读取4个字节，得到该数据的前半部分，然后再对编号为 12 的内存寻址，读取4个字节，得到该数据的后半部分，再将这两部分拼接起来，才能取得数据的值。</p>
<p>将一个数据尽量放在一个步长之内，避免跨步长存储，这称为内存对齐。在32位编译模式下，默认以4字节对齐；在64位编译模式下，默认以8字节对齐。</p>
<p>为了提高存取效率，编译器会自动进行内存对齐.</p>
<h2 id="_5、内存分页机制-完成虚拟地址的映射" tabindex="-1"> 5、内存分页机制，完成虚拟地址的映射</h2>
<p>关于虚拟地址和物理地址的映射有很多思路，我们可以假设以程序为单位，把一段与程序运行所需要的同等大小的虚拟空间映射到某段物理空间。</p>
<p>例如程序A需要 10MB 内存，虚拟地址的范围是从 <code>0X00000000 到 0X00A00000</code>，假设它被映射到一段同等大小的物理内存，地址范围从 <code>0X00100000 到 0X00B00000</code>，即虚拟空间中的每一个字节对应于物理空间中的每一个字节。</p>
<p>程序运行时，它们的对应关系如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/b060ae17237b4c2780b219764e7516f6.png" alt="在这里插入图片描述">
当程序A需要访问 <code>0X00001000 </code>时，系统会将这个虚拟地址转换成实际的物理地址 <code>0X00101000</code>，访问 <code>0X002E0000</code> 时，转换成 <code>0X003E0000</code>，以此类推。</p>
<p>这种以整个程序为单位的方法很好地解决了不同程序地址不隔离的问题，同时也能够在程序中使用固定的地址。</p>
<p><strong>地址隔离</strong></p>
<p>如上图所示，程序A和程序B分别被映射到了两块不同的物理内存，它们之间没有任何重叠，如果程序A访问的虚拟地址超出了 <code>0X00A00000</code> 这个范围，系统就会判断这是一个非法的访问，拒绝这个请求，并将这个错误报告给用户，通常的做法就是强制关闭程序。</p>
<p><strong>程序可以使用固定的内存地址</strong></p>
<p>虚拟内存无论被映射到物理内存的哪一个区域，对于程序员来说都是透明的，我们不需要关心物理地址的变化，只需要按照从地址 <code>0X00000000 到 0X00A00000</code> 来编写程序、放置变量即可，程序不再需要重定位。</p>
<p><strong>内存使用效率问题</strong></p>
<p><code>以程序为单位对虚拟内存进行映射</code>时，如果物理内存不足，被换入换出到磁盘的是整个程序，这样势必会导致大量的磁盘读写操作，严重影响运行速度，所以这种方法还是显得粗糙，粒度比较大。</p>
<h3 id="内存分页机制" tabindex="-1"> 内存分页机制</h3>
<p>我们知道，当一个程序运行时，在某个时间段内，它只是频繁地用到了一小部分数据，也就是说，程序的很多数据其实在一个时间段内都不会被用到。</p>
<p><strong><code>以整个程序为单位进行映射，不仅会将暂时用不到的数据从磁盘中读取到内存，也会将过多的数据一次性写入磁盘，这会严重降低程序的运行效率。</code></strong></p>
<p>现代计算机都使用<code>分页（Paging）</code>的方式对虚拟地址空间和物理地址空间进行分割和映射，以减小换入换出的粒度，提高程序运行效率。</p>
<p>分页（Paging）的思想是指把地址空间人为地分成大小相等（并且固定）的若干份，这样的一份称为一页，就像一本书由很多页面组成，每个页面的大小相等。如此，就能够以页为单位对内存进行换入换出：</p>
<ul>
<li>当程序运行时，只需要将必要的数据从磁盘读取到内存，暂时用不到的数据先留在磁盘中，什么时候用到什么时候读取。</li>
<li>当物理内存不足时，只需要将原来程序的部分数据写入磁盘，腾出足够的空间即可，不用把整个程序都写入磁盘。</li>
</ul>
<h4 id="关于页的大小" tabindex="-1"> 关于页的大小</h4>
<p>页的大小是固定的，由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。比如 Intel Pentium 系列处理器支持 4KB 或 4MB 的页大小，那么操作系统可以选择每页大小为 4KB，也可以选择每页大小为 4MB，但是在同一时刻只能选择一种大小，所以对整个系统来说，也就是固定大小的。</p>
<p>目前几乎所有PC上的操作系统都是用 4KB 大小的页。假设我们使用的PC机是32位的，那么虚拟地址空间总共有 4GB，按照 4KB 每页分的话，总共有 <code>2^32 </code>/ <code>2^12</code> = <code>2^20</code> = 1M = 1048576 个页；物理内存也是同样的分法。</p>
<h4 id="根据页进行映射" tabindex="-1"> 根据页进行映射</h4>
<p>下面我们通过一个简单的例子来说明虚拟地址是如何根据页来映射到物理地址的，请先看下图：</p>
<p><img src="https://img-blog.csdnimg.cn/fca5518f9c374b7683bdff999bd3b1af.png" alt="在这里插入图片描述">
当我们把程序的虚拟空间按页分隔后，把常用的数据和代码页加载到内存中，把不常用的暂时留在磁盘中，当需要用到的时候再从磁盘中读取。上图中，我们假设有两个程序 Program 1 和 Program 2，它们的部分虚拟页面被映射到物理页面，比如 Program 1 的 VP0、VP1 和 VP7 分别被映射到 PP0、PP2 和 PP3；而有部分却留在磁盘中，比如 VP2、VP3 分别位于磁盘的 DP0、DP1中；另外还有一些页面如 VP4、VP5、VP6 可能尚未被用到或者访问到，它们暂时处于未使用状态。</p>
<blockquote>
<p>这里，我们把虚拟空间的页叫做虚拟页（VP，Virtual Page），把物理内存中的页叫做物理页（PP，Physical Page），把磁盘中的页叫做磁盘页（DP，Disk Page）。</p>
</blockquote>
<p>图中的线表示映射关系，可以看到，Program 1 和 Program 2 中的有些虚拟页被映射到同一个物理页，这样可以实现内存共享。</p>
<p>Program 1 的 VP2、VP3 不在内存中，但是当进程需要用到这两个页的时候，硬件会捕获到这个消息，就是所谓的<code>页错误（Page Fault）</code>，然后操作系统接管进程，负责将 VP2 和 PV3 从磁盘中读取出来并且装入内存，然后将内存中的这两个页与 VP2、VP3 之间建立映射关系。</p>
<h2 id="_6、内存分页机制的实现-虚拟地址和物理地址的映射" tabindex="-1"> 6、内存分页机制的实现（虚拟地址和物理地址的映射）</h2>
<p>现代操作系统都使用分页机制来管理内存，这使得每个程序都拥有自己的地址空间。每当程序使用虚拟地址进行读写时，都必须转换为实际的物理地址，才能真正在内存条上定位数据。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/a18ccd89d8fa45ca89c07c9555afe61e.png" alt="在这里插入图片描述"></p>
<p>内存地址的转换是通过一种叫做<code>页表（Page Table）</code>的机制来完成的，这是本节要讲解的重点，即：</p>
<ul>
<li>页表是什么？为什么要采用页表机制，而不采用其他机制？</li>
<li>虚拟地址如何通过页表转换为物理地址？</li>
</ul>
<h3 id="直接使用数组转换" tabindex="-1"> 直接使用数组转换</h3>
<p>最容易想到的映射方案是使用数组：每个数组元素保存一个物理地址，而把虚拟地址作为数组下标，这样就能够很容易地完成映射，并且效率不低。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/515f6b79244d413b8c80ab69f7675ff8.png" alt="在这里插入图片描述"></p>
<p>但是这样的数组有 2^32 个元素，每个元素大小为4个字节，总共占用16GB的内存，显现是不现实的！</p>
<h3 id="使用一级页表" tabindex="-1"> 使用一级页表</h3>
<p>既然内存是分页的，只要我们能够定位到数据所在的页，以及它在页内的偏移（也就是距离页开头的字节数），就能够转换为物理地址。</p>
<p>例如，一个 int 类型的值保存在第 12 页，页内偏移为 240，那么对应的物理地址就是 <code>2^12 * 12 + 240</code> = 49392。</p>
<blockquote>
<p><code>2^12 </code>为一个页的大小，也就是4K。</p>
</blockquote>
<p>虚拟地址空间大小为 4GB，总共包含 <code>2^32 / 2^12 </code>= <code>2^20 </code>= 1K * 1K  = 1M = 1048576 个页面，我们可以定义一个这样的数组：它包含 <code>2^20 = 1M</code> 个元素，每个元素的值为页面编号（也就是位于第几个页面），长度为4字节，整个数组共占用4MB的内存空间。这样的数组就称为页表（Page Table），它记录了地址空间中所有页的编号。</p>
<p>虚拟地址长度为32位，我们不妨进行一下切割，将高20位作为页表数组的下标，低12位作为页内偏移。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/7d0d21561633413ca9d851ea69b8b838.png" alt="在这里插入图片描述"></p>
<p>为什么要这样切割呢？因为页表数组共有 <code>2^20 = 1M </code>个元素，使用虚拟地址的高20位作为下标，正好能够访问数组中的所有元素；并且，一个页面的大小为 <code>2^12 = 4KB</code>，使用虚拟地址的低12位恰好能够表示所有偏移。</p>
<p>注意，表示页面编号只需要 20 位，而页表数组的每个元素的长度却为 4 字节，即 32 位，多出 32 - 20 = 12 位。这 12 位也有很大的用处，可以用来表示当前页的相关属性，例如是否有读写权限、是否已经分配物理内存、是否被换出到硬盘等。</p>
<p>例如一个虚拟地址 0XA010BA01，它的高20位是 0XA010B，所以需要访问页表数组的第 0XA010B 个元素，才能找到数据所在的物理页面。假设页表数组第 0XA010B 个元素的值为 0X0F70AAA0，它的高20位为 0X0F70A，那么就可以确定数据位于第 0X0F70A 个物理页面。再来看虚拟地址，它的低12位是 0XA01，所以页内偏移也是 0XA01。有了页面索引和页内偏移，就可以算出物理地址了。经过计算，最终的物理地址为 0X0F70A * 2^12 + 0XA01 = 0X0F70A000 + 0XA01 = 0X0F70AA01。</p>
<p>这种思路所形成的映射关系如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/0cfd8fa204fc486e8ca8acca428b01ba.png" alt="在这里插入图片描述">
可以发现，有的页被映射到物理内存，有的被映射到硬盘，不同的映射方式可以由页表数组元素的低12位来控制。</p>
<p>使用这种方案，不管程序占用多大的内存，都要为页表数组分配4M的内存空间（页表数组也必须放在物理内存中），因为虚拟地址空间中的高1G或2G是被系统占用的，必须保证较大的数组下标有效。</p>
<p>现在硬件很便宜了，内存容量大了，很多电脑都配备4G或8G的内存，页表数组占用4M内存或许不觉得多，但在32位系统刚刚发布的时候，内存还是很紧缺的资源，很多电脑才配备100M甚至几十兆的内存，4M内存就显得有点大了，所以还得对上面的方案进行改进，压缩页表数组所占用的内存。</p>
<h3 id="使用两级页表" tabindex="-1"> 使用两级页表</h3>
<p>略</p>
<h3 id="使用多级页表" tabindex="-1"> 使用多级页表</h3>
<p>略</p>
<h2 id="_7、mmu部件以及对内存权限的控制" tabindex="-1"> 7、MMU部件以及对内存权限的控制</h2>
<p>通过页表完成虚拟地址和物理地址的映射时，要经过多次转换，还要进行计算，如果由操作系统来完成这项工作，那将会成倍降低程序的性能，得不偿失，所以这种方式是不现实的。</p>
<h3 id="mmu" tabindex="-1"> MMU</h3>
<p>在CPU内部，有一个部件叫做<code>MMU（Memory Management Unit，内存管理单元）</code>，由它来负责将虚拟地址映射为物理地址，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/bd9a83400f1c44fe8a9fa0457adb2d14.png" alt="在这里插入图片描述"></p>
<p>在页映射模式下，CPU 发出的是虚拟地址，也就是我们在程序中看到的地址，这个地址会先交给 MMU，经过 MMU 转换以后才能变成了物理地址。</p>
<p>即便是这样，MMU也要访问好几次内存，性能依然堪忧，所以在MMU内部又增加了一个缓存，专门用来存储页目录和页表。MMU内部的缓存有限，当页表过大时，也只能将部分常用页表加载到缓存，但这已经足够了，因为经过算法的巧妙设计，可以将缓存的命中率提高到 90%，剩下的10%的情况无法命中，再去物理内存中加载页表。</p>
<p>有了硬件的直接支持，使用虚拟地址和使用物理地址相比，损失的性能已经很小，在可接受的范围内。</p>
<p>MMU 只是通过页表来完成虚拟地址到物理地址的映射，但不会构建页表，构建页表是操作系统的任务。在程序加载到内存以及程序运行过程中，操作系统会不断更新程序对应的页表，并将页目录的物理地址保存到 CR3 寄存器。MMU 向缓存中加载页表时，会根据 CR3 寄存器找到页目录，再找到页表，最终通过软件和硬件的结合来完成内存映射。</p>
<blockquote>
<p>CR3 是CPU内部的一个寄存器，专门用来保存页目录的物理地址。</p>
</blockquote>
<p>每个程序在运行时都有自己的一套页表，切换程序时，只要改变 CR3 寄存器的值就能够切换到对应的页表。</p>
<h3 id="对内存权限的控制" tabindex="-1"> 对内存权限的控制</h3>
<p>MMU 除了能够完成虚拟地址到物理地址的映射，还能够对内存权限进行控制。上节《》讲到，在页表数组中，每个元素占用4个字节，也即32位，我们使用高20位来表示物理页编号，还剩下低12位，这12位就用来对内存进行控制，例如，是映射到物理内存还是映射到磁盘，程序有没有访问权限，当前页面有没有执行权限等。</p>
<p>操作系统在构建页表时将内存权限定义好，当MMU对虚拟地址进行映射时，首先检查低12位，看当前程序是否有权限使用，如果有，就完成映射，如果没有，就产生一个异常，并交给操作系统处理。操作系统在处理这种内存错误时一般比较粗暴，会直接终止程序的执行。</p>
<h2 id="_8、linux下c语言程序的内存布局-内存模型" tabindex="-1"> 8、Linux下C语言程序的内存布局（内存模型）</h2>
<p>在《》一节中讲到，虚拟地址空间在32位环境下的大小为 4GB，在64位环境下的大小为 256TB，那么，一个C语言程序的内存在整个地址空间中是如何分布的呢？数据在哪里？代码在哪里？为什么要这样分布？这些就是本节要讲解的内容。</p>
<p><strong>程序内存在地址空间中的分布情况称为内存模型（Memory Model）。</strong> 内存模型由操作系统构建，在Linux和Windows下有所差异，并且会受到编译模式的影响，本节我们讲解Linux下32位环境和64位环境的内存模型。</p>
<h3 id="内核空间和用户空间" tabindex="-1"> 内核空间和用户空间</h3>
<p>对于32位环境，理论上程序可以拥有 4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。</p>
<p>但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为<code>内核空间（Kernel Space）</code>。</p>
<p>Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux 默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为<code>用户空间（User Space）</code>。</p>
<h3 id="linux下32位环境的用户空间内存分布情况" tabindex="-1"> Linux下32位环境的用户空间内存分布情况</h3>
<p>我们暂时不关心内核空间的内存分布情况，下图是Linux下32位环境的一种经典内存模型：</p>
<p><img src="https://img-blog.csdnimg.cn/00d361eb36e942ab8862f59c2a45d2f2.png" alt="在这里插入图片描述">
对各个内存分区的说明：</p>
<table>
<thead>
<tr>
<th>内存分区</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序代码区(code)</td>
<td>存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。</td>
</tr>
<tr>
<td>常量区(constant)</td>
<td>存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。</td>
</tr>
<tr>
<td>全局数据区(global data)</td>
<td>存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。</td>
</tr>
<tr>
<td>堆区(heap)</td>
<td>一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存，这也是本章要讲解的重点。注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。</td>
</tr>
<tr>
<td>动态链接库</td>
<td>用于在程序运行期间加载和卸载动态链接库。</td>
</tr>
<tr>
<td>栈区(stack)</td>
<td>存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。</td>
</tr>
</tbody>
</table>
<p>在这些内存分区中（暂时不讨论动态链接库），程序代码区用来保存指令，常量区、全局数据区、堆、栈都用来保存数据。对内存的研究，重点是对数据分区的研究。</p>
<p>程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。</p>
<blockquote>
<p>常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。</p>
</blockquote>
<p>函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。</p>
<p>常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。</p>
<p>程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。</p>
<p>为了加深对内存布局的理解，请大家看下面一段代码：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>char</span> <span>*</span>str1 <span>=</span> <span>"www.c.xyz"</span><span>;</span>  		<span>//字符串在常量区，str1在全局数据区</span>
<span>int</span> n<span>;</span>  						<span>//全局数据区</span>
<span>char</span><span>*</span> <span>func</span><span>(</span><span>)</span><span>{</span>
    <span>char</span> <span>*</span>str <span>=</span> <span>"内存布局"</span><span>;</span> 		<span>//字符串在常量区，str在栈区</span>
    <span>return</span> str<span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>int</span> a<span>;</span>  					<span>//栈区</span>
    <span>char</span> <span>*</span>str2 <span>=</span> <span>"01234"</span><span>;</span>  		<span>//字符串在常量区，str2在栈区</span>
    <span>char</span>  arr<span>[</span><span>20</span><span>]</span> <span>=</span> <span>"56789"</span><span>;</span>  	<span>//字符串和arr都在栈区</span>
    <span>char</span> <span>*</span>pstr <span>=</span> <span>func</span><span>(</span><span>)</span><span>;</span>  		<span>//栈区</span>
    <span>int</span> b<span>;</span>  					<span>//栈区</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="linux下64位环境的用户空间内存分布情况" tabindex="-1"> Linux下64位环境的用户空间内存分布情况</h3>
<p>在64位环境下，虚拟地址空间大小为 256TB，Linux 将高 128TB 的空间分配给内核使用，而将低 128TB 的空间分配给用户程序使用。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/ed4f9573c4874ad78e9443613ab3f9b3.png" alt="在这里插入图片描述"></p>
<p>《》一节中讲到，在64位环境下，虚拟地址虽然占用64位，但只有最低48位有效。这里需要补充的一点是，任何虚拟地址的48位至63位必须与47位一致。</p>
<p>上图中，用户空间地址的47位是0，所以高16位也是0，换算成十六进制形式，最高的四个数都是0；内核空间地址的47位是1，所以高16位也是1，换算成十六进制形式，最高的四个数都是1。这样中间的一部分地址正好空出来，也就是图中的“未定义区域”，这部分内存无论如何也访问不到。</p>
<h2 id="_9、windows下c语言程序的内存布局" tabindex="-1"> 9、Windows下C语言程序的内存布局</h2>
<p>在32位环境下，Windows 默认会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而将剩下的 2GB 空间分配给用户程序。</p>
<p>不像 Linux，Windows 是闭源的，有版权保护，资料较少，不好深入研究每一个细节，至今仍有一些内部原理不被大家知晓。关于 Windows 地址空间的内存分布，官网上只给出了简单的说明：</p>
<ul>
<li>对于32位程序，内核占用较高的 2GB，剩下的 2GB 分配给用户程序；</li>
<li>对于64位程序，内核占用最高的 248TB，用户程序占用最低的 8TB。</li>
</ul>
<p>下图是一个典型的 Windows 32位程序的内存分布：</p>
<p><img src="https://img-blog.csdnimg.cn/8ffae0ba664542e7aaa09864d62a05ea.png" alt="在这里插入图片描述">
可以看到，Windows 的地址空间被分配给了各种 exe、dll 文件、堆、栈。其中 exe 文件一般位于 0x00400000 起始的地址；一部分 DLL 位于 0x10000000 起始的地址，如运行库 dll；还有一部分 DLL 位于接近 0x80000000 的位置，如系统 dll，Ntdll.dll、Kernel32.dll。</p>
<p>栈的位置则在 0x00030000 和 exe 文件后面都有分布，可能有读者奇怪为什么 Windows 需要这么多栈呢？我们知道，每个线程的栈都是独立的，所以一个进程中有多少个线程，就有多少个对应的栈，对于 Windows 来说，每个线程默认的栈大小是 1MB。</p>
<p>在分配完上面这些地址以后，Windows 的地址空间已经是支离破碎了。当程序向系统申请堆空间时，只好从这些剩下的还有没被占用的地址上分配。</p>
<h2 id="_10、用户模式和内核模式" tabindex="-1"> 10、用户模式和内核模式</h2>
<p>首先我们要解释一个概念——<code>进程（Process）</code>。简单来说，一个可执行程序就是一个进程，前面我们使用C语言编译生成的程序，运行后就是一个进程。<strong>进程最显著的特点就是拥有独立的地址空间</strong>。</p>
<p>严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个静态的概念；进程是程序加载到内存运行后一些列的活动，是一个动态的概念。</p>
<p>前面我们在讲解地址空间时，一直说“程序的地址空间”，这其实是不严谨的，应该说“进程的地址空间”。一个进程对应一个地址空间，而一个程序可能会创建多个进程。</p>
<p><strong>内核空间存放的是操作系统内核代码和数据，是被所有程序共享的</strong>，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。</p>
<p>要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。</p>
<p><strong>用户程序调用系统 API 函数称为系统调用（System Call）</strong>；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为<code>内核模式（Kernel Mode）</code>。</p>
<p><strong>用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问</strong>。当执行应用程序自己的代码时，称为<code>用户模式（User Mode）</code>。</p>
<p><strong>计算机会经常在内核模式和用户模式之间切换：</strong></p>
<ul>
<li>当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；</li>
<li>操作完成后，继续执行应用程序的代码，就又回到了用户模式。</li>
</ul>
<p><strong>总结：用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。</strong></p>
<h3 id="为什么要区分两种模式" tabindex="-1"> 为什么要区分两种模式</h3>
<p>我们知道，内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。</p>
<p>从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以运行在 ring0 ~ ring3 四个不同的权限级别，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<ul>
<li>一个是内核模式，对应 ring0 级，操作系统的核心部分和设备驱动都运行在该模式下。</li>
<li>另一个是用户模式，对应 ring3 级，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。</li>
</ul>
<h3 id="为什么内核和用户程序要共用地址空间" tabindex="-1"> 为什么内核和用户程序要共用地址空间</h3>
<p>既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？</p>
<p>让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。</p>
<p>而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。</p>
<hr>
<h2 id="_11、栈的概念以及栈溢出" tabindex="-1"> 11、栈的概念以及栈溢出</h2>
<p>在《》中我们讲到，程序的虚拟地址空间分为多个区域，栈（Stack）是其中地址较高的一个区域。</p>
<p><strong>栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。</strong></p>
<p>栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。</p>
<h3 id="栈的概念" tabindex="-1"> 栈的概念</h3>
<p>在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（First In Last Out）原则。</p>
<p>放入数据常称为入栈或压栈（Push），取出数据常称为出栈或弹出（Pop）。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/bfec145d19c4499b8feae8a53819e5ef.png" alt="在这里插入图片描述">
可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。</p>
<p>从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用ebp寄存器指向栈底，而使用esp寄存器指向栈顶。随着数据的进栈出栈，esp 的值会不断变化，进栈时 esp 的值减小，出栈时 esp 的值增大。</p>
<blockquote>
<p>ebp 和 esp 都是CPU中的寄存器：ebp 是 Extend Base Pointer 的缩写，通常用来指向栈底；esp 是 Extend Stack Pointer 的缩写，通常用来指向栈顶。</p>
</blockquote>
<h3 id="栈的大小以及栈溢出" tabindex="-1"> 栈的大小以及栈溢出</h3>
<p>对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。</p>
<blockquote>
<p>一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。</p>
</blockquote>
<p>栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在 VC/VS 下，默认是 1M，在 C-Free 下，默认是 2M，在 Linux GCC 下，默认是 8M。</p>
<p>当然，我们也可以通过参数来修改栈内存的大小。</p>
<blockquote>
<p>提示：栈也经常被称为堆栈，而堆依然称为堆，所以堆栈这个概念并不包含堆，大家要注意区分。</p>
</blockquote>
<h2 id="_12、一个函数在栈上到底是怎样的" tabindex="-1"> 12、一个函数在栈上到底是怎样的</h2>
<p>函数的调用和栈是分不开的，没有栈就没有函数调用，本节就来讲解函数在栈上是如何被调用的。</p>
<h3 id="栈帧-活动记录" tabindex="-1"> 栈帧/活动记录</h3>
<p>当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（Stack Frame）或活动记录（Activate Record）。</p>
<p>从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。</p>
<p>活动记录一般包括以下几个方面的内容：</p>
<ol>
<li>函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码。例如：</li>
</ol>
<div><pre><code><span>int</span> a<span>,</span> b<span>,</span> c<span>;</span>
<span>func</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>
c <span>=</span> a <span>+</span> b<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>站在C语言的角度看，func() 函数执行完成后，会继续执行c=a+b;语句，那么返回地址就是该语句在内存中的位置。</p>
<blockquote>
<p>注意：C语言代码最终会被编译为机器指令，确切地说，返回地址应该是下一条指令的地址，这里之所以说是下一条C语言语句的地址，仅仅是为了更加直观地说明问题。</p>
</blockquote>
<ol start="2">
<li>
<p>参数和局部变量。有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，我们暂时不考虑这种情况。</p>
</li>
<li>
<p>编译器自动生成的临时数据。例如，当函数返回值的长度较大（比如占用40个字节）时，会先将返回值压入栈中，然后再交给函数调用者。</p>
</li>
</ol>
<blockquote>
<p>当返回值的长度较小（char、int、long 等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。</p>
</blockquote>
<ol start="4">
<li>一些需要保存的寄存器，例如 ebp、ebx、esi、edi 等。之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。</li>
</ol>
<p>下图是一个函数调用的实例：</p>
<p><img src="https://img-blog.csdnimg.cn/7982f028245d4c05bc9651a9321c83fc.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>在寄存器名字前面添加“old”，表示函数调用之前该寄存器的值。</p>
</blockquote>
<p>当发生函数调用时：</p>
<ul>
<li>实参、返回地址、ebp 寄存器首先入栈；</li>
<li>然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余；</li>
<li>最后将其他寄存器的值压入栈中。</li>
</ul>
<h2 id="_13、详细分析一个函数进栈出栈的例子" tabindex="-1"> 13、详细分析一个函数进栈出栈的例子</h2>
<p>前面我们只是讲解了一个函数的活动记录是什么样子的，相信大家对函数的详细调用过程的认识还不是太清晰，这节我们就以 VS2010 Debug 模式为例来深入分析一下。</p>
<p>请看下面的代码：</p>
<div><pre><code><span>void</span> <span>func</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span><span>{</span>
    <span>int</span> p <span>=</span><span>12</span><span>,</span> q <span>=</span> <span>345</span><span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>func</span><span>(</span><span>90</span><span>,</span> <span>26</span><span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数使用默认的调用惯例，即参数从右到左入栈，由调用方负责将参数出栈。函数的进栈出栈过程如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/7882be5fc1b64912b24363e7ba4706d4.png" alt="在这里插入图片描述"></p>
<h3 id="函数进栈" tabindex="-1"> 函数进栈</h3>
<p>步骤①到⑥是函数进栈过程：</p>
<ol>
<li>
<p>main() 是主函数，也需要进栈，如步骤①所示。</p>
</li>
<li>
<p>在步骤②中，执行语句func(90, 26);，先将实参 90、26 压入栈中，再将返回地址压入栈中，这些工作都由 main() 函数（调用方）完成。这个时候 ebp 的值并没有变，仅仅是改变 esp 的指向。</p>
</li>
<li>
<p>到了步骤③，就开始执行 func() 的函数体了。首先将原来 ebp 寄存器的值压入栈中（也即图中的 old ebp），并将 esp 的值赋给 ebp，这样 ebp 就从 main() 函数的栈底指向了 func() 函数的栈底，完成了函数栈的切换。由于此时 esp 和ebp 的值相等，所以它们也就指向了同一个位置。</p>
</li>
<li>
<p>为局部变量、返回值等预留足够的内存，如步骤④所示。由于栈内存在函数调用之前就已经分配好了，所以这里并不是真的分配内存，而是将 esp 的值减去一个整数，例如 esp - 0XC0，就是预留 0XC0 字节的内存。</p>
</li>
<li>
<p>将 ebp、esi、edi 寄存器的值依次压入栈中。</p>
</li>
<li>
<p>将局部变量的值放入预留好的内存中。注意，第一个变量和 old ebp 之间有4个字节的空白，变量之间也有若干字节的空白。</p>
</li>
</ol>
<p>为什么要留出这么多的空白，岂不是浪费内存吗？这是因为我们使用Debug模式生成程序，留出多余的内存，方便加入调试信息；以Release模式生成程序时，内存将会变得更加紧凑，空白也被消除。</p>
<p>至此，func() 函数的活动记录就构造完成了。可以发现，在函数的实际调用过程中，形参是不存在的，不会占用内存空间，内存中只有实参，而且是在执行函数体代码之前、由调用方压入栈中的。</p>
<h3 id="未初始化的局部变量的值为什么是垃圾值" tabindex="-1"> 未初始化的局部变量的值为什么是垃圾值</h3>
<p>为局部变量分配内存时，仅仅是将 esp 的值减去一个整数，预留出足够的空白内存，不同的编译器在不同的模式下会对这片空白内存进行不同的处理，可能会初始化为一个固定的值，也可能不进行初始化。</p>
<p>虽然编译器对空白内存进行了初始化，但这个值对我们来说一般没有意义，所以我们可以认为它是垃圾值、是随机的。</p>
<h3 id="函数出栈" tabindex="-1"> 函数出栈</h3>
<p>步骤⑦到⑨是函数 func() 出栈过程：</p>
<ol start="7">
<li>
<p>函数 func() 执行完成后开始出栈，首先将 edi、esi、ebx 寄存器的值出栈。</p>
</li>
<li>
<p>将局部变量、返回值等数据出栈时，直接将 ebp 的值赋给 esp，这样 ebp 和 esp 就指向了同一个位置。</p>
</li>
<li>
<p>接下来将 old ebp 出栈，并赋值给现在的 ebp，此时 ebp 就指向了 func() 调用之前的位置，即 main() 活动记录的 old ebp 位置，如步骤⑨所示。</p>
</li>
</ol>
<p>这一步很关键，保证了还原到函数调用之前的情况，这也是每次调用函数时都必须将 old ebp 压入栈中的原因。</p>
<p>最后根据返回地址找到下一条指令的位置，并将返回地址和实参都出栈，此时 esp 就指向了 main() 活动记录的栈顶， 这意味着 func() 完全出栈了，栈被还原到了 func() 被调用之前的情况。</p>
<h3 id="遗留的错误认知" tabindex="-1"> 遗留的错误认知</h3>
<p>经过上面的分析可以发现，函数出栈只是在增加 esp 寄存器的值，使它指向上一个数据，并没有销毁之前的数据。前面我们讲局部变量在函数运行结束后立即被销毁其实是错误的，这只是为了让大家更容易理解，对局部变量的作用范围有一个清晰的认识。</p>
<p>栈上的数据只有在后续函数继续入栈时才能被覆盖掉，这就意味着，只要时机合适，在函数外部依然能够取得局部变量的值。请看下面的代码：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span>int</span> <span>*</span>p<span>;</span>
<span>void</span> <span>func</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>)</span><span>{</span>
    <span>int</span> a <span>=</span> <span>18</span><span>,</span> b <span>=</span> <span>100</span><span>;</span>
    p <span>=</span> <span>&amp;</span>a<span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>int</span> n<span>;</span>
    <span>func</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span><span>;</span>
    n <span>=</span> <span>*</span>p<span>;</span>
    <span>printf</span><span>(</span><span>"n = %d\n"</span><span>,</span> n<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行结果：n = 18</p>
<p>在 func() 中，将局部变量 a 的地址赋给 p，在 main() 函数中调用 func()，函数刚刚调用结束，还没有其他函数入栈，局部变量 a 所在的内存没有被覆盖掉，所以通过语句<code>n = *p</code>;能够取得它的值。</p>
<h2 id="_14、栈溢出攻击的原理" tabindex="-1"> 14、栈溢出攻击的原理</h2>
<p><img src="https://img-blog.csdnimg.cn/4fe96ac05b9046018d052d210f8c89a5.png" alt="在这里插入图片描述"></p>
<p>局部数组也是在栈上分配内存，当输入&quot;12345678901234567890&quot; 时，会发生数组溢出，占用“4字节空白内存”、“old ebp”和“返回地址”所在的内存，并将原有的数据覆盖掉，这样当 main() 函数执行完成后，会取得一个错误的返回地址，该地址上的指令是不确定的，或者根本就没有指令，所以程序在返回时出错。</p>
<p><strong>C语言不会对数组溢出做检测，这是一个典型的由于数组溢出导致覆盖了函数返回地址的例子，我们将这样的错误称为“栈溢出错误”。</strong></p>
<blockquote>
<p>注意：这里所说的“栈溢出”是指栈上的某个数据过大，覆盖了其他的数据，和《》一节中提到的栈溢出不是一回事。</p>
</blockquote>
<p>局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的 gets() 函数，strcpy()、scanf() 等能够向数组写入数据的函数都有导致栈溢出的风险。</p>
<h2 id="_15、c语言动态内存分配" tabindex="-1"> 15、C语言动态内存分配</h2>
<p>在进程的地址空间中，代码区、常量区、全局数据区的内存在程序启动时就已经分配好了，它们大小固定，不能由程序员分配和释放，只能等到程序运行结束由操作系统回收。这称为静态内存分配。</p>
<p>栈区和堆区的内存在程序运行期间可以根据实际需求来分配和释放，不用在程序刚启动时就备足所有内存。这称为动态内存分配。</p>
<p>使用静态内存的优点是速度快，省去了向操作系统申请内存的时间，缺点就是不灵活，缺乏表现力，例如不能控制数据的作用范围，不能使用较大的内存。而使用动态内存可以让程序对内存的管理更加灵活和高效，需要内存就立即分配，而且需要多少就分配多少，从几个字节到几个GB不等；不需要时就立即回收，再分配给其他程序使用。</p>
<h3 id="栈和堆的区别" tabindex="-1"> 栈和堆的区别</h3>
<p>栈区和堆区的管理模式有所不同：栈区内存由系统分配和释放，不受程序员控制；堆区内存完全由程序员掌控，想分配多少就分配多少，想什么时候释放就什么时候释放，非常灵活。</p>
<p>程序启动时会为栈区分配一块大小适当的内存，对于一般的函数调用这已经足够了，函数进栈出栈只是 ebp、esp 寄存器指向的变换，或者是向已有的内存中写入数据，不涉及内存的分配和释放。当函数中有较大的局部数组时，比如 1024*10 个元素，编译器就会在函数代码中插入针对栈的动态内存分配函数，这样函数被调用时才分配内存，不调用就不分配。</p>
<p>我们经常听说“栈内存的分配效率要高于堆”就是这个道理，因为大部分情况下并没有真的分配栈内存，仅仅是对已有内存的操作。</p>
<h3 id="动态内存分配函数" tabindex="-1"> 动态内存分配函数</h3>
<p>堆（Heap）是唯一由程序员控制的内存区域，我们常说的动态内存分配也是在这个区域。在堆上分配和释放内存需要用到C语言标准库中的几个函数：malloc()、calloc()、realloc() 和 free()。</p>
<h2 id="_16、malloc-背后的实现原理-内存池" tabindex="-1"> 16、malloc()背后的实现原理（内存池）</h2>
<p>相对于栈而言，堆这片内存面临着一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，而且申请的大小从几个字节到几个GB都有可能，我们不能假设程序一次申请多少堆空间，因此，堆的管理显得较为复杂。</p>
<p><strong>那么，使用 malloc() 在堆上分配内存到底是如何实现的呢？</strong></p>
<p>一种做法是把 malloc() 的内存管理交给系统内核去做，既然内核管理着进程的地址空间，那么如果它提供一个系统调用，可以让 malloc() 使用这个系统调用去申请内存，不就可以了吗？当然这是一种理论上的做法，但实际上这样做的性能比较差，因为每次程序申请或者释放堆空间都要进行系统调用。我们知道系统调用的性能开销是比较大的，当程序对堆的操作比较频繁时，这样做的结果会严重影响程序的性能。</p>
<p>比较好的做法就是 malloc() 向操作系统申请一块适当大小的堆空间，然后由 malloc() 自己管理这块空间。</p>
<p>malloc() 相当于向操作系统“批发”了一块较大的内存空间，然后“零售”给程序用。当全部“售完”或程序有大量的内存需求时，再根据实际需求向操作系统“进货”。当然 malloc() 在向程序零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致地址的冲突。于是 malloc() 需要一个算法来管理堆空间，这个算法就是堆的分配算法。</p>
<h3 id="malloc-和free-的分配算法" tabindex="-1"> malloc()和free()的分配算法</h3>
<p>在程序运行过程中，堆内存从低地址向高地址连续分配，随着内存的释放，会出现不连续的空闲区域，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/ee75e403b24c41c6af01e60b23799874.png" alt="图片描述" title="已分配内存和空闲内存相间出现"></p>
<p>带阴影的方框是已被分配的内存，白色方框是空闲内存或已被释放的内存。程序需要内存时，malloc() 首先遍历空闲区域，看是否有大小合适的内存块，如果有，就分配，如果没有，就向操作系统申请（发生系统调用）。为了保证分配给程序的内存的连续性，malloc() 只会在一个空闲区域中分配，而不能将多个空闲区域联合起来。</p>
<p>内存块（包括已分配和空闲的）的结构类似于链表，它们之间通过指针连接在一起。在实际应用中，一个内存块的结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/1f0176f0d71f403faa3680a7ff0596a3.png" alt="在这里插入图片描述" title="内存块的结构"></p>
<p>next 是指针，指向下一个内存块，used 用来表示当前内存块是否已被使用。这样，整个堆区就会形成如下图所示的链表：</p>
<p><img src="https://img-blog.csdnimg.cn/75cb88f7b6f04313ba9ea95f6a285348.png" alt="在这里插入图片描述" title="类似链表的内存管理方式"></p>
<p>现在假设需要为程序分配100个字节的内存，当搜索到图中第一个空闲区域（大小为200个字节）时，发现满足条件，那么就在这里分配。这时候 malloc() 会把第一个空闲区域拆分成两部分，一部分交给程序使用，剩下的部分任然空闲，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/8803e861a2fd403ea7ee498f7cb3cde2.png" alt="在这里插入图片描述" title="为程序分配100个字节的内存"></p>
<p>仍然以图3为例，当程序释放掉第三个内存块时，就会形成新的空闲区域，free() 会将第二、三、四个连续的空闲区域合并为一个，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/77f65fffd5c3497db7d302676a1355a8.png" alt="在这里插入图片描述" title="释放第三个内存块"></p>
<p>可以看到，malloc() 和 free() 所做的工作主要是对已有内存块的分拆和合并，并没有频繁地向操作系统申请内存，这大大提高了内存分配的效率。</p>
<p>另外，由于单向链表只能向一个方向搜索，在合并或拆分内存块时不方便，所以大部分 malloc() 实现都会在内存块中增加一个 pre 指针指向上一个内存块，构成双向链表，如下图所示：
<img src="https://img-blog.csdnimg.cn/e25f6524e63a48c4823c55b9bde5e4e6.png" alt="在这里插入图片描述"></p>
<p>链表是一种经典的堆内存管理方式，经常被用在教学中，很多C语言教程都会提到“栈内存的分配类似于数据结构中的栈，而堆内存的分配却类似于数据结构中的链表”就是源于此。</p>
<p>链表式内存管理虽然思路简单，容易理解，但存在很多问题，例如：</p>
<ul>
<li>一旦链表中的 pre 或 next 指针被破坏，整个堆就无法工作，而这些数据恰恰很容易被越界读写所接触到。</li>
<li>小的空闲区域往往不容易再次分配，形成很多内存碎片。</li>
<li>经常分配和释放内存会造成链表过长，增加遍历的时间。</li>
</ul>
<p>针对链表的缺点，后来人们提出了位图和对象池的管理方式，而现在的 malloc() 往往采用多种方式复合而成，不同大小的内存块往往采用不同的措施，以保证内存分配的安全和效率。</p>
<h3 id="内存池" tabindex="-1"> 内存池</h3>
<p>不管具体的分配算法是怎样的，为了减少系统调用，减少物理内存碎片，malloc() 的整体思想是先向操作系统申请一块大小适当的内存，然后自己管理，这就是内存池（Memory Pool）。</p>
<p>内存池的研究重点不是向操作系统申请内存，而是对已申请到的内存的管理，这涉及到非常复杂的算法，是一个永远也研究不完的课题，除了C标准库自带的 malloc()，还有一些第三方的实现，比如 Goolge 的 tcmalloc 和 jemalloc。</p>
<p>我们知道，C/C++是编译型语言，没有内存回收机制，程序员需要自己释放不需要的内存，这在给程序带来了很大灵活性的同时，也带来了不少风险，例如C/C++程序经常会发生内存泄露，程序刚开始运行时占用内存很少，随着时间的推移，内存使用不断增加，导致整个计算机运行缓慢。</p>
<p>内存泄露的问题往往难于调试和发现，或者只有在特定条件下才会复现，这给代码修改带来了不少障碍。为了提高程序的稳定性和健壮性，后来的 Java、Python、C#、JavaScript、PHP 等使用了虚拟机机制的非编译型语言都加入了垃圾内存自动回收机制，这样程序员就不需要管理内存了，系统会自动识别不再使用的内存并把它们释放掉，避免内存泄露。可以说，这些高级语言在底层都实现了自己的内存池，也即有自己的内存管理机制。</p>
<h3 id="池化技术" tabindex="-1"> 池化技术</h3>
<p>在计算机中，有很多使用“池”这种技术的地方，除了内存池，还有连接池、线程池、对象池等。以服务器上的线程池为例，它的主要思想是：先启动若干数量的线程，让它们处于睡眠状态，当接收到客户端的请求时，唤醒池中某个睡眠的线程，让它来处理客户端的请求，当处理完这个请求，线程又进入睡眠状态。</p>
<p>所谓“池化技术”，就是程序先向系统申请过量的资源，然后自己管理，以备不时之需。之所以要申请过量的资源，是因为每次申请该资源都有较大的开销，不如提前申请好了，这样使用时就会变得非常快捷，大大提高程序运行效率。</p>
<h2 id="_17、c语言内存泄露-内存丢失" tabindex="-1"> 17、C语言内存泄露（内存丢失）</h2>
<p>使用 malloc()、calloc()、realloc() 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。</p>
<p>请看下面的代码：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>char</span> <span>*</span>p <span>=</span> <span>(</span><span>char</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>100</span> <span>*</span> <span>sizeof</span><span>(</span><span>char</span><span>)</span><span>)</span><span>;</span>
    p <span>=</span> <span>(</span><span>char</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>50</span> <span>*</span> <span>sizeof</span><span>(</span><span>char</span><span>)</span><span>)</span><span>;</span>
    <span>free</span><span>(</span>p<span>)</span><span>;</span>
    p <span>=</span> <span>NULL</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该程序中，第一次分配 100 字节的内存，并将 p 指向它；第二次分配 50 字节的内存，依然使用 p 指向它。</p>
<p>这就导致了一个问题，第一次分配的 100 字节的内存没有指针指向它了，而且我们也不知道这块内存的地址，所以就再也无法找回了，也没法释放了，这块内存就成了垃圾内存，虽然毫无用处，但依然占用资源，唯一的办法就是等程序运行结束后由操作系统回收。</p>
<p>这就是内存泄露（Memory Leak），可以理解为程序和内存失去了联系，再也无法对它进行任何操作。</p>
<p>内存泄漏形象的比喻是“操作系统可提供给所有程序使用的内存空间正在被某个程序榨干”，最终结果是程序运行时间越长，占用内存空间越来越多，最终用尽全部内存空间，整个系统崩溃。</p>
<h3 id="用c语言写一个内存泄露的例子" tabindex="-1"> 用C语言写一个内存泄露的例子</h3>
<p>操作系统允许程序自己分配内存，并自由使用，使用完了还可以再释放掉，将内存归还给计算机。</p>
<p>所谓分配内存，就是程序向计算机申请一块内存空间，然后自己使用；所谓释放内存，就是程序告诉计算机不再使用之前的内存空间了，需要归还给计算机，让其它程序使用。</p>
<p>如果一个程序不停地分配内存，而不释放内存，那么拥有的内存就会越来越多，计算机内存就会被消耗殆尽，其它程序能够使用的内存越来越少，整台计算机就会都变得缓慢，甚至卡死。</p>
<p>下面我们就用 while 循环来写一个内存泄漏的例子：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>while</span><span>(</span><span>1</span><span>)</span><span>{</span>  <span>//死循环</span>
        <span>malloc</span><span>(</span><span>1024</span><span>)</span><span>;</span>  <span>//分配1024个字节的内存</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>while 循环的条件是 1，始终成立，循环会一直进行下去，永无休止，所以是一个“死循环”。</p>
<p>每次循环，程序都会向计算机申请 1024 个字节（1KB）的内存，并且不会释放；循环到第 1024 次时，程序就占用了 1024<em>1024 个字节（1MB）的内存；循环到 1024</em>1024 次时，程序就占用了 1024<em>1024</em>1024 个字节（1GB）的内存。</p>
<p>不要害怕，亲自跑一下试试，打开 Windows 下的任务管理器，可以看到内存的使用率会飙升，稍等片刻后程序会被终止。Windows 的内存管理机制发现我们的程序占用内存太多，会让它崩溃，防止系统卡死（其它的操作系统也有相应的措施）。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/7ce095f844204c06969fd55e644da2a1.png" type="image/png"/>
    </item>
    <item>
      <title>Chrome架构：仅仅打开了1个页面，为什么有4个进程</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson01.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson01.html</guid>
      <source url="https://0808200.xyz/rss.xml">Chrome架构：仅仅打开了1个页面，为什么有4个进程</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="chrome架构-仅仅打开了1个页面-为什么有4个进程" tabindex="-1"> Chrome架构：仅仅打开了1个页面，为什么有4个进程</h1>
<p>在开始之前，我们一起看下，Chrome打开一个页面需要启动多少进程？你可以点击Chrome浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，如下图</p>
<p><img src="https://static001.geekbang.org/resource/image/ce/9e/ce7f8cfe212bec0f53360422e3b03a9e.png" alt=""></p>
<p>和Windows任务管理器一样，Chrome任务管理器也是用来展示运行中Chrome使用的进程信息的。从图中可以看到，Chrome启动了4个进程，你也许会好奇，只是打开了1个页面，为什么要启动这么多进程呢？</p>
<p>在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。</p>
<h2 id="进程和线程" tabindex="-1"> 进程和线程</h2>
<p>不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>
<h3 id="什么是并行处理" tabindex="-1"> 什么是并行处理</h3>
<p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果</p>
<div><pre><code>A = 1+2
B = 20/5
C = 7*8
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>
<ul>
<li>任务1 是计算A=1+2；</li>
<li>任务2 是计算B=20/5；</li>
<li>任务3 是计算C=7*8；</li>
<li>任务4 是显示最后计算的结果</li>
</ul>
<p>正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。</p>
<p>如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>
<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能</p>
<h3 id="线程-vs-进程" tabindex="-1"> 线程 VS 进程</h3>
<p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？</p>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p>
<p>为了让你更好地理解上述计算过程，我画了下面这张对比图</p>
<p><img src="https://static001.geekbang.org/resource/image/33/da/3380f0a16c323deda5d3a300804b95da.png" alt=""></p>
<p>从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</p>
<p>总结来说，进程和线程之间的关系有以下4个特点</p>
<p><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>
<p>我们可以模拟以下场景：</p>
<div><pre><code>A = 1+2
B = 20/0
C = 7*8
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>我把上述三个表达式稍作修改，在计算B的值的时候，我把表达式的分母改成0，当线程执行到B = 20/0时，由于分母为0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了</p>
<p><strong>2. 线程之间共享进程中的数据。</strong></p>
<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>
<p><img src="https://static001.geekbang.org/resource/image/d0/9e/d0efacd7f299ed99e776cb97da2a799e.png" alt=""></p>
<p>从上图可以看出，线程1、线程2、线程3分别把执行的结果写入A、B、C中，然后线程2继续从A、B、C中读取数据，用来显示执行结果。</p>
<p><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p>
<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
<p>比如之前的IE浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>
<p><strong>4. 进程之间的内容相互隔离。</strong></p>
<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程A写入数据到进程B的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。</p>
<h2 id="单进程浏览器时代" tabindex="-1"> 单进程浏览器时代</h2>
<p>在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示</p>
<p><img src="https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png" alt=""></p>
<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因</p>
<p><strong>问题1：不稳定</strong></p>
<p>早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>
<p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>
<p><strong>问题2：不流畅</strong></p>
<p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>
<p>比如，下面这个无限循环的脚本：</p>
<div><pre><code><span>function</span> <span>freeze</span><span>(</span><span>)</span> <span>{</span>
	<span>while</span> <span>(</span><span>1</span><span>)</span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>"freeze"</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>freeze</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？</p>
<p>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。</p>
<p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢</p>
<p><strong>问题3：不安全</strong></p>
<p>这里依然可以从插件和页面脚本两个方面来解释该原因。</p>
<p>插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>
<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>
<p>以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢</p>
<h2 id="多进程浏览器时代" tabindex="-1"> 多进程浏览器时代</h2>
<p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了</p>
<h3 id="早期多进程架构" tabindex="-1"> 早期多进程架构</h3>
<p>你可以先看看下面这张图，这是2008年Chrome发布时的进程架构。</p>
<p><img src="https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png" alt=""></p>
<p>从图中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信（如图中虚线部分）。</p>
<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p>
<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p>
<p>对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>
<p><strong>最后我们再来看看上面的两个安全问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>
<p>好了，分析完早期的Chrome浏览器后，相信你已经了解了浏览器采用多进程架构的必要性</p>
<h3 id="目前多进程架构" tabindex="-1"> 目前多进程架构</h3>
<p>不过Chrome的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的Chrome进程架构，你可以参考下图</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png" alt=""></p>
<p>从图中可以看出，最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程</p>
<p>下面我们来逐个分析下这几个进程的功能。</p>
<ul>
<li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU进程</strong>。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</li>
<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li>
</ul>
<p>讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了1个页面，为什么有4个进程？因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。</p>
<p>不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题</p>
<ul>
<li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li>
</ul>
<p>对于上面这两个问题，Chrome团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题</p>
<h3 id="未来面向服务的架构" tabindex="-1"> 未来面向服务的架构</h3>
<p>为了解决这些问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称SOA）的思想设计了新的Chrome架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过IPC来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。</p>
<p>Chrome最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是Chrome“面向服务的架构”的进程模型图</p>
<p><img src="https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png" alt=""></p>
<p>目前Chrome正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。</p>
<p>Chrome正在逐步构建Chrome基础服务（Chrome Foundation Service），如果你认为Chrome是“便携式操作系统”，那么Chrome基础服务便可以被视为该操作系统的“基础”系统服务层。</p>
<p>同时Chrome还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome会将很多服务整合到一个进程中，从而节省内存占用。</p>
<p><img src="https://static001.geekbang.org/resource/image/a9/76/a9ba86d7b03263fa3997d3733d958176.png" alt=""></p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，今天就到这里，下面我来简要梳理并总结今天的内容。</p>
<p>本文我主要是从Chrome进程架构的视角，分析了浏览器的进化史。</p>
<p>最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后Chrome试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome的架构体系变得越来越复杂，这种架构的复杂性倒逼Chrome开发团队必须进行架构的重构，最终Chrome团队选择了面向服务架构（SOA）形式，这也是Chrome团队现阶段的一个主要任务。</p>
<p>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过Chrome开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到Chrome新的变化。</p>
<p>总体说来，Chrome是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利</p>
]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/ce/9e/ce7f8cfe212bec0f53360422e3b03a9e.png" type="image/png"/>
    </item>
    <item>
      <title>TCP协议：如何保证页面文件能被完整送达浏览器</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson02.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson02.html</guid>
      <source url="https://0808200.xyz/rss.xml">TCP协议：如何保证页面文件能被完整送达浏览器</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="tcp协议-如何保证页面文件能被完整送达浏览器" tabindex="-1"> TCP协议：如何保证页面文件能被完整送达浏览器</h1>
<p>在衡量Web页面性能的时候有一个重要的指标叫“FP（First Paint）”，是指从页面加载到首次开始绘制的时长。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的PV、更高的参与度，以及更高的转化率。那什么影响FP指标呢？其中一个重要的因素是网络加载速度</p>
<p>要想优化Web页面的加载速度，你需要对网络有充分的了解。而理解网络的关键是要对网络协议有深刻的认识，不管你是使用HTTP，还是使用WebSocket，它们都是基于TCP/IP的，如果你对这些原理有足够了解，也就清楚如何去优化Web性能，或者能更轻松地定位Web问题了。此外，TCP/IP的设计思想还有助于拓宽你的知识边界，从而在整体上提升你对项目的理解和解决问题的能力。</p>
<p>好，接下来我们回到正题，开始今天的内容。在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？</p>
<p>这篇文章将站在数据包的视角，给出问题答案</p>
<h2 id="一个数据包的-旅程" tabindex="-1"> 一个数据包的“旅程”</h2>
<p>下面我将分别从“数据包如何送达主机”“主机如何将数据包转交给应用”和“数据是如何被完整地送达应用程序”这三个角度来为你讲述数据的传输过程</p>
<p><strong>互联网，实际上是一套理念和协议组成的体系架构</strong>。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍</p>
<p>互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的</p>
<h3 id="_1-ip-把数据包送达目的主机" tabindex="-1"> 1. IP：把数据包送达目的主机</h3>
<p>数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称IP）标准。互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地</p>
<p><strong>计算机的地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</strong></p>
<p>如果要想把一个数据包从主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本身的IP地址，有了这些信息主机B才可以回复信息给主机A。这些附加的信息会被装进一个叫IP头的数据结构里。IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息</p>
<p>为了方便理解，我先把网络简单分为三层结构，如下图</p>
<p><img src="https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png" alt=""></p>
<blockquote>
<p>下面我们一起来看下一个数据包从主机A到主机B的旅程：</p>
</blockquote>
<ul>
<li>上层将含有“极客时间”的数据包交给网络层；</li>
<li>网络层再将IP头附加到数据包上，组成新的 IP数据包，并交给底层；</li>
<li>底层通过物理网络将数据包传输给主机B；</li>
<li>数据包被传输到主机B的网络层，在这里主机B拆开数据包的IP头信息，并将拆开来的数据部分交给上层；</li>
<li>最终，含有“极客时间”信息的数据包就到达了主机B的上层了</li>
</ul>
<h3 id="_2-udp-把数据包送达应用程序" tabindex="-1"> 2. UDP：把数据包送达应用程序</h3>
<p>IP是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于IP之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称UDP。</p>
<p>UDP中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号UDP就能把指定的数据包发送给指定的程序了，所以IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。和IP头一样，端口号会被装进UDP头里面，UDP头再和原始数据包合并组成新的UDP数据包。UDP头中除了目的端口，还有源端口号等信息</p>
<p>为了支持UDP协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png" alt=""></p>
<p>下面我们一起来看下一个数据包从主机A旅行到主机B的路线：</p>
<ul>
<li>上层将含有“极客时间”的数据包交给传输层；</li>
<li>传输层会在数据包前面附加上UDP头，组成新的UDP数据包，再将新的UDP数据包交给网络层；</li>
<li>网络层再将IP头附加到数据包上，组成新的IP数据包，并交给底层；</li>
<li>数据包被传输到主机B的网络层，在这里主机B拆开IP头信息，并将拆开来的数据部分交给传输层；</li>
<li>在传输层，数据包中的UDP头会被拆开，并根据UDP中所提供的端口号，把数据部分交给上层的应用程序；</li>
<li>最终，含有“极客时间”信息的数据包就旅行到了主机B上层应用程序这里</li>
</ul>
<p>在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包，而且UDP在发送之后也无法知道是否能达到目的地。</p>
<p>虽说UDP不能保证数据可靠性，但是传输速度却非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等</p>
<h3 id="_3-tcp-把数据完整地送达应用程序" tabindex="-1"> 3. TCP：把数据完整地送达应用程序</h3>
<p>对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用UDP来传输会存在两个问题：</p>
<ul>
<li>数据包在传输过程中容易丢失；</li>
<li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件</li>
</ul>
<p>基于这两个问题，我们引入TCP了。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于UDP，TCP有下面两个特点:</p>
<ul>
<li>对于数据包丢失的情况，TCP提供重传机制；</li>
<li>TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li>
</ul>
<p>和UDP头一样，TCP头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p>
<p>下面看看TCP下的单个数据包的传输流程</p>
<p><img src="https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png" alt=""></p>
<p>通过上图你应该可以了解一个数据包是如何通过TCP来传输的。TCP单个数据包的传输流程和UDP流程差不多，不同的地方在于，通过TCP头的信息保证了一块大的数据传输的完整性。</p>
<p>下面我们再看下完整的TCP连接过程，通过这个过程你可以明白TCP是如何保证重传机制和数据包的排序功能的。</p>
<p>从下图可以看出，一个完整的TCP连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。</p>
<p><img src="https://static001.geekbang.org/resource/image/44/44/440ee50de56edc27c6b3c992b3a25844.png" alt=""></p>
<ul>
<li><strong>首先，建立连接阶段</strong>。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个TCP连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。</li>
<li><strong>其次，传输数据阶段</strong>。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从而保证组成完整的数据。</li>
<li><strong>最后，断开连接阶段</strong>。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接</li>
</ul>
<p>到这里你应该就明白了，TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，这一节就到这里，下面我来做一个简单的总结。</p>
<ul>
<li>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。</li>
<li>IP负责把数据包送达目的主机。</li>
<li>UDP负责把数据包送达具体应用。</li>
<li>而TCP保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。</li>
<li>其实了解TCP协议，是为了全方位了解HTTP，包括其实际功能和局限性，之后才会更加深刻地理解为什么要推出HTTP/2，以及为什么要推出QUIC协议，也就是未来的HTTP/3。这是一个由浅入深、循序渐进的过程，我希望你能稳扎稳打，学好这每一步、每一个协议，后面“水到自然渠成”</li>
</ul>
]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png" type="image/png"/>
    </item>
    <item>
      <title>HTTP请求流程：为什么很多站点第二次打开速度会很快</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson03.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson03.html</guid>
      <source url="https://0808200.xyz/rss.xml">HTTP请求流程：为什么很多站点第二次打开速度会很快</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="http请求流程-为什么很多站点第二次打开速度会很快" tabindex="-1"> HTTP请求流程：为什么很多站点第二次打开速度会很快</h1>
<p>一个TCP连接过程包括了建立连接、传输数据和断开连接三个阶段。</p>
<p>而HTTP协议，正是建立在TCP连接基础之上的。HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如HTML文件、CSS文件、JavaScript文件、图片、视频等。此外，HTTP也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解HTTP。</p>
<p>不知道你是否有过下面这些疑问：</p>
<ol>
<li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li>
<li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li>
</ol>
<p>这一切的秘密都隐藏在HTTP的请求过程中。所以，在今天这篇文章中，我将通过分析一个HTTP请求过程中每一步的状态来带你了解完整的HTTP请求过程，希望你看完这篇文章后，能够对HTTP协议有个全新的认识</p>
<h2 id="浏览器端发起http请求流程" tabindex="-1"> 浏览器端发起HTTP请求流程</h2>
<p>如果你在浏览器地址栏里键入地址：http://baidu.com， 那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细“追踪”下</p>
<h3 id="_1-构建请求" tabindex="-1"> 1. 构建请求</h3>
<p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求</p>
<div><pre><code>GET /index.html HTTP1.1
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="_2-查找缓存" tabindex="-1"> 2. 查找缓存</h3>
<p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p>
<p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p>
<ul>
<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>
<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>
</ul>
<p>当然，如果缓存查找失败，就会进入网络请求过程了。</p>
<h3 id="_3-准备ip地址和端口" tabindex="-1"> 3. 准备IP地址和端口</h3>
<p>不过，先不急，在了解网络请求之前，我们需要先看看HTTP和TCP的关系。因为浏览器使用HTTP协议作为应用层协议，用来封装请求的文本信息；并使用TCP/IP作传输层协议将它发到网络上，所以在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接。也就是说HTTP的内容是通过TCP的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。</p>
<p><img src="https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png" alt=""></p>
<p>那接下来你可以思考这么“一连串”问题：</p>
<ul>
<li>HTTP网络请求的第一步是做什么呢？结合上图看，是和服务器建立TCP连接。</li>
<li>那建立连接的信息都有了吗？上一篇文章中，我们讲到建立TCP连接的第一步就是需要准备IP地址和端口号。</li>
<li>那怎么获取IP地址和端口号呢？这得看看我们现在有什么，我们有一个URL地址，那么是否可以利用URL地址来获取IP和端口信息呢？</li>
</ul>
<p>在上一篇文章中，我们介绍过数据包都是通过IP地址传输给接收方的。由于IP地址是数字标识，比如极客时间网站的IP是39.106.233.176, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和IP地址做一一映射关系。这套域名映射为IP的系统就叫做“域名系统”，简称DNS（Domain Name System）。</p>
<p>所以，这样一路推导下来，你会发现在第一步浏览器会请求DNS返回域名对应的IP。当然浏览器还提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求</p>
<p>拿到IP之后，接下来就需要获取端口号了。通常情况下，如果URL没有特别指明端口号，那么HTTP协议默认是80端口。</p>
<h3 id="_4-等待tcp队列" tabindex="-1"> 4. 等待TCP队列</h3>
<p>现在已经把端口和IP地址都准备好了，那么下一步是不是可以建立TCP连接了呢？</p>
<p>答案依然是“不行”。Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。</p>
<p>当然，如果当前请求数量少于6，会直接进入下一步，建立TCP连接。</p>
<h3 id="_5-建立tcp连接" tabindex="-1"> 5. 建立TCP连接</h3>
<p>排队等待结束之后，终于可以快乐地和服务器握手了，在HTTP工作开始之前，浏览器通过TCP与服务器建立连接。而TCP的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。</p>
<h3 id="_6-发送http请求" tabindex="-1"> 6. 发送HTTP请求</h3>
<p>一旦建立了TCP连接，浏览器就可以和服务器进行通信了。而HTTP中的数据正是在这个通信过程中传输的。</p>
<p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p>
<p><img src="https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png" alt=""></p>
<p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求URI（Uniform Resource Identifier）和HTTP版本协议。</p>
<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要Get它的首页资源。</p>
<p>另外一个常用的请求方法是POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过POST方法把用户信息发送给服务器。如果使用POST方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>
<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的Cookie信息，等等</p>
<h2 id="服务器端处理http请求流程" tabindex="-1"> 服务器端处理HTTP请求流程</h2>
<p>历经千辛万苦，HTTP的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容</p>
<h3 id="_1-返回请求" tabindex="-1"> 1. 返回请求</h3>
<p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件curl来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p>
<div><pre><code>curl -i  https://time.geekbang.org/
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意这里加上了-i是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p>
<p><img src="https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png" alt=""></p>
<p>首先服务器会返回响应行，包括协议版本和状态码。</p>
<p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：</p>
<ul>
<li>最常用的状态码是200，表示处理成功；</li>
<li>如果没有找到页面，则会返回404-</li>
</ul>
<p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p>
<p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的Cookie等信息。</p>
<p>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了HTML的实际内容。</p>
<p>以上这些就是服务器响应浏览器的具体过程</p>
<h3 id="_2-断开连接" tabindex="-1"> 2. 断开连接</h3>
<p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>
<div><pre><code>Connection:Keep-Alive 
</code></pre><div aria-hidden="true"><div></div></div></div><p>那么TCP连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个Web页面中内嵌的图片就都来自同一个Web站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的TCP连接。</p>
<h3 id="_3-重定向" tabindex="-1"> 3. 重定向</h3>
<p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开geekbang.org后，你会发现最终打开的页面地址是 https://www.geekbang.org。</p>
<p>这两个URL之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用curl来查看下请求geekbang.org 会返回什么内容？</p>
<p>在控制台输入如下命令：</p>
<div><pre><code>curl -I geekbang.org
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意这里输入的参数是-I，和-i不一样，-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/01/6b/01db98e08233dba5847fab171ce95e6b.png" alt=""></p>
<p>从图中你可以看到，响应行返回的状态码是301，状态301就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的Location字段中，接下来，浏览器获取Location字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 https://www.geekbang.org 了。</p>
<p>不过也不要认为这种跳转是必然的。如果你打开 https://12306.cn，你会发现这个站点是打不开的。这是因为12306的服务器并没有处理跳转，所以必须要手动输入完整的 https://www.12306.com 才能打开页面。</p>
<h2 id="问题解答" tabindex="-1"> 问题解答</h2>
<p>说了这么多，相信你现在已经了解了HTTP的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p>
<h3 id="_1-为什么很多站点第二次打开速度会很快" tabindex="-1"> 1. 为什么很多站点第二次打开速度会很快？</h3>
<p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p>
<p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS缓存和页面资源缓存这两块数据是会被浏览器缓存的。其中，DNS缓存比较简单，它主要就是在浏览器本地把对应的IP和域名关联起来，这里就不做过多分析了。</p>
<p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p>
<p><img src="https://static001.geekbang.org/resource/image/16/02/1670e353bf6cccc096e63e0f102ed502.png" alt=""></p>
<p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p>
<p>从上图的第一次请求可以看出，当服务器返回HTTP响应头给浏览器时，浏览器是通过响应头中的Cache-Control字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过Cache-Control中的Max-age参数来设置的，比如上图设置的缓存过期时间是2000秒。</p>
<div><pre><code>Cache-Control:Max-age=2000
</code></pre><div aria-hidden="true"><div></div></div></div><p>这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p>
<p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上：</p>
<div><pre><code>If-None-Match:"4f80f-13c-3a1xb12a"
</code></pre><div aria-hidden="true"><div></div></div></div><p>服务器收到请求头后，会根据If-None-Match的值来判断请求的资源是否有更新。</p>
<ul>
<li>如果没有更新，就返回304状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li>
<li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li>
</ul>
<p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS数据也被浏览器缓存了，这又省去了DNS查询环节</p>
<h3 id="_2-登录状态是如何保持的" tabindex="-1"> 2. 登录状态是如何保持的？</h3>
<ul>
<li>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</li>
<li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用POST方法提交用户登录信息给服务器。</li>
<li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的<code>Set-Cookie</code>字段里，如下所示，然后把响应头发送给浏览器</li>
</ul>
<div><pre><code>Set-Cookie: UID=3431uad;
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有Set-Cookie字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。</li>
<li>当用户再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的Cookie数据，并把数据写进请求头里的Cookie字段里（如下所示），然后浏览器再将请求头发送给服务器。</li>
</ul>
<div><pre><code>Cookie: UID=3431uad;
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>服务器在收到HTTP请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li>
<li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了</li>
</ul>
<p>好了，通过这个流程你可以知道浏览器页面状态是通过使用Cookie来实现的。Cookie流程可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png" alt=""></p>
<p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p>
<p>为了便于你理解，我画了下面这张详细的“HTTP请求示意图”，用来展现浏览器中的HTTP请求所经历的各个阶段。</p>
<p><img src="https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png" alt=""></p>
<p>从图中可以看到，浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接。</p>
<p>然后我还通过HTTP请求路径解答了两个经常会碰到的问题，一个涉及到了Cache流程，另外一个涉及到如何使用Cookie来进行状态管理。</p>
<p>通过今天系统的讲解，想必你已经了解了一个HTTP完整的工作流程，相信这些知识点之于你以后的学习或工作会很有帮助。</p>
]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png" type="image/png"/>
    </item>
    <item>
      <title>导航流程：从输入URL到页面展示这中间发生了什么</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson04.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson04.html</guid>
      <source url="https://0808200.xyz/rss.xml">导航流程：从输入URL到页面展示这中间发生了什么</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="导航流程-从输入url到页面展示这中间发生了什么" tabindex="-1"> 导航流程：从输入URL到页面展示这中间发生了什么</h1>
<p>“在浏览器里，从输入URL到页面展示，这中间发生了什么？ ”这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web等一系列的知识。所以我在面试应聘者时也必问这道题，但遗憾的是大多数人只能回答其中部分零散的知识点，并不能将这些知识点串联成线，无法系统而又全面地回答这个问题。</p>
<p>那么今天我们就一起来探索下这个流程，下图是我梳理出的“从输入URL到页面展示完整流程示意图”：</p>
<p><img src="https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png" alt=""></p>
<p>从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。</p>
<ul>
<li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li>
<li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li>
<li>渲染进程的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么Chrome会让渲染进程运行在安全沙箱里，就是为了保证系统的安全</li>
</ul>
<p>回顾了浏览器的进程架构后，我们再结合上图来看下这个完整的流程，可以看出，整个流程包含了许多步骤，我把其中几个核心的节点用蓝色背景标记出来了。这个过程可以大致描述为如下：</p>
<ul>
<li>首先，用户从浏览器进程里输入请求信息；</li>
<li>然后，网络进程发起URL请求；</li>
<li>服务器响应URL请求之后，浏览器进程就又要开始准备渲染进程了；</li>
<li>渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；</li>
<li>渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。</li>
</ul>
<p>这其中，用户发出URL请求到页面开始解析的这个过程，就叫做导航。下面我们来详细分析下这些步骤，同时也就解答了开头所说的那道经典的面试题。</p>
<h2 id="从输入url到页面展示" tabindex="-1"> 从输入URL到页面展示</h2>
<p>知道了浏览器的几个主要进程的职责之后，那么接下来，我们就从浏览器的地址栏开始讲起。</p>
<h3 id="_1-用户输入" tabindex="-1"> 1. 用户输入</h3>
<p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。</li>
<li>如果判断输入内容符合URL规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 https://time.geekbang.org。</li>
</ul>
<p>当用户输入关键字并键入回车之后，浏览器便进入下图的状态：</p>
<p><img src="https://static001.geekbang.org/resource/image/fa/30/fad33fc7c5f2bdf4e20cac7691484130.png" alt=""></p>
<p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p>
<h3 id="_2-url请求过程" tabindex="-1"> 2. URL请求过程</h3>
<p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。那具体流程是怎样的呢？</p>
<p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。</p>
<p>接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p>
<p><strong>（1）重定向</strong></p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，一切又重头开始了。</p>
<p>比如，我们在终端里输入以下命令：</p>
<div><pre><code>curl -I http://time.geekbang.org/
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>curl -I + URL</code>的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/65/7e/655cbf32dd4bb6f9decc5c7f9a535a7e.png" alt=""></p>
<p>从图中可以看出，极客时间服务器会通过重定向的方式把所有HTTP请求转换为HTTPS请求。也就是说你使用HTTP向极客时间服务器请求时，服务器会返回一个包含有301或者302状态码响应头，并把响应头的Location字段中填上HTTPS的地址，这就是告诉了浏览器要重新导航到新的地址上。</p>
<p>下面我们再使用HTTPS协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。</p>
<div><pre><code>curl -I https://time.geekbang.org/
</code></pre><div aria-hidden="true"><div></div></div></div><p>我们看到服务器返回如下信息：</p>
<p><img src="https://static001.geekbang.org/resource/image/0c/43/0c4987fe5d05646fa8245d8cc50d1a43.png" alt=""></p>
<p>从图中可以看出，服务器返回的响应头的状态码是200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p>
<p>好了，以上是重定向内容的介绍。现在你应该理解了，在导航过程中，如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是200，那么表示浏览器可以继续处理该请求。</p>
<p><strong>（2）响应数据类型处理</strong></p>
<p>在处理了跳转信息之后，我们继续导航流程的分析。URL请求的数据类型，有时候是一个下载类型，有时候是正常的HTML页面，那么浏览器是如何区分它们呢？</p>
<p>答案是Content-Type。Content-Type是HTTP头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。</p>
<p>这里我们还是以极客时间为例，看看极客时间官网返回的Content-Type值是什么。在终端输入以下命令：</p>
<div><pre><code>curl -I https://time.geekbang.org/
</code></pre><div aria-hidden="true"><div></div></div></div><p>返回信息如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/89/1c/8951e161b5f44a73e52c16b631a63e1c.png" alt=""></p>
<p>从图中可以看到，响应头中的Content-type字段的值是text/html，这就是告诉浏览器，服务器返回的数据是HTML格式。</p>
<p>接下来我们再来利用curl来请求极客时间安装包的地址，如下所示：</p>
<div><pre><code>curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk
</code></pre><div aria-hidden="true"><div></div></div></div><p>请求后返回的响应头信息如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/59/3b/595902748d7d4c2f9c1d4783962ae43b.png" alt=""></p>
<p>从返回的响应头信息来看，其Content-Type的值是application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</p>
<p>需要注意的是，如果服务器配置Content-Type不正确，比如将text/html类型配置成application/octet-stream类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。</p>
<p>所以，不同Content-Type的后续处理流程也截然不同。如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。由于Chrome的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>
<h3 id="_3-准备渲染进程" tabindex="-1"> 3. 准备渲染进程</h3>
<p>默认情况下，Chrome会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>
<p>比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的Chrome的任务管理器截图：</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/28/d8fe2afbd8ea2d4a8d8cc4bb14c50f28.png" alt=""></p>
<p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程ID是23601。</p>
<p>那什么情况下多个页面会同时运行在一个渲染进程中呢？</p>
<p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p>
<div><pre><code>https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>它们都是属于同一站点，因为它们的协议都是HTTPS，而且根域名也都是geekbang.org。</p>
<p>Chrome的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。</p>
<p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？比如我通过极客邦页面里的链接打开InfoQ的官网（https://www.infoq.cn/ ）， 因为infoq.cn和geekbang.org不属于同一站点，所以infoq.cn会使用一个新的渲染进程，你可以参考下图</p>
<p><img src="https://static001.geekbang.org/resource/image/fb/74/fba1dd05f0aeba93a5cb25f305971274.png" alt=""></p>
<p>从图中任务管理器可以看出：由于极客邦和极客时间的标签页拥有相同的协议和根域名，所以它们属于同一站点，并运行在同一个渲染进程中；而infoq.cn的根域名不同于geekbang.org，也就是说InfoQ和极客邦不属于同一站点，因此它们会运行在两个不同的渲染进程之中。</p>
<p>总结来说，打开一个新页面采用的渲染进程策略就是：</p>
<ul>
<li>通常情况下，打开新的页面都会使用单独的渲染进程；</li>
<li>如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。</li>
</ul>
<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>
<h3 id="_4-提交文档" tabindex="-1"> 4. 提交文档</h3>
<p>首先要明确一点，这里的“文档”是指URL请求的响应体数据。</p>
<ul>
<li>“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。</li>
</ul>
<p>更新内容如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/a1/6f/a1b77a61361561e74e86fdae10ee246f.png" alt=""></p>
<p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>
<p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。</p>
<h3 id="_5-渲染阶段" tabindex="-1"> 5. 渲染阶段</h3>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/be/58/bef45eb5b01c34e328486004feedd658.png" alt=""></p>
<p>至此，一个完整的页面就生成了。那文章开头的“从输入URL到页面展示，这中间发生了什么？”这个过程极其“串联”的问题也就解决了。</p>
<h2 id="总结-从输入url到页面展示-这中间发生了什么" tabindex="-1"> 总结：从输入URL到页面展示，这中间发生了什么</h2>
<ul>
<li>用户输入url并回车</li>
<li>浏览器进程检查url，组装协议，构成完整的url</li>
<li>浏览器进程通过进程间通信（IPC）把url请求发送给网络进程</li>
<li>网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li>
<li><strong>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下</strong>：
<ul>
<li>进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）</li>
<li>利用ip地址和服务器建立tcp连接</li>
<li>构建请求头信息</li>
<li>发送请求头信息</li>
<li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li>
</ul>
</li>
<li><strong>网络进程解析响应流程</strong>；
<ul>
<li>检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
（301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。</li>
<li>200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</li>
</ul>
</li>
<li><strong>准备渲染进程</strong>
<ul>
<li>浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li>
</ul>
</li>
<li><strong>传输数据、更新状态</strong>
<ul>
<li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li>
<li>渲染进程接收完数据后，向浏览器发送“确认提交”</li>
<li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面</li>
</ul>
</li>
</ul>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，今天就到这里，下面我来简单总结下这篇文章的要点：</p>
<ul>
<li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li>
<li>Chrome默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</li>
<li>浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li>
<li>导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用</li>
</ul>
]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png" type="image/png"/>
    </item>
    <item>
      <title>渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson05.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson05.html</guid>
      <source url="https://0808200.xyz/rss.xml">渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="渲染流程-上-html、css和javascript是如何变成页面的" tabindex="-1"> 渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的</h1>
<p>在上一篇文章中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用JavaScript优化动画流程，通过优化样式表来防止强制同步布局，等等。</p>
<p>既然它的功能这么强大，那么今天，我们就来好好聊聊渲染流程。</p>
<p>通常，我们编写好HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p>
<p><img src="https://static001.geekbang.org/resource/image/2b/79/2b08a85c63bee68c6fd95dabb648fd79.png" alt=""></p>
<p>从图中可以看出，左边输入的是HTML、CSS、JavaScript数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p>
<p>这中间的渲染模块就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住HTML、CSS和JavaScript的含义：</p>
<p><img src="https://static001.geekbang.org/resource/image/31/e6/31cd7172f743193d682d088a60cb44e6.png" alt=""></p>
<p>从上图可以看出，HTML的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语意，浏览器会根据标签的语意来正确展示HTML内容。比如上面的<code>&lt;p&gt;</code>标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容</p>
<p>如果需要改变HTML的字体颜色、大小等信息，就需要用到CSS。CSS又称为层叠样式表，是由选择器和属性组成，比如图中的p选择器，它会把HTML里面<code>&lt;p&gt;</code>标签的内容选择出来，然后再把选择器的属性值应用到<code>&lt;p&gt;</code>标签内容上。选择器里面有个<code>color</code>属性，它的值是red，这是告诉渲染引擎把<code>&lt;p&gt;</code>标签的内容显示为红色</p>
<p>至于JavaScript（简称为JS），使用它可以使网页的内容“动”起来，比如上图中，可以通过JavaScript来修改CSS样式值，从而达到修改文本颜色的目的。</p>
<p>搞清楚HTML、CSS和JavaScript的含义后，那么接下来我们就正式开始分析渲染模块了。</p>
<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png" alt=""></p>
<p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容</p>
<ul>
<li>开始每个子阶段都有其输入的内容；</li>
<li>然后每个子阶段有其处理过程；</li>
<li>最终每个子阶段会生成输出内容。</li>
</ul>
<p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p>
<h2 id="构建dom树" tabindex="-1"> 构建DOM树</h2>
<p><strong>为什么要构建DOM树呢</strong>？这是因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。</p>
<p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p>
<p><img src="https://static001.geekbang.org/resource/image/fc/38/fcad0a4e3e73c796f00d6120284a3638.png" alt=""></p>
<p>从图中可以看出，树这种结构非常像我们现实生活中的“树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p>
<p>接下来咱们还是言归正传，来看看DOM树的构建过程，你可以参考下图</p>
<p><img src="https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png" alt=""></p>
<p>从图中可以看出，构建DOM树的输入内容是一个非常简单的HTML文件，然后经由HTML解析器解析，最终输出树状结构的DOM。</p>
<p>为了更加直观地理解DOM树，你可以打开Chrome的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的DOM树结构，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/47/73/47f57c3eee749dd838939bfe5dd64573.png" alt=""></p>
<p>图中的document就是DOM结构，你可以看到，DOM和HTML内容几乎是一样的，但是和HTML不同的是，DOM是保存在内存中树状结构，可以通过JavaScript来查询或修改其内容。</p>
<p>那下面就来看看如何通过JavaScript来修改DOM的内容，在控制台中输入：</p>
<div><pre><code>document.getElementsByTagName("p")[0].innerText = "black"
</code></pre><div aria-hidden="true"><div></div></div></div><p>这行代码的作用是把第一个<code>&lt;p&gt;</code>标签的内容修改为black，具体执行结果你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/e7/74/e730aa1d73c1151c588e2f8c7e22c274.png" alt=""></p>
<p>从图中可以看出，在执行了一段修改第一个<code>&lt;p&gt;</code>标签的JavaScript代码后，DOM的第一个p节点的内容成功被修改，同时页面中的内容也被修改了</p>
<p>好了，现在我们已经生成DOM树了，但是DOM节点的样式我们依然不知道，要让DOM节点拥有正确的样式，这就需要样式计算了</p>
<h2 id="样式计算" tabindex="-1"> 样式计算</h2>
<p>样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p>
<h3 id="_1-把css转换为浏览器能够理解的结构" tabindex="-1"> 1. 把CSS转换为浏览器能够理解的结构</h3>
<p>那CSS样式的来源主要有哪些呢？你可以先参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png" alt=""></p>
<p>从图中可以看出，CSS样式来源主要有三种：</p>
<ul>
<li>
<p>通过link引用的外部CSS文件</p>
</li>
<li>
<p><code>&lt;style&gt;</code>标记内的 CSS</p>
</li>
<li>
<p>元素的style属性内嵌的CSS</p>
</li>
<li>
<p>和HTML文件一样，浏览器也是无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets。</p>
</li>
<li>
<p>为了加深理解，你可以在Chrome控制台中查看其结构，只需要在控制台中输入<code>document.styleSheets</code>，然后就看到如下图所示的结构</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png" alt=""></p>
<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的CSS文本全部转换为styleSheets结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础</p>
<h3 id="_2-转换样式表中的属性值-使其标准化" tabindex="-1"> 2. 转换样式表中的属性值，使其标准化</h3>
<p>现在我们已经把现有的CSS文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</p>
<p>要理解什么是属性值标准化，你可以看下面这样一段CSS文本</p>
<div><pre><code><span>body</span> <span>{</span> <span>font-size</span><span>:</span> 2em <span>}</span>
<span>p</span> <span>{</span><span>color</span><span>:</span>blue<span>;</span><span>}</span>
<span>span</span>  <span>{</span><span>display</span><span>:</span> none<span>}</span>
<span>div</span> <span>{</span><span>font-weight</span><span>:</span> bold<span>}</span>
<span>div  p</span> <span>{</span><span>color</span><span>:</span>green<span>;</span><span>}</span>
<span>div</span> <span>{</span><span>color</span><span>:</span>red<span>;</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>
<p>那标准化后的属性值是什么样子的？</p>
<p><img src="https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png" alt=""></p>
<p>从图中可以看到，2em被解析成了32px，red被解析成了rgb(255,0,0)，bold被解析成了700……</p>
<h3 id="_3-计算出dom树中每个节点的具体样式" tabindex="-1"> 3. 计算出DOM树中每个节点的具体样式</h3>
<p>现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？</p>
<p><strong>这就涉及到CSS的继承规则和层叠规则了。</strong></p>
<p>首先是CSS继承。CSS继承就是每个DOM节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到DOM节点上的</p>
<div><pre><code><span>body</span> <span>{</span> <span>font-size</span><span>:</span> 20px <span>}</span>
<span>p</span> <span>{</span><span>color</span><span>:</span>blue<span>;</span><span>}</span>
<span>span</span>  <span>{</span><span>display</span><span>:</span> none<span>}</span>
<span>div</span> <span>{</span><span>font-weight</span><span>:</span> bold<span>;</span><span>color</span><span>:</span>red<span>}</span>
<span>div  p</span> <span>{</span><span>color</span><span>:</span>green<span>;</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这张样式表最终应用到DOM节点的效果如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/fe/b4/fe9a0ea868dc02a3c4a59f6080aa80b4.png" alt=""></p>
<p>从图中可以看出，所有子节点都继承了父节点样式。比如body节点的font-size属性是20，那body节点下面的所有节点的font-size都等于20。</p>
<p>为了加深你对CSS继承的理解，你可以打开Chrome的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面</p>
<p><img src="https://static001.geekbang.org/resource/image/88/b2/88a3aac427cc7c09361eac01a85fc7b2.png" alt=""></p>
<p>这个界面展示的信息很丰富，大致可描述为如下</p>
<ul>
<li>首先，可以选择要查看的元素的样式（位于图中的区域2中），在图中的第1个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是<code>&lt;p&gt;</code>标签，位于<code>html.body.div.</code>这个路径下面</li>
<li>其次，可以从样式来源（位于图中的区域3中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于UserAgent样式表。这里需要特别提下UserAgent样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是UserAgent样式。</li>
<li>最后，可以通过区域2和区域3来查看样式继承的具体过程。</li>
</ul>
<p>以上就是CSS继承的一些特性，样式计算过程中，会根据DOM节点的继承关系来合理计算节点样式。</p>
<p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法</strong>。它在CSS处于核心地位，CSS的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习</p>
<p>总之，样式计算阶段的目的是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。</p>
<p>如果你想了解每个DOM元素最终的计算样式，可以打开Chrome的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/46/d87415b0187e3860404bf963f1c3d646.png" alt=""></p>
<p>上图红色方框中显示了html.body.div.p标签的ComputedStyle的值。你想要查看哪个元素，点击左边对应的标签就可以了</p>
<h2 id="布局阶段" tabindex="-1"> 布局阶段</h2>
<p>现在，我们有DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>
<p>Chrome在布局阶段需要完成两个任务：创建布局树和布局计算</p>
<h3 id="_1-创建布局树" tabindex="-1"> 1. 创建布局树</h3>
<p>你可能注意到了DOM树还含有很多不可见的元素，比如head标签，还有使用了<code>display:none</code>属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p>
<p>我们结合下图来看看布局树的构造过程：</p>
<p><img src="https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png" alt=""></p>
<p>从上图可以看出，DOM树中所有不可见的节点都没有包含到布局树中。</p>
<p>为了构建布局树，浏览器大体上完成了下面这些工作</p>
<ul>
<li>遍历DOM树中的所有可见节点，并把这些节点加到布局中；</li>
<li>而不可见的节点会被布局树忽略掉，如<code>head</code>标签下面的全部内容，再比如<code>body.p.span</code>这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树</li>
</ul>
<h3 id="_2-布局计算" tabindex="-1"> 2. 布局计算</h3>
<p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p>
<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome团队正在重构布局代码，下一代布局系统叫LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，今天正文就到这里，我画了下面这张比较完整的渲染流水线，你可以结合这张图来回顾下今天的内容。</p>
<p><img src="https://static001.geekbang.org/resource/image/a4/9a/a4a0ea4da58260aafc9aabdd37613f9a.png" alt=""></p>
<p>从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：DOM生成、样式计算和布局。要点可大致总结为如下：</p>
<ul>
<li>浏览器不能直接理解HTML数据，所以第一步需要将其转换为浏览器能够理解的DOM树结构；</li>
<li>生成DOM树后，还需要根据CSS样式表，来计算出DOM树所有节点的样式；</li>
<li>最后计算DOM元素的布局信息，使其都保存在布局树中。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/2b/79/2b08a85c63bee68c6fd95dabb648fd79.png" type="image/png"/>
    </item>
    <item>
      <title>渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson06.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part1/lesson06.html</guid>
      <source url="https://0808200.xyz/rss.xml">渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="渲染流程-下-html、css和javascript是如何变成页面的" tabindex="-1"> 渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的</h1>
<p>在上篇文章中，我们介绍了渲染流水线中的DOM生成、样式计算和布局三个阶段，那今天我们接着讲解渲染流水线后面的阶段。</p>
<p>这里还是先简单回顾下上节前三个阶段的主要内容：在HTML页面内容被提交给渲染引擎之后，渲染引擎首先将HTML解析为浏览器可以理解的DOM；然后根据CSS样式表，计算出DOM树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中</p>
<h2 id="分层" tabindex="-1"> 分层</h2>
<p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p>
<p>答案依然是否定的。</p>
<p>因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>
<p>要想直观地理解什么是图层，你可以打开Chrome的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示</p>
<p><img src="https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png" alt=""></p>
<p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图</p>
<p><img src="https://static001.geekbang.org/resource/image/cd/78/cd6aac705501d48bda6e8eebca058b78.png" alt=""></p>
<p>现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png" alt=""></p>
<p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的span标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>
<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>
<p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong></p>
<p>页面是个二维平面，但是层叠上下文能够让HTML元素具有三维概念，这些HTML元素按照自身属性的优先级分布在垂直于这个二维平面的z轴上。你可以结合下图来直观感受下：</p>
<p><img src="https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png" alt=""></p>
<p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。</p>
<p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong></p>
<p>不过首先你需要了解什么是剪裁，结合下面的HTML代码：</p>
<div><pre><code><span><span><span>&lt;</span>style</span><span>></span></span><span><span>
      <span>div</span> <span>{</span>
            <span>width</span><span>:</span> 200<span>;</span>
            <span>height</span><span>:</span> 200<span>;</span>
            <span>overflow</span><span>:</span>auto<span>;</span>
            <span>background</span><span>:</span> gray<span>;</span>
        <span>}</span> 
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：<span><span><span>&lt;/</span>p</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。<span><span><span>&lt;/</span>p</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。<span><span><span>&lt;/</span>p</span><span>></span></span> 
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在这里我们把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，下图是运行时的执行结果</p>
<p><img src="https://static001.geekbang.org/resource/image/6a/0c/6a583733735edc1e4d7946740eb6fc0c.png" alt=""></p>
<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png" alt=""></p>
<p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。</p>
<h2 id="图层绘制" tabindex="-1"> 图层绘制</h2>
<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p>
<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>
<p><strong>通常，你会把你的绘制操作分解为三步</strong>：</p>
<ul>
<li>制蓝色背景；</li>
<li>在中间绘制一个红色的圆；</li>
<li>再在圆上绘制绿色三角形</li>
</ul>
<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png" alt=""></p>
<p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>
<p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png" alt=""></p>
<p>在该图中，区域1就是document的绘制列表，拖动区域2中的进度条可以重现列表的绘制过程。</p>
<h2 id="栅格化-raster-操作" tabindex="-1"> 栅格化（raster）操作</h2>
<p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p>
<p><img src="https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png" alt=""></p>
<p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>
<p>那我们得先来看看什么是视口，你可以参看下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/24/72/242225112f2a3ec97e736c960b88d972.png" alt=""></p>
<p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</p>
<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>
<p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是256x256或者512x512，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png" alt=""></p>
<p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png" alt=""></p>
<p>通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。</p>
<p>相信你还记得，GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png" alt=""></p>
<p>从图中可以看出，渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中。</p>
<h2 id="合成和显示" tabindex="-1"> 合成和显示</h2>
<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<p>到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。</p>
<h2 id="渲染流水线大总结" tabindex="-1"> 渲染流水线大总结</h2>
<p>好了，我们现在已经分析完了整个渲染流程，从HTML到DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p>
<p><img src="https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png" alt=""></p>
<p><strong>结合上图，一个完整的渲染流程大致可总结为如下</strong></p>
<ul>
<li>渲染进程将HTML内容转换为能够读懂的DOM树结构。</li>
<li>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li>
<li>创建布局树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。</li>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令DrawQuad给浏览器进程。</li>
<li>浏览器进程根据DrawQuad消息生成页面，并显示到显示器上</li>
</ul>
<h2 id="相关概念" tabindex="-1"> 相关概念</h2>
<p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续Web的性能优化会有很大帮助。</p>
<h3 id="_1-更新了元素的几何属性-重排" tabindex="-1"> 1. 更新了元素的几何属性（重排）</h3>
<p><img src="https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png" alt=""></p>
<p>从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的</p>
<h3 id="_2-更新元素的绘制属性-重绘" tabindex="-1"> 2. 更新元素的绘制属性（重绘）</h3>
<p>接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png" alt=""></p>
<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。<strong>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p>
<h3 id="_3-直接合成阶段" tabindex="-1"> 3. 直接合成阶段</h3>
<p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图</p>
<p><img src="https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png" alt=""></p>
<p>在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>
<p>至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过本文的分析，你应该可以看到，Chrome的渲染流水线还是相当复杂晦涩，且难以理解，不过Chrome团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p>
<h2 id="思考时间" tabindex="-1"> 思考时间</h2>
<p>在优化Web性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化Web性能吗？那又有那些具体的实践方法能减少重绘、重排呢？</p>
<ul>
<li>触发repaint reflow的操作尽量放在一起，比如改变dom高度和设置margin分开写，可能会出发两次重排</li>
<li>通过虚拟dom层计算出操作总得差异，一起提交给浏览器。之前还用过createdocumentfragment来汇总append的dom,来减少触发重排重绘次数。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png" type="image/png"/>
    </item>
    <item>
      <title>浏览器中的JavaScript执行机制</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part2/</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part2/</guid>
      <source url="https://0808200.xyz/rss.xml">浏览器中的JavaScript执行机制</source>
      <category>浏览器</category>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
    </item>
    <item>
      <title>变量提升：JavaScript代码是按顺序执行的吗</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part2/lesson07.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part2/lesson07.html</guid>
      <source url="https://0808200.xyz/rss.xml">变量提升：JavaScript代码是按顺序执行的吗</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="变量提升-javascript代码是按顺序执行的吗" tabindex="-1"> 变量提升：JavaScript代码是按顺序执行的吗</h1>
<p>讲解完宏观视角下的浏览器后，从这篇文章开始，我们就进入下一个新的模块了，这里我会对JavaScript执行原理做深入介绍。</p>
<p>今天在该模块的第一篇文章，我们主要讲解执行上下文相关的内容。那为什么先讲执行上下文呢？它这么重要吗？可以这么说，只有理解了JavaScrip的执行上下文，你才能更好地理解JavaScript语言本身，比如变量提升、作用域和闭包等。不仅如此，理解执行上下文和调用栈的概念还能助你成为一名更合格的前端开发者。</p>
<p>不过由于我们专栏不是专门讲JavaScript语言的，所以我并不会对JavaScript语法本身做过多介绍。本文主要是从JavaScript的顺序执行讲起，然后一步步带你了解JavaScript是怎么运行的。</p>
<p>接下来咱们先看段代码，你觉得下面这段代码输出的结果是什么？</p>
<div><pre><code><span>showName</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>myname<span>)</span>
<span>var</span> myname <span>=</span> <span>'极客时间'</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'函数showName被执行'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用过JavaScript开发的程序员应该都知道，JavaScript是按顺序执行的。若按照这个逻辑来理解的话，那么：</p>
<ul>
<li>当执行到第1行的时候，由于函数showName还没有定义，所以执行应该会报错；</li>
<li>同样执行第2行的时候，由于变量myname函数也未定义，所以同样也会报错</li>
</ul>
<p>然而实际执行结果却并非如此， 如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/fb/03/fbafaba4ad7092cbee011a8a02e38903.png" alt=""></p>
<p>第1行输出“函数showName被执行”，第2行输出“undefined”，这和前面想象中的顺序执行有点不一样啊！</p>
<p>通过上面的执行结果，你应该已经知道了函数或者变量可以在定义之前使用，那如果使用没有定义的变量或者函数，JavaScript代码还能继续执行吗？为了验证这点，我们可以删除第3行变量myname的定义，如下所示：</p>
<div><pre><code><span>showName</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>myname<span>)</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'函数showName被执行'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>然后再次执行这段代码时，JavaScript引擎就会报错，结果如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/a5/c2/a5262e2ca891ea114dfaf1e37f9ca4c2.png" alt=""></p>
<p>从上面两段代码的执行结果来看，我们可以得出如下三个结论。</p>
<ul>
<li>执行过程中，若使用了未声明的变量，那么JavaScript执行会报错。</li>
<li>在一个变量定义之前使用它，不会出错，但是该变量的值会为undefined，而不是定义时的值。</li>
<li>在一个函数定义之前使用它，不会出错，且函数能正确执行</li>
</ul>
<p>第一个结论很好理解，因为变量没有定义，这样在执行JavaScript代码时，就找不到该变量，所以JavaScript会抛出错误。</p>
<p>但是对于第二个和第三个结论，就挺让人费解的：</p>
<ul>
<li>变量和函数为什么能在其定义之前使用？这似乎表明JavaScript代码并不是一行一行执行的。</li>
<li>同样的方式，变量和函数的处理结果为什么不一样？比如上面的执行结果，提前使用的showName函数能打印出来完整结果，但是提前使用的myname变量值却是undefined，而不是定义时使用的“极客时间”这个值</li>
</ul>
<h2 id="变量提升-hoisting" tabindex="-1"> 变量提升（Hoisting）</h2>
<p>要解释这两个问题，你就需要先了解下什么是变量提升。</p>
<p>不过在介绍变量提升之前，我们先通过下面这段代码，来看看什么是JavaScript中的声明和赋值。</p>
<div><pre><code>var myname = '极客时间'
</code></pre><div aria-hidden="true"><div></div></div></div><p>这段代码你可以把它看成是两行代码组成的：</p>
<div><pre><code>var myname    //声明部分
myname = '极客时间'  //赋值部分
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><img src="https://static001.geekbang.org/resource/image/ec/3c/ec882f2d9deec26ce168b409f274533c.png" alt=""></p>
<p>上面是变量的声明和赋值，那接下来我们再来看看函数的声明和赋值，结合下面这段代码：</p>
<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span><span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'foo'</span><span>)</span>
<span>}</span>

<span>var</span> <span>bar</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'bar'</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>第一个函数foo是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量bar，再把<code>function(){console.log('bar')}</code>赋值给bar。为了直观理解，你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/61/77/611c09ab995b9b608d9c0db193266777.png" alt=""></p>
<p>好了，理解了声明和赋值操作，那接下来我们就可以聊聊什么是变量提升了。</p>
<p><strong>所谓的变量提升，是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined</strong>。</p>
<p>下面我们来模拟下实现：</p>
<div><pre><code><span>/*
* 变量提升部分
*/</span>
<span>// 把变量 myname提升到开头，</span>
<span>// 同时给myname赋值为undefined</span>
<span>var</span> myname <span>=</span> <span>undefined</span>
<span>// 把函数showName提升到开头</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'showName被调用'</span><span>)</span><span>;</span>
<span>}</span>

<span>/*
* 可执行代码部分
*/</span>
<span>showName</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>myname<span>)</span>
<span>// 去掉var声明部分，保留赋值语句</span>
myname <span>=</span> <span>'极客时间'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>为了模拟变量提升的效果，我们对代码做了以下调整，如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/ce/d5/cefe564dbff729e735a834fd9e3bd0d5.png" alt=""></p>
<p>从图中可以看出，对原来的代码主要做了两处调整：</p>
<ul>
<li>第一处是把声明的部分都提升到了代码开头，如变量<code>myname</code>和函数<code>showName</code>，并给变量设置默认值<code>undefined</code>；</li>
<li>第二处是移除原本声明的变量和函数，如var myname = '极客时间'的语句，移除了<code>var</code>声明，整个移除<code>showName</code>的函数声明。</li>
<li>通过这两步，就可以实现变量提升的效果。你也可以执行这段模拟变量提升的代码，其输出结果和第一段代码应该是完全一样的。</li>
</ul>
<p>通过这段模拟的变量提升代码，相信你已经明白了可以在定义之前使用变量或者函数的原因——函数和变量在执行之前都提升到了代码开头。</p>
<h2 id="javascript代码的执行流程" tabindex="-1"> JavaScript代码的执行流程</h2>
<p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被JavaScript引擎放入内存中。对，你没听错，一段JavaScript代码在执行之前需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。大致流程你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/64/1e/649c6e3b5509ffd40e13ce9c91b3d91e.png" alt=""></p>
<h3 id="_1-编译阶段" tabindex="-1"> 1. 编译阶段</h3>
<p>那么编译阶段和变量提升存在什么关系呢？</p>
<p>为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。</p>
<p><strong>第一部分：变量提升部分的代码。</strong></p>
<div><pre><code><span>var</span> myname <span>=</span> <span>undefined</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'函数showName被执行'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>第二部分：执行部分的代码。</strong></p>
<div><pre><code><span>showName</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>myname<span>)</span>
myname <span>=</span> <span>'极客时间'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面我们就可以把JavaScript的执行流程细化，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" alt=""></p>
<p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。</p>
<p>执行上下文是JavaScript执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。</p>
<p>关于执行上下文的细节，我会在下一篇文章《08 | 调用栈：为什么JavaScript代码会出现栈溢出？》做详细介绍，现在你只需要知道，在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量myname和函数showName，都保存在该对象中。</p>
<p>你可以简单地把变量环境对象看成是如下结构</p>
<div><pre><code>VariableEnvironment:
     myname -> undefined, 
     showName ->function : {console.log(myname)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。</p>
<div><pre><code><span>showName</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>myname<span>)</span>
<span>var</span> myname <span>=</span> <span>'极客时间'</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'函数showName被执行'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以一行一行来分析上述代码：</p>
<ul>
<li>第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理；</li>
<li>第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为myname的属性，并使用undefined对其初始化；</li>
<li>第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript的执行堆和执行栈我会在后续文章中介绍）。
这样就生成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码</li>
</ul>
<div><pre><code><span>showName</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>myname<span>)</span>
myname <span>=</span> <span>'极客时间'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>好了，现在有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。</p>
<h3 id="_2-执行阶段" tabindex="-1"> 2. 执行阶段</h3>
<p>JavaScript引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程</p>
<ul>
<li>当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。</li>
<li>接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。</li>
<li>接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”，变量环境如下所示：</li>
</ul>
<div><pre><code>VariableEnvironment:
     myname -> "极客时间", 
     showName ->function : {console.log(myname)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>好了，以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等，这些内容我会在《14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？》那节详细介绍，在本篇文章中你只需要知道JavaScript代码经过编译生成了什么内容就可以了</p>
<h2 id="代码中出现相同的变量或者函数怎么办" tabindex="-1"> 代码中出现相同的变量或者函数怎么办？</h2>
<p>现在你已经知道了，在执行一段JavaScript代码之前，会编译代码，并将代码中的函数和变量保存到执行上下文的变量环境中，那么如果代码中出现了重名的函数或者变量，JavaScript引擎会如何处理？</p>
<p>我们先看下面这样一段代码</p>
<div><pre><code><span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'极客邦'</span><span>)</span><span>;</span>
<span>}</span>
<span>showName</span><span>(</span><span>)</span><span>;</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'极客时间'</span><span>)</span><span>;</span>
<span>}</span>
<span>showName</span><span>(</span><span>)</span><span>;</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在上面代码中，我们先定义了一个showName的函数，该函数打印出来“极客邦”；然后调用showName，并定义了一个showName函数，这个showName函数打印出来的是“极客时间”；最后接着继续调用showName。那么你能分析出来这两次调用打印出来的值是什么吗？</p>
<p><strong>我们来分析下其完整执行流程</strong>：</p>
<ul>
<li><strong>首先是编译阶段</strong>。遇到了第一个showName函数，会将该函数体存放到变量环境中。接下来是第二个showName函数，继续存放至变量环境中，但是变量环境中已经存在一个showName函数了，此时，第二个showName函数会将第一个showName函数覆盖掉。这样变量环境中就只存在第二个showName函数了。</li>
<li><strong>接下来是执行阶段</strong>。先执行第一个showName函数，但由于是从变量环境中查找showName函数，而变量环境中只保存了第二个showName函数，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行showName函数也是走同样的流程，所以输出的结果也是“极客时间”</li>
</ul>
<p>综上所述，<strong>一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数</strong>。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，今天就到这里，下面我来简单总结下今天的主要内容：</p>
<ul>
<li>JavaScript代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为JavaScript代码在执行之前需要先编译。
在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。</li>
<li>如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。</li>
<li>以上就是今天所讲的主要内容，当然，学习这些内容并不是让你掌握一些JavaScript小技巧，其主要目的是让你清楚JavaScript的执行机制：先编译，再执行。</li>
</ul>
<p>如果你了解了JavaScript执行流程，那么在编写代码时，你就能避开一些陷阱；在分析代码过程中，也能通过分析JavaScript的执行过程来定位问题</p>
<h2 id="思考时间" tabindex="-1"> 思考时间</h2>
<p>最后，看下面这段代码：</p>
<div><pre><code><span>showName</span><span>(</span><span>)</span>
<span>var</span> <span>showName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>
<span>}</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>你能按照JavaScript的执行流程，来分析最终输出结果吗？</p>
<p>分析</p>
<div><pre><code>输出1
</code></pre><div aria-hidden="true"><div></div></div></div><p>编译阶段:</p>
<div><pre><code>var showName
function showName(){console.log(1)}
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>执行阶段:</p>
<div><pre><code>showName()//输出1
showName=function(){console.log(2)}
//如果后面再有showName执行的话，就输出2因为这时候函数引用已经变了
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/fb/03/fbafaba4ad7092cbee011a8a02e38903.png" type="image/png"/>
    </item>
    <item>
      <title>调用栈：为什么JavaScript代码会出现栈溢出</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part2/lesson08.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part2/lesson08.html</guid>
      <source url="https://0808200.xyz/rss.xml">调用栈：为什么JavaScript代码会出现栈溢出</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="调用栈-为什么javascript代码会出现栈溢出" tabindex="-1"> 调用栈：为什么JavaScript代码会出现栈溢出</h1>
<p>在上篇文章中，我们讲到了，当一段代码被执行时，JavaScript引擎先会对其进行编译，并创建执行上下文。但是并没有明确说明到底什么样的代码才算符合规范</p>
<p>那么接下来我们就来明确下，哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况</p>
<ul>
<li>当JavaScript执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用eval函数的时候，eval的代码也会被编译，并创建执行上下文。</li>
</ul>
<p>好了，又进一步理解了执行上下文，那本节我们就在这基础之上继续深入，一起聊聊调用栈。学习调用栈至少有以下三点好处：</p>
<ul>
<li>可以帮助你了解JavaScript引擎背后的工作原理；</li>
<li>让你有调试JavaScript代码的能力；</li>
<li>帮助你搞定面试，因为面试过程中，调用栈也是出境率非常高的题目</li>
</ul>
<p>比如你在写JavaScript代码的时候，有时候可能会遇到栈溢出的错误，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/0c/70/0c9e2c4f7ee8ca59cfa99a6f51510470.png" alt=""></p>
<p>那为什么会出现这种错误呢？这就涉及到了调用栈的内容。你应该知道JavaScript中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此要讲清楚调用栈，你还要先弄明白函数调用和栈结构</p>
<h2 id="什么是函数调用" tabindex="-1"> 什么是函数调用</h2>
<p>函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面我们看个简单的示例代码</p>
<div><pre><code><span>var</span> a <span>=</span> <span>2</span>
<span>function</span> <span>add</span><span>(</span><span>)</span><span>{</span>
<span>var</span> b <span>=</span> <span>10</span>
<span>return</span>  a<span>+</span>b
<span>}</span>
<span>add</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段代码很简单，先是创建了一个add函数，接着在代码的最下面又调用了该函数。</p>
<p>那么下面我们就利用这段简单的代码来解释下函数调用的过程。</p>
<p>在执行到函数add()之前，JavaScript引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png" alt=""></p>
<p>从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。</p>
<p>执行上下文准备好之后，便开始执行全局代码，当执行到add这儿时，JavaScript判断这是一个函数调用，那么将执行以下操作：</p>
<ul>
<li>首先，从全局执行上下文中，取出add函数代码。</li>
<li>其次，对add函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li>
<li>最后，执行代码，输出结果。</li>
</ul>
<p>完整流程你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png" alt=""></p>
<p>就这样，当执行到add函数的时候，我们就有了两个执行上下文了——全局执行上下文和add函数的执行上下文。</p>
<p>也就是说在执行JavaScript时，可能会存在多个执行上下文，那么JavaScript引擎是如何管理这些执行上下文的呢？</p>
<p>答案是通过一种叫<strong>栈的数据结构来管理的</strong>。那什么是栈呢？它又是如何管理这些执行上下文呢？</p>
<h2 id="什么是栈" tabindex="-1"> 什么是栈</h2>
<p>关于栈，你可以结合这么一个贴切的例子来理解，一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个栈容器，车子开进单行线的操作叫做入栈，车子倒出去的操作叫做出栈。</p>
<p>在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。</p>
<p>所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足后进先出的特点。你可以参看下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/5e/05/5e2bb65019053abfd5e7710e41d1b405.png" alt=""></p>
<h2 id="什么是javascript的调用栈" tabindex="-1"> 什么是JavaScript的调用栈</h2>
<p>JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p>
<p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p>
<div><pre><code><span>var</span> a <span>=</span> <span>2</span>
<span>function</span> <span>add</span><span>(</span><span>b<span>,</span>c</span><span>)</span><span>{</span>
  <span>return</span> b<span>+</span>c
<span>}</span>
<span>function</span> <span>addAll</span><span>(</span><span>b<span>,</span>c</span><span>)</span><span>{</span>
<span>var</span> d <span>=</span> <span>10</span>
result <span>=</span> <span>add</span><span>(</span>b<span>,</span>c<span>)</span>
<span>return</span>  a<span>+</span>result<span>+</span>d
<span>}</span>
<span>addAll</span><span>(</span><span>3</span><span>,</span><span>6</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在上面这段代码中，你可以看到它是在addAll函数中调用了add函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？</p>
<p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p>
<p><strong>第一步，创建全局上下文，并将其压入栈底</strong>。如下图所示</p>
<p><img src="https://static001.geekbang.org/resource/image/a5/1d/a5d7ec1f8f296412acc045835b85431d.png" alt=""></p>
<p>从图中你也可以看出，变量a、函数add和addAll都保存到了全局上下文的变量环境对象中。</p>
<p>全局执行上下文压入到调用栈后，JavaScript引擎便开始执行全局代码了。首先会执行a=2的赋值操作，执行该语句会将全局上下文变量环境中a的值设置为2。设置后的全局上下文的状态如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/1d/1d/1d50269dbc5b4c69f83662ecdd977b1d.png" alt=""></p>
<p>接下来，<strong>第二步是调用addAll函数</strong>。当调用该函数时，JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/7d/52/7d6c4c45db4ef9b900678092e6c53652.png" alt=""></p>
<p>addAll函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是d=10的赋值操作，执行语句会将addAll函数执行上下文中的d由undefined变成了10。</p>
<p>然后接着往下执行，<strong>第三步，当执行到add函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈</strong>，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/cc/37/ccfe41d906040031a7df1e4f1bce5837.png" alt=""></p>
<p>当add函数返回时，该函数的执行上下文就会从栈顶弹出，并将result的值设置为add函数的返回值，也就是9。如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/03/96/03ca801a5372f941bf17d6088fee0f96.png" alt=""></p>
<p>紧接着addAll执行最后一个相加操作后并返回，addAll的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d0/7b/d0ac1d6e77735338fa97cc9a3f6c717b.png" alt=""></p>
<p>至此，整个JavaScript流程执行结束了。</p>
<p>好了，现在你应该知道了<strong>调用栈是JavaScript引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>
<h2 id="在开发中-如何利用好调用栈" tabindex="-1"> 在开发中，如何利用好调用栈</h2>
<p>鉴于调用栈的重要性和实用性，那么接下来我们就一起来看看在实际工作中，应该如何查看和利用好调用栈。</p>
<h3 id="_1-如何利用浏览器查看调用栈的信息" tabindex="-1"> 1. 如何利用浏览器查看调用栈的信息</h3>
<p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p>
<p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开“开发者工具”，点击“Source”标签，选择JavaScript代码的页面，然后在第3行加上断点，并刷新页面。你可以看到执行到add函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/c0/a2/c0d303a289a535b87a6c445ba7f34fa2.png" alt=""></p>
<p>从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：栈的最底部是anonymous，也就是全局的函数入口；中间是addAll函数；顶部是add函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查Bug时，调用栈都是非常有用的。</p>
<p>除了通过断点来查看调用栈，你还可以使用<code>console.trace()</code>来输出当前的函数调用关系，比如在示例代码中的add函数里面加上了<code>console.trace()</code>，你就可以看到控制台输出的结果，如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/ab/ce/abfba06cd23a7704a6eb148cff443ece.png" alt=""></p>
<h3 id="_2-栈溢出-stack-overflow" tabindex="-1"> 2. 栈溢出（Stack Overflow）</h3>
<p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，<strong>调用栈是有大小的</strong>，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做栈溢出。</p>
<p>特别是在你写递归代码的时候，就很容易出现<strong>栈溢出</strong>的情况。比如下面这段代码：</p>
<div><pre><code><span>function</span> <span>division</span><span>(</span><span>a<span>,</span>b</span><span>)</span><span>{</span>
    <span>return</span> <span>division</span><span>(</span>a<span>,</span>b<span>)</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>division</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>当执行时，就会抛出栈溢出错误，如下图：</p>
<p><a href="https://static001.geekbang.org/resource/image/b4/4d/b4f7196077d9ef4eac1ca6a279f2054d.png" target="_blank" rel="noopener noreferrer"></a></p>
<p>从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。</p>
<p>那为什么会出现这个问题呢？这是因为当JavaScript引擎开始执行这段代码时，它首先调用函数division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p>
<p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，今天的内容就讲到这里，下面来总结下今天的内容。</p>
<ul>
<li>每调用一个函数，JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码。</li>
<li>如果在一个函数A中调用了另外一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶。</li>
<li>当前函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈。</li>
<li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li>
<li>栈是一种非常重要的数据结构，不光应用在JavaScript语言中，其他的编程语言，如C/C++、Java、Python等语言，在执行过程中也都使用了栈来管理函数之间的调用关系。所以栈是非常基础且重要的知识点，你必须得掌握。</li>
</ul>
<h2 id="思考时间" tabindex="-1"> 思考时间</h2>
<p>最后，我给你留个思考题，你可以看下面这段代码：</p>
<div><pre><code>function runStack (n) {
  if (n === 0) return 100;
  return runStack( n- 2);
}
runStack(50000)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这是一段递归代码，可以通过传入参数n，让代码递归执行n次，也就意味着调用栈的深度能达到n，当输入一个较大的数时，比如50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？</p>
<div><pre><code><span>// 优化</span>
<span>function</span> <span>runStack</span><span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>100</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>n <span>===</span> <span>1</span><span>)</span> <span>{</span> <span>// 防止陷入死循环</span>
            <span>return</span> <span>200</span><span>;</span>
        <span>}</span>

        n <span>=</span> n <span>-</span> <span>2</span><span>;</span>
    <span>}</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>runStack</span><span>(</span><span>50000</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/0c/70/0c9e2c4f7ee8ca59cfa99a6f51510470.png" type="image/png"/>
    </item>
    <item>
      <title>块级作用域：var缺陷以及为什么要引入let和const</title>
      <link>https://0808200.xyz/bedstone/browser-working-principle/part2/lesson09.html</link>
      <guid>https://0808200.xyz/bedstone/browser-working-principle/part2/lesson09.html</guid>
      <source url="https://0808200.xyz/rss.xml">块级作用域：var缺陷以及为什么要引入let和const</source>
      <pubDate>Thu, 29 Dec 2022 09:56:01 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="块级作用域-var缺陷以及为什么要引入let和const" tabindex="-1"> 块级作用域：var缺陷以及为什么要引入let和const</h1>
<p>在前面《07 | 变量提升：JavaScript代码是按顺序执行的吗？》这篇文章中，我们已经讲解了JavaScript中变量提升的相关内容，正是由于JavaScript存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是JavaScript的一个重要设计缺陷</p>
<p>虽然ECMAScript6（以下简称ES6）已经通过引入块级作用域并配合let、const关键字，来避开了这种设计缺陷，但是由于JavaScript需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。这也加大了你理解概念的难度，因为既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在“一套”系统中的。</p>
<p>但如果抛开JavaScript的底层去理解这些，那么你大概率会很难深入理解其概念。俗话说，“断病要断因，治病要治根”，所以为了便于你更好地理解和学习，今天我们这篇文章会先“探病因”——分析为什么在JavaScript中会存在变量提升，以及变量提升所带来的问题；然后再来“开药方”——介绍如何通过块级作用域并配合let和const关键字来修复这种缺陷</p>
<h2 id="作用域-scope" tabindex="-1"> 作用域（scope）</h2>
<p>为什么<code>JavaScript</code>中会存在变量提升这个特性，而其他语言似乎都没有这个特性呢？要讲清楚这个问题，我们就得先从作用域讲起</p>
<p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</strong></p>
<p>在ES6之前，ES的作用域只有两种：全局作用域和函数作用域。</p>
<ul>
<li>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li>
</ul>
<p>在ES6之前，JavaScript只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</p>
<p>为了更好地理解块级作用域，你可以参考下面的一些示例代码：</p>
<div><pre><code><span>//if块</span>
<span>if</span><span>(</span><span>1</span><span>)</span><span>{</span><span>}</span>

<span>//while块</span>
<span>while</span><span>(</span><span>1</span><span>)</span><span>{</span><span>}</span>

<span>//函数块</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span><span>{</span>
 
<span>//for循环块</span>
<span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i<span>&lt;</span><span>100</span><span>;</span> i<span>++</span><span>)</span><span>{</span><span>}</span>

<span>//单独一个块</span>
<span>{</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。你可以看下面这段C代码：</p>
<div><pre><code><span>char</span><span>*</span> myname <span>=</span> <span>"极客时间"</span><span>;</span>
<span>void</span> <span>showName</span><span>(</span><span>)</span> <span>{</span>
  <span>printf</span><span>(</span><span>"%s \n"</span><span>,</span>myname<span>)</span><span>;</span>
  <span>if</span><span>(</span><span>0</span><span>)</span><span>{</span>
    <span>char</span><span>*</span> myname <span>=</span> <span>"极客邦"</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
   <span>showName</span><span>(</span><span>)</span><span>;</span>
   <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面这段C代码执行后，最终打印出来的是上面全局变量myname的值，之所以这样，是因为C语言是支持块级作用域的，所以if块里面定义的变量是不能被if块外面的语句访问到的。</p>
<p>和Java、C/C++不同，ES6之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到JavaScript会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是JavaScript中的变量提升。</p>
<h2 id="变量提升所带来的问题" tabindex="-1"> 变量提升所带来的问题</h2>
<p>由于变量提升作用，使用JavaScript来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。那为什么会出现这种情况呢？主要有以下两种原因。</p>
<h3 id="_1-变量容易在不被察觉的情况下被覆盖掉" tabindex="-1"> 1. 变量容易在不被察觉的情况下被覆盖掉</h3>
<p>比如我们重新使用JavaScript来实现上面那段C代码，实现后的JavaScript代码如下：</p>
<div><pre><code><span>var</span> myname <span>=</span> <span>"极客时间"</span>
<span>function</span> <span>showName</span><span>(</span><span>)</span><span>{</span>
  console<span>.</span><span>log</span><span>(</span>myname<span>)</span><span>;</span>
  <span>if</span><span>(</span><span>0</span><span>)</span><span>{</span>
   <span>var</span> myname <span>=</span> <span>"极客邦"</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>myname<span>)</span><span>;</span>
<span>}</span>
<span>showName</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面这段代码，打印出来的是undefined，而并没有像前面C代码那样打印出来“极客时间”的字符串。为什么输出的内容是undefined呢？我们再来分析一下。</p>
<p>首先当刚执行到showName函数调用时，执行上下文和调用栈的状态是怎样的？具体分析过程你可以回顾《08 | 调用栈：为什么JavaScript代码会出现栈溢出？》这篇文章的分析过程，这里我就直接展示出来了，最终的调用栈状态如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/94/c9/944aaeaeb9ee50feea3c7d218acdd5c9.png" alt=""></p>
<p>showName函数的执行上下文创建后，JavaScript引擎便开始执行showName函数内部的代码了。首先执行的是：</p>
<div><pre><code>console.log(myname);
</code></pre><div aria-hidden="true"><div></div></div></div><p>执行这段代码需要使用变量myname，结合上面的调用栈状态图，你可以看到这里有两个myname变量：一个在全局执行上下文中，其值是“极客时间”；另外一个在showName函数的执行上下文中，其值是undefined。那么到底该使用哪个呢？</p>
<p>相信做过JavaScript开发的同学都能轻松回答出来答案：“当然是先使用函数执行上下文里面的变量啦！”的确是这样，这是因为在函数执行过程中，JavaScript会优先从当前的执行上下文中查找变量，由于变量提升，当前的执行上下文中就包含了变量myname，而值是undefined，所以获取到的myname的值就是undefined。</p>
<p>这输出的结果和其他大部分支持块级作用域的语言都不一样，比如上面C语言输出的就是全局变量，所以这会很容易造成误解，特别是在你会一些其他语言的基础之上，再来学习JavaScript，你会觉得这种结果很不自然。</p>
<h3 id="_2-本应销毁的变量没有被销毁" tabindex="-1"> 2. 本应销毁的变量没有被销毁</h3>
<p>接下来我们再来看下面这段让人误解更大的代码：</p>
<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span><span>{</span>
  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>7</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>i<span>)</span><span>;</span> 
<span>}</span>
<span>foo</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果你使用C语言或者其他的大部分语言实现类似代码，在for循环结束之后，i就已经被销毁了，但是在JavaScript代码中，i的值并未被销毁，所以最后打印出来的是7。</p>
<p>这同样也是由变量提升而导致的，在创建执行上下文阶段，变量i就已经被提升了，所以当for循环结束之后，变量i并没有被销毁。</p>
<p>这依旧和其他支持块级作用域的语言表现是不一致的，所以必然会给一些人造成误解。</p>
<h2 id="es6是如何解决变量提升带来的缺陷" tabindex="-1"> ES6是如何解决变量提升带来的缺陷</h2>
<p>上面我们介绍了变量提升而带来的一系列问题，为了解决这些问题，ES6引入了let和const关键字，从而使JavaScript也能像其他语言一样拥有了块级作用域。</p>
<p>关于let和const的用法，你可以参考下面代码：</p>
<div><pre><code><span>let</span> x <span>=</span> <span>5</span>
<span>const</span> y <span>=</span> <span>6</span>
x <span>=</span> <span>7</span>
y <span>=</span> <span>9</span> <span>//报错，const声明的变量不可以修改</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>从这段代码你可以看出来，两者之间的区别是，使用let关键字声明的变量是可以被改变的，而使用const声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级作用域，为了简单起见，在下面的代码中，我统一使用let关键字来演示。</p>
<p>那么接下来，我们就通过实际的例子来分析下，ES6是如何通过块级作用域来解决上面的问题的？</p>
<p>你可以先参考下面这段存在变量提升的代码：</p>
<div><pre><code><span>function</span> <span>varTest</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> x <span>=</span> <span>1</span><span>;</span>
  <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>var</span> x <span>=</span> <span>2</span><span>;</span>  <span>// 同样的变量!</span>
    console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>  <span>// 2</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>  <span>// 2</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在这段代码中，有两个地方都定义了变量x，第一个地方在函数块的顶部，第二个地方在if块的内部，由于var的作用范围是整个函数，所以在编译阶段，会生成如下的执行上下文：</p>
<p><img src="https://static001.geekbang.org/resource/image/45/bf/4501368679083f3a8e1a9e4a8e316dbf.png" alt=""></p>
<p>从执行上下文的变量环境中可以看出，最终只生成了一个变量x，函数体内所有对x的赋值操作都会直接改变变量环境中的x值。</p>
<p>所以上述代码最后通过console.log(x)输出的是2，而对于相同逻辑的代码，其他语言最后一步输出的值应该是1，因为在if块里面的声明不应该影响到块外面的变量。</p>
<p>既然支持块级作用域和不支持块级作用域的代码执行逻辑是不一样的，那么接下来我们就来改造上面的代码，让其支持块级作用域。</p>
<p>这个改造过程其实很简单，只需要把var关键字替换为let关键字，改造后的代码如下</p>
<div><pre><code><span>function</span> <span>letTest</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> x <span>=</span> <span>1</span><span>;</span>
  <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>let</span> x <span>=</span> <span>2</span><span>;</span>  <span>// 不同的变量</span>
    console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>  <span>// 2</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>  <span>// 1</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行这段代码，其输出结果就和我们的预期是一致的。这是因为let关键字是支持块级作用域的，所以在编译阶段，JavaScript引擎并不会把if块中通过let声明的变量存放到变量环境中，这也就意味着在if块通过let声明的关键字，并不会提升到全函数可见。所以在if块之内打印出来的值是2，跳出语块之后，打印出来的值就是1了。这种就非常符合我们的编程习惯了：<strong>作用块内声明的变量不影响块外面的变量</strong>。</p>
<h2 id="javascript是如何支持块级作用域的" tabindex="-1"> JavaScript是如何支持块级作用域的</h2>
<p>现在你知道了ES可以通过使用let或者const关键字来实现块级作用域，不过你是否有过这样的疑问：“在同一段代码中，ES6是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”</p>
<p>那么接下来，我们就要<strong>站在执行上下文的角度来揭开答案</strong>。</p>
<p>你已经知道JavaScript引擎是通过变量环境实现函数级作用域的，那么ES6又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码</p>
<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span><span>{</span>
    <span>var</span> a <span>=</span> <span>1</span>
    <span>let</span> b <span>=</span> <span>2</span>
    <span>{</span>
      <span>let</span> b <span>=</span> <span>3</span>
      <span>var</span> c <span>=</span> <span>4</span>
      <span>let</span> d <span>=</span> <span>5</span>
      console<span>.</span><span>log</span><span>(</span>a<span>)</span>
      console<span>.</span><span>log</span><span>(</span>b<span>)</span>
    <span>}</span>
    console<span>.</span><span>log</span><span>(</span>b<span>)</span> 
    console<span>.</span><span>log</span><span>(</span>c<span>)</span>
    console<span>.</span><span>log</span><span>(</span>d<span>)</span>
<span>}</span>   
<span>foo</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当执行上面这段代码的时候，JavaScript引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了let关键字，let关键字会创建块级作用域，那么let关键字是如何影响执行上下文的呢？</p>
<p>接下来我们就来一步步分析上面这段代码的执行流程。</p>
<p><strong>第一步是编译并创建执行上下文</strong>，下面是我画出来的执行上下文示意图，你可以参考下</p>
<p><img src="https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png" alt=""></p>
<p>通过上图，我们可以得出以下结论：</p>
<ul>
<li>函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面了。</li>
<li>通过let声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li>
<li>在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中。</li>
<li>接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中a的值已经被设置成了1，词法环境中b的值已经被设置成了2，</li>
</ul>
<p>这时候函数的执行上下文就如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt=""></p>
<p>从图中可以看出，当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，当执行到作用域内部时，它们都是独立的存在。</p>
<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。</p>
<p>再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给JavaScript引擎，如果没有查找到，那么继续在变量环境中查找。</p>
<p>这样一个变量查找过程就完成了，你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt=""></p>
<p>从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了，这个我们会在下篇文章中做详细介绍。</p>
<p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png" alt=""></p>
<p>通过上面的分析，想必你已经理解了词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript引擎也就同时支持了变量提升和块级作用域了。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>好了，今天的内容就讲到这里，下面我来简单总结下今天的内容。</p>
<p>由于JavaScript的变量提升存在着变量覆盖、变量污染等设计缺陷，所以ES6引入了块级作用域关键字来解决这些问题。</p>
<p>之后我们还通过对变量环境和词法环境的介绍，分析了JavaScript引擎是如何同时支持变量提升和块级作用域的。</p>
<p>既然聊到了作用域，那最后我们再简单聊下编程语言吧。经常有人争论什么编程语言是世界上最好的语言，但如果站在语言本身来说，我觉得这种争论没有意义，因为语言是工具，而工具是用来创造价值的，至于能否创造价值或创造多大价值不完全由语言本身的特性决定。这么说吧，即便一门设计不那么好的语言，它也可能拥有非常好的生态，比如有完善的框架、非常多的落地应用，又或者能够给开发者带来更多的回报，这些都是评判因素。</p>
<p>如果站在语言层面来谈，每种语言其实都是在相互借鉴对方的优势，协同进化，比如JavaScript引进了作用域、迭代器和协程，其底层虚拟机的实现和Java、Python又是非常相似，也就是说如果你理解了JavaScript协程和JavaScript中的虚拟机，其实你也就理解了Java、Python中的协程和虚拟机的实现机制。</p>
<p>所以说，语言本身好坏不重要，重要的是能为开发者创造价值。</p>
<h2 id="思考时间" tabindex="-1"> 思考时间</h2>
<p>下面给你留个思考题，看下面这样一段代码：</p>
<div><pre><code><span>let</span> myname<span>=</span> <span>'极客时间'</span>
<span>{</span>
  console<span>.</span><span>log</span><span>(</span>myname<span>)</span> 
  <span>let</span> myname<span>=</span> <span>'极客邦'</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>你能通过分析词法环境，得出来最终的打印结果吗？</p>
<p>分析</p>
<ol>
<li>
<p>在块级作用域中，从<code>开始到let myname= '极客邦' </code>代码之间会形成一个暂时性死区，如果中间去访问变量<code>myname</code>，会报初始化之前不能访问<code>myname</code>的错误。<code>Uncaught ReferenceError</code></p>
</li>
<li>
<p>另外上面的一个foo函数也会报d没有定义，d在块级作用域中声明，在外面是访问不到的</p>
</li>
</ol>
<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span><span>{</span>
<span>var</span> a <span>=</span> <span>1</span>
<span>let</span> b <span>=</span> <span>2</span>
<span>{</span>
<span>let</span> b <span>=</span> <span>3</span>
<span>var</span> c <span>=</span> <span>4</span>
<span>let</span> d <span>=</span> <span>5</span>
console<span>.</span><span>log</span><span>(</span>a<span>)</span>
console<span>.</span><span>log</span><span>(</span>b<span>)</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>b<span>)</span>
console<span>.</span><span>log</span><span>(</span>c<span>)</span>
console<span>.</span><span>log</span><span>(</span>d<span>)</span>
<span>}</span>
<span>foo</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://static001.geekbang.org/resource/image/94/c9/944aaeaeb9ee50feea3c7d218acdd5c9.png" type="image/png"/>
    </item>
  </channel>
</rss>