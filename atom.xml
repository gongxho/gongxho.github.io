<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://0808200.xyz/</id>
  <title>𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ</title>
  <subtitle>𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ personal blog.</subtitle>
  <updated>2022-08-29T09:20:11.245Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://0808200.xyz/atom.xml"/>
  <link rel="alternate" href="https://0808200.xyz/"/>
  <category term="随笔"/>
  <contributor>
    <name>BetaSu</name>
  </contributor>
  <contributor>
    <name>ustbhuangyi</name>
  </contributor>
  <entry>
    <title type="html">React 源码解析</title>
    <id>https://0808200.xyz/react/</id>
    <link href="https://0808200.xyz/react/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>本书的宗旨是打造一本严谨、易懂的<code>React</code>源码分析教程。</p>
<p>为了达到这个目标，在行文上，本书会遵循：</p>
<ol>
<li>
<p>不预设观点 —— 所有观点来自<code>React</code>核心团队成员在公开场合的分享。</p>
</li>
<li>
<p>丰富的参考资料 —— 包括在线Demo、文章、视频。</p>
</li>
<li>
<p>保持更新 —— 在<code>React</code>版本更新后会及时补充。当前版本<code>v17.0.0-alpha</code>。</p>
</li>
</ol>
<h2 id="导学视频" tabindex="-1"> 导学视频</h2>
<p>每位同学的基础、学习目的、可支配的学习时间都不同，对于“学习源码”这种需要长期投入的事情，需要慎重考虑投入产出比。</p>
<p>为此，我在B站录了一期<a href="https://www.bilibili.com/video/BV1Ki4y1u7Vr" target="_blank" rel="noopener noreferrer">导学视频</a>。</p>
<p>在视频的前半部分，我将“学习源码”划分为5个层次，阐述了：</p>
<ul>
<li>
<p>达到每个层次需要掌握哪些知识</p>
</li>
<li>
<p>怎样最快的掌握这些知识</p>
</li>
<li>
<p>达到这一层次后会收获什么</p>
</li>
</ul>
<p>在学习本书前，你可以结合自身情况做出取舍，有的放矢。</p>
<p>在视频的后半部分，我会以一个<code>Demo</code>演示<code>React</code>源码的运行流程，为你学习本书内容打下基础。</p>
<div><p>视频课程</p>
<p>文字包含的信息量有限，追求效率的同学可以考虑<a href="https://ke.segmentfault.com/course/1650000023864436" target="_blank" rel="noopener noreferrer">视频课程</a>，由我带着你一起debug源码。</p>
</div>
<h2 id="章节说明" tabindex="-1"> 章节说明</h2>
<p>我们并没有从如<code>ReactDOM.render</code>、<code>this.setState</code>或<code>Hooks</code>等这些日常开发耳熟能详的<code>API</code>入手，而是从<strong>理念</strong>这样比较高的抽象层次开始学习，这是有意为之的。</p>
<p>从理念到架构，从架构到实现，从实现到具体代码。</p>
<p>这是一个自顶向下、抽象程度递减，符合认知的过程。如果直接讲解API，那么很容易陷入源码的汪洋大海。</p>
<p>基于此，本书划分为<code>理念篇</code>、<code>架构篇</code>、<code>实现篇</code>。</p>
<h2 id="章节列表" tabindex="-1"> 章节列表</h2>
<h3 id="理念篇" tabindex="-1"> 理念篇</h3>
<h4 id="第一章-react理念" tabindex="-1"> 第一章 React理念</h4>
<p>✅ React理念</p>
<p>✅ 老的React架构</p>
<p>✅ 新的React架构</p>
<p>✅ Fiber架构的心智模型</p>
<p>✅ Fiber架构的实现原理</p>
<p>✅ Fiber架构的工作原理</p>
<p>✅ 总结</p>
<h4 id="第二章-前置知识" tabindex="-1"> 第二章 前置知识</h4>
<p>✅ 源码的文件结构</p>
<p>✅ 调试源码</p>
<p>✅ 深入理解JSX</p>
<h3 id="架构篇" tabindex="-1"> 架构篇</h3>
<h4 id="第三章-render阶段" tabindex="-1"> 第三章 render阶段</h4>
<p>✅ 流程概览</p>
<p>✅ beginWork</p>
<p>✅ completeWork</p>
<h4 id="第四章-commit阶段" tabindex="-1"> 第四章 commit阶段</h4>
<p>✅ 流程概览</p>
<p>✅ before mutation阶段</p>
<p>✅ mutation阶段</p>
<p>✅ layout阶段</p>
<h3 id="实现篇" tabindex="-1"> 实现篇</h3>
<h4 id="第五章-diff算法" tabindex="-1"> 第五章 Diff算法</h4>
<p>✅ 概览</p>
<p>✅ 单节点Diff</p>
<p>✅ 多节点Diff</p>
<h4 id="第六章-状态更新" tabindex="-1"> 第六章 状态更新</h4>
<p>✅ 流程概览</p>
<p>✅ 心智模型</p>
<p>✅ Update</p>
<p>✅ 深入理解优先级</p>
<p>✅ ReactDOM.render</p>
<p>✅ this.setState</p>
<h4 id="第七章-hooks" tabindex="-1"> 第七章 Hooks</h4>
<p>✅ Hooks理念</p>
<p>✅ 极简Hooks实现</p>
<p>✅ Hooks数据结构</p>
<p>✅ useState与useReducer</p>
<p>✅ useEffect</p>
<p>✅ useRef</p>
<p>✅ useMemo与useCallback</p>
<h4 id="第八章-concurrent-mode" tabindex="-1"> 第八章 Concurrent Mode</h4>
<p>✅ 概览</p>
<p>✅ Scheduler的原理与实现</p>
<p>✅ lane模型</p>
<p>📝 异步可中断更新</p>
<p>📝 高优任务打断机制</p>
<p>📝 batchedUpdates</p>
<p>📝 Suspense</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">vue2 源码解析</title>
    <id>https://0808200.xyz/vue2/</id>
    <link href="https://0808200.xyz/vue2/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言" tabindex="-1"> 前言</h2>
<p>目前社区有很多 Vue.js 的源码解析文章，但是质量层次不齐，不够系统和全面，这本电子书的目标是全方位细致深度解析 Vue.js 的实现原理，让同学们可以彻底掌握 Vue.js。目前分析的版本是 Vue.js 的最新版本 Vue.js 2.5.17-beta.0，并且之后会随着版本升级而做相应的更新，充分发挥电子书的优势。</p>
<p>这本电子书是作为 <a href="http://coding.imooc.com/class/228.html" target="_blank" rel="noopener noreferrer">《Vue.js 源码揭秘》</a>视频课程的辅助教材。电子书是开源的，同学们可以免费阅读，视频是收费的，25+小时纯干货课程，如果有需要的同学可以购买来学习，<strong>但请务必支持正版，请尊重作者的劳动成果</strong>。</p>
<h2 id="章节目录" tabindex="-1"> 章节目录</h2>
<p>为了把 Vue.js 的源码讲明白，课程设计成由浅入深，分为核心、编译、扩展、生态四个方面去讲，并拆成了八个章节，如下图：</p>
<img :src="$withBase('/assets/mind.png')">
<p><strong>第一章：准备工作</strong></p>
<p>介绍了 Flow、Vue.js 的源码目录设计、Vue.js 的源码构建方式，以及从入口开始分析了 Vue.js 的初始化过程。</p>
<p><strong>第二章：数据驱动</strong></p>
<p>详细讲解了模板数据到 DOM 渲染的过程，从 <code>new Vue</code> 开始，分析了 <code>mount</code>、<code>render</code>、<code>update</code>、<code>patch</code> 等流程。</p>
<p><strong>第三章：组件化</strong></p>
<p>分析了组件化的实现原理，并且分析了组件周边的原理实现，包括合并配置、生命周期、组件注册、异步组件。</p>
<p><strong>第四章：深入响应式原理</strong></p>
<p>详细讲解了数据的变化如何驱动视图的变化，分析了响应式对象的创建，依赖收集、派发更新的实现过程，一些特殊情况的处理，并对比了计算属性和侦听属性的实现，最后分析了组件更新的过程。</p>
<p><strong>第五章：编译</strong></p>
<p>从编译的入口函数开始，分析了编译的三个核心流程的实现：<code>parse</code> -&gt; <code>optimize</code> -&gt; <code>codegen</code>。</p>
<p><strong>第六章：扩展</strong></p>
<p>详细讲解了 <code>event</code>、<code>v-model</code>、<code>slot</code>、<code>keep-alive</code>、<code>transition</code>、<code>transition-group</code> 等常用功能的原理实现，该章节作为一个可扩展章节，未来会分析更多 Vue 提供的特性。</p>
<p><strong>第七章：Vue-Router</strong></p>
<p>分析了 Vue-Router 的实现原理，从路由注册开始，分析了路由对象、<code>matcher</code>，并深入分析了整个路径切换的实现过程和细节。</p>
<p><strong>第八章：Vuex</strong></p>
<p>分析了 Vuex 的实现原理，深入分析了它的初始化过程，常用 API 以及插件部分的实现。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue3 源码解析</title>
    <id>https://0808200.xyz/vue3/</id>
    <link href="https://0808200.xyz/vue3/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">异步可中断的更新</title>
    <id>https://0808200.xyz/react/concurrent/disrupt.html</id>
    <link href="https://0808200.xyz/react/concurrent/disrupt.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>施工中...</p>
<p>后续三节内容<a href="https://ke.segmentfault.com/course/1650000023864436" target="_blank" rel="noopener noreferrer">视频课程</a>已更新。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">lane模型</title>
    <id>https://0808200.xyz/react/concurrent/lane.html</id>
    <link href="https://0808200.xyz/react/concurrent/lane.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>上一节我们提到<code>Scheduler</code>与<code>React</code>是两套<code>优先级</code>机制。在<code>React</code>中，存在多种使用不同<code>优先级</code>的情况，比如：</p>
<p>注：以下例子皆为<code>Concurrent Mode</code>开启情况</p>
<ul>
<li>
<p>过期任务或者同步任务使用<code>同步</code>优先级</p>
</li>
<li>
<p>用户交互产生的更新（比如点击事件）使用高优先级</p>
</li>
<li>
<p>网络请求产生的更新使用一般优先级</p>
</li>
<li>
<p><code>Suspense</code>使用低优先级</p>
</li>
</ul>
<p><code>React</code>需要设计一套满足如下需要的<code>优先级</code>机制：</p>
<ul>
<li>
<p>可以表示<code>优先级</code>的不同</p>
</li>
<li>
<p>可能同时存在几个同<code>优先级</code>的<code>更新</code>，所以还得能表示<code>批</code>的概念</p>
</li>
<li>
<p>方便进行<code>优先级</code>相关计算</p>
</li>
</ul>
<p>为了满足如上需求，<code>React</code>设计了<code>lane</code>模型。接下来我们来看<code>lane</code>模型如何满足以上3个条件。</p>
<h2 id="表示优先级的不同" tabindex="-1"> 表示优先级的不同</h2>
<p>想象你身处赛车场。</p>
<img :src="$withBase('/img/lane.jpeg')" alt="30sec">
<p>不同的赛车疾驰在不同的赛道。内圈的赛道总长度更短，外圈更长。某几个临近的赛道的长度可以看作差不多长。</p>
<p><code>lane</code>模型借鉴了同样的概念，使用31位的二进制表示31条赛道，位数越小的赛道<code>优先级</code>越高，某些相邻的赛道拥有相同<code>优先级</code>。</p>
<p>如下：</p>
<div><pre><code><span>export</span> <span>const</span> <span>NoLanes</span><span>:</span> Lanes <span>=</span> <span>/*                        */</span> <span>0b0000000000000000000000000000000</span><span>;</span>
<span>export</span> <span>const</span> <span>NoLane</span><span>:</span> Lane <span>=</span> <span>/*                          */</span> <span>0b0000000000000000000000000000000</span><span>;</span>

<span>export</span> <span>const</span> <span>SyncLane</span><span>:</span> Lane <span>=</span> <span>/*                        */</span> <span>0b0000000000000000000000000000001</span><span>;</span>
<span>export</span> <span>const</span> <span>SyncBatchedLane</span><span>:</span> Lane <span>=</span> <span>/*                 */</span> <span>0b0000000000000000000000000000010</span><span>;</span>

<span>export</span> <span>const</span> <span>InputDiscreteHydrationLane</span><span>:</span> Lane <span>=</span> <span>/*      */</span> <span>0b0000000000000000000000000000100</span><span>;</span>
<span>const</span> <span>InputDiscreteLanes</span><span>:</span> Lanes <span>=</span> <span>/*                    */</span> <span>0b0000000000000000000000000011000</span><span>;</span>

<span>const</span> <span>InputContinuousHydrationLane</span><span>:</span> Lane <span>=</span> <span>/*           */</span> <span>0b0000000000000000000000000100000</span><span>;</span>
<span>const</span> <span>InputContinuousLanes</span><span>:</span> Lanes <span>=</span> <span>/*                  */</span> <span>0b0000000000000000000000011000000</span><span>;</span>

<span>export</span> <span>const</span> <span>DefaultHydrationLane</span><span>:</span> Lane <span>=</span> <span>/*            */</span> <span>0b0000000000000000000000100000000</span><span>;</span>
<span>export</span> <span>const</span> <span>DefaultLanes</span><span>:</span> Lanes <span>=</span> <span>/*                   */</span> <span>0b0000000000000000000111000000000</span><span>;</span>

<span>const</span> <span>TransitionHydrationLane</span><span>:</span> Lane <span>=</span> <span>/*                */</span> <span>0b0000000000000000001000000000000</span><span>;</span>
<span>const</span> <span>TransitionLanes</span><span>:</span> Lanes <span>=</span> <span>/*                       */</span> <span>0b0000000001111111110000000000000</span><span>;</span>

<span>const</span> <span>RetryLanes</span><span>:</span> Lanes <span>=</span> <span>/*                            */</span> <span>0b0000011110000000000000000000000</span><span>;</span>

<span>export</span> <span>const</span> <span>SomeRetryLane</span><span>:</span> Lanes <span>=</span> <span>/*                  */</span> <span>0b0000010000000000000000000000000</span><span>;</span>

<span>export</span> <span>const</span> <span>SelectiveHydrationLane</span><span>:</span> Lane <span>=</span> <span>/*          */</span> <span>0b0000100000000000000000000000000</span><span>;</span>

<span>const</span> NonIdleLanes <span>=</span> <span>/*                                 */</span> <span>0b0000111111111111111111111111111</span><span>;</span>

<span>export</span> <span>const</span> <span>IdleHydrationLane</span><span>:</span> Lane <span>=</span> <span>/*               */</span> <span>0b0001000000000000000000000000000</span><span>;</span>
<span>const</span> <span>IdleLanes</span><span>:</span> Lanes <span>=</span> <span>/*                             */</span> <span>0b0110000000000000000000000000000</span><span>;</span>

<span>export</span> <span>const</span> <span>OffscreenLane</span><span>:</span> Lane <span>=</span> <span>/*                   */</span> <span>0b1000000000000000000000000000000</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberLane.js#L77-L107" target="_blank" rel="noopener noreferrer">这里</a>看到<code>lane</code>的定义</p>
</blockquote>
<p>其中，同步优先级占用的赛道为第一位：</p>
<div><pre><code><span>export</span> <span>const</span> <span>SyncLane</span><span>:</span> Lane <span>=</span> <span>/*                        */</span> <span>0b0000000000000000000000000000001</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>从<code>SyncLane</code>往下一直到<code>SelectiveHydrationLane</code>，赛道的<code>优先级</code>逐步降低。</p>
<h2 id="表示-批-的概念" tabindex="-1"> 表示“批”的概念</h2>
<p>可以看到其中有几个变量占用了几条赛道，比如：</p>
<div><pre><code><span>const</span> <span>InputDiscreteLanes</span><span>:</span> Lanes <span>=</span> <span>/*                    */</span> <span>0b0000000000000000000000000011000</span><span>;</span>
<span>export</span> <span>const</span> <span>DefaultLanes</span><span>:</span> Lanes <span>=</span> <span>/*                   */</span> <span>0b0000000000000000000111000000000</span><span>;</span>
<span>const</span> <span>TransitionLanes</span><span>:</span> Lanes <span>=</span> <span>/*                       */</span> <span>0b0000000001111111110000000000000</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这就是<code>批</code>的概念，被称作<code>lanes</code>（区别于<code>优先级</code>的<code>lane</code>）。</p>
<p>其中<code>InputDiscreteLanes</code>是“用户交互”触发更新会拥有的<code>优先级</code>范围。</p>
<p><code>DefaultLanes</code>是“请求数据返回后触发更新”拥有的<code>优先级</code>范围。</p>
<p><code>TransitionLanes</code>是<code>Suspense</code>、<code>useTransition</code>、<code>useDeferredValue</code>拥有的<code>优先级</code>范围。</p>
<p>这其中有个细节，越低<code>优先级</code>的<code>lanes</code>占用的位越多。比如<code>InputDiscreteLanes</code>占了2个位，<code>TransitionLanes</code>占了9个位。</p>
<p>原因在于：越低<code>优先级</code>的<code>更新</code>越容易被打断，导致积压下来，所以需要更多的位。相反，最高优的同步更新的<code>SyncLane</code>不需要多余的<code>lanes</code>。</p>
<h2 id="方便进行优先级相关计算" tabindex="-1"> 方便进行优先级相关计算</h2>
<p>既然<code>lane</code>对应了二进制的位，那么<code>优先级</code>相关计算其实就是位运算。</p>
<p>比如：</p>
<p>计算<code>a</code>、<code>b</code>两个<code>lane</code>是否存在交集，只需要判断<code>a</code>与<code>b</code>按位与的结果是否为<code>0</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>includesSomeLane</span><span>(</span><span><span>a</span><span>:</span> Lanes <span>|</span> Lane<span>,</span> <span>b</span><span>:</span> Lanes <span>|</span> Lane</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>a <span>&amp;</span> b<span>)</span> <span>!==</span> NoLanes<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>计算<code>b</code>这个<code>lanes</code>是否是<code>a</code>对应的<code>lanes</code>的子集，只需要判断<code>a</code>与<code>b</code>按位与的结果是否为<code>b</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>isSubsetOfLanes</span><span>(</span><span><span>set</span><span>:</span> Lanes<span>,</span> <span>subset</span><span>:</span> Lanes <span>|</span> Lane</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>set <span>&amp;</span> subset<span>)</span> <span>===</span> subset<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>将两个<code>lane</code>或<code>lanes</code>的位合并只需要执行按位或操作：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mergeLanes</span><span>(</span><span><span>a</span><span>:</span> Lanes <span>|</span> Lane<span>,</span> <span>b</span><span>:</span> Lanes <span>|</span> Lane</span><span>)</span><span>:</span> Lanes <span>{</span>
  <span>return</span> a <span>|</span> b<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>从<code>set</code>对应<code>lanes</code>中移除<code>subset</code>对应<code>lane</code>（或<code>lanes</code>），只需要对<code>subset</code>的<code>lane</code>（或<code>lanes</code>）执行按位非，结果再对<code>set</code>执行按位与。</p>
<div><pre><code><span>export</span> <span>function</span> <span>removeLanes</span><span>(</span><span><span>set</span><span>:</span> Lanes<span>,</span> <span>subset</span><span>:</span> Lanes <span>|</span> Lane</span><span>)</span><span>:</span> Lanes <span>{</span>
  <span>return</span> set <span>&amp;</span> <span>~</span>subset<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>更多位运算参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener noreferrer">MDN</a></p>
</blockquote>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>这就是<code>React</code>的优先级模型<code>lane</code>模型。</p>
<p>至此，我们已经了解<code>Fiber</code>架构、<code>更新</code>的<code>优先级</code>、<code>Scheduler</code>的实现、<code>lane</code>模型。从下一节开始，我们会逐步讲解<code>Concurrent Mode</code>的各种应用。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">概览</title>
    <id>https://0808200.xyz/react/concurrent/prepare.html</id>
    <link href="https://0808200.xyz/react/concurrent/prepare.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/react/state/reactdom.html#react%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0">ReactDOM.render</a>一节我们介绍了<code>React</code>当前的三种入口函数。日常开发主要使用的是<code>Legacy Mode</code>（通过<code>ReactDOM.render</code>创建）。</p>
<p>从<a href="https://mp.weixin.qq.com/s/zrrqldzRbcPApga_Cp2b8A" target="_blank" rel="noopener noreferrer">React v17.0 正式发布！</a>一文可以看到，<code>v17.0</code>没有包含新特性。究其原因，<code>v17.0</code>主要的工作在于源码内部对<code>Concurrent Mode</code>的支持。所以<code>v17</code>版本也被称为“垫脚石”版本。</p>
<p>你可以从官网<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener noreferrer">Concurrent 模式介绍</a>了解其基本概念。</p>
<p>一句话概括：</p>
<blockquote>
<p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p>
</blockquote>
<p><code>Concurrent Mode</code>是<code>React</code>过去2年重构<code>Fiber架构</code>的源动力，也是<code>React</code>未来的发展方向。</p>
<p>可以预见，当<code>v17</code>完美支持<code>Concurrent Mode</code>后，<code>v18</code>会迎来一大波基于<code>Concurrent Mode</code>的库。</p>
<p>底层基础决定了上层<code>API</code>的实现，接下来让我们了解下，<code>Concurrent Mode</code>自底向上都包含哪些组成部分，能够发挥哪些能力？</p>
<h2 id="底层架构-——-fiber架构" tabindex="-1"> 底层架构 —— Fiber架构</h2>
<p>从<a href="/react/preparation/idea.html">设计理念</a>我们了解到要实现<code>Concurrent Mode</code>，最关键的一点是：实现异步可中断的更新。</p>
<p>基于这个前提，<code>React</code>花费2年时间重构完成了<code>Fiber</code>架构。</p>
<p><code>Fiber</code>架构的意义在于，他将单个<code>组件</code>作为<code>工作单元</code>，使以<code>组件</code>为粒度的“异步可中断的更新”成为可能。</p>
<h2 id="架构的驱动力-——-scheduler" tabindex="-1"> 架构的驱动力 —— Scheduler</h2>
<p>如果我们同步运行<code>Fiber</code>架构（通过<code>ReactDOM.render</code>），则<code>Fiber</code>架构与重构前并无区别。</p>
<p>但是当我们配合<code>时间切片</code>，就能根据宿主环境性能，为每个<code>工作单元</code>分配一个<code>可运行时间</code>，实现“异步可中断的更新”。</p>
<p>于是，<a href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank" rel="noopener noreferrer">scheduler</a>（调度器）产生了。</p>
<h2 id="架构运行策略-——-lane模型" tabindex="-1"> 架构运行策略 —— lane模型</h2>
<p>到目前为止，<code>React</code>可以控制<code>更新</code>在<code>Fiber</code>架构中运行/中断/继续运行。</p>
<p>基于当前的架构，当一次<code>更新</code>在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”。</p>
<p>当一次<code>更新</code>在运行过程中被中断，转而重新开始一次新的<code>更新</code>，我们可以说：后一次<code>更新</code>打断了前一次<code>更新</code>。</p>
<p>这就是<code>优先级</code>的概念：后一次<code>更新</code>的<code>优先级</code>更高，他打断了正在进行的前一次<code>更新</code>。</p>
<p>多个<code>优先级</code>之间如何互相打断？<code>优先级</code>能否升降？本次<code>更新</code>应该赋予什么<code>优先级</code>？</p>
<p>这就需要一个模型控制不同<code>优先级</code>之间的关系与行为，于是<code>lane</code>模型诞生了。</p>
<h2 id="上层实现" tabindex="-1"> 上层实现</h2>
<p>现在，我们可以说：</p>
<blockquote>
<p>从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”。</p>
</blockquote>
<p>那么基于该架构之上可以实现哪些有意思的功能？我们举几个例子：</p>
<h3 id="batchedupdates" tabindex="-1"> batchedUpdates</h3>
<p>如果我们在一次事件回调中触发多次<code>更新</code>，他们会被合并为一次<code>更新</code>进行处理。</p>
<p>如下代码执行只会触发一次<code>更新</code>：</p>
<div><pre><code><span>onClick</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span><span>stateA</span><span>:</span> <span>1</span><span>}</span><span>)</span><span>;</span>
  <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span><span>stateB</span><span>:</span> <span>false</span><span>}</span><span>)</span><span>;</span>
  <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span><span>stateA</span><span>:</span> <span>2</span><span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这种合并多个<code>更新</code>的优化方式被称为<code>batchedUpdates</code>。</p>
<p><code>batchedUpdates</code>在很早的版本就存在了，不过之前的实现局限很多（脱离当前上下文环境的<code>更新</code>不会被合并）。</p>
<p>在<code>Concurrent Mode</code>中，是以<code>优先级</code>为依据对更新进行合并的，使用范围更广。</p>
<h3 id="suspense" tabindex="-1"> Suspense</h3>
<p><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener noreferrer">Suspense</a>可以在组件请求数据时展示一个<code>pending</code>状态。请求成功后渲染数据。</p>
<p>本质上讲<code>Suspense</code>内的组件子树比组件树的其他部分拥有更低的<code>优先级</code>。</p>
<h3 id="usedeferredvalue" tabindex="-1"> useDeferredValue</h3>
<p><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue" target="_blank" rel="noopener noreferrer">useDeferredValue</a>返回一个延迟响应的值，该值可能“延后”的最长时间为<code>timeoutMs</code>。</p>
<p>例子：</p>
<div><pre><code><span>const</span> deferredValue <span>=</span> <span>useDeferredValue</span><span>(</span>value<span>,</span> <span>{</span> <span>timeoutMs</span><span>:</span> <span>2000</span> <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在<code>useDeferredValue</code>内部会调用<code>useState</code>并触发一次<code>更新</code>。</p>
<p>这次<code>更新</code>的<code>优先级</code>很低，所以当前如果有正在进行中的<code>更新</code>，不会受<code>useDeferredValue</code>产生的<code>更新</code>影响。所以<code>useDeferredValue</code>能够返回延迟的值。</p>
<p>当超过<code>timeoutMs</code>后<code>useDeferredValue</code>产生的<code>更新</code>还没进行（由于<code>优先级</code>太低一直被打断），则会再触发一次高优先级<code>更新</code>。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>除了以上介绍的实现，相信未来<code>React</code>还会开发更多基于<code>Concurrent Mode</code>的玩法。</p>
<p><code>Fiber</code>架构在之前的章节已经学习了。所以，在本章接下来的部分，我们会按照上文的脉络，自底向上，从架构到实现讲解<code>Concurrent Mode</code>。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Scheduler的原理与实现</title>
    <id>https://0808200.xyz/react/concurrent/scheduler.html</id>
    <link href="https://0808200.xyz/react/concurrent/scheduler.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/react/preparation/newConstructure.html#react16%E6%9E%B6%E6%9E%84">新的React架构</a>一节我们介绍了<code>Scheduler</code>，他包含两个功能：</p>
<ol>
<li>
<p>时间切片</p>
</li>
<li>
<p>优先级调度</p>
</li>
</ol>
<p>本节我们学习这个两个功能是如何在<code>Scheduler</code>中实现的。</p>
<h2 id="时间切片原理" tabindex="-1"> 时间切片原理</h2>
<p><code>时间切片</code>的本质是模拟实现<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback</a>。</p>
<p>除去“浏览器重排/重绘”，下图是浏览器一帧中可以用于执行<code>JS</code>的时机。</p>
<div><pre><code><span>一个task</span><span>(</span>宏任务<span>)</span> <span>--</span> <span>队列中全部job</span><span>(</span>微任务<span>)</span> <span>--</span> requestAnimationFrame <span>--</span> 浏览器重排<span>/</span>重绘 <span>--</span> requestIdleCallback
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>requestIdleCallback</code>是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。</p>
<p>浏览器并没有提供其他<code>API</code>能够在同样的时机（浏览器重排/重绘后）调用以模拟其实现。</p>
<p>唯一能精准控制调用时机的<code>API</code>是<code>requestAnimationFrame</code>，他能让我们在“浏览器重排/重绘”之前执行<code>JS</code>。</p>
<p>这也是为什么我们通常用这个<code>API</code>实现<code>JS</code>动画 —— 这是浏览器渲染前的最后时机，所以动画能快速被渲染。</p>
<p>所以，退而求其次，<code>Scheduler</code>的<code>时间切片</code>功能是通过<code>task</code>（宏任务）实现的。</p>
<p>最常见的<code>task</code>当属<code>setTimeout</code>了。但是有个<code>task</code>比<code>setTimeout</code>执行时机更靠前，那就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener noreferrer">MessageChannel</a>。</p>
<p>所以<code>Scheduler</code>将需要被执行的回调函数作为<code>MessageChannel</code>的回调执行。如果当前宿主环境不支持<code>MessageChannel</code>，则使用<code>setTimeout</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234" target="_blank" rel="noopener noreferrer">这里</a>看到<code>MessageChannel</code>的实现。<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55" target="_blank" rel="noopener noreferrer">这里</a>看到<code>setTimeout</code>的实现</p>
</blockquote>
<p>在<code>React</code>的<code>render</code>阶段，开启<code>Concurrent Mode</code>时，每次遍历前，都会通过<code>Scheduler</code>提供的<code>shouldYield</code>方法判断是否需要中断遍历，使浏览器有时间渲染：</p>
<div><pre><code><span>function</span> <span>workLoopConcurrent</span><span>(</span><span>)</span> <span>{</span>
  <span>// Perform work until Scheduler asks us to yield</span>
  <span>while</span> <span>(</span>workInProgress <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span><span>shouldYield</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>performUnitOfWork</span><span>(</span>workInProgress<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。</p>
<p>在<code>Schdeduler</code>中，为任务分配的初始剩余时间为<code>5ms</code>。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119" target="_blank" rel="noopener noreferrer">这里</a>看到初始剩余时间的定义</p>
</blockquote>
<p>随着应用运行，会通过<code>fps</code>动态调整分配给任务的可执行时间。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L172-L187" target="_blank" rel="noopener noreferrer">这里</a>看到动态分配任务时间</p>
</blockquote>
<p>这也解释了为什么<a href="/react/preparation/idea.html#cpu%E7%9A%84%E7%93%B6%E9%A2%88">设计理念</a>一节启用<code>Concurrent Mode</code>后每个任务的执行时间大体都是多于5ms的一小段时间 —— 每个时间切片被设定为5ms，任务本身再执行一小段时间，所以整体时间是多于5ms的时间</p>
<img :src="$withBase('/img/time-slice.png')" alt="长任务">
<p>那么当<code>shouldYield</code>为<code>true</code>，以至于<code>performUnitOfWork</code>被中断后是如何重新启动的呢？我们会在介绍完&quot;优先级调度&quot;后解答。</p>
<h2 id="优先级调度" tabindex="-1"> 优先级调度</h2>
<p>首先我们来了解<code>优先级</code>的来源。需要明确的一点是，<code>Scheduler</code>是独立于<code>React</code>的包，所以他的<code>优先级</code>也是独立于<code>React</code>的<code>优先级</code>的。</p>
<p><code>Scheduler</code>对外暴露了一个方法<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L217-L237" target="_blank" rel="noopener noreferrer">unstable_runWithPriority</a>。</p>
<p>这个方法接受一个<code>优先级</code>与一个<code>回调函数</code>，在<code>回调函数</code>内部调用获取<code>优先级</code>的方法都会取得第一个参数对应的<code>优先级</code>：</p>
<div><pre><code><span>function</span> <span>unstable_runWithPriority</span><span>(</span><span>priorityLevel<span>,</span> eventHandler</span><span>)</span> <span>{</span>
  <span>switch</span> <span>(</span>priorityLevel<span>)</span> <span>{</span>
    <span>case</span> <span>ImmediatePriority</span><span>:</span>
    <span>case</span> <span>UserBlockingPriority</span><span>:</span>
    <span>case</span> <span>NormalPriority</span><span>:</span>
    <span>case</span> <span>LowPriority</span><span>:</span>
    <span>case</span> <span>IdlePriority</span><span>:</span>
      <span>break</span><span>;</span>
    <span>default</span><span>:</span>
      priorityLevel <span>=</span> NormalPriority<span>;</span>
  <span>}</span>

  <span>var</span> previousPriorityLevel <span>=</span> currentPriorityLevel<span>;</span>
  currentPriorityLevel <span>=</span> priorityLevel<span>;</span>

  <span>try</span> <span>{</span>
    <span>return</span> <span>eventHandler</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>finally</span> <span>{</span>
    currentPriorityLevel <span>=</span> previousPriorityLevel<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，<code>Scheduler</code>内部存在5种优先级。</p>
<p>在<code>React</code>内部凡是涉及到<code>优先级</code>调度的地方，都会使用<code>unstable_runWithPriority</code>。</p>
<p>比如，我们知道<code>commit</code>阶段是同步执行的。可以看到，<code>commit</code>阶段的起点<code>commitRoot</code>方法的优先级为<code>ImmediateSchedulerPriority</code>。</p>
<p><code>ImmediateSchedulerPriority</code>即<code>ImmediatePriority</code>的别名，为最高优先级，会立即执行。</p>
<div><pre><code><span>function</span> <span>commitRoot</span><span>(</span><span>root</span><span>)</span> <span>{</span>
  <span>const</span> renderPriorityLevel <span>=</span> <span>getCurrentPriorityLevel</span><span>(</span><span>)</span><span>;</span>
  <span>runWithPriority</span><span>(</span>
    ImmediateSchedulerPriority<span>,</span>
    <span>commitRootImpl</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> root<span>,</span> renderPriorityLevel<span>)</span><span>,</span>
  <span>)</span><span>;</span>
  <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="优先级的意义" tabindex="-1"> 优先级的意义</h2>
<p><code>Scheduler</code>对外暴露最重要的方法便是<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L279-L359" target="_blank" rel="noopener noreferrer">unstable_scheduleCallback</a>。该方法用于以某个<code>优先级</code>注册回调函数。</p>
<p>比如在<code>React</code>中，之前讲过在<code>commit</code>阶段的<code>beforeMutation</code>阶段会调度<code>useEffect</code>的回调：</p>
<div><pre><code><span>if</span> <span>(</span><span>!</span>rootDoesHavePassiveEffects<span>)</span> <span>{</span>
  rootDoesHavePassiveEffects <span>=</span> <span>true</span><span>;</span>
  <span>scheduleCallback</span><span>(</span>NormalSchedulerPriority<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>flushPassiveEffects</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的回调便是通过<code>scheduleCallback</code>调度的，优先级为<code>NormalSchedulerPriority</code>，即<code>NormalPriority</code>。</p>
<p>不同<code>优先级</code>意味着什么？不同<code>优先级</code>意味着不同时长的任务过期时间：</p>
<div><pre><code><span>var</span> timeout<span>;</span>
<span>switch</span> <span>(</span>priorityLevel<span>)</span> <span>{</span>
  <span>case</span> <span>ImmediatePriority</span><span>:</span>
    timeout <span>=</span> <span>IMMEDIATE_PRIORITY_TIMEOUT</span><span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> <span>UserBlockingPriority</span><span>:</span>
    timeout <span>=</span> <span>USER_BLOCKING_PRIORITY_TIMEOUT</span><span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> <span>IdlePriority</span><span>:</span>
    timeout <span>=</span> <span>IDLE_PRIORITY_TIMEOUT</span><span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> <span>LowPriority</span><span>:</span>
    timeout <span>=</span> <span>LOW_PRIORITY_TIMEOUT</span><span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> <span>NormalPriority</span><span>:</span>
  <span>default</span><span>:</span>
    timeout <span>=</span> <span>NORMAL_PRIORITY_TIMEOUT</span><span>;</span>
    <span>break</span><span>;</span>
<span>}</span>

<span>var</span> expirationTime <span>=</span> startTime <span>+</span> timeout<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中：</p>
<div><pre><code><span>// Times out immediately</span>
<span>var</span> <span>IMMEDIATE_PRIORITY_TIMEOUT</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
<span>// Eventually times out</span>
<span>var</span> <span>USER_BLOCKING_PRIORITY_TIMEOUT</span> <span>=</span> <span>250</span><span>;</span>
<span>var</span> <span>NORMAL_PRIORITY_TIMEOUT</span> <span>=</span> <span>5000</span><span>;</span>
<span>var</span> <span>LOW_PRIORITY_TIMEOUT</span> <span>=</span> <span>10000</span><span>;</span>
<span>// Never times out</span>
<span>var</span> <span>IDLE_PRIORITY_TIMEOUT</span> <span>=</span> maxSigned31BitInt<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，如果一个任务的<code>优先级</code>是<code>ImmediatePriority</code>，对应<code>IMMEDIATE_PRIORITY_TIMEOUT</code>为<code>-1</code>，那么</p>
<div><pre><code><span>var</span> expirationTime <span>=</span> startTime <span>-</span> <span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>则该任务的过期时间比当前时间还短，表示他已经过期了，需要立即被执行。</p>
<h2 id="不同优先级任务的排序" tabindex="-1"> 不同优先级任务的排序</h2>
<p>我们已经知道<code>优先级</code>意味着任务的过期时间。设想一个大型<code>React</code>项目，在某一刻，存在很多不同<code>优先级</code>的<code>任务</code>，对应不同的过期时间。</p>
<p>同时，又因为任务可以被延迟，所以我们可以将这些任务按是否被延迟分为：</p>
<ul>
<li>
<p>已就绪任务</p>
</li>
<li>
<p>未就绪任务</p>
</li>
</ul>
<div><pre><code>  <span>if</span> <span>(</span><span>typeof</span> options <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> options <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>var</span> delay <span>=</span> options<span>.</span>delay<span>;</span>
    <span>if</span> <span>(</span><span>typeof</span> delay <span>===</span> <span>'number'</span> <span>&amp;&amp;</span> delay <span>></span> <span>0</span><span>)</span> <span>{</span>
      <span>// 任务被延迟</span>
      startTime <span>=</span> currentTime <span>+</span> delay<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      startTime <span>=</span> currentTime<span>;</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    startTime <span>=</span> currentTime<span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以，<code>Scheduler</code>存在两个队列：</p>
<ul>
<li>
<p>timerQueue：保存未就绪任务</p>
</li>
<li>
<p>taskQueue：保存已就绪任务</p>
</li>
</ul>
<p>每当有新的未就绪的任务被注册，我们将其插入<code>timerQueue</code>并根据开始时间重新排列<code>timerQueue</code>中任务的顺序。</p>
<p>当<code>timerQueue</code>中有任务就绪，即<code>startTime &lt;= currentTime </code>，我们将其取出并加入<code>taskQueue</code>。</p>
<p>取出<code>taskQueue</code>中最早过期的任务并执行他。</p>
<p>为了能在O(1)复杂度找到两个队列中时间最早的那个任务，<code>Scheduler</code>使用<a href="https://www.cnblogs.com/lanhaicode/p/10546257.html" target="_blank" rel="noopener noreferrer">小顶堆</a>实现了<code>优先级队列</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/SchedulerMinHeap.js" target="_blank" rel="noopener noreferrer">这里</a>看到<code>优先级队列</code>的实现</p>
</blockquote>
<p>至此，我们了解了<code>Scheduler</code>的实现。现在可以回答介绍<code>时间切片</code>时提到的问题：</p>
<blockquote>
<p>那么当shouldYield为true，以至于performUnitOfWork被中断后是如何重新启动的呢？</p>
</blockquote>
<p>在“取出<code>taskQueue</code>中最早过期的任务并执行他”这一步中有如下关键步骤：</p>
<div><pre><code><span>const</span> continuationCallback <span>=</span> <span>callback</span><span>(</span>didUserCallbackTimeout<span>)</span><span>;</span>
currentTime <span>=</span> <span>getCurrentTime</span><span>(</span><span>)</span><span>;</span>
<span>if</span> <span>(</span><span>typeof</span> continuationCallback <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
  <span>// continuationCallback是函数</span>
  currentTask<span>.</span>callback <span>=</span> continuationCallback<span>;</span>
  <span>markTaskYield</span><span>(</span>currentTask<span>,</span> currentTime<span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>if</span> <span>(</span>enableProfiling<span>)</span> <span>{</span>
    <span>markTaskCompleted</span><span>(</span>currentTask<span>,</span> currentTime<span>)</span><span>;</span>
    currentTask<span>.</span>isQueued <span>=</span> <span>false</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>currentTask <span>===</span> <span>peek</span><span>(</span>taskQueue<span>)</span><span>)</span> <span>{</span>
    <span>// 将当前任务清除</span>
    <span>pop</span><span>(</span>taskQueue<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
<span>advanceTimers</span><span>(</span>currentTime<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当注册的回调函数执行后的返回值<code>continuationCallback</code>为<code>function</code>，会将<code>continuationCallback</code>作为当前任务的回调函数。</p>
<p>如果返回值不是<code>function</code>，则将当前被执行的任务清除出<code>taskQueue</code>。</p>
<p><code>render</code>阶段被调度的函数为<code>performConcurrentWorkOnRoot</code>，在该函数末尾有这样一段代码：</p>
<div><pre><code><span>if</span> <span>(</span>root<span>.</span>callbackNode <span>===</span> originalCallbackNode<span>)</span> <span>{</span>
  <span>// The task node scheduled for this root is the same one that's</span>
  <span>// currently executed. Need to return a continuation.</span>
  <span>return</span> <span>performConcurrentWorkOnRoot</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> root<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，在满足一定条件时，该函数会将自己作为返回值。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L850-L854" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>刚才我们讲到，<code>Scheduler</code>与<code>React</code>是两套<code>优先级</code>机制。那么<code>React</code>中的<code>优先级</code>是如何运转的？我们会在下一节介绍。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">多节点Diff</title>
    <id>https://0808200.xyz/react/diff/multi.html</id>
    <link href="https://0808200.xyz/react/diff/multi.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>上一节我们介绍了单一节点的<code>Diff</code>，现在考虑我们有一个<code>FunctionComponent</code>：</p>
<div><pre><code><span>function</span> <span>List</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>ul</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span><span>3</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>他的返回值<code>JSX对象</code>的<code>children</code>属性不是单一节点，而是包含四个对象的数组</p>
<div><pre><code><span>{</span>
  $$<span>typeof</span><span>:</span> <span>Symbol</span><span>(</span>react<span>.</span>element<span>)</span><span>,</span>
  <span>key</span><span>:</span> <span>null</span><span>,</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>children</span><span>:</span> <span>[</span>
      <span>{</span>$$<span>typeof</span><span>:</span> <span>Symbol</span><span>(</span>react<span>.</span>element<span>)</span><span>,</span> <span>type</span><span>:</span> <span>"li"</span><span>,</span> <span>key</span><span>:</span> <span>"0"</span><span>,</span> <span>ref</span><span>:</span> <span>null</span><span>,</span> <span>props</span><span>:</span> <span>{</span>…<span>}</span><span>,</span> …<span>}</span>
      <span>{</span>$$<span>typeof</span><span>:</span> <span>Symbol</span><span>(</span>react<span>.</span>element<span>)</span><span>,</span> <span>type</span><span>:</span> <span>"li"</span><span>,</span> <span>key</span><span>:</span> <span>"1"</span><span>,</span> <span>ref</span><span>:</span> <span>null</span><span>,</span> <span>props</span><span>:</span> <span>{</span>…<span>}</span><span>,</span> …<span>}</span>
      <span>{</span>$$<span>typeof</span><span>:</span> <span>Symbol</span><span>(</span>react<span>.</span>element<span>)</span><span>,</span> <span>type</span><span>:</span> <span>"li"</span><span>,</span> <span>key</span><span>:</span> <span>"2"</span><span>,</span> <span>ref</span><span>:</span> <span>null</span><span>,</span> <span>props</span><span>:</span> <span>{</span>…<span>}</span><span>,</span> …<span>}</span>
      <span>{</span>$$<span>typeof</span><span>:</span> <span>Symbol</span><span>(</span>react<span>.</span>element<span>)</span><span>,</span> <span>type</span><span>:</span> <span>"li"</span><span>,</span> <span>key</span><span>:</span> <span>"3"</span><span>,</span> <span>ref</span><span>:</span> <span>null</span><span>,</span> <span>props</span><span>:</span> <span>{</span>…<span>}</span><span>,</span> …<span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
  <span>ref</span><span>:</span> <span>null</span><span>,</span>
  <span>type</span><span>:</span> <span>"ul"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这种情况下，<code>reconcileChildFibers</code>的<code>newChild</code>参数类型为<code>Array</code>，在<code>reconcileChildFibers</code>函数内部对应如下情况：</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1352" target="_blank" rel="noopener noreferrer">这里</a>看到这段源码逻辑</p>
</blockquote>
<div><pre><code>  <span>if</span> <span>(</span><span>isArray</span><span>(</span>newChild<span>)</span><span>)</span> <span>{</span>
    <span>// 调用 reconcileChildrenArray 处理</span>
    <span>// ...省略</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这一节我们来看看，如何处理同级多个节点的<code>Diff</code>。</p>
<h2 id="概览" tabindex="-1"> 概览</h2>
<p>首先归纳下我们需要处理的情况：</p>
<p>我们以<strong>之前</strong>代表更新前的<code>JSX对象</code>，<strong>之后</strong>代表更新后的<code>JSX对象</code></p>
<h3 id="情况1-节点更新" tabindex="-1"> 情况1：节点更新</h3>
<div><pre><code><span>// 之前</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>before<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>

// 之后 情况1 —— 节点属性变化
</span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>after<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>

// 之后 情况2 —— 节点类型更新
</span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="情况2-节点新增或减少" tabindex="-1"> 情况2：节点新增或减少</h3>
<div><pre><code><span>// 之前</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>

// 之后 情况1 —— 新增节点
</span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>

// 之后 情况2 —— 删除节点
</span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="情况3-节点位置变化" tabindex="-1"> 情况3：节点位置变化</h3>
<div><pre><code><span>// 之前</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>

// 之后
</span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同级多个节点的<code>Diff</code>，一定属于以上三种情况中的一种或多种。</p>
<h2 id="diff的思路" tabindex="-1"> Diff的思路</h2>
<p>该如何设计算法呢？如果让我设计一个<code>Diff算法</code>，我首先想到的方案是：</p>
<ol>
<li>判断当前节点的更新属于哪种情况</li>
<li>如果是<code>新增</code>，执行新增逻辑</li>
<li>如果是<code>删除</code>，执行删除逻辑</li>
<li>如果是<code>更新</code>，执行更新逻辑</li>
</ol>
<p>按这个方案，其实有个隐含的前提——<strong>不同操作的优先级是相同的</strong></p>
<p>但是<code>React团队</code>发现，在日常开发中，相较于<code>新增</code>和<code>删除</code>，<code>更新</code>组件发生的频率更高。所以<code>Diff</code>会优先判断当前节点是否属于<code>更新</code>。</p>
<div><p>注意</p>
<p>在我们做数组相关的算法题时，经常使用<strong>双指针</strong>从数组头和尾同时遍历以提高效率，但是这里却不行。</p>
<p>虽然本次更新的<code>JSX对象</code> <code>newChildren</code>为数组形式，但是和<code>newChildren</code>中每个组件进行比较的是<code>current fiber</code>，同级的<code>Fiber节点</code>是由<code>sibling</code>指针链接形成的单链表，即不支持双指针遍历。</p>
<p>即 <code>newChildren[0]</code>与<code>fiber</code>比较，<code>newChildren[1]</code>与<code>fiber.sibling</code>比较。</p>
<p>所以无法使用<strong>双指针</strong>优化。</p>
</div>
<p>基于以上原因，<code>Diff算法</code>的整体逻辑会经历两轮遍历：</p>
<p>第一轮遍历：处理<code>更新</code>的节点。</p>
<p>第二轮遍历：处理剩下的不属于<code>更新</code>的节点。</p>
<h2 id="第一轮遍历" tabindex="-1"> 第一轮遍历</h2>
<p>第一轮遍历步骤如下：</p>
<ol>
<li>
<p><code>let i = 0</code>，遍历<code>newChildren</code>，将<code>newChildren[i]</code>与<code>oldFiber</code>比较，判断<code>DOM节点</code>是否可复用。</p>
</li>
<li>
<p>如果可复用，<code>i++</code>，继续比较<code>newChildren[i]</code>与<code>oldFiber.sibling</code>，可以复用则继续遍历。</p>
</li>
<li>
<p>如果不可复用，分两种情况：</p>
</li>
</ol>
<ul>
<li>
<p><code>key</code>不同导致不可复用，立即跳出整个遍历，<strong>第一轮遍历结束。</strong></p>
</li>
<li>
<p><code>key</code>相同<code>type</code>不同导致不可复用，会将<code>oldFiber</code>标记为<code>DELETION</code>，并继续遍历</p>
</li>
</ul>
<ol start="4">
<li>如果<code>newChildren</code>遍历完（即<code>i === newChildren.length - 1</code>）或者<code>oldFiber</code>遍历完（即<code>oldFiber.sibling === null</code>），跳出遍历，<strong>第一轮遍历结束。</strong></li>
</ol>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818" target="_blank" rel="noopener noreferrer">这里</a>看到这轮遍历的源码</p>
</blockquote>
<p>当遍历结束后，会有两种结果：</p>
<h3 id="步骤3跳出的遍历" tabindex="-1"> 步骤3跳出的遍历</h3>
<p>此时<code>newChildren</code>没有遍历完，<code>oldFiber</code>也没有遍历完。</p>
<p>举个例子，考虑如下代码：</p>
<div><pre><code><span>// 之前</span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span>
            
<span>// 之后</span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>第一个节点可复用，遍历到<code>key === 2</code>的节点发现<code>key</code>改变，不可复用，跳出遍历，等待第二轮遍历处理。</p>
<p>此时<code>oldFiber</code>剩下<code>key === 1</code>、<code>key === 2</code>未遍历，<code>newChildren</code>剩下<code>key === 2</code>、<code>key === 1</code>未遍历。</p>
<h3 id="步骤4跳出的遍历" tabindex="-1"> 步骤4跳出的遍历</h3>
<p>可能<code>newChildren</code>遍历完，或<code>oldFiber</code>遍历完，或他们同时遍历完。</p>
<p>举个例子，考虑如下代码：</p>
<div><pre><code><span>// 之前</span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>a<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>b<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span>
            
<span>// 之后 情况1 —— newChildren与oldFiber都遍历完</span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>aa<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>bb<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span>
            
<span>// 之后 情况2 —— newChildren没遍历完，oldFiber遍历完</span>
<span>// newChildren剩下 key==="2" 未遍历</span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>aa<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>bb<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>cc<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span>
            
<span>// 之后 情况3 —— newChildren遍历完，oldFiber没遍历完</span>
<span>// oldFiber剩下 key==="1" 未遍历</span>
<span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>className</span><span><span>=</span><span>"</span>aa<span>"</span></span><span>></span></span><span>0</span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>
<h2 id="第二轮遍历" tabindex="-1"> 第二轮遍历</h2>
<p>对于第一轮遍历的结果，我们分别讨论：</p>
<h3 id="newchildren与oldfiber同时遍历完" tabindex="-1"> <code>newChildren</code>与<code>oldFiber</code>同时遍历完</h3>
<p>那就是最理想的情况：只需在第一轮遍历进行组件<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L825" target="_blank" rel="noopener noreferrer"><code>更新</code></a>。此时<code>Diff</code>结束。</p>
<h3 id="newchildren没遍历完-oldfiber遍历完" tabindex="-1"> <code>newChildren</code>没遍历完，<code>oldFiber</code>遍历完</h3>
<p>已有的<code>DOM节点</code>都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记<code>Placement</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869" target="_blank" rel="noopener noreferrer">这里</a>看到这段源码逻辑</p>
</blockquote>
<h3 id="newchildren遍历完-oldfiber没遍历完" tabindex="-1"> <code>newChildren</code>遍历完，<code>oldFiber</code>没遍历完</h3>
<p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的<code>oldFiber</code>，依次标记<code>Deletion</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L863" target="_blank" rel="noopener noreferrer">这里</a>看到这段源码逻辑</p>
</blockquote>
<h3 id="newchildren与oldfiber都没遍历完" tabindex="-1"> <code>newChildren</code>与<code>oldFiber</code>都没遍历完</h3>
<p>这意味着有节点在这次更新中改变了位置。</p>
<p>这是<code>Diff算法</code>最精髓也是最难懂的部分。我们接下来会重点讲解。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L893" target="_blank" rel="noopener noreferrer">这里</a>看到这段源码逻辑</p>
</blockquote>
<h2 id="处理移动的节点" tabindex="-1"> 处理移动的节点</h2>
<p>由于有节点改变了位置，所以不能再用位置索引<code>i</code>对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？</p>
<p>我们需要使用<code>key</code>。</p>
<p>为了快速的找到<code>key</code>对应的<code>oldFiber</code>，我们将所有还未处理的<code>oldFiber</code>存入以<code>key</code>为key，<code>oldFiber</code>为value的<code>Map</code>中。</p>
<div><pre><code><span>const</span> existingChildren <span>=</span> <span>mapRemainingChildren</span><span>(</span>returnFiber<span>,</span> oldFiber<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L890" target="_blank" rel="noopener noreferrer">这里</a>看到这段源码逻辑</p>
</blockquote>
<p>接下来遍历剩余的<code>newChildren</code>，通过<code>newChildren[i].key</code>就能在<code>existingChildren</code>中找到<code>key</code>相同的<code>oldFiber</code>。</p>
<h2 id="标记节点是否移动" tabindex="-1"> 标记节点是否移动</h2>
<p>既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？</p>
<p>我们的参照物是：最后一个可复用的节点在<code>oldFiber</code>中的位置索引（用变量<code>lastPlacedIndex</code>表示）。</p>
<p>由于本次更新中节点是按<code>newChildren</code>的顺序排列。在遍历<code>newChildren</code>过程中，每个<code>遍历到的可复用节点</code>一定是当前遍历到的<code>所有可复用节点</code>中<strong>最靠右的那个</strong>，即一定在<code>lastPlacedIndex</code>对应的<code>可复用的节点</code>在本次更新中位置的后面。</p>
<p>那么我们只需要比较<code>遍历到的可复用节点</code>在上次更新时是否也在<code>lastPlacedIndex</code>对应的<code>oldFiber</code>后面，就能知道两次更新中这两个节点的相对位置改变没有。</p>
<p>我们用变量<code>oldIndex</code>表示<code>遍历到的可复用节点</code>在<code>oldFiber</code>中的位置索引。如果<code>oldIndex &lt; lastPlacedIndex</code>，代表本次更新该节点需要向右移动。</p>
<p><code>lastPlacedIndex</code>初始为<code>0</code>，每遍历一个可复用的节点，如果<code>oldIndex &gt;=  lastPlacedIndex</code>，则<code>lastPlacedIndex = oldIndex</code>。</p>
<p>单纯文字表达比较晦涩，这里我们提供两个Demo，你可以对照着理解。</p>
<h2 id="demo1" tabindex="-1"> Demo1</h2>
<p>在Demo中我们简化下书写，每个字母代表一个节点，字母的值代表节点的<code>key</code></p>
<div><pre><code>
<span>// 之前</span>
abcd

<span>// 之后</span>
acdb

<span>===</span>第一轮遍历开始<span>===</span>
a（之后）vs a（之前）  
key不变，可复用
此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为<span>0</span>
所以 lastPlacedIndex <span>=</span> <span>0</span><span>;</span>

继续第一轮遍历<span>...</span>

c（之后）vs b（之前）  
key改变，不能复用，跳出第一轮遍历
此时 lastPlacedIndex <span>===</span> <span>0</span><span>;</span>
<span>===</span>第一轮遍历结束<span>===</span>

<span>===</span>第二轮遍历开始<span>===</span>
newChildren <span>===</span> cdb，没用完，不需要执行删除旧节点
oldFiber <span>===</span> bcd，没用完，不需要执行插入新节点

将剩余oldFiber（bcd）保存为map

<span>// 当前oldFiber：bcd</span>
<span>// 当前newChildren：cdb</span>

继续遍历剩余newChildren

key <span>===</span> c 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> c（之前）<span>.</span>index<span>;</span>
此时 oldIndex <span>===</span> <span>2</span><span>;</span>  <span>// 之前节点为 abcd，所以c.index === 2</span>
比较 oldIndex 与 lastPlacedIndex<span>;</span>

如果 oldIndex <span>>=</span> lastPlacedIndex 代表该可复用节点不需要移动
并将 lastPlacedIndex <span>=</span> oldIndex<span>;</span>
如果 oldIndex <span>&lt;</span> lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动

在例子中，oldIndex <span>2</span> <span>></span> lastPlacedIndex <span>0</span>，
则 lastPlacedIndex <span>=</span> <span>2</span><span>;</span>
c节点位置不变

继续遍历剩余newChildren

<span>// 当前oldFiber：bd</span>
<span>// 当前newChildren：db</span>

key <span>===</span> d 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> d（之前）<span>.</span>index<span>;</span>
oldIndex <span>3</span> <span>></span> lastPlacedIndex <span>2</span> <span>// 之前节点为 abcd，所以d.index === 3</span>
则 lastPlacedIndex <span>=</span> <span>3</span><span>;</span>
d节点位置不变

继续遍历剩余newChildren

<span>// 当前oldFiber：b</span>
<span>// 当前newChildren：b</span>

key <span>===</span> b 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> b（之前）<span>.</span>index<span>;</span>
oldIndex <span>1</span> <span>&lt;</span> lastPlacedIndex <span>3</span> <span>// 之前节点为 abcd，所以b.index === 1</span>
则 b节点需要向右移动
<span>===</span>第二轮遍历结束<span>===</span>

最终acd <span>3</span>个节点都没有移动，b节点被标记为移动

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="demo2" tabindex="-1"> Demo2</h2>
<div><pre><code><span>// 之前</span>
abcd

<span>// 之后</span>
dabc

<span>===</span>第一轮遍历开始<span>===</span>
d（之后）vs a（之前）  
key改变，不能复用，跳出遍历
<span>===</span>第一轮遍历结束<span>===</span>

<span>===</span>第二轮遍历开始<span>===</span>
newChildren <span>===</span> dabc，没用完，不需要执行删除旧节点
oldFiber <span>===</span> abcd，没用完，不需要执行插入新节点

将剩余oldFiber（abcd）保存为map

继续遍历剩余newChildren

<span>// 当前oldFiber：abcd</span>
<span>// 当前newChildren dabc</span>

key <span>===</span> d 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> d（之前）<span>.</span>index<span>;</span>
此时 oldIndex <span>===</span> <span>3</span><span>;</span> <span>// 之前节点为 abcd，所以d.index === 3</span>
比较 oldIndex 与 lastPlacedIndex<span>;</span>
oldIndex <span>3</span> <span>></span> lastPlacedIndex <span>0</span>
则 lastPlacedIndex <span>=</span> <span>3</span><span>;</span>
d节点位置不变

继续遍历剩余newChildren

<span>// 当前oldFiber：abc</span>
<span>// 当前newChildren abc</span>

key <span>===</span> a 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> a（之前）<span>.</span>index<span>;</span> <span>// 之前节点为 abcd，所以a.index === 0</span>
此时 oldIndex <span>===</span> <span>0</span><span>;</span>
比较 oldIndex 与 lastPlacedIndex<span>;</span>
oldIndex <span>0</span> <span>&lt;</span> lastPlacedIndex <span>3</span>
则 a节点需要向右移动

继续遍历剩余newChildren

<span>// 当前oldFiber：bc</span>
<span>// 当前newChildren bc</span>

key <span>===</span> b 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> b（之前）<span>.</span>index<span>;</span> <span>// 之前节点为 abcd，所以b.index === 1</span>
此时 oldIndex <span>===</span> <span>1</span><span>;</span>
比较 oldIndex 与 lastPlacedIndex<span>;</span>
oldIndex <span>1</span> <span>&lt;</span> lastPlacedIndex <span>3</span>
则 b节点需要向右移动

继续遍历剩余newChildren

<span>// 当前oldFiber：c</span>
<span>// 当前newChildren c</span>

key <span>===</span> c 在 oldFiber中存在
<span>const</span> oldIndex <span>=</span> c（之前）<span>.</span>index<span>;</span> <span>// 之前节点为 abcd，所以c.index === 2</span>
此时 oldIndex <span>===</span> <span>2</span><span>;</span>
比较 oldIndex 与 lastPlacedIndex<span>;</span>
oldIndex <span>2</span> <span>&lt;</span> lastPlacedIndex <span>3</span>
则 c节点需要向右移动

<span>===</span>第二轮遍历结束<span>===</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，我们以为从 <code>abcd</code> 变为 <code>dabc</code>，只需要将<code>d</code>移动到前面。</p>
<p>但实际上React保持<code>d</code>不变，将<code>abc</code>分别移动到了<code>d</code>的后面。</p>
<p>从这点可以看出，考虑性能，我们要尽量减少将节点从后面移动到前面的操作。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">单节点Diff</title>
    <id>https://0808200.xyz/react/diff/one.html</id>
    <link href="https://0808200.xyz/react/diff/one.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>对于单个节点，我们以类型<code>object</code>为例，会进入<code>reconcileSingleElement</code></p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141" target="_blank" rel="noopener noreferrer">这里</a>看到<code>reconcileSingleElement</code>源码</p>
</blockquote>
<div><pre><code>  <span>const</span> isObject <span>=</span> <span>typeof</span> newChild <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> newChild <span>!==</span> <span>null</span><span>;</span>

  <span>if</span> <span>(</span>isObject<span>)</span> <span>{</span>
    <span>// 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span>
    <span>switch</span> <span>(</span>newChild<span>.</span>$$<span>typeof</span><span>)</span> <span>{</span>
      <span>case</span> <span>REACT_ELEMENT_TYPE</span><span>:</span>
        <span>// 调用 reconcileSingleElement 处理</span>
      <span>// ...其他case</span>
    <span>}</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个函数会做如下事情：</p>
<img :src="$withBase('/img/diff.png')" alt="diff">
<p>让我们看看第二步<strong>判断DOM节点是否可以复用</strong>是如何实现的。</p>
<div><pre><code><span>function</span> <span>reconcileSingleElement</span><span>(</span>
  <span><span>returnFiber</span><span>:</span> Fiber<span>,</span>
  <span>currentFirstChild</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span>
  <span>element</span><span>:</span> ReactElement</span>
<span>)</span><span>:</span> Fiber <span>{</span>
  <span>const</span> key <span>=</span> element<span>.</span>key<span>;</span>
  <span>let</span> child <span>=</span> currentFirstChild<span>;</span>
  
  <span>// 首先判断是否存在对应DOM节点</span>
  <span>while</span> <span>(</span>child <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>// 上一次更新存在DOM节点，接下来判断是否可复用</span>

    <span>// 首先比较key是否相同</span>
    <span>if</span> <span>(</span>child<span>.</span>key <span>===</span> key<span>)</span> <span>{</span>

      <span>// key相同，接下来比较type是否相同</span>

      <span>switch</span> <span>(</span>child<span>.</span>tag<span>)</span> <span>{</span>
        <span>// ...省略case</span>
        
        <span>default</span><span>:</span> <span>{</span>
          <span>if</span> <span>(</span>child<span>.</span>elementType <span>===</span> element<span>.</span>type<span>)</span> <span>{</span>
            <span>// type相同则表示可以复用</span>
            <span>// 返回复用的fiber</span>
            <span>return</span> existing<span>;</span>
          <span>}</span>
          
          <span>// type不同则跳出switch</span>
          <span>break</span><span>;</span>
        <span>}</span>
      <span>}</span>
      <span>// 代码执行到这里代表：key相同但是type不同</span>
      <span>// 将该fiber及其兄弟fiber标记为删除</span>
      <span>deleteRemainingChildren</span><span>(</span>returnFiber<span>,</span> child<span>)</span><span>;</span>
      <span>break</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// key不同，将该fiber标记为删除</span>
      <span>deleteChild</span><span>(</span>returnFiber<span>,</span> child<span>)</span><span>;</span>
    <span>}</span>
    child <span>=</span> child<span>.</span>sibling<span>;</span>
  <span>}</span>

  <span>// 创建新Fiber，并返回 ...省略</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>还记得我们刚才提到的，React预设的限制么，</p>
<p>从代码可以看出，React通过先判断<code>key</code>是否相同，如果<code>key</code>相同则判断<code>type</code>是否相同，只有都相同时一个<code>DOM节点</code>才能复用。</p>
<p>这里有个细节需要关注下：</p>
<ul>
<li>
<p>当<code>child !== null</code>且<code>key相同</code>且<code>type不同</code>时执行<code>deleteRemainingChildren</code>将<code>child</code>及其兄弟<code>fiber</code>都标记删除。</p>
</li>
<li>
<p>当<code>child !== null</code>且<code>key不同</code>时仅将<code>child</code>标记删除。</p>
</li>
</ul>
<p>考虑如下例子：</p>
<p>当前页面有3个<code>li</code>，我们要全部删除，再插入一个<code>p</code>。</p>
<div><pre><code><span>// 当前页面显示的</span>
ul <span>></span> li <span>*</span> <span>3</span>

<span>// 这次需要更新的</span>
ul <span>></span> p
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>由于本次更新时只有一个<code>p</code>，属于单一节点的<code>Diff</code>，会走上面介绍的代码逻辑。</p>
<p>在<code>reconcileSingleElement</code>中遍历之前的3个<code>fiber</code>（对应的<code>DOM</code>为3个<code>li</code>），寻找本次更新的<code>p</code>是否可以复用之前的3个<code>fiber</code>中某个的<code>DOM</code>。</p>
<p>当<code>key相同</code>且<code>type不同</code>时，代表我们已经找到本次更新的<code>p</code>对应的上次的<code>fiber</code>，但是<code>p</code>与<code>li</code> <code>type</code>不同，不能复用。既然唯一的可能性已经不能复用，则剩下的<code>fiber</code>都没有机会了，所以都需要标记删除。</p>
<p>当<code>key不同</code>时只代表遍历到的该<code>fiber</code>不能被<code>p</code>复用，后面还有兄弟<code>fiber</code>还没有遍历到。所以仅仅标记该<code>fiber</code>删除。</p>
<h2 id="练习题" tabindex="-1"> 练习题</h2>
<p>让我们来做几道习题巩固下吧：</p>
<p>请判断如下<code>JSX对象</code>对应的<code>DOM</code>元素是否可以复用：</p>
<div><pre><code><span>// 习题1 更新前</span>
<span><span><span>&lt;</span>div</span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>// 更新后</span>
<span><span><span>&lt;</span>p</span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span>// 习题2 更新前</span>
<span><span><span>&lt;</span>div</span> <span>key</span><span><span>=</span><span>"</span>xxx<span>"</span></span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>// 更新后</span>
<span><span><span>&lt;</span>div</span> <span>key</span><span><span>=</span><span>"</span>ooo<span>"</span></span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>// 习题3 更新前</span>
<span><span><span>&lt;</span>div</span> <span>key</span><span><span>=</span><span>"</span>xxx<span>"</span></span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>// 更新后</span>
<span><span><span>&lt;</span>p</span> <span>key</span><span><span>=</span><span>"</span>ooo<span>"</span></span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span>// 习题4 更新前</span>
<span><span><span>&lt;</span>div</span> <span>key</span><span><span>=</span><span>"</span>xxx<span>"</span></span><span>></span></span><span>ka song</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>// 更新后</span>
<span><span><span>&lt;</span>div</span> <span>key</span><span><span>=</span><span>"</span>xxx<span>"</span></span><span>></span></span><span>xiao bei</span><span><span><span>&lt;/</span>div</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>。</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>公布答案：</p>
<p>习题1: 未设置<code>key prop</code>默认 <code>key = null;</code>，所以更新前后key相同，都为<code>null</code>，但是更新前<code>type</code>为<code>div</code>，更新后为<code>p</code>，<code>type</code>改变则不能复用。</p>
<p>习题2: 更新前后<code>key</code>改变，不需要再判断<code>type</code>，不能复用。</p>
<p>习题3: 更新前后<code>key</code>改变，不需要再判断<code>type</code>，不能复用。</p>
<p>习题4: 更新前后<code>key</code>与<code>type</code>都未改变，可以复用。<code>children</code>变化，<code>DOM</code>的子元素需要更新。</p>
<p>你是不是都答对了呢。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">diff概览</title>
    <id>https://0808200.xyz/react/diff/prepare.html</id>
    <link href="https://0808200.xyz/react/diff/prepare.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<div><p>本章为选读章节</p>
<p>是否学习该章对后续章节的学习没有影响。</p>
</div>
<p>在<a href="/react/process/beginWork.html#reconcilechildren">beginWork一节</a>我们提到</p>
<blockquote>
<p>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点。</p>
</blockquote>
<p>这一章我们讲解<code>Diff算法</code>的实现。</p>
<blockquote>
<p>你可以从<a href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank" rel="noopener noreferrer">这里</a>看到<code>Diff算法</code>的介绍。</p>
</blockquote>
<div><p>为了防止概念混淆，这里再强调下</p>
<p>一个<code>DOM节点</code>在某一时刻最多会有4个节点和他相关。</p>
<ol>
<li>
<p><code>current Fiber</code>。如果该<code>DOM节点</code>已在页面中，<code>current Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。</p>
</li>
<li>
<p><code>workInProgress Fiber</code>。如果该<code>DOM节点</code>将在本次更新中渲染到页面中，<code>workInProgress Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。</p>
</li>
<li>
<p><code>DOM节点</code>本身。</p>
</li>
<li>
<p><code>JSX对象</code>。即<code>ClassComponent</code>的<code>render</code>方法的返回结果，或<code>FunctionComponent</code>的调用结果。<code>JSX对象</code>中包含描述<code>DOM节点</code>的信息。</p>
</li>
</ol>
<p><code>Diff算法</code>的本质是对比1和4，生成2。</p>
</div>
<h2 id="diff的瓶颈以及react如何应对" tabindex="-1"> Diff的瓶颈以及React如何应对</h2>
<p>由于<code>Diff</code>操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中<code>n</code>是树中元素的数量。</p>
<p>如果在<code>React</code>中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。</p>
<p>为了降低算法复杂度，<code>React</code>的<code>diff</code>会预设三个限制：</p>
<ol>
<li>
<p>只对同级元素进行<code>Diff</code>。如果一个<code>DOM节点</code>在前后两次更新中跨越了层级，那么<code>React</code>不会尝试复用他。</p>
</li>
<li>
<p>两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。</p>
</li>
<li>
<p>开发者可以通过 <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</p>
</li>
</ol>
<div><pre><code><span>// 更新前</span>
<span><span><span>&lt;</span>div</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>p</span> <span>key</span><span><span>=</span><span>"</span>ka<span>"</span></span><span>></span></span><span>ka</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>h3</span> <span>key</span><span><span>=</span><span>"</span>song<span>"</span></span><span>></span></span><span>song</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>// 更新后</span>
<span><span><span>&lt;</span>div</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>h3</span> <span>key</span><span><span>=</span><span>"</span>song<span>"</span></span><span>></span></span><span>song</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>p</span> <span>key</span><span><span>=</span><span>"</span>ka<span>"</span></span><span>></span></span><span>ka</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>div</span><span>></span></span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果没有<code>key</code>，<code>React</code>会认为<code>div</code>的第一个子节点由<code>p</code>变为<code>h3</code>，第二个子节点由<code>h3</code>变为<code>p</code>。这符合限制2的设定，会销毁并新建。</p>
<p>但是当我们用<code>key</code>指明了节点前后对应关系后，<code>React</code>知道<code>key === &quot;ka&quot;</code>的<code>p</code>在更新后还存在，所以<code>DOM节点</code>可以复用，只是需要交换下顺序。</p>
<p>这就是<code>React</code>为了应对算法性能瓶颈做出的三条限制。</p>
<h2 id="diff是如何实现的" tabindex="-1"> Diff是如何实现的</h2>
<p>我们从<code>Diff</code>的入口函数<code>reconcileChildFibers</code>出发，该函数会根据<code>newChild</code>（即<code>JSX对象</code>）类型调用不同的处理函数。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280" target="_blank" rel="noopener noreferrer">这里</a>看到<code>reconcileChildFibers</code>的源码。</p>
</blockquote>
<div><pre><code><span>// 根据newChild类型选择不同diff函数处理</span>
<span>function</span> <span>reconcileChildFibers</span><span>(</span>
  <span><span>returnFiber</span><span>:</span> Fiber<span>,</span>
  <span>currentFirstChild</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span>
  <span>newChild</span><span>:</span> any<span>,</span></span>
<span>)</span><span>:</span> Fiber <span>|</span> <span>null</span> <span>{</span>

  <span>const</span> isObject <span>=</span> <span>typeof</span> newChild <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> newChild <span>!==</span> <span>null</span><span>;</span>

  <span>if</span> <span>(</span>isObject<span>)</span> <span>{</span>
    <span>// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span>
    <span>switch</span> <span>(</span>newChild<span>.</span>$$<span>typeof</span><span>)</span> <span>{</span>
      <span>case</span> <span>REACT_ELEMENT_TYPE</span><span>:</span>
        <span>// 调用 reconcileSingleElement 处理</span>
      <span>// // ...省略其他case</span>
    <span>}</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>typeof</span> newChild <span>===</span> <span>'string'</span> <span>||</span> <span>typeof</span> newChild <span>===</span> <span>'number'</span><span>)</span> <span>{</span>
    <span>// 调用 reconcileSingleTextNode 处理</span>
    <span>// ...省略</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>isArray</span><span>(</span>newChild<span>)</span><span>)</span> <span>{</span>
    <span>// 调用 reconcileChildrenArray 处理</span>
    <span>// ...省略</span>
  <span>}</span>

  <span>// 一些其他情况调用处理函数</span>
  <span>// ...省略</span>

  <span>// 以上都没有命中，删除节点</span>
  <span>return</span> <span>deleteRemainingChildren</span><span>(</span>returnFiber<span>,</span> currentFirstChild<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以从同级的节点数量将Diff分为两类：</p>
<ol>
<li>
<p>当<code>newChild</code>类型为<code>object</code>、<code>number</code>、<code>string</code>，代表同级只有一个节点</p>
</li>
<li>
<p>当<code>newChild</code>类型为<code>Array</code>，同级有多个节点</p>
</li>
</ol>
<p>在接下来两节我们会分别讨论这两类节点的<code>Diff</code>。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">极简Hooks实现</title>
    <id>https://0808200.xyz/react/hooks/create.html</id>
    <link href="https://0808200.xyz/react/hooks/create.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>为了更好理解<code>Hooks</code>原理，这一节我们遵循<code>React</code>的运行流程，实现一个不到100行代码的极简<code>useState Hook</code>。建议对照着代码来看本节内容。</p>
<h2 id="工作原理" tabindex="-1"> 工作原理</h2>
<p>对于<code>useState Hook</code>，考虑如下例子：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>num<span>,</span> updateNum<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span>p onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>p<span>></span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>可以将工作分为两部分：</p>
<ol>
<li>
<p>通过一些途径产生<code>更新</code>，<code>更新</code>会造成组件<code>render</code>。</p>
</li>
<li>
<p>组件<code>render</code>时<code>useState</code>返回的<code>num</code>为更新后的结果。</p>
</li>
</ol>
<p>其中<code>步骤1</code>的<code>更新</code>可以分为<code>mount</code>和<code>update</code>：</p>
<ol>
<li>
<p>调用<code>ReactDOM.render</code>会产生<code>mount</code>的<code>更新</code>，<code>更新</code>内容为<code>useState</code>的<code>initialValue</code>（即<code>0</code>）。</p>
</li>
<li>
<p>点击<code>p</code>标签触发<code>updateNum</code>会产生一次<code>update</code>的<code>更新</code>，<code>更新</code>内容为<code>num =&gt; num + 1</code>。</p>
</li>
</ol>
<p>接下来讲解这两个步骤如何实现。</p>
<h2 id="更新是什么" tabindex="-1"> 更新是什么</h2>
<blockquote>
<ol>
<li>通过一些途径产生<code>更新</code>，<code>更新</code>会造成组件<code>render</code>。</li>
</ol>
</blockquote>
<p>首先我们要明确<code>更新</code>是什么。</p>
<p>在我们的极简例子中，<code>更新</code>就是如下数据结构：</p>
<div><pre><code><span>const</span> update <span>=</span> <span>{</span>
  <span>// 更新执行的函数</span>
  action<span>,</span>
  <span>// 与同一个Hook的其他更新形成链表</span>
  <span>next</span><span>:</span> <span>null</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于<code>App</code>来说，点击<code>p</code>标签产生的<code>update</code>的<code>action</code>为<code>num =&gt; num + 1</code>。</p>
<p>如果我们改写下<code>App</code>的<code>onClick</code>：</p>
<div><pre><code><span>// 之前</span>
<span>return</span> <span>&lt;</span>p onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>p<span>></span><span>;</span>

<span>// 之后</span>
<span>return</span> <span>&lt;</span>p onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>}</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>p<span>></span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么点击<code>p</code>标签会产生三个<code>update</code>。</p>
<h2 id="update数据结构" tabindex="-1"> update数据结构</h2>
<p>这些<code>update</code>是如何组合在一起呢？</p>
<p>答案是：他们会形成<code>环状单向链表</code>。</p>
<p>调用<code>updateNum</code>实际调用的是<code>dispatchAction.bind(null, hook.queue)</code>，我们先来了解下这个函数：</p>
<div><pre><code><span>function</span> <span>dispatchAction</span><span>(</span><span>queue<span>,</span> action</span><span>)</span> <span>{</span>
  <span>// 创建update</span>
  <span>const</span> update <span>=</span> <span>{</span>
    action<span>,</span>
    <span>next</span><span>:</span> <span>null</span>
  <span>}</span>

  <span>// 环状单向链表操作</span>
  <span>if</span> <span>(</span>queue<span>.</span>pending <span>===</span> <span>null</span><span>)</span> <span>{</span>
    update<span>.</span>next <span>=</span> update<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    update<span>.</span>next <span>=</span> queue<span>.</span>pending<span>.</span>next<span>;</span>
    queue<span>.</span>pending<span>.</span>next <span>=</span> update<span>;</span>
  <span>}</span>
  queue<span>.</span>pending <span>=</span> update<span>;</span>

  <span>// 模拟React开始调度更新</span>
  <span>schedule</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>环状链表操作不太容易理解，这里我们详细讲解下。</p>
<p>当产生第一个<code>update</code>（我们叫他<code>u0</code>），此时<code>queue.pending === null</code>。</p>
<p><code>update.next = update;</code>即<code>u0.next = u0</code>，他会和自己首尾相连形成<code>单向环状链表</code>。</p>
<p>然后<code>queue.pending = update;</code>即<code>queue.pending = u0</code></p>
<div><pre><code>queue<span>.</span>pending <span>=</span> u0 <span>--</span><span>-</span><span>></span> u0
                <span>^</span>       <span>|</span>
                <span>|</span>       <span>|</span>
                <span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>当产生第二个<code>update</code>（我们叫他<code>u1</code>），<code>update.next = queue.pending.next;</code>，此时<code>queue.pending.next === u0</code>，
即<code>u1.next = u0</code>。</p>
<p><code>queue.pending.next = update;</code>，即<code>u0.next = u1</code>。</p>
<p>然后<code>queue.pending = update;</code>即<code>queue.pending = u1</code></p>
<div><pre><code>queue<span>.</span>pending <span>=</span> u1 <span>--</span><span>-</span><span>></span> u0   
                <span>^</span>       <span>|</span>
                <span>|</span>       <span>|</span>
                <span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>你可以照着这个例子模拟插入多个<code>update</code>的情况，会发现<code>queue.pending</code>始终指向最后一个插入的<code>update</code>。</p>
<p>这样做的好处是，当我们要遍历<code>update</code>时，<code>queue.pending.next</code>指向第一个插入的<code>update</code>。</p>
<h2 id="状态如何保存" tabindex="-1"> 状态如何保存</h2>
<p>现在我们知道，<code>更新</code>产生的<code>update</code>对象会保存在<code>queue</code>中。</p>
<p>不同于<code>ClassComponent</code>的实例可以存储数据，对于<code>FunctionComponent</code>，<code>queue</code>存储在哪里呢？</p>
<p>答案是：<code>FunctionComponent</code>对应的<code>fiber</code>中。</p>
<p>我们使用如下精简的<code>fiber</code>结构：</p>
<div><pre><code><span>// App组件对应的fiber对象</span>
<span>const</span> fiber <span>=</span> <span>{</span>
  <span>// 保存该FunctionComponent对应的Hooks链表</span>
  <span>memoizedState</span><span>:</span> <span>null</span><span>,</span>
  <span>// 指向App函数</span>
  <span>stateNode</span><span>:</span> App
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="hook数据结构" tabindex="-1"> Hook数据结构</h2>
<p>接下来我们关注<code>fiber.memoizedState</code>中保存的<code>Hook</code>的数据结构。</p>
<p>可以看到，<code>Hook</code>与<code>update</code>类似，都通过<code>链表</code>连接。不过<code>Hook</code>是<code>无环</code>的<code>单向链表</code>。</p>
<div><pre><code>hook <span>=</span> <span>{</span>
  <span>// 保存update的queue，即上文介绍的queue</span>
  <span>queue</span><span>:</span> <span>{</span>
    <span>pending</span><span>:</span> <span>null</span>
  <span>}</span><span>,</span>
  <span>// 保存hook对应的state</span>
  <span>memoizedState</span><span>:</span> initialState<span>,</span>
  <span>// 与下一个Hook连接形成单向无环链表</span>
  <span>next</span><span>:</span> <span>null</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>注意区分<code>update</code>与<code>hook</code>的所属关系：</p>
<p>每个<code>useState</code>对应一个<code>hook</code>对象。</p>
<p>调用<code>const [num, updateNum] = useState(0);</code>时<code>updateNum</code>（即上文介绍的<code>dispatchAction</code>）产生的<code>update</code>保存在<code>useState</code>对应的<code>hook.queue</code>中。</p>
</div>
<h2 id="模拟react调度更新流程" tabindex="-1"> 模拟React调度更新流程</h2>
<p>在上文<code>dispatchAction</code>末尾我们通过<code>schedule</code>方法模拟<code>React</code>调度更新流程。</p>
<div><pre><code><span>function</span> <span>dispatchAction</span><span>(</span><span>queue<span>,</span> action</span><span>)</span> <span>{</span>
  <span>// ...创建update</span>
  
  <span>// ...环状单向链表操作</span>

  <span>// 模拟React开始调度更新</span>
  <span>schedule</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在我们来实现他。</p>
<p>我们用<code>isMount</code>变量指代是<code>mount</code>还是<code>update</code>。</p>
<div><pre><code><span>// 首次render时是mount</span>
isMount <span>=</span> <span>true</span><span>;</span>

<span>function</span> <span>schedule</span><span>(</span><span>)</span> <span>{</span>
  <span>// 更新前将workInProgressHook重置为fiber保存的第一个Hook</span>
  workInProgressHook <span>=</span> fiber<span>.</span>memoizedState<span>;</span>
  <span>// 触发组件render</span>
  fiber<span>.</span><span>stateNode</span><span>(</span><span>)</span><span>;</span>
  <span>// 组件首次render为mount，以后再触发的更新为update</span>
  isMount <span>=</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通过<code>workInProgressHook</code>变量指向当前正在工作的<code>hook</code>。</p>
<div><pre><code>workInProgressHook <span>=</span> fiber<span>.</span>memoizedState<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在组件<code>render</code>时，每当遇到下一个<code>useState</code>，我们移动<code>workInProgressHook</code>的指针。</p>
<div><pre><code>workInProgressHook <span>=</span> workInProgressHook<span>.</span>next<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样，只要每次组件<code>render</code>时<code>useState</code>的调用顺序及数量保持一致，那么始终可以通过<code>workInProgressHook</code>找到当前<code>useState</code>对应的<code>hook</code>对象。</p>
<p>到此为止，我们已经完成第一步。</p>
<blockquote>
<ol>
<li>通过一些途径产生<code>更新</code>，<code>更新</code>会造成组件<code>render</code>。</li>
</ol>
</blockquote>
<p>接下来实现第二步。</p>
<blockquote>
<ol start="2">
<li>组件<code>render</code>时<code>useState</code>返回的<code>num</code>为更新后的结果。</li>
</ol>
</blockquote>
<h2 id="计算state" tabindex="-1"> 计算state</h2>
<p>组件<code>render</code>时会调用<code>useState</code>，他的大体逻辑如下：</p>
<div><pre><code><span>function</span> <span>useState</span><span>(</span><span>initialState</span><span>)</span> <span>{</span>
  <span>// 当前useState使用的hook会被赋值该该变量</span>
  <span>let</span> hook<span>;</span>

  <span>if</span> <span>(</span>isMount<span>)</span> <span>{</span>
    <span>// ...mount时需要生成hook对象</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// ...update时从workInProgressHook中取出该useState对应的hook</span>
  <span>}</span>

  <span>let</span> baseState <span>=</span> hook<span>.</span>memoizedState<span>;</span>
  <span>if</span> <span>(</span>hook<span>.</span>queue<span>.</span>pending<span>)</span> <span>{</span>
    <span>// ...根据queue.pending中保存的update更新state</span>
  <span>}</span>
  hook<span>.</span>memoizedState <span>=</span> baseState<span>;</span>

  <span>return</span> <span>[</span>baseState<span>,</span> <span>dispatchAction</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> hook<span>.</span>queue<span>)</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们首先关注如何获取<code>hook</code>对象：</p>
<div><pre><code><span>if</span> <span>(</span>isMount<span>)</span> <span>{</span>
  <span>// mount时为该useState生成hook</span>
  hook <span>=</span> <span>{</span>
    <span>queue</span><span>:</span> <span>{</span>
      <span>pending</span><span>:</span> <span>null</span>
    <span>}</span><span>,</span>
    <span>memoizedState</span><span>:</span> initialState<span>,</span>
    <span>next</span><span>:</span> <span>null</span>
  <span>}</span>

  <span>// 将hook插入fiber.memoizedState链表末尾</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>memoizedState<span>)</span> <span>{</span>
    fiber<span>.</span>memoizedState <span>=</span> hook<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    workInProgressHook<span>.</span>next <span>=</span> hook<span>;</span>
  <span>}</span>
  <span>// 移动workInProgressHook指针</span>
  workInProgressHook <span>=</span> hook<span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// update时找到对应hook</span>
  hook <span>=</span> workInProgressHook<span>;</span>
  <span>// 移动workInProgressHook指针</span>
  workInProgressHook <span>=</span> workInProgressHook<span>.</span>next<span>;</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当找到该<code>useState</code>对应的<code>hook</code>后，如果该<code>hook.queue.pending</code>不为空（即存在<code>update</code>），则更新其<code>state</code>。</p>
<div><pre><code><span>// update执行前的初始state</span>
<span>let</span> baseState <span>=</span> hook<span>.</span>memoizedState<span>;</span>

<span>if</span> <span>(</span>hook<span>.</span>queue<span>.</span>pending<span>)</span> <span>{</span>
  <span>// 获取update环状单向链表中第一个update</span>
  <span>let</span> firstUpdate <span>=</span> hook<span>.</span>queue<span>.</span>pending<span>.</span>next<span>;</span>

  <span>do</span> <span>{</span>
    <span>// 执行update action</span>
    <span>const</span> action <span>=</span> firstUpdate<span>.</span>action<span>;</span>
    baseState <span>=</span> <span>action</span><span>(</span>baseState<span>)</span><span>;</span>
    firstUpdate <span>=</span> firstUpdate<span>.</span>next<span>;</span>

    <span>// 最后一个update执行完后跳出循环</span>
  <span>}</span> <span>while</span> <span>(</span>firstUpdate <span>!==</span> hook<span>.</span>queue<span>.</span>pending<span>.</span>next<span>)</span>

  <span>// 清空queue.pending</span>
  hook<span>.</span>queue<span>.</span>pending <span>=</span> <span>null</span><span>;</span>
<span>}</span>

<span>// 将update action执行完后的state作为memoizedState</span>
hook<span>.</span>memoizedState <span>=</span> baseState<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>完整代码如下：</p>
<div><pre><code><span>function</span> <span>useState</span><span>(</span><span>initialState</span><span>)</span> <span>{</span>
  <span>let</span> hook<span>;</span>

  <span>if</span> <span>(</span>isMount<span>)</span> <span>{</span>
    hook <span>=</span> <span>{</span>
      <span>queue</span><span>:</span> <span>{</span>
        <span>pending</span><span>:</span> <span>null</span>
      <span>}</span><span>,</span>
      <span>memoizedState</span><span>:</span> initialState<span>,</span>
      <span>next</span><span>:</span> <span>null</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>memoizedState<span>)</span> <span>{</span>
      fiber<span>.</span>memoizedState <span>=</span> hook<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      workInProgressHook<span>.</span>next <span>=</span> hook<span>;</span>
    <span>}</span>
    workInProgressHook <span>=</span> hook<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    hook <span>=</span> workInProgressHook<span>;</span>
    workInProgressHook <span>=</span> workInProgressHook<span>.</span>next<span>;</span>
  <span>}</span>

  <span>let</span> baseState <span>=</span> hook<span>.</span>memoizedState<span>;</span>
  <span>if</span> <span>(</span>hook<span>.</span>queue<span>.</span>pending<span>)</span> <span>{</span>
    <span>let</span> firstUpdate <span>=</span> hook<span>.</span>queue<span>.</span>pending<span>.</span>next<span>;</span>

    <span>do</span> <span>{</span>
      <span>const</span> action <span>=</span> firstUpdate<span>.</span>action<span>;</span>
      baseState <span>=</span> <span>action</span><span>(</span>baseState<span>)</span><span>;</span>
      firstUpdate <span>=</span> firstUpdate<span>.</span>next<span>;</span>
    <span>}</span> <span>while</span> <span>(</span>firstUpdate <span>!==</span> hook<span>.</span>queue<span>.</span>pending<span>.</span>next<span>)</span>

    hook<span>.</span>queue<span>.</span>pending <span>=</span> <span>null</span><span>;</span>
  <span>}</span>
  hook<span>.</span>memoizedState <span>=</span> baseState<span>;</span>

  <span>return</span> <span>[</span>baseState<span>,</span> <span>dispatchAction</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> hook<span>.</span>queue<span>)</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="对触发事件进行抽象" tabindex="-1"> 对触发事件进行抽象</h2>
<p>最后，让我们抽象一下<code>React</code>的事件触发方式。</p>
<p>通过调用<code>App</code>返回的<code>click</code>方法模拟组件<code>click</code>的行为。</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>num<span>,</span> updateNum<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>isMount <span>?</span> <span>'mount'</span> <span>:</span> <span>'update'</span><span>}</span></span><span> num: </span><span>`</span></span><span>,</span> num<span>)</span><span>;</span>

  <span>return</span> <span>{</span>
    <span>click</span><span>(</span><span>)</span> <span>{</span>
      <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="在线demo" tabindex="-1"> 在线Demo</h2>
<p>至此，我们完成了一个不到100行代码的<code>Hooks</code>。重要的是，他与<code>React</code>的运行逻辑相同。</p>
<details><summary>精简Hooks的在线Demo</summary>
<p>调用<code>window.app.click()</code>模拟组件点击事件。</p>
<p>你也可以使用多个<code>useState</code>。</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>num<span>,</span> updateNum<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span>num1<span>,</span> updateNum1<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>100</span><span>)</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>isMount <span>?</span> <span>'mount'</span> <span>:</span> <span>'update'</span><span>}</span></span><span> num: </span><span>`</span></span><span>,</span> num<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>isMount <span>?</span> <span>'mount'</span> <span>:</span> <span>'update'</span><span>}</span></span><span> num1: </span><span>`</span></span><span>,</span> num1<span>)</span><span>;</span>

  <span>return</span> <span>{</span>
    <span>click</span><span>(</span><span>)</span> <span>{</span>
      <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
    <span>focus</span><span>(</span><span>)</span> <span>{</span>
      <span>updateNum1</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>3</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><a href="/react/me.html">关注公众号</a>，后台回复<strong>616</strong>获得在线Demo地址</p>
</details>
<h2 id="与react的区别" tabindex="-1"> 与React的区别</h2>
<p>我们用尽可能少的代码模拟了<code>Hooks</code>的运行，但是相比<code>React Hooks</code>，他还有很多不足。以下是他与<code>React Hooks</code>的区别：</p>
<ol>
<li>
<p><code>React Hooks</code>没有使用<code>isMount</code>变量，而是在不同时机使用不同的<code>dispatcher</code>。换言之，<code>mount</code>时的<code>useState</code>与<code>update</code>时的<code>useState</code>不是同一个函数。</p>
</li>
<li>
<p><code>React Hooks</code>有中途跳过<code>更新</code>的优化手段。</p>
</li>
<li>
<p><code>React Hooks</code>有<code>batchedUpdates</code>，当在<code>click</code>中触发三次<code>updateNum</code>，<code>精简React</code>会触发三次更新，而<code>React</code>只会触发一次。</p>
</li>
<li>
<p><code>React Hooks</code>的<code>update</code>有<code>优先级</code>概念，可以跳过不高优先的<code>update</code>。</p>
</li>
</ol>
<p>更多的细节，我们会在本章后续小节讲解。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Hooks理念</title>
    <id>https://0808200.xyz/react/hooks/prepare.html</id>
    <link href="https://0808200.xyz/react/hooks/prepare.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<div><p>注意</p>
<p>在开始本章学习前，你需要了解<code>Hooks</code>的基本用法。</p>
<p>如果你还未使用过<code>Hooks</code>，可以从<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">官方文档</a>开始。</p>
</div>
<p>你可以从<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noopener noreferrer">这里</a>了解<code>Hooks</code>的设计动机。作为一名<code>框架使用者</code>，了解<code>设计动机</code>对于我们日常开发就足够了。</p>
<p>但是，为了更好的理解<code>Hooks</code>的<code>源码架构</code>，我们需要转换身份，以<code>框架开发者</code>的角度来看待<code>Hooks</code>的<code>设计理念</code>。</p>
<h2 id="从logo聊起" tabindex="-1"> 从LOGO聊起</h2>
<img :src="$withBase('/img/logo.png')" alt="LOGO">
<p><code>React</code> <code>LOGO</code>的图案是代表<code>原子</code>（<code>atom</code>）的符号。世间万物由<code>原子</code>组成，<code>原子</code>的<code>类型</code>与<code>属性</code>决定了事物的外观与表现。</p>
<p>同样，在<code>React</code>中，我们可以将<code>UI</code>拆分为很多独立的单元，每个单元被称为<code>Component</code>。这些<code>Component</code>的<code>属性</code>与<code>类型</code>决定了<code>UI</code>的外观与表现。</p>
<p>讽刺的是，<code>原子</code>在希腊语中的意思为<code>不可分割的</code>（<code>indivisible</code>），但随后科学家在原子中发现了更小的粒子 —— 电子（<code>electron</code>）。电子可以很好的解释<code>原子</code>是如何工作的。</p>
<p>在<code>React</code>中，我们可以说<code>ClassComponent</code>是一类<code>原子</code>。</p>
<p>但对于<code>Hooks</code>来说，与其说是一类<code>原子</code>，不如说他是更贴近事物<code>运行规律</code>的<code>电子</code>。</p>
<p>我们知道，<code>React</code>的架构遵循<code>schedule - render - commit</code>的运行流程，这个流程是<code>React</code>世界最底层的<code>运行规律</code>。</p>
<p><code>ClassComponent</code>作为<code>React</code>世界的<code>原子</code>，他的<code>生命周期</code>（<code>componentWillXXX</code>/<code>componentDidXXX</code>）是为了介入<code>React</code>的运行流程而实现的更上层抽象，这么做是为了方便<code>框架使用者</code>更容易上手。</p>
<p>相比于<code>ClassComponent</code>的更上层抽象，<code>Hooks</code>则更贴近<code>React</code>内部运行的各种概念（<code>state</code> | <code>context</code> | <code>life-cycle</code>）。</p>
<p>作为使用<code>React</code>技术栈的开发者，当我们初次学习<code>Hooks</code>时，不管是官方文档还是身边有经验的同事，总会拿<code>ClassComponent</code>的生命周期来类比<code>Hooks API</code>的执行时机。</p>
<p>这固然是很好的上手方式，但是当我们熟练运用<code>Hooks</code>时，就会发现，这两者的概念有很多割裂感，并不是同一抽象层次可以互相替代的概念。</p>
<p>比如：替代<code>componentWillReceiveProps</code>的<code>Hooks</code>是什么呢？</p>
<p>可能有些同学会回答，是<code>useEffect</code>：</p>
<div><pre><code>  <span>useEffect</span><span>(</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'something updated'</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>props<span>.</span>something<span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>但是<code>componentWillReceiveProps</code>是在<code>render阶段</code>执行，而<code>useEffect</code>是在<code>commit阶段</code>完成渲染后异步执行。</p>
<blockquote>
<p>这篇文章可以帮你更好理解<code>componentWillReceiveProps</code>：<a href="https://juejin.im/post/5f05a3e25188252e5c576cdb" target="_blank" rel="noopener noreferrer">深入源码剖析componentWillXXX为什么UNSAFE</a></p>
</blockquote>
<p>所以，从源码运行规律的角度看待<code>Hooks</code>，可能是更好的角度。这也是为什么上文说<code>Hooks</code>是<code>React</code>世界的<code>电子</code>而不是<code>原子</code>的原因。</p>
<blockquote>
<p>以上见解参考自<a href="https://www.youtube.com/watch?v=dpw9EHDh2bM&amp;feature=youtu.be" target="_blank" rel="noopener noreferrer">React Core Team Dan在 React Conf2018的演讲</a></p>
</blockquote>

<h2 id="总结" tabindex="-1"> 总结</h2>
<p><code>Concurrent Mode</code>是<code>React</code>未来的发展方向，而<code>Hooks</code>是能够最大限度发挥<code>Concurrent Mode</code>潜力的<code>Component</code>构建方式。</p>
<p>正如Dan在<code>React Conf 2018</code>演讲结尾所说：你可以从<code>React</code>的<code>LOGO</code>中看到这些围绕着<code>核心</code>的<code>电子飞行轨道</code>，<code>Hooks</code>可能一直就在其中。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Hooks数据结构</title>
    <id>https://0808200.xyz/react/hooks/structure.html</id>
    <link href="https://0808200.xyz/react/hooks/structure.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在上一节我们实现了一个极简的<code>useState</code>，了解了<code>Hooks</code>的运行原理。</p>
<p>本节我们讲解<code>Hooks</code>的数据结构，为后面介绍具体的<code>hook</code>打下基础。</p>
<h2 id="dispatcher" tabindex="-1"> dispatcher</h2>
<p>在上一节的极简<code>useState</code>实现中，使用<code>isMount</code>变量区分<code>mount</code>与<code>update</code>。</p>
<p>在真实的<code>Hooks</code>中，组件<code>mount</code>时的<code>hook</code>与<code>update</code>时的<code>hook</code>来源于不同的对象，这类对象在源码中被称为<code>dispatcher</code>。</p>
<div><pre><code><span>// mount时的Dispatcher</span>
<span>const</span> <span>HooksDispatcherOnMount</span><span>:</span> Dispatcher <span>=</span> <span>{</span>
  <span>useCallback</span><span>:</span> mountCallback<span>,</span>
  <span>useContext</span><span>:</span> readContext<span>,</span>
  <span>useEffect</span><span>:</span> mountEffect<span>,</span>
  <span>useImperativeHandle</span><span>:</span> mountImperativeHandle<span>,</span>
  <span>useLayoutEffect</span><span>:</span> mountLayoutEffect<span>,</span>
  <span>useMemo</span><span>:</span> mountMemo<span>,</span>
  <span>useReducer</span><span>:</span> mountReducer<span>,</span>
  <span>useRef</span><span>:</span> mountRef<span>,</span>
  <span>useState</span><span>:</span> mountState<span>,</span>
  <span>// ...省略</span>
<span>}</span><span>;</span>

<span>// update时的Dispatcher</span>
<span>const</span> <span>HooksDispatcherOnUpdate</span><span>:</span> Dispatcher <span>=</span> <span>{</span>
  <span>useCallback</span><span>:</span> updateCallback<span>,</span>
  <span>useContext</span><span>:</span> readContext<span>,</span>
  <span>useEffect</span><span>:</span> updateEffect<span>,</span>
  <span>useImperativeHandle</span><span>:</span> updateImperativeHandle<span>,</span>
  <span>useLayoutEffect</span><span>:</span> updateLayoutEffect<span>,</span>
  <span>useMemo</span><span>:</span> updateMemo<span>,</span>
  <span>useReducer</span><span>:</span> updateReducer<span>,</span>
  <span>useRef</span><span>:</span> updateRef<span>,</span>
  <span>useState</span><span>:</span> updateState<span>,</span>
  <span>// ...省略</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，<code>mount</code>时调用的<code>hook</code>和<code>update</code>时调用的<code>hook</code>其实是两个不同的函数。</p>
<p>在<code>FunctionComponent</code> <code>render</code>前，会根据<code>FunctionComponent</code>对应<code>fiber</code>的以下条件区分<code>mount</code>与<code>update</code>。</p>
<div><pre><code>current <span>===</span> <span>null</span> <span>||</span> current<span>.</span>memoizedState <span>===</span> <span>null</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>并将不同情况对应的<code>dispatcher</code>赋值给全局变量<code>ReactCurrentDispatcher</code>的<code>current</code>属性。</p>
<div><pre><code>ReactCurrentDispatcher<span>.</span>current <span>=</span>
      current <span>===</span> <span>null</span> <span>||</span> current<span>.</span>memoizedState <span>===</span> <span>null</span>
        <span>?</span> HooksDispatcherOnMount
        <span>:</span> HooksDispatcherOnUpdate<span>;</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div>
<blockquote>
<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L409" target="_blank" rel="noopener noreferrer">这里</a>看到这行代码</p>
</blockquote>
<p>在<code>FunctionComponent</code> <code>render</code>时，会从<code>ReactCurrentDispatcher.current</code>（即当前<code>dispatcher</code>）中寻找需要的<code>hook</code>。</p>
<p>换言之，不同的调用栈上下文为<code>ReactCurrentDispatcher.current</code>赋值不同的<code>dispatcher</code>，则<code>FunctionComponent</code> <code>render</code>时调用的<code>hook</code>也是不同的函数。</p>
<blockquote>
<p>除了这两个<code>dispatcher</code>，你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1775" target="_blank" rel="noopener noreferrer">这里</a>看到其他<code>dispatcher</code>定义</p>
</blockquote>
<h2 id="一个dispatcher使用场景" tabindex="-1"> 一个dispatcher使用场景</h2>
<p>当错误的书写了嵌套形式的<code>hook</code>，如：</p>
<div><pre><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>此时<code>ReactCurrentDispatcher.current</code>已经指向<code>ContextOnlyDispatcher</code>，所以调用<code>useState</code>实际会调用<code>throwInvalidHookError</code>，直接抛出异常。</p>
<div><pre><code><span>export</span> <span>const</span> <span>ContextOnlyDispatcher</span><span>:</span> Dispatcher <span>=</span> <span>{</span>
  <span>useCallback</span><span>:</span> throwInvalidHookError<span>,</span>
  <span>useContext</span><span>:</span> throwInvalidHookError<span>,</span>
  <span>useEffect</span><span>:</span> throwInvalidHookError<span>,</span>
  <span>useImperativeHandle</span><span>:</span> throwInvalidHookError<span>,</span>
  <span>useLayoutEffect</span><span>:</span> throwInvalidHookError<span>,</span>
  <span>// ...省略</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L458" target="_blank" rel="noopener noreferrer">这里</a>看到这段逻辑</p>
</blockquote>
<h2 id="hook的数据结构" tabindex="-1"> Hook的数据结构</h2>
<p>接下来我们学习<code>hook</code>的数据结构。</p>
<div><pre><code><span>const</span> <span>hook</span><span>:</span> Hook <span>=</span> <span>{</span>
  <span>memoizedState</span><span>:</span> <span>null</span><span>,</span>

  <span>baseState</span><span>:</span> <span>null</span><span>,</span>
  <span>baseQueue</span><span>:</span> <span>null</span><span>,</span>
  <span>queue</span><span>:</span> <span>null</span><span>,</span>

  <span>next</span><span>:</span> <span>null</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L546" target="_blank" rel="noopener noreferrer">这里</a>看到创建<code>hook</code>的逻辑</p>
</blockquote>
<p>其中除<code>memoizedState</code>以外字段的意义与上一章介绍的<a href="/react/state/update.html#updatequeue">updateQueue</a>类似。</p>
<h2 id="memoizedstate" tabindex="-1"> memoizedState</h2>
<div><p>注意</p>
<p><code>hook</code>与<code>FunctionComponent fiber</code>都存在<code>memoizedState</code>属性，不要混淆他们的概念。</p>
<ul>
<li>
<p><code>fiber.memoizedState</code>：<code>FunctionComponent</code>对应<code>fiber</code>保存的<code>Hooks</code>链表。</p>
</li>
<li>
<p><code>hook.memoizedState</code>：<code>Hooks</code>链表中保存的单一<code>hook</code>对应的数据。</p>
</li>
</ul>
</div>
<p>不同类型<code>hook</code>的<code>memoizedState</code>保存不同类型数据，具体如下：</p>
<ul>
<li>
<p>useState：对于<code>const [state, updateState] = useState(initialState)</code>，<code>memoizedState</code>保存<code>state</code>的值</p>
</li>
<li>
<p>useReducer：对于<code>const [state, dispatch] = useReducer(reducer, {});</code>，<code>memoizedState</code>保存<code>state</code>的值</p>
</li>
<li>
<p>useEffect：<code>memoizedState</code>保存包含<code>useEffect回调函数</code>、<code>依赖项</code>等的链表数据结构<code>effect</code>，你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1181" target="_blank" rel="noopener noreferrer">这里</a>看到<code>effect</code>的创建过程。<code>effect</code>链表同时会保存在<code>fiber.updateQueue</code>中</p>
</li>
<li>
<p>useRef：对于<code>useRef(1)</code>，<code>memoizedState</code>保存<code>{current: 1}</code></p>
</li>
<li>
<p>useMemo：对于<code>useMemo(callback, [depA])</code>，<code>memoizedState</code>保存<code>[callback(), depA]</code></p>
</li>
<li>
<p>useCallback：对于<code>useCallback(callback, [depA])</code>，<code>memoizedState</code>保存<code>[callback, depA]</code>。与<code>useMemo</code>的区别是，<code>useCallback</code>保存的是<code>callback</code>函数本身，而<code>useMemo</code>保存的是<code>callback</code>函数的执行结果</p>
</li>
</ul>
<p>有些<code>hook</code>是没有<code>memoizedState</code>的，比如：</p>
<ul>
<li>useContext</li>
</ul>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">useEffect</title>
    <id>https://0808200.xyz/react/hooks/useeffect.html</id>
    <link href="https://0808200.xyz/react/hooks/useeffect.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/react/renderer/prepare.html">架构篇commit阶段流程概览</a>我们讲解了<code>useEffect</code>的工作流程。</p>
<p>其中我们谈到</p>
<blockquote>
<p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。</p>
</blockquote>
<p>本节我们深入<code>flushPassiveEffects</code>方法内部探索<code>useEffect</code>的工作原理。</p>
<h2 id="flushpassiveeffectsimpl" tabindex="-1"> flushPassiveEffectsImpl</h2>
<p><code>flushPassiveEffects</code>内部会设置<code>优先级</code>，并执行<code>flushPassiveEffectsImpl</code>。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2458" target="_blank" rel="noopener noreferrer">这里</a>看到<code>flushPassiveEffects</code>的代码</p>
</blockquote>
<p><code>flushPassiveEffectsImpl</code>主要做三件事：</p>
<ul>
<li>
<p>调用该<code>useEffect</code>在上一次<code>render</code>时的销毁函数</p>
</li>
<li>
<p>调用该<code>useEffect</code>在本次<code>render</code>时的回调函数</p>
</li>
<li>
<p>如果存在同步任务，不需要等待下次<code>事件循环</code>的<code>宏任务</code>，提前执行他</p>
</li>
</ul>
<p>本节我们关注前两步。</p>
<p>在<code>v16</code>中第一步是同步执行的，在<a href="https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing" target="_blank" rel="noopener noreferrer">官方博客</a>中提到：</p>
<blockquote>
<p>副作用清理函数（如果存在）在 React 16 中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。</p>
</blockquote>
<p>基于这个原因，在<code>v17.0.0</code>中，<code>useEffect</code>的两个阶段会在页面渲染后（<code>layout</code>阶段后）异步执行。</p>
<blockquote>
<p>事实上，从代码中看，<code>v16.13.1</code>中已经是异步执行了</p>
</blockquote>
<p>接下来我们详细讲解这两个步骤。</p>
<h2 id="阶段一-销毁函数的执行" tabindex="-1"> 阶段一：销毁函数的执行</h2>
<p><code>useEffect</code>的执行需要保证所有组件<code>useEffect</code>的<code>销毁函数</code>必须都执行完后才能执行任意一个组件的<code>useEffect</code>的<code>回调函数</code>。</p>
<p>这是因为多个<code>组件</code>间可能共用同一个<code>ref</code>。</p>
<p>如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件<code>useEffect</code>的<code>销毁函数</code>中修改的<code>ref.current</code>可能影响另一个组件<code>useEffect</code>的<code>回调函数</code>中的同一个<code>ref</code>的<code>current</code>属性。</p>
<p>在<code>useLayoutEffect</code>中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。</p>
<p>在阶段一，会遍历并执行所有<code>useEffect</code>的<code>销毁函数</code>。</p>
<div><pre><code><span>// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect</span>
<span>const</span> unmountEffects <span>=</span> pendingPassiveHookEffectsUnmount<span>;</span>
  pendingPassiveHookEffectsUnmount <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> unmountEffects<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span><span>)</span> <span>{</span>
    <span>const</span> effect <span>=</span> <span>(</span><span>(</span>unmountEffects<span>[</span>i<span>]</span><span>:</span> any<span>)</span><span>:</span> HookEffect<span>)</span><span>;</span>
    <span>const</span> fiber <span>=</span> <span>(</span><span>(</span>unmountEffects<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>:</span> any<span>)</span><span>:</span> Fiber<span>)</span><span>;</span>
    <span>const</span> destroy <span>=</span> effect<span>.</span>destroy<span>;</span>
    effect<span>.</span>destroy <span>=</span> <span>undefined</span><span>;</span>

    <span>if</span> <span>(</span><span>typeof</span> destroy <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>// 销毁函数存在则执行</span>
      <span>try</span> <span>{</span>
        <span>destroy</span><span>(</span><span>)</span><span>;</span>
      <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
        <span>captureCommitPhaseError</span><span>(</span>fiber<span>,</span> error<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中<code>pendingPassiveHookEffectsUnmount</code>数组的索引<code>i</code>保存需要销毁的<code>effect</code>，<code>i+1</code>保存该<code>effect</code>对应的<code>fiber</code>。</p>
<p>向<code>pendingPassiveHookEffectsUnmount</code>数组内<code>push</code>数据的操作发生在<code>layout阶段</code> <code>commitLayoutEffectOnFiber</code>方法内部的<code>schedulePassiveEffects</code>方法中。</p>
<blockquote>
<p><code>commitLayoutEffectOnFiber</code>方法我们在<a href="/react/renderer/layout.html#commitlayouteffectonfiber">Layout阶段</a>已经介绍</p>
</blockquote>
<div><pre><code><span>function</span> <span>schedulePassiveEffects</span><span>(</span><span><span>finishedWork</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  <span>const</span> <span>updateQueue</span><span>:</span> FunctionComponentUpdateQueue <span>|</span> <span>null</span> <span>=</span> <span>(</span>finishedWork<span>.</span>updateQueue<span>:</span> any<span>)</span><span>;</span>
  <span>const</span> lastEffect <span>=</span> updateQueue <span>!==</span> <span>null</span> <span>?</span> updateQueue<span>.</span>lastEffect <span>:</span> <span>null</span><span>;</span>
  <span>if</span> <span>(</span>lastEffect <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>const</span> firstEffect <span>=</span> lastEffect<span>.</span>next<span>;</span>
    <span>let</span> effect <span>=</span> firstEffect<span>;</span>
    <span>do</span> <span>{</span>
      <span>const</span> <span>{</span>next<span>,</span> tag<span>}</span> <span>=</span> effect<span>;</span>
      <span>if</span> <span>(</span>
        <span>(</span>tag <span>&amp;</span> HookPassive<span>)</span> <span>!==</span> NoHookEffect <span>&amp;&amp;</span>
        <span>(</span>tag <span>&amp;</span> HookHasEffect<span>)</span> <span>!==</span> NoHookEffect
      <span>)</span> <span>{</span>
        <span>// 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect</span>
        <span>enqueuePendingPassiveHookEffectUnmount</span><span>(</span>finishedWork<span>,</span> effect<span>)</span><span>;</span>
        <span>// 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect</span>
        <span>enqueuePendingPassiveHookEffectMount</span><span>(</span>finishedWork<span>,</span> effect<span>)</span><span>;</span>
      <span>}</span>
      effect <span>=</span> next<span>;</span>
    <span>}</span> <span>while</span> <span>(</span>effect <span>!==</span> firstEffect<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="阶段二-回调函数的执行" tabindex="-1"> 阶段二：回调函数的执行</h2>
<p>与阶段一类似，同样遍历数组，执行对应<code>effect</code>的<code>回调函数</code>。</p>
<p>其中向<code>pendingPassiveHookEffectsMount</code>中<code>push</code>数据的操作同样发生在<code>schedulePassiveEffects</code>中。</p>
<div><pre><code><span>// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect</span>
<span>const</span> mountEffects <span>=</span> pendingPassiveHookEffectsMount<span>;</span>
pendingPassiveHookEffectsMount <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> mountEffects<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span><span>)</span> <span>{</span>
  <span>const</span> effect <span>=</span> <span>(</span><span>(</span>mountEffects<span>[</span>i<span>]</span><span>:</span> any<span>)</span><span>:</span> HookEffect<span>)</span><span>;</span>
  <span>const</span> fiber <span>=</span> <span>(</span><span>(</span>mountEffects<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>:</span> any<span>)</span><span>:</span> Fiber<span>)</span><span>;</span>
  
  <span>try</span> <span>{</span>
    <span>const</span> create <span>=</span> effect<span>.</span>create<span>;</span>
   effect<span>.</span>destroy <span>=</span> <span>create</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
    <span>captureCommitPhaseError</span><span>(</span>fiber<span>,</span> error<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">useMemo与useCallback</title>
    <id>https://0808200.xyz/react/hooks/usememo.html</id>
    <link href="https://0808200.xyz/react/hooks/usememo.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在了解其他<code>hook</code>的实现后，理解<code>useMemo</code>与<code>useCallback</code>的实现非常容易。</p>
<p>本节我们以<code>mount</code>与<code>update</code>两种情况分别讨论这两个<code>hook</code>。</p>
<h2 id="mount" tabindex="-1"> mount</h2>
<div><pre><code><span>function</span> mountMemo<span>&lt;</span><span>T</span><span>></span><span>(</span>
  <span>nextCreate</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>T</span><span>,</span>
  <span>deps</span><span>:</span> Array<span>&lt;</span>mixed<span>></span> <span>|</span> <span>void</span> <span>|</span> <span>null</span><span>,</span>
<span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>// 创建并返回当前hook</span>
  <span>const</span> hook <span>=</span> <span>mountWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> nextDeps <span>=</span> deps <span>===</span> <span>undefined</span> <span>?</span> <span>null</span> <span>:</span> deps<span>;</span>
  <span>// 计算value</span>
  <span>const</span> nextValue <span>=</span> <span>nextCreate</span><span>(</span><span>)</span><span>;</span>
  <span>// 将value与deps保存在hook.memoizedState</span>
  hook<span>.</span>memoizedState <span>=</span> <span>[</span>nextValue<span>,</span> nextDeps<span>]</span><span>;</span>
  <span>return</span> nextValue<span>;</span>
<span>}</span>

<span>function</span> mountCallback<span>&lt;</span><span>T</span><span>></span><span>(</span>callback<span>:</span> <span>T</span><span>,</span> <span>deps</span><span>:</span> Array<span>&lt;</span>mixed<span>></span> <span>|</span> <span>void</span> <span>|</span> <span>null</span><span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>// 创建并返回当前hook</span>
  <span>const</span> hook <span>=</span> <span>mountWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> nextDeps <span>=</span> deps <span>===</span> <span>undefined</span> <span>?</span> <span>null</span> <span>:</span> deps<span>;</span>
  <span>// 将value与deps保存在hook.memoizedState</span>
  hook<span>.</span>memoizedState <span>=</span> <span>[</span>callback<span>,</span> nextDeps<span>]</span><span>;</span>
  <span>return</span> callback<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，与<code>mountCallback</code>这两个唯一的区别是</p>
<ul>
<li>
<p><code>mountMemo</code>会将<code>回调函数</code>(nextCreate)的执行结果作为<code>value</code>保存</p>
</li>
<li>
<p><code>mountCallback</code>会将<code>回调函数</code>作为<code>value</code>保存</p>
</li>
</ul>
<h2 id="update" tabindex="-1"> update</h2>
<div><pre><code><span>function</span> updateMemo<span>&lt;</span><span>T</span><span>></span><span>(</span>
  <span>nextCreate</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>T</span><span>,</span>
  <span>deps</span><span>:</span> Array<span>&lt;</span>mixed<span>></span> <span>|</span> <span>void</span> <span>|</span> <span>null</span><span>,</span>
<span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>// 返回当前hook</span>
  <span>const</span> hook <span>=</span> <span>updateWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> nextDeps <span>=</span> deps <span>===</span> <span>undefined</span> <span>?</span> <span>null</span> <span>:</span> deps<span>;</span>
  <span>const</span> prevState <span>=</span> hook<span>.</span>memoizedState<span>;</span>

  <span>if</span> <span>(</span>prevState <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextDeps <span>!==</span> <span>null</span><span>)</span> <span>{</span>
      <span>const</span> <span>prevDeps</span><span>:</span> Array<span>&lt;</span>mixed<span>></span> <span>|</span> <span>null</span> <span>=</span> prevState<span>[</span><span>1</span><span>]</span><span>;</span>
      <span>// 判断update前后value是否变化</span>
      <span>if</span> <span>(</span><span>areHookInputsEqual</span><span>(</span>nextDeps<span>,</span> prevDeps<span>)</span><span>)</span> <span>{</span>
        <span>// 未变化</span>
        <span>return</span> prevState<span>[</span><span>0</span><span>]</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>// 变化，重新计算value</span>
  <span>const</span> nextValue <span>=</span> <span>nextCreate</span><span>(</span><span>)</span><span>;</span>
  hook<span>.</span>memoizedState <span>=</span> <span>[</span>nextValue<span>,</span> nextDeps<span>]</span><span>;</span>
  <span>return</span> nextValue<span>;</span>
<span>}</span>

<span>function</span> updateCallback<span>&lt;</span><span>T</span><span>></span><span>(</span>callback<span>:</span> <span>T</span><span>,</span> <span>deps</span><span>:</span> Array<span>&lt;</span>mixed<span>></span> <span>|</span> <span>void</span> <span>|</span> <span>null</span><span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>// 返回当前hook</span>
  <span>const</span> hook <span>=</span> <span>updateWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> nextDeps <span>=</span> deps <span>===</span> <span>undefined</span> <span>?</span> <span>null</span> <span>:</span> deps<span>;</span>
  <span>const</span> prevState <span>=</span> hook<span>.</span>memoizedState<span>;</span>

  <span>if</span> <span>(</span>prevState <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextDeps <span>!==</span> <span>null</span><span>)</span> <span>{</span>
      <span>const</span> <span>prevDeps</span><span>:</span> Array<span>&lt;</span>mixed<span>></span> <span>|</span> <span>null</span> <span>=</span> prevState<span>[</span><span>1</span><span>]</span><span>;</span>
      <span>// 判断update前后value是否变化</span>
      <span>if</span> <span>(</span><span>areHookInputsEqual</span><span>(</span>nextDeps<span>,</span> prevDeps<span>)</span><span>)</span> <span>{</span>
        <span>// 未变化</span>
        <span>return</span> prevState<span>[</span><span>0</span><span>]</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>// 变化，将新的callback作为value</span>
  hook<span>.</span>memoizedState <span>=</span> <span>[</span>callback<span>,</span> nextDeps<span>]</span><span>;</span>
  <span>return</span> callback<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，对于<code>update</code>，这两个<code>hook</code>的唯一区别也是<strong>是回调函数本身还是回调函数的执行结果作为value</strong>。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">useRef</title>
    <id>https://0808200.xyz/react/hooks/useref.html</id>
    <link href="https://0808200.xyz/react/hooks/useref.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p><code>ref</code>是<code>reference</code>（引用）的缩写。在<code>React</code>中，我们习惯用<code>ref</code>保存<code>DOM</code>。</p>
<p>事实上，任何需要被&quot;引用&quot;的数据都可以保存在<code>ref</code>中，<code>useRef</code>的出现将这种思想进一步发扬光大。</p>
<p>在<a href="/react/hooks/structure.html#memoizedstate">Hooks数据结构一节</a>我们讲到：</p>
<blockquote>
<p>对于<code>useRef(1)</code>，<code>memoizedState</code>保存<code>{current: 1}</code></p>
</blockquote>
<p>本节我们会介绍<code>useRef</code>的实现，以及<code>ref</code>的工作流程。</p>
<p>由于<code>string</code>类型的<code>ref</code>已不推荐使用，所以本节针对<code>function | {current: any}</code>类型的<code>ref</code>。</p>
<h2 id="useref" tabindex="-1"> useRef</h2>
<p>与其他<code>Hook</code>一样，对于<code>mount</code>与<code>update</code>，<code>useRef</code>对应两个不同<code>dispatcher</code>。</p>
<div><pre><code><span>function</span> mountRef<span>&lt;</span><span>T</span><span>></span><span>(</span>initialValue<span>:</span> <span>T</span><span>)</span><span>:</span> <span>{</span><span>|</span>current<span>:</span> <span>T</span><span>|</span><span>}</span> <span>{</span>
  <span>// 获取当前useRef hook</span>
  <span>const</span> hook <span>=</span> <span>mountWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>// 创建ref</span>
  <span>const</span> ref <span>=</span> <span>{</span><span>current</span><span>:</span> initialValue<span>}</span><span>;</span>
  hook<span>.</span>memoizedState <span>=</span> ref<span>;</span>
  <span>return</span> ref<span>;</span>
<span>}</span>

<span>function</span> updateRef<span>&lt;</span><span>T</span><span>></span><span>(</span>initialValue<span>:</span> <span>T</span><span>)</span><span>:</span> <span>{</span><span>|</span>current<span>:</span> <span>T</span><span>|</span><span>}</span> <span>{</span>
  <span>// 获取当前useRef hook</span>
  <span>const</span> hook <span>=</span> <span>updateWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>// 返回保存的数据</span>
  <span>return</span> hook<span>.</span>memoizedState<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L1208-L1221" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>可见，<code>useRef</code>仅仅是返回一个包含<code>current</code>属性的对象。</p>
<p>为了验证这个观点，我们再看下<code>React.createRef</code>方法的实现：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createRef</span><span>(</span><span>)</span><span>:</span> RefObject <span>{</span>
  <span>const</span> refObject <span>=</span> <span>{</span>
    <span>current</span><span>:</span> <span>null</span><span>,</span>
  <span>}</span><span>;</span>
  <span>return</span> refObject<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactCreateRef.js" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>了解了<code>ref</code>的数据结构后，我们再来看看<code>ref</code>的工作流程。</p>
<h2 id="ref的工作流程" tabindex="-1"> ref的工作流程</h2>
<p>在<code>React</code>中，<code>HostComponent</code>、<code>ClassComponent</code>、<code>ForwardRef</code>可以赋值<code>ref</code>属性。</p>
<div><pre><code><span>// HostComponent</span>
<span>&lt;</span>div ref<span>=</span><span>{</span>domRef<span>}</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>
<span>// ClassComponent / ForwardRef</span>
<span>&lt;</span>App ref<span>=</span><span>{</span>cpnRef<span>}</span> <span>/</span><span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>其中，<code>ForwardRef</code>只是将<code>ref</code>作为第二个参数传递下去，不会进入<code>ref</code>的工作流程。</p>
<p>所以接下来讨论<code>ref</code>的工作流程时会排除<code>ForwardRef</code>。</p>
<div><pre><code><span>// 对于ForwardRef，secondArg为传递下去的ref</span>
<span>let</span> children <span>=</span> <span>Component</span><span>(</span>props<span>,</span> secondArg<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L415" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>我们知道<code>HostComponent</code>在<code>commit阶段</code>的<code>mutation阶段</code>执行<code>DOM</code>操作。</p>
<p>所以，对应<code>ref</code>的更新也是发生在<code>mutation阶段</code>。</p>
<p>再进一步，<code>mutation阶段</code>执行<code>DOM</code>操作的依据为<code>effectTag</code>。</p>
<p>所以，对于<code>HostComponent</code>、<code>ClassComponent</code>如果包含<code>ref</code>操作，那么也会赋值相应的<code>effectTag</code>。</p>
<div><pre><code><span>// ...</span>
<span>export</span> <span>const</span> Placement <span>=</span> <span>/*                    */</span> <span>0b0000000000000010</span><span>;</span>
<span>export</span> <span>const</span> Update <span>=</span> <span>/*                       */</span> <span>0b0000000000000100</span><span>;</span>
<span>export</span> <span>const</span> Deletion <span>=</span> <span>/*                     */</span> <span>0b0000000000001000</span><span>;</span>
<span>export</span> <span>const</span> Ref <span>=</span> <span>/*                          */</span> <span>0b0000000010000000</span><span>;</span>
<span>// ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js#L24" target="_blank" rel="noopener noreferrer">ReactSideEffectTags文件</a>中看到<code>ref</code>对应的<code>effectTag</code></p>
</blockquote>
<p>所以，<code>ref</code>的工作流程可以分为两部分：</p>
<ul>
<li>
<p><code>render阶段</code>为含有<code>ref</code>属性的<code>fiber</code>添加<code>Ref effectTag</code></p>
</li>
<li>
<p><code>commit阶段</code>为包含<code>Ref effectTag</code>的<code>fiber</code>执行对应操作</p>
</li>
</ul>
<h2 id="render阶段" tabindex="-1"> render阶段</h2>
<p>在<code>render阶段</code>的<code>beginWork</code>与<code>completeWork</code>中有个同名方法<code>markRef</code>用于为含有<code>ref</code>属性的<code>fiber</code>增加<code>Ref effectTag</code>。</p>
<div><pre><code><span>// beginWork的markRef</span>
<span>function</span> <span>markRef</span><span>(</span><span><span>current</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span> <span>workInProgress</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  <span>const</span> ref <span>=</span> workInProgress<span>.</span>ref<span>;</span>
  <span>if</span> <span>(</span>
    <span>(</span>current <span>===</span> <span>null</span> <span>&amp;&amp;</span> ref <span>!==</span> <span>null</span><span>)</span> <span>||</span>
    <span>(</span>current <span>!==</span> <span>null</span> <span>&amp;&amp;</span> current<span>.</span>ref <span>!==</span> ref<span>)</span>
  <span>)</span> <span>{</span>
    <span>// Schedule a Ref effect</span>
    workInProgress<span>.</span>effectTag <span>|=</span> Ref<span>;</span>
  <span>}</span>
<span>}</span>
<span>// completeWork的markRef</span>
<span>function</span> <span>markRef</span><span>(</span><span><span>workInProgress</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  workInProgress<span>.</span>effectTag <span>|=</span> Ref<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L693" target="_blank" rel="noopener noreferrer">这里</a>看到<code>beginWork</code>的<code>markRef</code>、<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L153" target="_blank" rel="noopener noreferrer">这里</a>看到<code>completeWork</code>的<code>markRef</code></p>
</blockquote>
<p>在<code>beginWork</code>中，如下两处调用了<code>markRef</code>：</p>
<ul>
<li><code>updateClassComponent</code>内的<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L958" target="_blank" rel="noopener noreferrer">finishClassComponent</a>，对应<code>ClassComponent</code></li>
</ul>
<p>注意<code>ClassComponent</code>即使<code>shouldComponentUpdate</code>为<code>false</code>该组件也会调用<code>markRef</code></p>
<ul>
<li><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L1156" target="_blank" rel="noopener noreferrer">updateHostComponent</a>，对应<code>HostComponent</code></li>
</ul>
<p>在<code>completeWork</code>中，如下两处调用了<code>markRef</code>：</p>
<ul>
<li>
<p><code>completeWork</code>中的<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L728" target="_blank" rel="noopener noreferrer">HostComponent</a>类型</p>
</li>
<li>
<p><code>completeWork</code>中的<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L1278" target="_blank" rel="noopener noreferrer">ScopeComponent</a>类型</p>
</li>
</ul>
<blockquote>
<p><code>ScopeComponent</code>是一种用于管理<code>focus</code>的测试特性，详见<a href="https://github.com/facebook/react/pull/16587" target="_blank" rel="noopener noreferrer">PR</a></p>
</blockquote>
<p>总结下<code>组件</code>对应<code>fiber</code>被赋值<code>Ref effectTag</code>需要满足的条件：</p>
<ul>
<li>
<p><code>fiber</code>类型为<code>HostComponent</code>、<code>ClassComponent</code>、<code>ScopeComponent</code>（这种情况我们不讨论）</p>
</li>
<li>
<p>对于<code>mount</code>，<code>workInProgress.ref !== null</code>，即存在<code>ref</code>属性</p>
</li>
<li>
<p>对于<code>update</code>，<code>current.ref !== workInProgress.ref</code>，即<code>ref</code>属性改变</p>
</li>
</ul>
<h2 id="commit阶段" tabindex="-1"> commit阶段</h2>
<p>在<code>commit阶段</code>的<code>mutation阶段</code>中，对于<code>ref</code>属性改变的情况，需要先移除之前的<code>ref</code>。</p>
<div><pre><code><span>function</span> <span>commitMutationEffects</span><span>(</span><span><span>root</span><span>:</span> FiberRoot<span>,</span> renderPriorityLevel</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>nextEffect <span>!==</span> <span>null</span><span>)</span> <span>{</span>

    <span>const</span> effectTag <span>=</span> nextEffect<span>.</span>effectTag<span>;</span>
    <span>// ...</span>

    <span>if</span> <span>(</span>effectTag <span>&amp;</span> Ref<span>)</span> <span>{</span>
      <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>
      <span>if</span> <span>(</span>current <span>!==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 移除之前的ref</span>
        <span>commitDetachRef</span><span>(</span>current<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>// ...</span>
  <span>}</span>
  <span>// ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2342" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<div><pre><code><span>function</span> <span>commitDetachRef</span><span>(</span><span><span>current</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  <span>const</span> currentRef <span>=</span> current<span>.</span>ref<span>;</span>
  <span>if</span> <span>(</span>currentRef <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>typeof</span> currentRef <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>// function类型ref，调用他，传参为null</span>
      <span>currentRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// 对象类型ref，current赋值为null</span>
      currentRef<span>.</span>current <span>=</span> <span>null</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>接下来，在<code>mutation阶段</code>，对于<code>Deletion effectTag</code>的<code>fiber</code>（对应需要删除的<code>DOM节点</code>），需要递归他的子树，对子孙<code>fiber</code>的<code>ref</code>执行类似<code>commitDetachRef</code>的操作。</p>
<p>在<a href="/react/hooks/renderer/mutation.html#commitmutationeffects">mutation阶段一节</a>我们讲到</p>
<blockquote>
<p>对于<code>Deletion effectTag</code>的<code>fiber</code>，会执行<code>commitDeletion</code>。</p>
</blockquote>
<p>在<code>commitDeletion</code>——<code>unmountHostComponents</code>——<code>commitUnmount</code>——<code>ClassComponent | HostComponent</code>类型<code>case</code>中调用的<code>safelyDetachRef</code>方法负责执行类似<code>commitDetachRef</code>的操作。</p>
<div><pre><code><span>function</span> <span>safelyDetachRef</span><span>(</span><span><span>current</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  <span>const</span> ref <span>=</span> current<span>.</span>ref<span>;</span>
  <span>if</span> <span>(</span>ref <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>typeof</span> ref <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>try</span> <span>{</span>
        <span>ref</span><span>(</span><span>null</span><span>)</span><span>;</span>
      <span>}</span> <span>catch</span> <span>(</span>refError<span>)</span> <span>{</span>
        <span>captureCommitPhaseError</span><span>(</span>current<span>,</span> refError<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      ref<span>.</span>current <span>=</span> <span>null</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L183" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>接下来进入<code>ref</code>的赋值阶段。我们在<a href="/react/renderer/layout.html#commitlayouteffects">Layout阶段一节</a>讲到</p>
<blockquote>
<p><code>commitLayoutEffect</code>会执行<code>commitAttachRef</code>（赋值<code>ref</code>）</p>
</blockquote>
<div><pre><code><span>function</span> <span>commitAttachRef</span><span>(</span><span><span>finishedWork</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  <span>const</span> ref <span>=</span> finishedWork<span>.</span>ref<span>;</span>
  <span>if</span> <span>(</span>ref <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>// 获取ref属性对应的Component实例</span>
    <span>const</span> instance <span>=</span> finishedWork<span>.</span>stateNode<span>;</span>
    <span>let</span> instanceToUse<span>;</span>
    <span>switch</span> <span>(</span>finishedWork<span>.</span>tag<span>)</span> <span>{</span>
      <span>case</span> <span>HostComponent</span><span>:</span>
        instanceToUse <span>=</span> <span>getPublicInstance</span><span>(</span>instance<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>default</span><span>:</span>
        instanceToUse <span>=</span> instance<span>;</span>
    <span>}</span>

    <span>// 赋值ref</span>
    <span>if</span> <span>(</span><span>typeof</span> ref <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>ref</span><span>(</span>instanceToUse<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      ref<span>.</span>current <span>=</span> instanceToUse<span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>至此，<code>ref</code>的工作流程完毕。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>本节我们学习了<code>ref</code>的工作流程。</p>
<ul>
<li>
<p>对于<code>FunctionComponent</code>，<code>useRef</code>负责创建并返回对应的<code>ref</code>。</p>
</li>
<li>
<p>对于赋值了<code>ref</code>属性的<code>HostComponent</code>与<code>ClassComponent</code>，会在<code>render阶段</code>经历赋值<code>Ref effectTag</code>，在<code>commit阶段</code>执行对应<code>ref</code>操作。</p>
</li>
</ul>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">useState与useReducer</title>
    <id>https://0808200.xyz/react/hooks/usestate.html</id>
    <link href="https://0808200.xyz/react/hooks/usestate.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p><code>Redux</code>的作者<code>Dan</code>加入<code>React</code>核心团队后的一大贡献就是“将<code>Redux</code>的理念带入<code>React</code>”。</p>
<p>这里面最显而易见的影响莫过于<code>useState</code>与<code>useReducer</code>这两个<code>Hook</code>。本质来说，<code>useState</code>只是预置了<code>reducer</code>的<code>useReducer</code>。</p>
<p>本节我们来学习<code>useState</code>与<code>useReducer</code>的实现。</p>
<h2 id="流程概览" tabindex="-1"> 流程概览</h2>
<p>我们将这两个<code>Hook</code>的工作流程分为<code>声明阶段</code>和<code>调用阶段</code>，对于：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>state<span>,</span> dispatch<span>]</span> <span>=</span> <span>useReducer</span><span>(</span>reducer<span>,</span> <span>{</span><span>a</span><span>:</span> <span>1</span><span>}</span><span>)</span><span>;</span>

  <span>const</span> <span>[</span>num<span>,</span> updateNum<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>></span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span><span>{</span><span>type</span><span>:</span> <span>'a'</span><span>}</span><span>)</span><span>}</span><span>></span><span>{</span>state<span>.</span>a<span>}</span><span>&lt;</span><span>/</span>button<span>></span>  
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>button<span>></span>  
    <span>&lt;</span><span>/</span>div<span>></span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>声明阶段</code>即<code>App</code>调用时，会依次执行<code>useReducer</code>与<code>useState</code>方法。</p>
<p><code>调用阶段</code>即点击按钮后，<code>dispatch</code>或<code>updateNum</code>被调用时。</p>
<h2 id="声明阶段" tabindex="-1"> 声明阶段</h2>
<p>当<code>FunctionComponent</code>进入<code>render阶段</code>的<code>beginWork</code>时，会调用<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1419" target="_blank" rel="noopener noreferrer">renderWithHooks</a>方法。</p>
<p>该方法内部会执行<code>FunctionComponent</code>对应函数（即<code>fiber.type</code>）。</p>
<blockquote>
<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L415" target="_blank" rel="noopener noreferrer">这里</a>看到这段逻辑</p>
</blockquote>
<p>对于这两个<code>Hook</code>，他们的源码如下：</p>
<div><pre><code><span>function</span> <span>useState</span><span>(</span><span>initialState</span><span>)</span> <span>{</span>
  <span>var</span> dispatcher <span>=</span> <span>resolveDispatcher</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> dispatcher<span>.</span><span>useState</span><span>(</span>initialState<span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>useReducer</span><span>(</span><span>reducer<span>,</span> initialArg<span>,</span> init</span><span>)</span> <span>{</span>
  <span>var</span> dispatcher <span>=</span> <span>resolveDispatcher</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> dispatcher<span>.</span><span>useReducer</span><span>(</span>reducer<span>,</span> initialArg<span>,</span> init<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>正如上一节<a href="/react/hooks/structure.html#dispatcher">dispatcher</a>所说，在不同场景下，同一个<code>Hook</code>会调用不同处理函数。</p>
<p>我们分别讲解<code>mount</code>与<code>update</code>两个场景。</p>
<h3 id="mount时" tabindex="-1"> mount时</h3>
<p><code>mount</code>时，<code>useReducer</code>会调用<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L638" target="_blank" rel="noopener noreferrer">mountReducer</a>，<code>useState</code>会调用<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1143" target="_blank" rel="noopener noreferrer">mountState</a>。</p>
<p>我们来简单对比这这两个方法：</p>
<div><pre><code><span>function</span> mountState<span>&lt;</span><span>S</span><span>></span><span>(</span>
  <span>initialState</span><span>:</span> <span>(</span><span>(</span><span>)</span> <span>=></span> <span>S</span><span>)</span> <span>|</span> <span>S</span><span>,</span>
<span>)</span><span>:</span> <span>[</span><span>S</span><span>,</span> Dispatch<span>&lt;</span>BasicStateAction<span>&lt;</span><span>S</span><span>>></span><span>]</span> <span>{</span>
  <span>// 创建并返回当前的hook</span>
  <span>const</span> hook <span>=</span> <span>mountWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>

  <span>// ...赋值初始state</span>

  <span>// 创建queue</span>
  <span>const</span> queue <span>=</span> <span>(</span>hook<span>.</span>queue <span>=</span> <span>{</span>
    <span>pending</span><span>:</span> <span>null</span><span>,</span>
    <span>dispatch</span><span>:</span> <span>null</span><span>,</span>
    <span>lastRenderedReducer</span><span>:</span> basicStateReducer<span>,</span>
    <span>lastRenderedState</span><span>:</span> <span>(</span>initialState<span>:</span> any<span>)</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>

  <span>// ...创建dispatch</span>
  <span>return</span> <span>[</span>hook<span>.</span>memoizedState<span>,</span> dispatch<span>]</span><span>;</span>
<span>}</span>

<span>function</span> mountReducer<span>&lt;</span><span>S</span><span>,</span> <span>I</span><span>,</span> <span>A</span><span>></span><span>(</span>
  <span>reducer</span><span>:</span> <span>(</span><span><span>S</span><span>,</span> <span>A</span></span><span>)</span> <span>=></span> <span>S</span><span>,</span>
  <span>initialArg</span><span>:</span> <span>I</span><span>,</span>
  init<span>?</span><span>:</span> <span><span>I</span></span> <span>=></span> <span>S</span><span>,</span>
<span>)</span><span>:</span> <span>[</span><span>S</span><span>,</span> Dispatch<span>&lt;</span><span>A</span><span>></span><span>]</span> <span>{</span>
  <span>// 创建并返回当前的hook</span>
  <span>const</span> hook <span>=</span> <span>mountWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>

  <span>// ...赋值初始state</span>

  <span>// 创建queue</span>
  <span>const</span> queue <span>=</span> <span>(</span>hook<span>.</span>queue <span>=</span> <span>{</span>
    <span>pending</span><span>:</span> <span>null</span><span>,</span>
    <span>dispatch</span><span>:</span> <span>null</span><span>,</span>
    <span>lastRenderedReducer</span><span>:</span> reducer<span>,</span>
    <span>lastRenderedState</span><span>:</span> <span>(</span>initialState<span>:</span> any<span>)</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>

  <span>// ...创建dispatch</span>
  <span>return</span> <span>[</span>hook<span>.</span>memoizedState<span>,</span> dispatch<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中<code>mountWorkInProgressHook</code>方法会创建并返回对应<code>hook</code>，对应<code>极简Hooks实现</code>中<code>useState</code>方法的<code>isMount</code>逻辑部分。</p>
<p>可以看到，<code>mount</code>时这两个<code>Hook</code>的唯一区别为<code>queue</code>参数的<code>lastRenderedReducer</code>字段。</p>
<p><code>queue</code>的数据结构如下：</p>
<div><pre><code><span>const</span> queue <span>=</span> <span>(</span>hook<span>.</span>queue <span>=</span> <span>{</span>
  <span>// 与极简实现中的同名字段意义相同，保存update对象</span>
  <span>pending</span><span>:</span> <span>null</span><span>,</span>
  <span>// 保存dispatchAction.bind()的值</span>
  <span>dispatch</span><span>:</span> <span>null</span><span>,</span>
  <span>// 上一次render时使用的reducer</span>
  <span>lastRenderedReducer</span><span>:</span> reducer<span>,</span>
  <span>// 上一次render时的state</span>
  <span>lastRenderedState</span><span>:</span> <span>(</span>initialState<span>:</span> any<span>)</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中，<code>useReducer</code>的<code>lastRenderedReducer</code>为传入的<code>reducer</code>参数。<code>useState</code>的<code>lastRenderedReducer</code>为<code>basicStateReducer</code>。</p>
<p><code>basicStateReducer</code>方法如下：</p>
<div><pre><code><span>function</span> basicStateReducer<span>&lt;</span><span>S</span><span>></span><span>(</span>state<span>:</span> <span>S</span><span>,</span> <span>action</span><span>:</span> BasicStateAction<span>&lt;</span><span>S</span><span>></span><span>)</span><span>:</span> <span>S</span> <span>{</span>
  <span>return</span> <span>typeof</span> action <span>===</span> <span>'function'</span> <span>?</span> <span>action</span><span>(</span>state<span>)</span> <span>:</span> action<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可见，<code>useState</code>即<code>reducer</code>参数为<code>basicStateReducer</code>的<code>useReducer</code>。</p>
<p><code>mount</code>时的整体运行逻辑与<code>极简实现</code>的<code>isMount</code>逻辑类似，你可以对照着看。</p>
<h3 id="update时" tabindex="-1"> update时</h3>
<p>如果说<code>mount</code>时这两者还有区别，那<code>update</code>时，<code>useReducer</code>与<code>useState</code>调用的则是同一个函数<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L665" target="_blank" rel="noopener noreferrer">updateReducer</a>。</p>
<div><pre><code><span>function</span> updateReducer<span>&lt;</span><span>S</span><span>,</span> <span>I</span><span>,</span> <span>A</span><span>></span><span>(</span>
  <span>reducer</span><span>:</span> <span>(</span><span><span>S</span><span>,</span> <span>A</span></span><span>)</span> <span>=></span> <span>S</span><span>,</span>
  <span>initialArg</span><span>:</span> <span>I</span><span>,</span>
  init<span>?</span><span>:</span> <span><span>I</span></span> <span>=></span> <span>S</span><span>,</span>
<span>)</span><span>:</span> <span>[</span><span>S</span><span>,</span> Dispatch<span>&lt;</span><span>A</span><span>></span><span>]</span> <span>{</span>
  <span>// 获取当前hook</span>
  <span>const</span> hook <span>=</span> <span>updateWorkInProgressHook</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> queue <span>=</span> hook<span>.</span>queue<span>;</span>
  
  queue<span>.</span>lastRenderedReducer <span>=</span> reducer<span>;</span>

  <span>// ...同update与updateQueue类似的更新逻辑</span>

  <span>const</span> <span>dispatch</span><span>:</span> Dispatch<span>&lt;</span><span>A</span><span>></span> <span>=</span> <span>(</span>queue<span>.</span>dispatch<span>:</span> any<span>)</span><span>;</span>
  <span>return</span> <span>[</span>hook<span>.</span>memoizedState<span>,</span> dispatch<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>整个流程可以概括为一句话：</p>
<blockquote>
<p>找到对应的<code>hook</code>，根据<code>update</code>计算该<code>hook</code>的新<code>state</code>并返回。</p>
</blockquote>
<p><code>mount</code>时获取当前<code>hook</code>使用的是<code>mountWorkInProgressHook</code>，而<code>update</code>时使用的是<code>updateWorkInProgressHook</code>，这里的原因是：</p>
<ul>
<li>
<p><code>mount</code>时可以确定是调用<code>ReactDOM.render</code>或相关初始化<code>API</code>产生的<code>更新</code>，只会执行一次。</p>
</li>
<li>
<p><code>update</code>可能是在事件回调或副作用中触发的<code>更新</code>或者是<code>render阶段</code>触发的<code>更新</code>，为了避免组件无限循环<code>更新</code>，后者需要区别对待。</p>
</li>
</ul>
<p>举个<code>render阶段</code>触发的<code>更新</code>的例子：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>num<span>,</span> updateNum<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>updateNum</span><span>(</span>num <span>+</span> <span>1</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>button<span>></span>  
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在这个例子中，<code>App</code>调用时，代表已经进入<code>render阶段</code>执行<code>renderWithHooks</code>。</p>
<p>在<code>App</code>内部，调用<code>updateNum</code>会触发一次<code>更新</code>。如果不对这种情况下触发的更新作出限制，那么这次<code>更新</code>会开启一次新的<code>render阶段</code>，最终会无限循环更新。</p>
<p>基于这个原因，<code>React</code>用一个标记变量<code>didScheduleRenderPhaseUpdate</code>判断是否是<code>render阶段</code>触发的更新。</p>
<p><code>updateWorkInProgressHook</code>方法也会区分这两种情况来获取对应<code>hook</code>。</p>
<p>获取对应<code>hook</code>，接下来会根据<code>hook</code>中保存的<code>state</code>计算新的<code>state</code>，这个步骤同<a href="/react/state/update.html">Update一节</a>一致。</p>
<h2 id="调用阶段" tabindex="-1"> 调用阶段</h2>
<p>调用阶段会执行<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1662" target="_blank" rel="noopener noreferrer">dispatchAction</a>，此时该<code>FunctionComponent</code>对应的<code>fiber</code>以及<code>hook.queue</code>已经通过调用<code>bind</code>方法预先作为参数传入。</p>
<div><pre><code><span>function</span> <span>dispatchAction</span><span>(</span><span>fiber<span>,</span> queue<span>,</span> action</span><span>)</span> <span>{</span>

  <span>// ...创建update</span>
  <span>var</span> update <span>=</span> <span>{</span>
    <span>eventTime</span><span>:</span> eventTime<span>,</span>
    <span>lane</span><span>:</span> lane<span>,</span>
    <span>suspenseConfig</span><span>:</span> suspenseConfig<span>,</span>
    <span>action</span><span>:</span> action<span>,</span>
    <span>eagerReducer</span><span>:</span> <span>null</span><span>,</span>
    <span>eagerState</span><span>:</span> <span>null</span><span>,</span>
    <span>next</span><span>:</span> <span>null</span>
  <span>}</span><span>;</span> 

  <span>// ...将update加入queue.pending</span>
  
  <span>var</span> alternate <span>=</span> fiber<span>.</span>alternate<span>;</span>

  <span>if</span> <span>(</span>fiber <span>===</span> currentlyRenderingFiber$1 <span>||</span> alternate <span>!==</span> <span>null</span> <span>&amp;&amp;</span> alternate <span>===</span> currentlyRenderingFiber$1<span>)</span> <span>{</span>
    <span>// render阶段触发的更新</span>
    didScheduleRenderPhaseUpdateDuringThisPass <span>=</span> didScheduleRenderPhaseUpdate <span>=</span> <span>true</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>if</span> <span>(</span>fiber<span>.</span>lanes <span>===</span> NoLanes <span>&amp;&amp;</span> <span>(</span>alternate <span>===</span> <span>null</span> <span>||</span> alternate<span>.</span>lanes <span>===</span> NoLanes<span>)</span><span>)</span> <span>{</span>
      <span>// ...fiber的updateQueue为空，优化路径</span>
    <span>}</span>

    <span>scheduleUpdateOnFiber</span><span>(</span>fiber<span>,</span> lane<span>,</span> eventTime<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>整个过程可以概括为：</p>
<blockquote>
<p>创建<code>update</code>，将<code>update</code>加入<code>queue.pending</code>中，并开启调度。</p>
</blockquote>
<p>这里值得注意的是<code>if...else...</code>逻辑，其中：</p>
<div><pre><code><span>if</span> <span>(</span>fiber <span>===</span> currentlyRenderingFiber$1 <span>||</span> alternate <span>!==</span> <span>null</span> <span>&amp;&amp;</span> alternate <span>===</span> currentlyRenderingFiber$1<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>currentlyRenderingFiber</code>即<code>workInProgress</code>，<code>workInProgress</code>存在代表当前处于<code>render阶段</code>。</p>
<p>触发<code>更新</code>时通过<code>bind</code>预先保存的<code>fiber</code>与<code>workInProgress</code>全等，代表本次<code>更新</code>发生于<code>FunctionComponent</code>对应<code>fiber</code>的<code>render阶段</code>。</p>
<p>所以这是一个<code>render阶段</code>触发的<code>更新</code>，需要标记变量<code>didScheduleRenderPhaseUpdate</code>，后续单独处理。</p>
<p>再来关注：</p>
<div><pre><code><span>if</span> <span>(</span>fiber<span>.</span>lanes <span>===</span> NoLanes <span>&amp;&amp;</span> <span>(</span>alternate <span>===</span> <span>null</span> <span>||</span> alternate<span>.</span>lanes <span>===</span> NoLanes<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>fiber.lanes</code>保存<code>fiber</code>上存在的<code>update</code>的<code>优先级</code>。</p>
<p><code>fiber.lanes === NoLanes</code>意味着<code>fiber</code>上不存在<code>update</code>。</p>
<p>我们已经知道，通过<code>update</code>计算<code>state</code>发生在<code>声明阶段</code>，这是因为该<code>hook</code>上可能存在多个不同<code>优先级</code>的<code>update</code>，最终<code>state</code>的值由多个<code>update</code>共同决定。</p>
<p>但是当<code>fiber</code>上不存在<code>update</code>，则<code>调用阶段</code>创建的<code>update</code>为该<code>hook</code>上第一个<code>update</code>，在<code>声明阶段</code>计算<code>state</code>时也只依赖于该<code>update</code>，完全不需要进入<code>声明阶段</code>再计算<code>state</code>。</p>
<p>这样做的好处是：如果计算出的<code>state</code>与该<code>hook</code>之前保存的<code>state</code>一致，那么完全不需要开启一次调度。即使计算出的<code>state</code>与该<code>hook</code>之前保存的<code>state</code>不一致，在<code>声明阶段</code>也可以直接使用<code>调用阶段</code>已经计算出的<code>state</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1727" target="_blank" rel="noopener noreferrer">这里</a>看到这段提前计算<code>state</code>的逻辑</p>
</blockquote>
<h2 id="小tip" tabindex="-1"> 小Tip</h2>
<p>我们通常认为，<code>useReducer(reducer, initialState)</code>的传参为初始化参数，在以后的调用中都不可变。</p>
<p>但是在<code>updateReducer</code>方法中，可以看到<code>lastRenderedReducer</code>在每次调用时都会重新赋值。</p>
<div><pre><code><span>function</span> <span>updateReducer</span><span>(</span><span>reducer<span>,</span> initialArg<span>,</span> init</span><span>)</span> <span>{</span>
  <span>// ...</span>

  queue<span>.</span>lastRenderedReducer <span>=</span> reducer<span>;</span>

  <span>// ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，<code>reducer</code>参数是随时可变的。</p>
<details><summary>reducer可变Demo</summary>
<p>每秒<code>useReducer</code>使用的<code>reducer</code>会改变一次</p>
<p>点击按钮后会随时间不同会出现<code>+1</code>或<code>-1</code>的效果</p>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>582</strong>获得在线Demo地址</p>
</details>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">源码的文件结构</title>
    <id>https://0808200.xyz/react/preparation/file.html</id>
    <link href="https://0808200.xyz/react/preparation/file.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>经过之前的学习，我们已经知道<code>React16</code>的架构分为三层：</p>
<ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>那么架构是如何体现在源码的文件结构上呢，让我们一起看看吧。</p>
<h2 id="顶层目录" tabindex="-1"> 顶层目录</h2>
<p>除去配置文件和隐藏文件夹，根目录的文件夹包括三个：</p>
<div><pre><code>根目录
├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目
├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）
├── scripts         # 各种工具链的脚本，比如git、jest、eslint等
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这里我们关注<strong>packages</strong>目录</p>
<h2 id="packages目录" tabindex="-1"> packages目录</h2>
<p>目录下的文件夹非常多，我们来看下：</p>
<h3 id="react文件夹" tabindex="-1"> <a href="https://github.com/facebook/react/tree/master/packages/react" target="_blank" rel="noopener noreferrer">react</a>文件夹</h3>
<p>React的核心，包含所有全局 React API，如：</p>
<ul>
<li>React.createElement</li>
<li>React.Component</li>
<li>React.Children</li>
</ul>
<p>这些 API 是全平台通用的，它不包含<code>ReactDOM</code>、<code>ReactNative</code>等平台特定的代码。在 NPM 上作为<a href="https://www.npmjs.com/package/react" target="_blank" rel="noopener noreferrer">单独的一个包</a>发布。</p>
<h3 id="scheduler文件夹" tabindex="-1"> <a href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank" rel="noopener noreferrer">scheduler</a>文件夹</h3>
<p>Scheduler（调度器）的实现。</p>
<h3 id="shared文件夹" tabindex="-1"> <a href="https://github.com/facebook/react/tree/master/packages/shared" target="_blank" rel="noopener noreferrer">shared</a>文件夹</h3>
<p>源码中其他模块公用的<strong>方法</strong>和<strong>全局变量</strong>，比如在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/shared/ReactSymbols.js" target="_blank" rel="noopener noreferrer">shared/ReactSymbols.js</a>中保存<code>React</code>不同组件类型的定义。</p>
<div><pre><code><span>// ...</span>
<span>export</span> <span>let</span> <span>REACT_ELEMENT_TYPE</span> <span>=</span> <span>0xeac7</span><span>;</span>
<span>export</span> <span>let</span> <span>REACT_PORTAL_TYPE</span> <span>=</span> <span>0xeaca</span><span>;</span>
<span>export</span> <span>let</span> <span>REACT_FRAGMENT_TYPE</span> <span>=</span> <span>0xeacb</span><span>;</span>
<span>// ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="renderer相关的文件夹" tabindex="-1"> Renderer相关的文件夹</h3>
<p>如下几个文件夹为对应的<strong>Renderer</strong></p>
<div><pre><code>- react-art
- react-dom                 # 注意这同时是DOM和SSR（服务端渲染）的入口
- react-native-renderer
- react-noop-renderer       # 用于debug fiber（后面会介绍fiber）
- react-test-renderer
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="试验性包的文件夹" tabindex="-1"> 试验性包的文件夹</h3>
<p><code>React</code>将自己流程中的一部分抽离出来，形成可以独立使用的包，由于他们是试验性质的，所以不被建议在生产环境使用。包括如下文件夹：</p>
<div><pre><code>- react-server        # 创建自定义SSR流
- react-client        # 创建自定义的流
- react-fetch         # 用于数据请求
- react-interactions  # 用于测试交互相关的内部特性，比如React的事件模型
- react-reconciler    # Reconciler的实现，你可以用他构建自己的Renderer
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="辅助包的文件夹" tabindex="-1"> 辅助包的文件夹</h3>
<p><code>React</code>将一些辅助功能形成单独的包。包括如下文件夹：</p>
<div><pre><code>- react-is       # 用于测试组件是否是某类型
- react-client   # 创建自定义的流
- react-fetch    # 用于数据请求
- react-refresh  # “热重载”的React官方实现
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="react-reconciler文件夹" tabindex="-1"> <a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener noreferrer">react-reconciler</a>文件夹</h3>
<p>我们需要重点关注<strong>react-reconciler</strong>，在接下来源码学习中 80%的代码量都来自这个包。</p>
<p>虽然他是一个实验性的包，内部的很多功能在正式版本中还未开放。但是他一边对接<strong>Scheduler</strong>，一边对接不同平台的<strong>Renderer</strong>，构成了整个 React16 的架构体系。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">React理念</title>
    <id>https://0808200.xyz/react/preparation/idea.html</id>
    <link href="https://0808200.xyz/react/preparation/idea.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>软件的设计是为了服务理念。只有懂了设计理念，才能明白为了实现这样的理念需要如何架构。</p>
<p>所以，在我们深入源码架构之前，先来聊聊<code>React</code>理念。</p>
<h2 id="react理念" tabindex="-1"> React理念</h2>
<p>我们可以从<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html" target="_blank" rel="noopener noreferrer">官网</a>看到<code>React</code>的理念：</p>
<blockquote>
<p>我们认为，React 是用 JavaScript 构建<strong>快速响应</strong>的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p>
</blockquote>
<p>可见，关键是实现<code>快速响应</code>。那么制约<code>快速响应</code>的因素是什么呢？</p>
<p>我们日常使用App，浏览网页时，有两类场景会制约<code>快速响应</code>：</p>
<ul>
<li>
<p>当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</p>
</li>
<li>
<p>发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</p>
</li>
</ul>
<p>这两类场景可以概括为：</p>
<ul>
<li>
<p>CPU的瓶颈</p>
</li>
<li>
<p>IO的瓶颈</p>
</li>
</ul>
<p><code>React</code>是如何解决这两个瓶颈的呢？</p>
<h2 id="cpu的瓶颈" tabindex="-1"> CPU的瓶颈</h2>
<p>当项目变得庞大、组件数量繁多时，就容易遇到CPU的瓶颈。</p>
<p>考虑如下Demo，我们向视图中渲染3000个<code>li</code>：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> <span>3000</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>ul<span>></span>
      <span>{</span><span>Array</span><span>(</span>len<span>)</span><span>.</span><span>fill</span><span>(</span><span>0</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=></span> <span>&lt;</span>li<span>></span><span>{</span>i<span>}</span><span>&lt;</span><span>/</span>li<span>></span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span>ul<span>></span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> rootEl <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>"#root"</span><span>)</span><span>;</span>
ReactDOM<span>.</span><span>render</span><span>(</span><span>&lt;</span>App<span>/</span><span>></span><span>,</span> rootEl<span>)</span><span>;</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>主流浏览器刷新频率为60Hz，即每（1000ms / 60Hz）16.6ms浏览器刷新一次。</p>
<p>我们知道，JS可以操作DOM，<code>GUI渲染线程</code>与<code>JS线程</code>是互斥的。所以<strong>JS脚本执行</strong>和<strong>浏览器布局、绘制</strong>不能同时执行。</p>
<p>在每16.6ms时间内，需要完成如下工作：</p>
<div><pre><code>JS脚本执行 -----  样式布局 ----- 样式绘制
</code></pre><div aria-hidden="true"><div></div></div></div><p>当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>了。</p>
<p>在Demo中，由于组件数量繁多（3000个），JS脚本执行时间过长，页面掉帧，造成卡顿。</p>
<p>可以从打印的执行堆栈图看到，JS执行时间为73.65ms，远远多于一帧的时间。</p>
<img :src="$withBase('/img/long-task.png')" alt="长任务">
<p>如何解决这个问题呢？</p>
<p>答案是：在浏览器每一帧的时间中，预留一些时间给JS线程，<code>React</code>利用这部分时间更新组件（可以看到，在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119" target="_blank" rel="noopener noreferrer">源码</a>中，预留的初始时间是5ms）。</p>
<p>当预留的时间不够用时，<code>React</code>将线程控制权交还给浏览器使其有时间渲染UI，<code>React</code>则等待下一帧时间到来继续被中断的工作。</p>
<blockquote>
<p>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为<code>时间切片</code>（time slice）</p>
</blockquote>
<p>接下来我们开启<code>Concurrent Mode</code>（后续章节会讲到，当前你只需了解开启后会启用<code>时间切片</code>）：</p>
<div><pre><code><span>// 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode</span>
<span>// ReactDOM.render(&lt;App/>, rootEl);  </span>
ReactDOM<span>.</span><span>unstable_createRoot</span><span>(</span>rootEl<span>)</span><span>.</span><span>render</span><span>(</span><span>&lt;</span>App<span>/</span><span>></span><span>)</span><span>;</span>
</code></pre><div><br><br><div>&nbsp;</div></div><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>此时我们的长任务被拆分到每一帧不同的<code>task</code>中，<code>JS脚本</code>执行时间大体在<code>5ms</code>左右，这样浏览器就有剩余时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>，减少掉帧的可能性。</p>
<img :src="$withBase('/img/time-slice.png')" alt="长任务">
<p>所以，解决<code>CPU瓶颈</code>的关键是实现<code>时间切片</code>，而<code>时间切片</code>的关键是：将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
<details><summary>同步更新 vs 异步更新 Demo</summary>
<p>我们有个更新很耗时的大列表，让我们看看<strong>同步更新</strong>和<strong>异步更新</strong>时，输入框的响应速度</p>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>323</strong>获得在线Demo地址</p>
<p>可以从Demo看到，当牺牲了列表的更新速度，<code>React</code>大幅提高了输入响应速度，使交互更自然。</p>
</details>
<h2 id="io的瓶颈" tabindex="-1"> IO的瓶颈</h2>
<p><code>网络延迟</code>是前端开发者无法解决的。如何在<code>网络延迟</code>客观存在的情况下，减少用户对<code>网络延迟</code>的感知？</p>
<p><code>React</code>给出的答案是<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production" target="_blank" rel="noopener noreferrer">将人机交互研究的结果整合到真实的 UI 中</a>。</p>
<p>这里我们以业界人机交互最顶尖的苹果举例，在IOS系统中：</p>
<p>点击“设置”面板中的“通用”，进入“通用”界面：</p>
<img  :src="$withBase('/img/legacy-move.gif')" alt="同步">
<p>作为对比，再点击“设置”面板中的“Siri与搜索”，进入“Siri与搜索”界面：</p>
<img  :src="$withBase('/img/concurrent-mov.gif')" alt="异步">
<p>你能感受到两者体验上的区别么？</p>
<p>事实上，点击“通用”后的交互是同步的，直接显示后续界面。而点击“Siri与搜索”后的交互是异步的，需要等待请求返回后再显示后续界面。但从用户感知来看，这两者的区别微乎其微。</p>
<p>这里的窍门在于：点击“Siri与搜索”后，先在当前页面停留了一小段时间，这一小段时间被用来请求数据。</p>
<p>当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示<code>loading</code>的效果。</p>
<p>试想如果我们一点击“Siri与搜索”就显示<code>loading</code>效果，即使数据请求时间很短，<code>loading</code>效果一闪而过。用户也是可以感知到的。</p>
<p>为此，<code>React</code>实现了<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener noreferrer">Suspense</a>功能及配套的<code>hook</code>——<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue" target="_blank" rel="noopener noreferrer">useDeferredValue</a>。</p>
<p>而在源码内部，为了支持这些特性，同样需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过以上内容，我们可以看到，<code>React</code>为了践行“构建<strong>快速响应</strong>的大型 Web 应用程序”理念做出的努力。</p>
<p>其中的关键是解决CPU的瓶颈与IO的瓶颈。而落实到实现上，则需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://www.bilibili.com/video/BV134411c7Sk?from=search&amp;seid=17404881291635824595" target="_blank" rel="noopener noreferrer">「英文」尤雨溪论JavaScript框架设计哲学：平衡</a></p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">深入理解JSX</title>
    <id>https://0808200.xyz/react/preparation/jsx.html</id>
    <link href="https://0808200.xyz/react/preparation/jsx.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p><code>JSX</code>作为描述组件内容的数据结构，为JS赋予了更多视觉表现力。在<code>React</code>中我们大量使用他。在深入源码之前，有些疑问我们需要先解决：</p>
<ul>
<li><code>JSX</code>和<code>Fiber节点</code>是同一个东西么？</li>
<li><code>React Component</code>、<code>React Element</code>是同一个东西么，他们和<code>JSX</code>有什么关系？</li>
</ul>
<p>带着这些疑问，让我们开始这一节的学习。</p>
<h2 id="jsx简介" tabindex="-1"> JSX简介</h2>
<p>相信作为<code>React</code>的使用者，你已经接触过<code>JSX</code>。如果你还不了解他，可以看下<a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener noreferrer">官网对其的描述</a>。</p>
<p><code>JSX</code>在编译时会被<code>Babel</code>编译为<code>React.createElement</code>方法。</p>
<details><summary>JSX编译</summary>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>712</strong>获得在线Demo地址</p>
</details>
<p>这也是为什么在每个使用<code>JSX</code>的JS文件中，你必须显式的声明</p>
<div><pre><code><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>否则在运行时该模块内就会报<code>未定义变量 React</code>的错误。</p>
<div><p>注意</p>
<p>在React17中，已经不需要显式导入React了。详见<a href="https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" target="_blank" rel="noopener noreferrer">介绍全新的 JSX 转换</a></p>
</div>
<p><code>JSX</code>并不是只能被编译为<code>React.createElement</code>方法，你可以通过<a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" target="_blank" rel="noopener noreferrer">@babel/plugin-transform-react-jsx</a>插件显式告诉<code>Babel</code>编译时需要将<code>JSX</code>编译为什么函数的调用（默认为<code>React.createElement</code>）。</p>
<p>比如在<a href="https://github.com/preactjs/preact" target="_blank" rel="noopener noreferrer">preact</a>这个类<code>React</code>库中，<code>JSX</code>会被编译为一个名为<code>h</code>的函数调用。</p>
<div><pre><code><span>// 编译前</span>
<span><span><span>&lt;</span>p</span><span>></span></span><span>KaSong</span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span>// 编译后</span>
<span>h</span><span>(</span><span>"p"</span><span>,</span> <span>null</span><span>,</span> <span>"KaSong"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="react-createelement" tabindex="-1"> <a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L348" target="_blank" rel="noopener noreferrer">React.createElement</a></h2>
<p>既然<code>JSX</code>会被编译为<code>React.createElement</code>，让我们看看他做了什么：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createElement</span><span>(</span><span>type<span>,</span> config<span>,</span> children</span><span>)</span> <span>{</span>
  <span>let</span> propName<span>;</span>

  <span>const</span> props <span>=</span> <span>{</span><span>}</span><span>;</span>

  <span>let</span> key <span>=</span> <span>null</span><span>;</span>
  <span>let</span> ref <span>=</span> <span>null</span><span>;</span>
  <span>let</span> self <span>=</span> <span>null</span><span>;</span>
  <span>let</span> source <span>=</span> <span>null</span><span>;</span>

  <span>if</span> <span>(</span>config <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>// 将 config 处理后赋值给 props</span>
    <span>// ...省略</span>
  <span>}</span>

  <span>const</span> childrenLength <span>=</span> arguments<span>.</span>length <span>-</span> <span>2</span><span>;</span>
  <span>// 处理 children，会被赋值给props.children</span>
  <span>// ...省略</span>

  <span>// 处理 defaultProps</span>
  <span>// ...省略</span>

  <span>return</span> <span>ReactElement</span><span>(</span>
    type<span>,</span>
    key<span>,</span>
    ref<span>,</span>
    self<span>,</span>
    source<span>,</span>
    ReactCurrentOwner<span>.</span>current<span>,</span>
    props<span>,</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>ReactElement</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> key<span>,</span> ref<span>,</span> self<span>,</span> source<span>,</span> owner<span>,</span> props</span><span>)</span> <span>{</span>
  <span>const</span> element <span>=</span> <span>{</span>
    <span>// 标记这是个 React Element</span>
    $$<span>typeof</span><span>:</span> <span>REACT_ELEMENT_TYPE</span><span>,</span>

    <span>type</span><span>:</span> type<span>,</span>
    <span>key</span><span>:</span> key<span>,</span>
    <span>ref</span><span>:</span> ref<span>,</span>
    <span>props</span><span>:</span> props<span>,</span>
    <span>_owner</span><span>:</span> owner<span>,</span>
  <span>}</span><span>;</span>

  <span>return</span> element<span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以看到，<code>React.createElement</code>最终会调用<code>ReactElement</code>方法返回一个包含组件数据的对象，该对象有个参数<code>$$typeof: REACT_ELEMENT_TYPE</code>标记了该对象是个<code>React Element</code>。</p>
<p>所以调用<code>React.createElement</code>返回的对象就是<code>React Element</code>么？</p>
<p><code>React</code>提供了验证合法<code>React Element</code>的全局API <a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L547" target="_blank" rel="noopener noreferrer">React.isValidElement</a>，我们看下他的实现：</p>
<div><pre><code><span>export</span> <span>function</span> <span>isValidElement</span><span>(</span><span>object</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>typeof</span> object <span>===</span> <span>'object'</span> <span>&amp;&amp;</span>
    object <span>!==</span> <span>null</span> <span>&amp;&amp;</span>
    object<span>.</span>$$<span>typeof</span> <span>===</span> <span>REACT_ELEMENT_TYPE</span>
  <span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，<code>$$typeof === REACT_ELEMENT_TYPE</code>的非<code>null</code>对象就是一个合法的<code>React Element</code>。换言之，在<code>React</code>中，所有<code>JSX</code>在运行时的返回结果（即<code>React.createElement()</code>的返回值）都是<code>React Element</code>。</p>
<p>那么<code>JSX</code>和<code>React Component</code>的关系呢?</p>
<h2 id="react-component" tabindex="-1"> React Component</h2>
<p>在<code>React</code>中，我们常使用<code>ClassComponent</code>与<code>FunctionComponent</code>构建组件。</p>
<div><pre><code><span>class</span> <span>AppClass</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>KaSong</span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span>}</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>'这是ClassComponent：'</span><span>,</span> AppClass<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'这是Element：'</span><span>,</span> <span><span><span>&lt;</span><span>AppClass</span></span><span>/></span></span><span>)</span><span>;</span>


<span>function</span> <span>AppFunc</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>KaSong</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>'这是FunctionComponent：'</span><span>,</span> AppFunc<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'这是Element：'</span><span>,</span> <span><span><span>&lt;</span><span>AppFunc</span></span><span>/></span></span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>React Component 分类 Demo</summary>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>901</strong>获得在线Demo地址</p>
</details>
<p>我们可以从Demo控制台打印的对象看出，<code>ClassComponent</code>对应的<code>Element</code>的<code>type</code>字段为<code>AppClass</code>自身。</p>
<p><code>FunctionComponent</code>对应的<code>Element</code>的<code>type</code>字段为<code>AppFunc</code>自身，如下所示：</p>
<div><pre><code><span>{</span>
  $$<span>typeof</span><span>:</span> <span>Symbol</span><span>(</span>react<span>.</span>element<span>)</span><span>,</span>
  <span>key</span><span>:</span> <span>null</span><span>,</span>
  <span>props</span><span>:</span> <span>{</span><span>}</span><span>,</span>
  <span>ref</span><span>:</span> <span>null</span><span>,</span>
  <span>type</span><span>:</span> ƒ <span>AppFunc</span><span>(</span><span>)</span><span>,</span>
  <span>_owner</span><span>:</span> <span>null</span><span>,</span>
  <span>_store</span><span>:</span> <span>{</span><span>validated</span><span>:</span> <span>false</span><span>}</span><span>,</span>
  <span>_self</span><span>:</span> <span>null</span><span>,</span>
  <span>_source</span><span>:</span> <span>null</span> 
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>值得注意的一点，由于</p>
<div><pre><code>AppClass <span>instanceof</span> <span>Function</span> <span>===</span> <span>true</span><span>;</span>
AppFunc <span>instanceof</span> <span>Function</span> <span>===</span> <span>true</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>所以无法通过引用类型区分<code>ClassComponent</code>和<code>FunctionComponent</code>。<code>React</code>通过<code>ClassComponent</code>实例原型上的<code>isReactComponent</code>变量判断是否是<code>ClassComponent</code>。</p>
<div><pre><code><span>ClassComponent</span><span>.</span>prototype<span>.</span>isReactComponent <span>=</span> <span>{</span><span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="jsx与fiber节点" tabindex="-1"> JSX与Fiber节点</h2>
<p>从上面的内容我们可以发现，<code>JSX</code>是一种描述当前组件内容的数据结构，他不包含组件<strong>schedule</strong>、<strong>reconcile</strong>、<strong>render</strong>所需的相关信息。</p>
<p>比如如下信息就不包括在<code>JSX</code>中：</p>
<ul>
<li>组件在更新中的<code>优先级</code></li>
<li>组件的<code>state</code></li>
<li>组件被打上的用于<strong>Renderer</strong>的<code>标记</code></li>
</ul>
<p>这些内容都包含在<code>Fiber节点</code>中。</p>
<p>所以，在组件<code>mount</code>时，<code>Reconciler</code>根据<code>JSX</code>描述的组件内容生成组件对应的<code>Fiber节点</code>。</p>
<p>在<code>update</code>时，<code>Reconciler</code>将<code>JSX</code>与<code>Fiber节点</code>保存的数据对比，生成组件对应的<code>Fiber节点</code>，并根据对比结果为<code>Fiber节点</code>打上<code>标记</code>。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/ICjOlJL-fUGRb2S_xqBT7Q" target="_blank" rel="noopener noreferrer">如何干掉知乎的全部DIV -- 通过这篇文章在运行时修改<code>React.createElement</code>达到消除页面所有<code>div</code>元素的效果</a></p>
</li>
<li>
<p><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener noreferrer">React官网Blog，关于React Component, Element, Instance, Reconciliation的简介</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">新的React架构</title>
    <id>https://0808200.xyz/react/preparation/newConstructure.html</id>
    <link href="https://0808200.xyz/react/preparation/newConstructure.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>上一节我们聊到React15架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的React16是如何支持异步更新的。</p>
<h2 id="react16架构" tabindex="-1"> React16架构</h2>
<p>React16架构可以分为三层：</p>
<ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>可以看到，相较于React15，React16中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p>
<h3 id="scheduler-调度器" tabindex="-1"> Scheduler（调度器）</h3>
<p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>
<p>其实部分浏览器已经实现了这个API，这就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback</a>。但是由于以下因素，<code>React</code>放弃使用：</p>
<ul>
<li>浏览器兼容性</li>
<li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低</li>
</ul>
<p>基于以上原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，<strong>Scheduler</strong>还提供了多种调度优先级供任务设置。</p>
<blockquote>
<p><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md" target="_blank" rel="noopener noreferrer">Scheduler</a>是独立于<code>React</code>的库</p>
</blockquote>
<h3 id="reconciler-协调器" tabindex="-1"> Reconciler（协调器）</h3>
<p>我们知道，在React15中<strong>Reconciler</strong>是递归处理虚拟DOM的。让我们看看<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673" target="_blank" rel="noopener noreferrer">React16的Reconciler</a>。</p>
<p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p>
<div><pre><code><span>/** <span>@noinline</span> */</span>
<span>function</span> <span>workLoopConcurrent</span><span>(</span><span>)</span> <span>{</span>
  <span>// Perform work until Scheduler asks us to yield</span>
  <span>while</span> <span>(</span>workInProgress <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span><span>shouldYield</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    workInProgress <span>=</span> <span>performUnitOfWork</span><span>(</span>workInProgress<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</p>
<p>在React16中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：</p>
<div><pre><code><span>export</span> <span>const</span> Placement <span>=</span> <span>/*             */</span> <span>0b0000000000010</span><span>;</span>
<span>export</span> <span>const</span> Update <span>=</span> <span>/*                */</span> <span>0b0000000000100</span><span>;</span>
<span>export</span> <span>const</span> PlacementAndUpdate <span>=</span> <span>/*    */</span> <span>0b0000000000110</span><span>;</span>
<span>export</span> <span>const</span> Deletion <span>=</span> <span>/*              */</span> <span>0b0000000001000</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>全部的标记见<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js" target="_blank" rel="noopener noreferrer">这里</a></p>
</blockquote>
<p>整个<strong>Scheduler</strong>与<strong>Reconciler</strong>的工作都在内存中进行。只有当所有组件都完成<strong>Reconciler</strong>的工作，才会统一交给<strong>Renderer</strong>。</p>
<blockquote>
<p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#fiber-reconciler" target="_blank" rel="noopener noreferrer">这里</a>看到<code>React</code>官方对React16新<strong>Reconciler</strong>的解释</p>
</blockquote>
<h3 id="renderer-渲染器" tabindex="-1"> Renderer（渲染器）</h3>
<p><strong>Renderer</strong>根据<strong>Reconciler</strong>为虚拟DOM打的标记，同步执行对应的DOM操作。</p>
<p>所以，对于我们在上一节使用过的Demo</p>
<details><summary>乘法小Demo</summary>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>222</strong>获得在线Demo地址</p>
<p><code>state.count = 1</code>，每次点击按钮<code>state.count++</code></p>
<p>列表中3个元素的值分别为1，2，3乘以<code>state.count</code>的结果</p>
</details>
<p>在React16架构中整个更新流程为：</p>
<img :src="$withBase('/img/process.png')" alt="更新流程">
<p>其中红框中的步骤随时可能由于以下原因被中断：</p>
<ul>
<li>有其他更高优任务需要先更新</li>
<li>当前帧没有剩余时间</li>
</ul>
<p>由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。</p>
<blockquote>
<p>实际上，由于<strong>Scheduler</strong>和<strong>Reconciler</strong>都是平台无关的，所以<code>React</code>为他们单独发了一个包<a href="https://www.npmjs.com/package/react-reconciler" target="_blank" rel="noopener noreferrer">react-Reconciler</a>。你可以用这个包自己实现一个<code>ReactDOM</code>，具体见<strong>参考资料</strong></p>
</blockquote>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过本节我们知道了<code>React16</code>采用新的<code>Reconciler</code>。</p>
<p><code>Reconciler</code>内部采用了<code>Fiber</code>的架构。</p>
<p><code>Fiber</code>是什么？他和<code>Reconciler</code>或者说和<code>React</code>之间是什么关系？我们会在接下来三节解答。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://www.youtube.com/watch?v=CGpMlWVcHok&amp;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&amp;index=7" target="_blank" rel="noopener noreferrer">「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert</a>
<a href="https://agent-hunt.medium.com/hello-world-custom-react-renderer-9a95b7cd04bc" target="_blank" rel="noopener noreferrer">hello-world-custom-react-renderer</a></p>
<details><summary>同步/Debounce/Throttle/并发 情况下性能对比Demo</summary>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>323</strong>获得在线Demo地址</p>
</details>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">老的React架构</title>
    <id>https://0808200.xyz/react/preparation/oldConstructure.html</id>
    <link href="https://0808200.xyz/react/preparation/oldConstructure.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在上一节中我们了解了<code>React</code>的理念，简单概括就是<strong>快速响应</strong>。</p>
<p><code>React</code>从v15升级到v16后重构了整个架构。本节我们聊聊v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构。</p>
<h2 id="react15架构" tabindex="-1"> React15架构</h2>
<p>React15架构可以分为两层：</p>
<ul>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<h3 id="reconciler-协调器" tabindex="-1"> Reconciler（协调器）</h3>
<p>我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等API触发更新。</p>
<p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p>
<ul>
<li>调用函数组件、或class组件的<code>render</code>方法，将返回的JSX转化为虚拟DOM</li>
<li>将虚拟DOM和上次更新时的虚拟DOM对比</li>
<li>通过对比找出本次更新中变化的虚拟DOM</li>
<li>通知<strong>Renderer</strong>将变化的虚拟DOM渲染到页面上</li>
</ul>
<blockquote>
<p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers" target="_blank" rel="noopener noreferrer">这里</a>看到<code>React</code>官方对<strong>Reconciler</strong>的解释</p>
</blockquote>
<h3 id="renderer-渲染器" tabindex="-1"> Renderer（渲染器）</h3>
<p>由于<code>React</code>支持跨平台，所以不同平台有不同的<strong>Renderer</strong>。我们前端最熟悉的是负责在浏览器环境渲染的<strong>Renderer</strong> —— <a href="https://www.npmjs.com/package/react-dom" target="_blank" rel="noopener noreferrer">ReactDOM</a>。</p>
<p>除此之外，还有：</p>
<ul>
<li><a href="https://www.npmjs.com/package/react-native" target="_blank" rel="noopener noreferrer">ReactNative</a>渲染器，渲染App原生组件</li>
<li><a href="https://www.npmjs.com/package/react-test-renderer" target="_blank" rel="noopener noreferrer">ReactTest</a>渲染器，渲染出纯Js对象用于测试</li>
<li><a href="https://www.npmjs.com/package/react-art" target="_blank" rel="noopener noreferrer">ReactArt</a>渲染器，渲染到Canvas, SVG 或 VML (IE8)</li>
</ul>
<p>在每次更新发生时，<strong>Renderer</strong>接到<strong>Reconciler</strong>通知，将变化的组件渲染在当前宿主环境。</p>
<blockquote>
<p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers" target="_blank" rel="noopener noreferrer">这里</a>看到<code>React</code>官方对<strong>Renderer</strong>的解释</p>
</blockquote>
<h2 id="react15架构的缺点" tabindex="-1"> React15架构的缺点</h2>
<p>在<strong>Reconciler</strong>中，<code>mount</code>的组件会调用<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498" target="_blank" rel="noopener noreferrer">mountComponent</a>，<code>update</code>的组件会调用<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877" target="_blank" rel="noopener noreferrer">updateComponent</a>。这两个方法都会递归更新子组件。</p>
<h3 id="递归更新的缺点" tabindex="-1"> 递归更新的缺点</h3>
<p>由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。</p>
<p>在上一节中，我们已经提出了解决办法——用<strong>可中断的异步更新</strong>代替<strong>同步的更新</strong>。那么React15的架构支持异步更新么？让我们看一个例子：</p>
<details><summary>乘法小Demo</summary>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>222</strong>获得在线Demo地址</p>
<p>初始化时<code>state.count = 1</code>，每次点击按钮<code>state.count++</code></p>
<p>列表中3个元素的值分别为1，2，3乘以<code>state.count</code>的结果</p>
</details>
<p>我用红色标注了更新的步骤。
<img :src="$withBase('/img/v15.png')" alt="更新流程"></p>
<p>我们可以看到，<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，当第一个<code>li</code>在页面上已经变化后，第二个<code>li</code>再进入<strong>Reconciler</strong>。</p>
<p>由于整个过程都是同步的，所以在用户看来所有DOM是同时更新的。</p>
<p>接下来，让我们模拟一下，如果中途中断更新会怎么样？</p>
<div><p>注意</p>
<p>以下是我们模拟中断的情况，实际上<code>React15</code>并不会中断进行中的更新</p>
</div>
<img :src="$withBase('/img/dist.png')" alt="中断更新流程">
<p>当第一个<code>li</code>完成更新时中断更新，即步骤3完成后中断更新，此时后面的步骤都还未执行。</p>
<p>用户本来期望<code>123</code>变为<code>246</code>。实际却看见更新不完全的DOM！（即<code>223</code>）</p>
<p>基于这个原因，<code>React</code>决定重写整个架构。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">调试源码</title>
    <id>https://0808200.xyz/react/preparation/source.html</id>
    <link href="https://0808200.xyz/react/preparation/source.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>了解了源码的文件目录，这一节我们看看如何调试源码。</p>
<p>即使版本号相同（当前最新版为<code>17.0.0 RC</code>），但是<code>facebook/react</code>项目<code>master</code>分支的代码和我们使用<code>create-react-app</code>创建的项目<code>node_modules</code>下的<code>react</code>项目代码还是有些区别。</p>
<p>因为<code>React</code>的新代码都是直接提交到<code>master</code>分支，而<code>create-react-app</code>内的<code>react</code>使用的是稳定版的包。</p>
<p>为了始终使用最新版<code>React</code>教学，我们调试源码遵循以下步骤：</p>
<ol>
<li>从<code>facebook/react</code>项目<code>master</code>分支拉取最新源码</li>
<li>基于最新源码构建<code>react</code>、<code>scheduler</code>、<code>react-dom</code>三个包</li>
<li>通过<code>create-react-app</code>创建测试项目，并使用步骤2创建的包作为项目依赖的包</li>
</ol>
<h2 id="拉取源码" tabindex="-1"> 拉取源码</h2>
<p>拉取<code>facebook/react</code>代码</p>
<div><pre><code><span># 拉取代码</span>
<span>git</span> clone https://github.com/facebook/react.git

<span># 如果拉取速度很慢，可以考虑如下2个方案：</span>

<span># 1. 使用cnpm代理</span>
<span>git</span> clone https://github.com.cnpmjs.org/facebook/react

<span># 2. 使用码云的镜像（一天会与react同步一次）</span>
<span>git</span> clone https://gitee.com/mirrors/react.git

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>安装依赖</p>
<div><pre><code><span># 切入到react源码所在文件夹</span>
<span>cd</span> react

<span># 安装依赖</span>
<span>yarn</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>打包<code>react</code>、<code>scheduler</code>、<code>react-dom</code>三个包为dev环境可以使用的<code>cjs</code>包。</p>
<blockquote>
<p>我们的步骤只包含具体做法，对每一步更详细的介绍可以参考<code>React</code>文档<a href="https://zh-hans.reactjs.org/docs/how-to-contribute.html#development-workflow" target="_blank" rel="noopener noreferrer">源码贡献章节</a></p>
</blockquote>
<div><pre><code>
<span># 执行打包命令</span>
<span>yarn</span> build react/index,react/jsx,react-dom/index,scheduler --type<span>=</span>NODE


</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>网络不好的同学看这里</summary>
<p>如果网络不好，执行<code>yarn</code>命令无法完成依赖安装，或者执行<code>yarn build</code>无法完成打包，可以使用我打好的包。</p>
<p>版本为<code>17.0.0-alpha.0</code></p>
<p><a href="https://gitee.com/kasong/react" target="_blank" rel="noopener noreferrer">地址</a></p>
</details>
<p>现在源码目录<code>build/node_modules</code>下会生成最新代码的包。我们为<code>react</code>、<code>react-dom</code>创建<code>yarn link</code>。</p>
<blockquote>
<p>通过<code>yarn link</code>可以改变项目中依赖包的目录指向</p>
</blockquote>
<div><pre><code><span>cd</span> build/node_modules/react
<span># 申明react指向</span>
<span>yarn</span> <span>link</span>
<span>cd</span> build/node_modules/react-dom
<span># 申明react-dom指向</span>
<span>yarn</span> <span>link</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="创建项目" tabindex="-1"> 创建项目</h2>
<p>接下来我们通过<code>create-react-app</code>在其他地方创建新项目。这里我们随意起名，比如“a-react-demo”。</p>
<div><pre><code>npx create-react-app a-react-demo
</code></pre><div aria-hidden="true"><div></div></div></div><p>在新项目中，将<code>react</code>与<code>react-dom</code>2个包指向<code>facebook/react</code>下我们刚才生成的包。</p>
<div><pre><code><span># 将项目内的react react-dom指向之前申明的包</span>
<span>yarn</span> <span>link</span> react react-dom
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>现在试试在<code>react/build/node_modules/react-dom/cjs/react-dom.development.js</code>中随意打印些东西。</p>
<p>在<code>a-react-demo</code>项目下执行<code>yarn start</code>。现在浏览器控制台已经可以打印出我们输入的东西了。</p>
<p>通过以上方法，我们的运行时代码就和<code>React</code>最新代码一致了。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">总结</title>
    <id>https://0808200.xyz/react/preparation/summary.html</id>
    <link href="https://0808200.xyz/react/preparation/summary.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>通过本章的学习，我们了解了<code>React</code>的<code>Scheduler-Reconciler-Renderer</code>架构体系，在结束本章前，我想介绍几个源码内的术语：</p>
<ul>
<li><code>Reconciler</code>工作的阶段被称为<code>render</code>阶段。因为在该阶段会调用组件的<code>render</code>方法。</li>
<li><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。就像你完成一个需求的编码后执行<code>git commit</code>提交代码。<code>commit</code>阶段会把<code>render</code>阶段提交的信息渲染在页面上。</li>
<li><code>render</code>与<code>commit</code>阶段统称为<code>work</code>，即<code>React</code>在工作中。相对应的，如果任务正在<code>Scheduler</code>内调度，就不属于<code>work</code>。</li>
</ul>
<p>在<code>架构篇</code>我们会分别讲解<code>Reconciler</code>和<code>Renderer</code>的工作流程，所以章节名分别为<code>render阶段</code>和<code>commit阶段</code>。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">beginWork</title>
    <id>https://0808200.xyz/react/process/beginWork.html</id>
    <link href="https://0808200.xyz/react/process/beginWork.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>上一节我们了解到<code>render阶段</code>的工作可以分为“递”阶段和“归”阶段。其中“递”阶段会执行<code>beginWork</code>，“归”阶段会执行<code>completeWork</code>。这一节我们看看“递”阶段的<code>beginWork</code>方法究竟做了什么。</p>
<h2 id="方法概览" tabindex="-1"> 方法概览</h2>
<p>可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075" target="_blank" rel="noopener noreferrer">源码这里</a>看到<code>beginWork</code>的定义。整个方法大概有500行代码。</p>
<p>从上一节我们已经知道，<code>beginWork</code>的工作是传入<code>当前Fiber节点</code>，创建<code>子Fiber节点</code>，我们从传参来看看具体是如何做的。</p>
<h3 id="从传参看方法执行" tabindex="-1"> 从传参看方法执行</h3>
<div><pre><code><span>function</span> <span>beginWork</span><span>(</span>
  <span><span>current</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span>
  <span>workInProgress</span><span>:</span> Fiber<span>,</span>
  <span>renderLanes</span><span>:</span> Lanes<span>,</span></span>
<span>)</span><span>:</span> Fiber <span>|</span> <span>null</span> <span>{</span>
  <span>// ...省略函数体</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中传参：</p>
<ul>
<li>current：当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>workInProgress.alternate</code></li>
<li>workInProgress：当前组件对应的<code>Fiber节点</code></li>
<li>renderLanes：优先级相关，在讲解<code>Scheduler</code>时再讲解</li>
</ul>
<p>从<a href="/react/process/doubleBuffer.html">双缓存机制一节</a>我们知道，除<a href="/react/process/doubleBuffer.html#mount%E6%97%B6"><code>rootFiber</code></a>以外， 组件<code>mount</code>时，由于是首次渲染，是不存在当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>mount</code>时<code>current === null</code>。</p>
<p>组件<code>update</code>时，由于之前已经<code>mount</code>过，所以<code>current !== null</code>。</p>
<p>所以我们可以通过<code>current === null ?</code>来区分组件是处于<code>mount</code>还是<code>update</code>。</p>
<p>基于此原因，<code>beginWork</code>的工作可以分为两部分：</p>
<ul>
<li>
<p><code>update</code>时：如果<code>current</code>存在，在满足一定条件时可以复用<code>current</code>节点，这样就能克隆<code>current.child</code>作为<code>workInProgress.child</code>，而不需要新建<code>workInProgress.child</code>。</p>
</li>
<li>
<p><code>mount</code>时：除<code>fiberRootNode</code>以外，<code>current === null</code>。会根据<code>fiber.tag</code>不同，创建不同类型的<code>子Fiber节点</code></p>
</li>
</ul>
<div><pre><code><span>function</span> <span>beginWork</span><span>(</span>
  <span><span>current</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span>
  <span>workInProgress</span><span>:</span> Fiber<span>,</span>
  <span>renderLanes</span><span>:</span> Lanes</span>
<span>)</span><span>:</span> Fiber <span>|</span> <span>null</span> <span>{</span>

  <span>// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span>
  <span>if</span> <span>(</span>current <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>// ...省略</span>

    <span>// 复用current</span>
    <span>return</span> <span>bailoutOnAlreadyFinishedWork</span><span>(</span>
      current<span>,</span>
      workInProgress<span>,</span>
      renderLanes<span>,</span>
    <span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    didReceiveUpdate <span>=</span> <span>false</span><span>;</span>
  <span>}</span>

  <span>// mount时：根据tag不同，创建不同的子Fiber节点</span>
  <span>switch</span> <span>(</span>workInProgress<span>.</span>tag<span>)</span> <span>{</span>
    <span>case</span> <span>IndeterminateComponent</span><span>:</span> 
      <span>// ...省略</span>
    <span>case</span> <span>LazyComponent</span><span>:</span> 
      <span>// ...省略</span>
    <span>case</span> <span>FunctionComponent</span><span>:</span> 
      <span>// ...省略</span>
    <span>case</span> <span>ClassComponent</span><span>:</span> 
      <span>// ...省略</span>
    <span>case</span> <span>HostRoot</span><span>:</span>
      <span>// ...省略</span>
    <span>case</span> <span>HostComponent</span><span>:</span>
      <span>// ...省略</span>
    <span>case</span> <span>HostText</span><span>:</span>
      <span>// ...省略</span>
    <span>// ...省略其他类型</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="update时" tabindex="-1"> update时</h2>
<p>我们可以看到，满足如下情况时<code>didReceiveUpdate === false</code>（即可以直接复用前一次更新的<code>子Fiber</code>，不需要新建<code>子Fiber</code>）</p>
<ol>
<li><code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code>，即<code>props</code>与<code>fiber.type</code>不变</li>
<li><code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前<code>Fiber节点</code>优先级不够，会在讲解<code>Scheduler</code>时介绍</li>
</ol>
<div><pre><code><span>if</span> <span>(</span>current <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>const</span> oldProps <span>=</span> current<span>.</span>memoizedProps<span>;</span>
    <span>const</span> newProps <span>=</span> workInProgress<span>.</span>pendingProps<span>;</span>

    <span>if</span> <span>(</span>
      oldProps <span>!==</span> newProps <span>||</span>
      <span>hasLegacyContextChanged</span><span>(</span><span>)</span> <span>||</span>
      <span>(</span>__DEV__ <span>?</span> workInProgress<span>.</span>type <span>!==</span> current<span>.</span>type <span>:</span> <span>false</span><span>)</span>
    <span>)</span> <span>{</span>
      didReceiveUpdate <span>=</span> <span>true</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>includesSomeLane</span><span>(</span>renderLanes<span>,</span> updateLanes<span>)</span><span>)</span> <span>{</span>
      didReceiveUpdate <span>=</span> <span>false</span><span>;</span>
      <span>switch</span> <span>(</span>workInProgress<span>.</span>tag<span>)</span> <span>{</span>
        <span>// 省略处理</span>
      <span>}</span>
      <span>return</span> <span>bailoutOnAlreadyFinishedWork</span><span>(</span>
        current<span>,</span>
        workInProgress<span>,</span>
        renderLanes<span>,</span>
      <span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      didReceiveUpdate <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    didReceiveUpdate <span>=</span> <span>false</span><span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="mount时" tabindex="-1"> mount时</h2>
<p>当不满足优化路径时，我们就进入第二部分，新建<code>子Fiber</code>。</p>
<p>我们可以看到，根据<code>fiber.tag</code>不同，进入不同类型<code>Fiber</code>的创建逻辑。</p>
<blockquote>
<p>可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js" target="_blank" rel="noopener noreferrer">这里</a>看到<code>tag</code>对应的组件类型</p>
</blockquote>
<div><pre><code><span>// mount时：根据tag不同，创建不同的Fiber节点</span>
<span>switch</span> <span>(</span>workInProgress<span>.</span>tag<span>)</span> <span>{</span>
  <span>case</span> <span>IndeterminateComponent</span><span>:</span> 
    <span>// ...省略</span>
  <span>case</span> <span>LazyComponent</span><span>:</span> 
    <span>// ...省略</span>
  <span>case</span> <span>FunctionComponent</span><span>:</span> 
    <span>// ...省略</span>
  <span>case</span> <span>ClassComponent</span><span>:</span> 
    <span>// ...省略</span>
  <span>case</span> <span>HostRoot</span><span>:</span>
    <span>// ...省略</span>
  <span>case</span> <span>HostComponent</span><span>:</span>
    <span>// ...省略</span>
  <span>case</span> <span>HostText</span><span>:</span>
    <span>// ...省略</span>
  <span>// ...省略其他类型</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于我们常见的组件类型，如（<code>FunctionComponent</code>/<code>ClassComponent</code>/<code>HostComponent</code>），最终会进入<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233" target="_blank" rel="noopener noreferrer">reconcileChildren</a>方法。</p>
<h2 id="reconcilechildren" tabindex="-1"> reconcileChildren</h2>
<p>从该函数名就能看出这是<code>Reconciler</code>模块的核心部分。那么他究竟做了什么呢？</p>
<ul>
<li>
<p>对于<code>mount</code>的组件，他会创建新的<code>子Fiber节点</code></p>
</li>
<li>
<p>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的<code>Fiber节点</code>比较（也就是俗称的<code>Diff</code>算法），将比较的结果生成新<code>Fiber节点</code></p>
</li>
</ul>
<div><pre><code><span>export</span> <span>function</span> <span>reconcileChildren</span><span>(</span>
  <span><span>current</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span>
  <span>workInProgress</span><span>:</span> Fiber<span>,</span>
  <span>nextChildren</span><span>:</span> any<span>,</span>
  <span>renderLanes</span><span>:</span> Lanes</span>
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>current <span>===</span> <span>null</span><span>)</span> <span>{</span>
    <span>// 对于mount的组件</span>
    workInProgress<span>.</span>child <span>=</span> <span>mountChildFibers</span><span>(</span>
      workInProgress<span>,</span>
      <span>null</span><span>,</span>
      nextChildren<span>,</span>
      renderLanes<span>,</span>
    <span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// 对于update的组件</span>
    workInProgress<span>.</span>child <span>=</span> <span>reconcileChildFibers</span><span>(</span>
      workInProgress<span>,</span>
      current<span>.</span>child<span>,</span>
      nextChildren<span>,</span>
      renderLanes<span>,</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>从代码可以看出，和<code>beginWork</code>一样，他也是通过<code>current === null ?</code>区分<code>mount</code>与<code>update</code>。</p>
<p>不论走哪个逻辑，最终他会生成新的子<code>Fiber节点</code>并赋值给<code>workInProgress.child</code>，作为本次<code>beginWork</code><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1158" target="_blank" rel="noopener noreferrer">返回值</a>，并作为下次<code>performUnitOfWork</code>执行时<code>workInProgress</code>的<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1702" target="_blank" rel="noopener noreferrer">传参</a>。</p>
<div><p>注意</p>
<p>值得一提的是，<code>mountChildFibers</code>与<code>reconcileChildFibers</code>这两个方法的逻辑基本一致。唯一的区别是：<code>reconcileChildFibers</code>会为生成的<code>Fiber节点</code>带上<code>effectTag</code>属性，而<code>mountChildFibers</code>不会。</p>
</div>
<h2 id="effecttag" tabindex="-1"> effectTag</h2>
<p>我们知道，<code>render阶段</code>的工作是在内存中进行，当工作结束后会通知<code>Renderer</code>需要执行的<code>DOM</code>操作。要执行<code>DOM</code>操作的具体类型就保存在<code>fiber.effectTag</code>中。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js" target="_blank" rel="noopener noreferrer">这里</a>看到<code>effectTag</code>对应的<code>DOM</code>操作</p>
</blockquote>
<p>比如：</p>
<div><pre><code><span>// DOM需要插入到页面中</span>
<span>export</span> <span>const</span> Placement <span>=</span> <span>/*                */</span> <span>0b00000000000010</span><span>;</span>
<span>// DOM需要更新</span>
<span>export</span> <span>const</span> Update <span>=</span> <span>/*                   */</span> <span>0b00000000000100</span><span>;</span>
<span>// DOM需要插入到页面中并更新</span>
<span>export</span> <span>const</span> PlacementAndUpdate <span>=</span> <span>/*       */</span> <span>0b00000000000110</span><span>;</span>
<span>// DOM需要删除</span>
<span>export</span> <span>const</span> Deletion <span>=</span> <span>/*                 */</span> <span>0b00000000001000</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>通过二进制表示<code>effectTag</code>，可以方便的使用位操作为<code>fiber.effectTag</code>赋值多个<code>effect</code>。</p>
</blockquote>
<p>那么，如果要通知<code>Renderer</code>将<code>Fiber节点</code>对应的<code>DOM节点</code>插入页面中，需要满足两个条件：</p>
<ol>
<li>
<p><code>fiber.stateNode</code>存在，即<code>Fiber节点</code>中保存了对应的<code>DOM节点</code></p>
</li>
<li>
<p><code>(fiber.effectTag &amp; Placement) !== 0</code>，即<code>Fiber节点</code>存在<code>Placement effectTag</code></p>
</li>
</ol>
<p>我们知道，<code>mount</code>时，<code>fiber.stateNode === null</code>，且在<code>reconcileChildren</code>中调用的<code>mountChildFibers</code>不会为<code>Fiber节点</code>赋值<code>effectTag</code>。那么首屏渲染如何完成呢？</p>
<p>针对第一个问题，<code>fiber.stateNode</code>会在<code>completeWork</code>中创建，我们会在下一节介绍。</p>
<p>第二个问题的答案十分巧妙：假设<code>mountChildFibers</code>也会赋值<code>effectTag</code>，那么可以预见<code>mount</code>时整棵<code>Fiber树</code>所有节点都会有<code>Placement effectTag</code>。那么<code>commit阶段</code>在执行<code>DOM</code>操作时每个节点都会执行一次插入操作，这样大量的<code>DOM</code>操作是极低效的。</p>
<p>为了解决这个问题，在<code>mount</code>时只有<code>rootFiber</code>会赋值<code>Placement effectTag</code>，在<code>commit阶段</code>只会执行一次插入操作。</p>
<details><summary>根Fiber节点 Demo</summary>
<p>借用上一节的Demo，第一个进入<code>beginWork</code>方法的<code>Fiber节点</code>就是<code>rootFiber</code>，他的<code>alternate</code>指向<code>current rootFiber</code>（即他存在<code>current</code>）。</p>
<blockquote>
<p>为什么<code>rootFiber</code>节点存在<code>current</code>（即<code>rootFiber.alternate</code>），我们在<a href="/react/process/doubleBuffer.html">双缓存机制一节mount时的第二步</a>已经讲过</p>
</blockquote>
<p>由于存在<code>current</code>，<code>rootFiber</code>在<code>reconcileChildren</code>时会走<code>reconcileChildFibers</code>逻辑。</p>
<p>而之后通过<code>beginWork</code>创建的<code>Fiber节点</code>是不存在<code>current</code>的（即 <code>fiber.alternate === null</code>），会走<code>mountChildFibers</code>逻辑</p>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>531</strong>获得在线Demo地址</p>
</details>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><code>beginWork</code>流程图</p>
<img :src="$withBase('/img/beginWork.png')" alt="beginWork流程图">
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">completeWork</title>
    <id>https://0808200.xyz/react/process/completeWork.html</id>
    <link href="https://0808200.xyz/react/process/completeWork.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/process/reconciler">流程概览一节</a>我们了解组件在<code>render阶段</code>会经历<code>beginWork</code>与<code>completeWork</code>。</p>
<p>上一节我们讲解了组件执行<code>beginWork</code>后会创建<code>子Fiber节点</code>，节点上可能存在<code>effectTag</code>。</p>
<p>这一节让我们看看<code>completeWork</code>会做什么工作。</p>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673" target="_blank" rel="noopener noreferrer">这里</a>看到<code>completeWork</code>方法定义。</p>
<h2 id="流程概览" tabindex="-1"> 流程概览</h2>
<p>类似<code>beginWork</code>，<code>completeWork</code>也是针对不同<code>fiber.tag</code>调用不同的处理逻辑。</p>
<div><pre><code><span>function</span> <span>completeWork</span><span>(</span>
  <span><span>current</span><span>:</span> Fiber <span>|</span> <span>null</span><span>,</span>
  <span>workInProgress</span><span>:</span> Fiber<span>,</span>
  <span>renderLanes</span><span>:</span> Lanes<span>,</span></span>
<span>)</span><span>:</span> Fiber <span>|</span> <span>null</span> <span>{</span>
  <span>const</span> newProps <span>=</span> workInProgress<span>.</span>pendingProps<span>;</span>

  <span>switch</span> <span>(</span>workInProgress<span>.</span>tag<span>)</span> <span>{</span>
    <span>case</span> <span>IndeterminateComponent</span><span>:</span>
    <span>case</span> <span>LazyComponent</span><span>:</span>
    <span>case</span> <span>SimpleMemoComponent</span><span>:</span>
    <span>case</span> <span>FunctionComponent</span><span>:</span>
    <span>case</span> <span>ForwardRef</span><span>:</span>
    <span>case</span> <span>Fragment</span><span>:</span>
    <span>case</span> <span>Mode</span><span>:</span>
    <span>case</span> <span>Profiler</span><span>:</span>
    <span>case</span> <span>ContextConsumer</span><span>:</span>
    <span>case</span> <span>MemoComponent</span><span>:</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>case</span> <span>ClassComponent</span><span>:</span> <span>{</span>
      <span>// ...省略</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>case</span> <span>HostRoot</span><span>:</span> <span>{</span>
      <span>// ...省略</span>
      <span>updateHostContainer</span><span>(</span>workInProgress<span>)</span><span>;</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>case</span> <span>HostComponent</span><span>:</span> <span>{</span>
      <span>// ...省略</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
  <span>// ...省略</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们重点关注页面渲染所必须的<code>HostComponent</code>（即原生<code>DOM组件</code>对应的<code>Fiber节点</code>），其他类型<code>Fiber</code>的处理留在具体功能实现时讲解。</p>
<h2 id="处理hostcomponent" tabindex="-1"> 处理HostComponent</h2>
<p>和<code>beginWork</code>一样，我们根据<code>current === null ?</code>判断是<code>mount</code>还是<code>update</code>。</p>
<p>同时针对<code>HostComponent</code>，判断<code>update</code>时我们还需要考虑<code>workInProgress.stateNode != null ?</code>（即该<code>Fiber节点</code>是否存在对应的<code>DOM节点</code>）</p>
<div><pre><code><span>case</span> <span>HostComponent</span><span>:</span> <span>{</span>
  <span>popHostContext</span><span>(</span>workInProgress<span>)</span><span>;</span>
  <span>const</span> rootContainerInstance <span>=</span> <span>getRootHostContainer</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> type <span>=</span> workInProgress<span>.</span>type<span>;</span>

  <span>if</span> <span>(</span>current <span>!==</span> <span>null</span> <span>&amp;&amp;</span> workInProgress<span>.</span>stateNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>// update的情况</span>
    <span>// ...省略</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// mount的情况</span>
    <span>// ...省略</span>
  <span>}</span>
  <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="update时" tabindex="-1"> update时</h2>
<p>当<code>update</code>时，<code>Fiber节点</code>已经存在对应<code>DOM节点</code>，所以不需要生成<code>DOM节点</code>。需要做的主要是处理<code>props</code>，比如：</p>
<ul>
<li><code>onClick</code>、<code>onChange</code>等回调函数的注册</li>
<li>处理<code>style prop</code></li>
<li>处理<code>DANGEROUSLY_SET_INNER_HTML prop</code></li>
<li>处理<code>children prop</code></li>
</ul>
<p>我们去掉一些当前不需要关注的功能（比如<code>ref</code>）。可以看到最主要的逻辑是调用<code>updateHostComponent</code>方法。</p>
<div><pre><code><span>if</span> <span>(</span>current <span>!==</span> <span>null</span> <span>&amp;&amp;</span> workInProgress<span>.</span>stateNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
  <span>// update的情况</span>
  <span>updateHostComponent</span><span>(</span>
    current<span>,</span>
    workInProgress<span>,</span>
    type<span>,</span>
    newProps<span>,</span>
    rootContainerInstance<span>,</span>
  <span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L225" target="_blank" rel="noopener noreferrer">这里</a>看到<code>updateHostComponent</code>方法定义。</p>
<p>在<code>updateHostComponent</code>内部，被处理完的<code>props</code>会被赋值给<code>workInProgress.updateQueue</code>，并最终会在<code>commit阶段</code>被渲染在页面上。</p>
<div><pre><code>workInProgress<span>.</span>updateQueue <span>=</span> <span>(</span>updatePayload<span>:</span> <span>any</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中<code>updatePayload</code>为数组形式，他的偶数索引的值为变化的<code>prop key</code>，奇数索引的值为变化的<code>prop value</code>。</p>
<blockquote>
<p>具体渲染过程见<a href="/react/renderer/mutation.html#hostcomponent-mutation">mutation阶段一节</a></p>
</blockquote>
<details><summary>updatePayload属性 Demo</summary>
<p><code>updateHostComponent</code>方法内打印了<code>Fiber节点</code>对应的<code>type</code>与<code>updatePayload</code>。</p>
<p>你可以直观的感受<code>updatePayload</code>的数据结构</p>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>431</strong>获得在线Demo地址</p>
</details>
<h2 id="mount时" tabindex="-1"> mount时</h2>
<p>同样，我们省略了不相关的逻辑。可以看到，<code>mount</code>时的主要逻辑包括三个：</p>
<ul>
<li>为<code>Fiber节点</code>生成对应的<code>DOM节点</code></li>
<li>将子孙<code>DOM节点</code>插入刚生成的<code>DOM节点</code>中</li>
<li>与<code>update</code>逻辑中的<code>updateHostComponent</code>类似的处理<code>props</code>的过程</li>
</ul>
<div><pre><code><span>// mount的情况</span>

<span>// ...省略服务端渲染相关逻辑</span>

<span>const</span> currentHostContext <span>=</span> <span>getHostContext</span><span>(</span><span>)</span><span>;</span>
<span>// 为fiber创建对应DOM节点</span>
<span>const</span> instance <span>=</span> <span>createInstance</span><span>(</span>
    type<span>,</span>
    newProps<span>,</span>
    rootContainerInstance<span>,</span>
    currentHostContext<span>,</span>
    workInProgress<span>,</span>
  <span>)</span><span>;</span>
<span>// 将子孙DOM节点插入刚生成的DOM节点中</span>
<span>appendAllChildren</span><span>(</span>instance<span>,</span> workInProgress<span>,</span> <span>false</span><span>,</span> <span>false</span><span>)</span><span>;</span>
<span>// DOM节点赋值给fiber.stateNode</span>
workInProgress<span>.</span>stateNode <span>=</span> instance<span>;</span>

<span>// 与update逻辑中的updateHostComponent类似的处理props的过程</span>
<span>if</span> <span>(</span>
  <span>finalizeInitialChildren</span><span>(</span>
    instance<span>,</span>
    type<span>,</span>
    newProps<span>,</span>
    rootContainerInstance<span>,</span>
    currentHostContext<span>,</span>
  <span>)</span>
<span>)</span> <span>{</span>
  <span>markUpdate</span><span>(</span>workInProgress<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>还记得<a href="/react/process/beginWork.html#effecttag">上一节</a>我们讲到：<code>mount</code>时只会在<code>rootFiber</code>存在<code>Placement effectTag</code>。那么<code>commit阶段</code>是如何通过一次插入<code>DOM</code>操作（对应一个<code>Placement effectTag</code>）将整棵<code>DOM树</code>插入页面的呢？</p>
<p>原因就在于<code>completeWork</code>中的<code>appendAllChildren</code>方法。</p>
<p>由于<code>completeWork</code>属于“归”阶段调用的函数，每次调用<code>appendAllChildren</code>时都会将已生成的子孙<code>DOM节点</code>插入当前生成的<code>DOM节点</code>下。那么当“归”到<code>rootFiber</code>时，我们已经有一个构建好的离屏<code>DOM树</code>。</p>
<h2 id="effectlist" tabindex="-1"> effectList</h2>
<p>至此<code>render阶段</code>的绝大部分工作就完成了。</p>
<p>还有一个问题：作为<code>DOM</code>操作的依据，<code>commit阶段</code>需要找到所有有<code>effectTag</code>的<code>Fiber节点</code>并依次执行<code>effectTag</code>对应操作。难道需要在<code>commit阶段</code>再遍历一次<code>Fiber树</code>寻找<code>effectTag !== null</code>的<code>Fiber节点</code>么？</p>
<p>这显然是很低效的。</p>
<p>为了解决这个问题，在<code>completeWork</code>的上层函数<code>completeUnitOfWork</code>中，每个执行完<code>completeWork</code>且存在<code>effectTag</code>的<code>Fiber节点</code>会被保存在一条被称为<code>effectList</code>的单向链表中。</p>
<p><code>effectList</code>中第一个<code>Fiber节点</code>保存在<code>fiber.firstEffect</code>，最后一个元素保存在<code>fiber.lastEffect</code>。</p>
<p>类似<code>appendAllChildren</code>，在“归”阶段，所有有<code>effectTag</code>的<code>Fiber节点</code>都会被追加在<code>effectList</code>中，最终形成一条以<code>rootFiber.firstEffect</code>为起点的单向链表。</p>
<div><pre><code>                       nextEffect         nextEffect
rootFiber<span>.</span>firstEffect <span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span><span>></span> fiber <span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span><span>></span> fiber
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这样，在<code>commit阶段</code>只需要遍历<code>effectList</code>就能执行所有<code>effect</code>了。</p>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1744" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码逻辑。</p>
<p>借用<code>React</code>团队成员<strong>Dan Abramov</strong>的话：<code>effectList</code>相较于<code>Fiber树</code>，就像圣诞树上挂的那一串彩灯。</p>
<h2 id="流程结尾" tabindex="-1"> 流程结尾</h2>
<p>至此，<code>render阶段</code>全部工作完成。在<code>performSyncWorkOnRoot</code>函数中<code>fiberRootNode</code>被传递给<code>commitRoot</code>方法，开启<code>commit阶段</code>工作流程。</p>
<div><pre><code><span>commitRoot</span><span>(</span>root<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>代码见<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1107" target="_blank" rel="noopener noreferrer">这里</a>。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><code>completeWork</code>流程图</p>
<img :src="$withBase('/img/completeWork.png')" alt="completeWork流程图">
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Fiber架构的工作原理</title>
    <id>https://0808200.xyz/react/process/doubleBuffer.html</id>
    <link href="https://0808200.xyz/react/process/doubleBuffer.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>通过上一节的学习，我们了解了<code>Fiber</code>是什么，知道<code>Fiber节点</code>可以保存对应的<code>DOM节点</code>。</p>
<p>相应的，<code>Fiber节点</code>构成的<code>Fiber树</code>就对应<code>DOM树</code>。</p>
<p>那么如何更新<code>DOM</code>呢？这需要用到被称为“双缓存”的技术。</p>
<h2 id="什么是-双缓存" tabindex="-1"> 什么是“双缓存”</h2>
<p>当我们用<code>canvas</code>绘制动画，每一帧绘制前都会调用<code>ctx.clearRect</code>清除上一帧的画面。</p>
<p>如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。</p>
<p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。</p>
<p>这种<strong>在内存中构建并直接替换</strong>的技术叫做<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2" target="_blank" rel="noopener noreferrer">双缓存</a>。</p>
<p><code>React</code>使用“双缓存”来完成<code>Fiber树</code>的构建与替换——对应着<code>DOM树</code>的创建与更新。</p>
<h2 id="双缓存fiber树" tabindex="-1"> 双缓存Fiber树</h2>
<p>在<code>React</code>中最多会同时存在两棵<code>Fiber树</code>。当前屏幕上显示内容对应的<code>Fiber树</code>称为<code>current Fiber树</code>，正在内存中构建的<code>Fiber树</code>称为<code>workInProgress Fiber树</code>。</p>
<p><code>current Fiber树</code>中的<code>Fiber节点</code>被称为<code>current fiber</code>，<code>workInProgress Fiber树</code>中的<code>Fiber节点</code>被称为<code>workInProgress fiber</code>，他们通过<code>alternate</code>属性连接。</p>
<div><pre><code>currentFiber<span>.</span>alternate <span>===</span> workInProgressFiber<span>;</span>
workInProgressFiber<span>.</span>alternate <span>===</span> currentFiber<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>React</code>应用的根节点通过使<code>current</code>指针在不同<code>Fiber树</code>的<code>rootFiber</code>间切换来完成<code>current Fiber</code>树指向的切换。</p>
<p>即当<code>workInProgress Fiber树</code>构建完成交给<code>Renderer</code>渲染在页面上后，应用根节点的<code>current</code>指针指向<code>workInProgress Fiber树</code>，此时<code>workInProgress Fiber树</code>就变为<code>current Fiber树</code>。</p>
<p>每次状态更新都会产生新的<code>workInProgress Fiber树</code>，通过<code>current</code>与<code>workInProgress</code>的替换，完成<code>DOM</code>更新。</p>
<p>接下来我们以具体例子讲解<code>mount时</code>、<code>update时</code>的构建/替换流程。</p>
<h2 id="mount时" tabindex="-1"> mount时</h2>
<p>考虑如下例子：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>num<span>,</span> add<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>p onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>add</span><span>(</span>num <span>+</span> <span>1</span><span>)</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>p<span>></span>
  <span>)</span>
<span>}</span>

ReactDOM<span>.</span><span>render</span><span>(</span><span>&lt;</span>App<span>/</span><span>></span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol>
<li>首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>（源码中叫<code>fiberRoot</code>）和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是<code>&lt;App/&gt;</code>所在组件树的根节点。</li>
</ol>
<p>之所以要区分<code>fiberRootNode</code>与<code>rootFiber</code>，是因为在应用中我们可以多次调用<code>ReactDOM.render</code>渲染不同的组件树，他们会拥有不同的<code>rootFiber</code>。但是整个应用的根节点只有一个，那就是<code>fiberRootNode</code>。</p>
<p><code>fiberRootNode</code>的<code>current</code>会指向当前页面上已渲染内容对应<code>Fiber树</code>，即<code>current Fiber树</code>。</p>
<img :src="$withBase('/img/rootfiber.png')" alt="rootFiber">
<div><pre><code>fiberRootNode<span>.</span>current <span>=</span> rootFiber<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>由于是首屏渲染，页面中还没有挂载任何<code>DOM</code>，所以<code>fiberRootNode.current</code>指向的<code>rootFiber</code>没有任何<code>子Fiber节点</code>（即<code>current Fiber树</code>为空）。</p>
<ol start="2">
<li>接下来进入<code>render阶段</code>，根据组件返回的<code>JSX</code>在内存中依次创建<code>Fiber节点</code>并连接在一起构建<code>Fiber树</code>，被称为<code>workInProgress Fiber树</code>。（下图中右侧为内存中构建的树，左侧为页面显示的树）</li>
</ol>
<p>在构建<code>workInProgress Fiber树</code>时会尝试复用<code>current Fiber树</code>中已有的<code>Fiber节点</code>内的属性，在<code>首屏渲染</code>时只有<code>rootFiber</code>存在对应的<code>current fiber</code>（即<code>rootFiber.alternate</code>）。</p>
<img :src="$withBase('/img/workInProgressFiber.png')" alt="workInProgressFiber">
<ol start="3">
<li>图中右侧已构建完的<code>workInProgress Fiber树</code>在<code>commit阶段</code>渲染到页面。</li>
</ol>
<p>此时<code>DOM</code>更新为右侧树对应的样子。<code>fiberRootNode</code>的<code>current</code>指针指向<code>workInProgress Fiber树</code>使其变为<code>current Fiber 树</code>。</p>
<img :src="$withBase('/img/wipTreeFinish.png')" alt="workInProgressFiberFinish">
<h2 id="update时" tabindex="-1"> update时</h2>
<ol>
<li>接下来我们点击<code>p节点</code>触发状态改变，这会开启一次新的<code>render阶段</code>并构建一棵新的<code>workInProgress Fiber 树</code>。</li>
</ol>
<img :src="$withBase('/img/wipTreeUpdate.png')" alt="wipTreeUpdate">
<p>和<code>mount</code>时一样，<code>workInProgress fiber</code>的创建可以复用<code>current Fiber树</code>对应的节点数据。</p>
<blockquote>
<p>这个决定是否复用的过程就是Diff算法，后面章节会详细讲解</p>
</blockquote>
<ol start="2">
<li><code>workInProgress Fiber 树</code>在<code>render阶段</code>完成构建后进入<code>commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>。</li>
</ol>
<img :src="$withBase('/img/currentTreeUpdate.png')" alt="currentTreeUpdate">
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>本文介绍了<code>Fiber树</code>的构建与替换过程，这个过程伴随着<code>DOM</code>的更新。</p>
<p>那么在构建过程中每个<code>Fiber节点</code>具体是如何创建的呢？我们会在<code>架构篇</code>的<a href="/react/process/reconciler.html">render阶段</a>讲解。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<details><summary>Fiber树的创建与切换Demo</summary>
<p>此<code>Demo</code>会在如下时机在控制台打印信息：</p>
<ul>
<li>
<p>构建<code>WorkInProgrss Fiber</code>时</p>
</li>
<li>
<p>在渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>时</p>
</li>
</ul>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>812</strong>获得在线Demo地址</p>
</details>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Fiber架构的心智模型</title>
    <id>https://0808200.xyz/react/process/fiber-mental.html</id>
    <link href="https://0808200.xyz/react/process/fiber-mental.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>React核心团队成员<a href="https://github.com/sebmarkbage/" target="_blank" rel="noopener noreferrer">Sebastian Markbåge</a>（<code>React Hooks</code>的发明者）曾说：我们在<code>React</code>中做的就是践行<code>代数效应</code>（Algebraic Effects）。</p>
<p>那么，<code>代数效应</code>是什么呢？他和<code>React</code>有什么关系呢。</p>
<h2 id="什么是代数效应" tabindex="-1"> 什么是代数效应</h2>
<p><code>代数效应</code>是<code>函数式编程</code>中的一个概念，用于将<code>副作用</code>从<code>函数</code>调用中分离。</p>
<p>接下来我们用<code>虚构的语法</code>来解释。</p>
<p>假设我们有一个函数<code>getTotalPicNum</code>，传入2个<code>用户名称</code>后，分别查找该用户在平台保存的图片数量，最后将图片数量相加后返回。</p>
<div><pre><code><span>function</span> <span>getTotalPicNum</span><span>(</span><span>user1<span>,</span> user2</span><span>)</span> <span>{</span>
  <span>const</span> picNum1 <span>=</span> <span>getPicNum</span><span>(</span>user1<span>)</span><span>;</span>
  <span>const</span> picNum2 <span>=</span> <span>getPicNum</span><span>(</span>user2<span>)</span><span>;</span>

  <span>return</span> picNum1 <span>+</span> picNum2<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在<code>getTotalPicNum</code>中，我们不关注<code>getPicNum</code>的实现，只在乎“获取到两个数字后将他们相加的结果返回”这一过程。</p>
<p>接下来我们来实现<code>getPicNum</code>。</p>
<p>&quot;用户在平台保存的图片数量&quot;是保存在服务器中的。所以，为了获取该值，我们需要发起异步请求。</p>
<p>为了尽量保持<code>getTotalPicNum</code>的调用方式不变，我们首先想到了使用<code>async await</code>：</p>
<div><pre><code><span>async</span> <span>function</span> <span>getTotalPicNum</span><span>(</span><span>user1<span>,</span> user2</span><span>)</span> <span>{</span>
  <span>const</span> picNum1 <span>=</span> <span>await</span> <span>getPicNum</span><span>(</span>user1<span>)</span><span>;</span>
  <span>const</span> picNum2 <span>=</span> <span>await</span> <span>getPicNum</span><span>(</span>user2<span>)</span><span>;</span>

  <span>return</span> picNum1 <span>+</span> picNum2<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是，<code>async await</code>是有<code>传染性</code>的 —— 当一个函数变为<code>async</code>后，这意味着调用他的函数也需要是<code>async</code>，这破坏了<code>getTotalPicNum</code>的同步特性。</p>
<p>有没有什么办法能保持<code>getTotalPicNum</code>保持现有调用方式不变的情况下实现异步请求呢？</p>
<p>没有。不过我们可以<code>虚构</code>一个。</p>
<p>我们虚构一个类似<code>try...catch</code>的语法 —— <code>try...handle</code>与两个操作符<code>perform</code>、<code>resume</code>。</p>
<div><pre><code><span>function</span> <span>getPicNum</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  <span>const</span> picNum <span>=</span> perform name<span>;</span>
  <span>return</span> picNum<span>;</span>
<span>}</span>

<span>try</span> <span>{</span>
  <span>getTotalPicNum</span><span>(</span><span>'kaSong'</span><span>,</span> <span>'xiaoMing'</span><span>)</span><span>;</span>
<span>}</span> <span>handle</span> <span>(</span><span>who</span><span>)</span> <span>{</span>
  <span>switch</span> <span>(</span>who<span>)</span> <span>{</span>
    <span>case</span> <span>'kaSong'</span><span>:</span>
      resume <span>with</span> <span>230</span><span>;</span>
    <span>case</span> <span>'xiaoMing'</span><span>:</span>
      resume <span>with</span> <span>122</span><span>;</span>
    <span>default</span><span>:</span>
      resume <span>with</span> <span>0</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当执行到<code>getTotalPicNum</code>内部的<code>getPicNum</code>方法时，会执行<code>perform name</code>。</p>
<p>此时函数调用栈会从<code>getPicNum</code>方法内跳出，被最近一个<code>try...handle</code>捕获。类似<code>throw Error</code>后被最近一个<code>try...catch</code>捕获。</p>
<p>类似<code>throw Error</code>后<code>Error</code>会作为<code>catch</code>的参数，<code>perform name</code>后<code>name</code>会作为<code>handle</code>的参数。</p>
<p>与<code>try...catch</code>最大的不同在于：当<code>Error</code>被<code>catch</code>捕获后，之前的调用栈就销毁了。而<code>handle</code>执行<code>resume</code>后会回到之前<code>perform</code>的调用栈。</p>
<p>对于<code>case 'kaSong'</code>，执行完<code>resume with 230;</code>后调用栈会回到<code>getPicNum</code>，此时<code>picNum === 230</code></p>
<div><p>注意</p>
<p>再次申明，<code>try...handle</code>的语法是虚构的，只是为了演示<code>代数效应</code>的思想。</p>
</div>
<p>总结一下：<code>代数效应</code>能够将<code>副作用</code>（例子中为<code>请求图片数量</code>）从函数逻辑中分离，使函数关注点保持纯粹。</p>
<p>并且，从例子中可以看出，<code>perform resume</code>不需要区分同步异步。</p>
<h2 id="代数效应在react中的应用" tabindex="-1"> 代数效应在React中的应用</h2>
<p>那么<code>代数效应</code>与<code>React</code>有什么关系呢？最明显的例子就是<code>Hooks</code>。</p>
<p>对于类似<code>useState</code>、<code>useReducer</code>、<code>useRef</code>这样的<code>Hook</code>，我们不需要关注<code>FunctionComponent</code>的<code>state</code>在<code>Hook</code>中是如何保存的，<code>React</code>会为我们处理。</p>
<p>我们只需要假设<code>useState</code>返回的是我们想要的<code>state</code>，并编写业务逻辑就行。</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>num<span>,</span> updateNum<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>updateNum</span><span>(</span><span>num</span> <span>=></span> num <span>+</span> <span>1</span><span>)</span><span>}</span><span>></span><span>{</span>num<span>}</span><span>&lt;</span><span>/</span>button<span>></span>  
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果这个例子还不够明显，可以看看官方的<a href="https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160" target="_blank" rel="noopener noreferrer">Suspense Demo</a></p>
<p>在<code>Demo</code>中<code>ProfileDetails</code>用于展示<code>用户名称</code>。而<code>用户名称</code>是<code>异步请求</code>的。</p>
<p>但是<code>Demo</code>中完全是<code>同步</code>的写法。</p>
<div><pre><code><span>function</span> <span>ProfileDetails</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> user <span>=</span> resource<span>.</span>user<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span>h1<span>></span><span>{</span>user<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>h1<span>></span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="代数效应与generator" tabindex="-1"> 代数效应与Generator</h2>
<p>从<code>React15</code>到<code>React16</code>，协调器（<code>Reconciler</code>）重构的一大目的是：将老的<code>同步更新</code>的架构变为<code>异步可中断更新</code>。</p>
<p><code>异步可中断更新</code>可以理解为：<code>更新</code>在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p>
<p>这就是<code>代数效应</code>中<code>try...handle</code>的作用。</p>
<p>其实，浏览器原生就支持类似的实现，这就是<code>Generator</code>。</p>
<p>但是<code>Generator</code>的一些缺陷使<code>React</code>团队放弃了他：</p>
<ul>
<li>
<p>类似<code>async</code>，<code>Generator</code>也是<code>传染性</code>的，使用了<code>Generator</code>则上下文的其他函数也需要作出改变。这样心智负担比较重。</p>
</li>
<li>
<p><code>Generator</code>执行的<code>中间状态</code>是上下文关联的。</p>
</li>
</ul>
<p>考虑如下例子：</p>
<div><pre><code><span>function</span><span>*</span> <span>doWork</span><span>(</span><span><span>A</span><span>,</span> <span>B</span><span>,</span> <span>C</span></span><span>)</span> <span>{</span>
  <span>var</span> x <span>=</span> <span>doExpensiveWorkA</span><span>(</span><span>A</span><span>)</span><span>;</span>
  <span>yield</span><span>;</span>
  <span>var</span> y <span>=</span> x <span>+</span> <span>doExpensiveWorkB</span><span>(</span><span>B</span><span>)</span><span>;</span>
  <span>yield</span><span>;</span>
  <span>var</span> z <span>=</span> y <span>+</span> <span>doExpensiveWorkC</span><span>(</span><span>C</span><span>)</span><span>;</span>
  <span>return</span> z<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>每当浏览器有空闲时间都会依次执行其中一个<code>doExpensiveWork</code>，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。</p>
<p>只考虑“单一优先级任务的中断与继续”情况下<code>Generator</code>可以很好的实现<code>异步可中断更新</code>。</p>
<p>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成<code>doExpensiveWorkA</code>与<code>doExpensiveWorkB</code>计算出<code>x</code>与<code>y</code>。</p>
<p>此时<code>B</code>组件接收到一个<code>高优更新</code>，由于<code>Generator</code>执行的<code>中间状态</code>是上下文关联的，所以计算<code>y</code>时无法复用之前已经计算出的<code>x</code>，需要重新计算。</p>
<p>如果通过<code>全局变量</code>保存之前执行的<code>中间状态</code>，又会引入新的复杂度。</p>
<blockquote>
<p>更详细的解释可以参考<a href="https://github.com/facebook/react/issues/7942#issuecomment-254987818" target="_blank" rel="noopener noreferrer">这个issue</a></p>
</blockquote>
<p>基于这些原因，<code>React</code>没有采用<code>Generator</code>实现<code>协调器</code>。</p>
<h2 id="代数效应与fiber" tabindex="-1"> 代数效应与Fiber</h2>
<p><code>Fiber</code>并不是计算机术语中的新名词，他的中文翻译叫做<code>纤程</code>，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p>
<p>在很多文章中将<code>纤程</code>理解为<code>协程</code>的一种实现。在<code>JS</code>中，<code>协程</code>的实现便是<code>Generator</code>。</p>
<p>所以，我们可以将<code>纤程</code>(Fiber)、<code>协程</code>(Generator)理解为<code>代数效应</code>思想在<code>JS</code>中的体现。</p>
<p><code>React Fiber</code>可以理解为：</p>
<p><code>React</code>内部实现的一套状态更新机制。支持任务不同<code>优先级</code>，可中断与恢复，并且恢复后可以复用之前的<code>中间状态</code>。</p>
<p>其中每个任务更新单元为<code>React Element</code>对应的<code>Fiber节点</code>。</p>
<p>下一节，我们具体讲解<code>Fiber架构</code>的实现。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Fiber架构的实现原理</title>
    <id>https://0808200.xyz/react/process/fiber.html</id>
    <link href="https://0808200.xyz/react/process/fiber.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/react/preparation/newConstructure.html">新的React架构一节</a>中，我们提到的<strong>虚拟DOM</strong>在<code>React</code>中有个正式的称呼——<code>Fiber</code>。在之后的学习中，我们会逐渐用<code>Fiber</code>来取代<strong>React16虚拟DOM</strong>这一称呼。</p>
<p>接下来让我们了解下<code>Fiber</code>因何而来？他的作用是什么？</p>
<h2 id="fiber的起源" tabindex="-1"> Fiber的起源</h2>
<blockquote>
<p>最早的<code>Fiber</code>官方解释来源于<a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noopener noreferrer">2016年React团队成员Acdlite的一篇介绍</a>。</p>
</blockquote>
<p>从上一章的学习我们知道：</p>
<p>在<code>React15</code>及以前，<code>Reconciler</code>采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p>
<p>为了解决这个问题，<code>React16</code>将<strong>递归的无法中断的更新</strong>重构为<strong>异步的可中断更新</strong>，由于曾经用于递归的<strong>虚拟DOM</strong>数据结构已经无法满足需要。于是，全新的<code>Fiber</code>架构应运而生。</p>
<h2 id="fiber的含义" tabindex="-1"> Fiber的含义</h2>
<p><code>Fiber</code>包含三层含义：</p>
<ol>
<li>
<p>作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</p>
</li>
<li>
<p>作为静态的数据结构来说，每个<code>Fiber节点</code>对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。</p>
</li>
<li>
<p>作为动态的工作单元来说，每个<code>Fiber节点</code>保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。</p>
</li>
</ol>
<h2 id="fiber的结构" tabindex="-1"> Fiber的结构</h2>
<p>你可以从这里看到<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117" target="_blank" rel="noopener noreferrer">Fiber节点的属性定义</a>。虽然属性很多，但我们可以按三层含义将他们分类来看</p>
<div><pre><code><span>function</span> <span>FiberNode</span><span>(</span>
  <span><span>tag</span><span>:</span> WorkTag<span>,</span>
  <span>pendingProps</span><span>:</span> mixed<span>,</span>
  <span>key</span><span>:</span> <span>null</span> <span>|</span> string<span>,</span>
  <span>mode</span><span>:</span> TypeOfMode<span>,</span></span>
<span>)</span> <span>{</span>
  <span>// 作为静态数据结构的属性</span>
  <span>this</span><span>.</span>tag <span>=</span> tag<span>;</span>
  <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
  <span>this</span><span>.</span>elementType <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>type <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>stateNode <span>=</span> <span>null</span><span>;</span>

  <span>// 用于连接其他Fiber节点形成Fiber树</span>
  <span>this</span><span>.</span>return <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>child <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>sibling <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>index <span>=</span> <span>0</span><span>;</span>

  <span>this</span><span>.</span>ref <span>=</span> <span>null</span><span>;</span>

  <span>// 作为动态的工作单元的属性</span>
  <span>this</span><span>.</span>pendingProps <span>=</span> pendingProps<span>;</span>
  <span>this</span><span>.</span>memoizedProps <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>updateQueue <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>memoizedState <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>dependencies <span>=</span> <span>null</span><span>;</span>

  <span>this</span><span>.</span>mode <span>=</span> mode<span>;</span>

  <span>this</span><span>.</span>effectTag <span>=</span> NoEffect<span>;</span>
  <span>this</span><span>.</span>nextEffect <span>=</span> <span>null</span><span>;</span>

  <span>this</span><span>.</span>firstEffect <span>=</span> <span>null</span><span>;</span>
  <span>this</span><span>.</span>lastEffect <span>=</span> <span>null</span><span>;</span>

  <span>// 调度优先级相关</span>
  <span>this</span><span>.</span>lanes <span>=</span> NoLanes<span>;</span>
  <span>this</span><span>.</span>childLanes <span>=</span> NoLanes<span>;</span>

  <span>// 指向该fiber在另一次更新时对应的fiber</span>
  <span>this</span><span>.</span>alternate <span>=</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="作为架构来说" tabindex="-1"> 作为架构来说</h3>
<p>每个Fiber节点有个对应的<code>React element</code>，多个<code>Fiber节点</code>是如何连接形成树呢？靠如下三个属性：</p>
<div><pre><code><span>// 指向父级Fiber节点</span>
<span>this</span><span>.</span>return <span>=</span> <span>null</span><span>;</span>
<span>// 指向子Fiber节点</span>
<span>this</span><span>.</span>child <span>=</span> <span>null</span><span>;</span>
<span>// 指向右边第一个兄弟Fiber节点</span>
<span>this</span><span>.</span>sibling <span>=</span> <span>null</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>举个例子，如下的组件结构：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>></span>
      i am
      <span>&lt;</span>span<span>></span>KaSong<span>&lt;</span><span>/</span>span<span>></span>
    <span>&lt;</span><span>/</span>div<span>></span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对应的<code>Fiber树</code>结构：
<img :src="$withBase('/img/fiber.png')" alt="Fiber架构"></p>
<blockquote>
<p>这里需要提一下，为什么父级指针叫做<code>return</code>而不是<code>parent</code>或者<code>father</code>呢？因为作为一个工作单元，<code>return</code>指节点执行完<code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子<code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用<code>return</code>指代父级节点。</p>
</blockquote>
<h3 id="作为静态的数据结构" tabindex="-1"> 作为静态的数据结构</h3>
<p>作为一种静态的数据结构，保存了组件相关的信息：</p>
<div><pre><code><span>// Fiber对应组件的类型 Function/Class/Host...</span>
<span>this</span><span>.</span>tag <span>=</span> tag<span>;</span>
<span>// key属性</span>
<span>this</span><span>.</span>key <span>=</span> key<span>;</span>
<span>// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span>
<span>this</span><span>.</span>elementType <span>=</span> <span>null</span><span>;</span>
<span>// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span>
<span>this</span><span>.</span>type <span>=</span> <span>null</span><span>;</span>
<span>// Fiber对应的真实DOM节点</span>
<span>this</span><span>.</span>stateNode <span>=</span> <span>null</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="作为动态的工作单元" tabindex="-1"> 作为动态的工作单元</h3>
<p>作为动态的工作单元，<code>Fiber</code>中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍</p>
<div><pre><code>
<span>// 保存本次更新造成的状态改变相关信息</span>
<span>this</span><span>.</span>pendingProps <span>=</span> pendingProps<span>;</span>
<span>this</span><span>.</span>memoizedProps <span>=</span> <span>null</span><span>;</span>
<span>this</span><span>.</span>updateQueue <span>=</span> <span>null</span><span>;</span>
<span>this</span><span>.</span>memoizedState <span>=</span> <span>null</span><span>;</span>
<span>this</span><span>.</span>dependencies <span>=</span> <span>null</span><span>;</span>

<span>this</span><span>.</span>mode <span>=</span> mode<span>;</span>

<span>// 保存本次更新会造成的DOM操作</span>
<span>this</span><span>.</span>effectTag <span>=</span> NoEffect<span>;</span>
<span>this</span><span>.</span>nextEffect <span>=</span> <span>null</span><span>;</span>

<span>this</span><span>.</span>firstEffect <span>=</span> <span>null</span><span>;</span>
<span>this</span><span>.</span>lastEffect <span>=</span> <span>null</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如下两个字段保存调度优先级相关的信息，会在讲解<code>Scheduler</code>时介绍。</p>
<div><pre><code><span>// 调度优先级相关</span>
<span>this</span><span>.</span>lanes <span>=</span> NoLanes<span>;</span>
<span>this</span><span>.</span>childLanes <span>=</span> NoLanes<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>在2020年5月，调度优先级策略经历了比较大的重构。以<code>expirationTime</code>属性为代表的优先级模型被<code>lane</code>取代。详见<a href="https://github.com/facebook/react/pull/18796" target="_blank" rel="noopener noreferrer">这个PR</a></p>
<p>如果你的源码中<code>fiber.expirationTime</code>仍存在，请参照<a href="/react/preparation/source.html">调试源码</a>章节获取最新代码。</p>
</div>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>本节我们了解了<code>Fiber</code>的起源与架构，其中<code>Fiber节点</code>可以构成<code>Fiber树</code>。那么<code>Fiber树</code>和页面呈现的<code>DOM树</code>有什么关系，<code>React</code>又是如何更新<code>DOM</code>的呢？</p>
<p>我们会在下一节讲解。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://www.bilibili.com/video/BV1it411p7v6?from=search&amp;seid=3508901752524570226" target="_blank" rel="noopener noreferrer">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">流程概览</title>
    <id>https://0808200.xyz/react/process/reconciler.html</id>
    <link href="https://0808200.xyz/react/process/reconciler.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>本章我们会讲解<code>Fiber节点</code>是如何被创建并构建<code>Fiber树</code>的。</p>
<p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p>
<p>我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：</p>
<div><pre><code><span>// performSyncWorkOnRoot会调用该方法</span>
<span>function</span> <span>workLoopSync</span><span>(</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>workInProgress <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>performUnitOfWork</span><span>(</span>workInProgress<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// performConcurrentWorkOnRoot会调用该方法</span>
<span>function</span> <span>workLoopConcurrent</span><span>(</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>workInProgress <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span><span>shouldYield</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>performUnitOfWork</span><span>(</span>workInProgress<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，他们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p>
<p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p>
<p><code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber节点</code>连接起来构成<code>Fiber树</code>。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599" target="_blank" rel="noopener noreferrer">这里</a>看到<code>workLoopConcurrent</code>的源码</p>
</blockquote>
<p>我们知道<code>Fiber Reconciler</code>是从<code>Stack Reconciler</code>重构而来，通过遍历的方式实现可中断的递归，所以<code>performUnitOfWork</code>的工作可以分为两部分：“递”和“归”。</p>
<h2 id="递-阶段" tabindex="-1"> “递”阶段</h2>
<p>首先从<code>rootFiber</code>开始向下深度优先遍历。为遍历到的每个<code>Fiber节点</code>调用<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058" target="_blank" rel="noopener noreferrer">beginWork方法</a>。</p>
<p>该方法会根据传入的<code>Fiber节点</code>创建<code>子Fiber节点</code>，并将这两个<code>Fiber节点</code>连接起来。</p>
<p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p>
<h2 id="归-阶段" tabindex="-1"> “归”阶段</h2>
<p>在“归”阶段会调用<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652" target="_blank" rel="noopener noreferrer">completeWork</a>处理<code>Fiber节点</code>。</p>
<p>当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。</p>
<p>如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p>
<p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p>
<h2 id="例子" tabindex="-1"> 例子</h2>
<p>以上一节的例子举例：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>></span>
      i am
      <span>&lt;</span>span<span>></span>KaSong<span>&lt;</span><span>/</span>span<span>></span>
    <span>&lt;</span><span>/</span>div<span>></span>
  <span>)</span>
<span>}</span>

ReactDOM<span>.</span><span>render</span><span>(</span><span>&lt;</span>App <span>/</span><span>></span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>"root"</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对应的<code>Fiber树</code>结构：
<img :src="$withBase('/img/fiber.png')" alt="Fiber架构"></p>
<p><code>render阶段</code>会依次执行：</p>
<div><pre><code><span>1</span>. rootFiber beginWork
<span>2</span>. App Fiber beginWork
<span>3</span>. div Fiber beginWork
<span>4</span>. <span>"i am"</span> Fiber beginWork
<span>5</span>. <span>"i am"</span> Fiber completeWork
<span>6</span>. span Fiber beginWork
<span>7</span>. span Fiber completeWork
<span>8</span>. div Fiber completeWork
<span>9</span>. App Fiber completeWork
<span>10</span>. rootFiber completeWork
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的<code>Fiber</code>，<code>React</code>会特殊处理。</p>
</div>
<details><summary>自己试一试 Demo</summary>
<p>我在<code>beginWork</code>和<code>completeWork</code>调用时打印<code>fiber.tag</code>和<code>fiber.type</code>。</p>
<p>你可以从<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactWorkTags.js" target="_blank" rel="noopener noreferrer">ReactWorkTags.js</a>看到<code>Fiber节点</code>的所有<code>tag</code>定义。</p>
<p>相信多调试几次，你一定能明白方法的调用顺序</p>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>904</strong>获得在线Demo地址</p>
</details>
<details><summary>performUnitOfWork 的递归版本</summary>
<p>如果将<code>performUnitOfWork</code>转化为递归版本，大体代码如下：</p>
<div><pre><code><span>function</span> <span>performUnitOfWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>// 执行beginWork</span>

  <span>if</span> <span>(</span>fiber<span>.</span>child<span>)</span> <span>{</span>
    <span>performUnitOfWork</span><span>(</span>fiber<span>.</span>child<span>)</span><span>;</span>
  <span>}</span>

  <span>// 执行completeWork</span>

  <span>if</span> <span>(</span>fiber<span>.</span>sibling<span>)</span> <span>{</span>
    <span>performUnitOfWork</span><span>(</span>fiber<span>.</span>sibling<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></details>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>本节我们介绍了<code>render阶段</code>会调用的方法。在接下来两节中，我们会讲解<code>beginWork</code>和<code>completeWork</code>做的具体工作。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/" target="_blank" rel="noopener noreferrer">The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a></p>
<p><a href="https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/" target="_blank" rel="noopener noreferrer">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">before mutation阶段</title>
    <id>https://0808200.xyz/react/renderer/beforeMutation.html</id>
    <link href="https://0808200.xyz/react/renderer/beforeMutation.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在本节正式开始前，让我们复习下这一章到目前为止所学的。</p>
<p><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。<code>commit</code>阶段可以分为三个子阶段：</p>
<ul>
<li>
<p>before mutation阶段（执行<code>DOM</code>操作前）</p>
</li>
<li>
<p>mutation阶段（执行<code>DOM</code>操作）</p>
</li>
<li>
<p>layout阶段（执行<code>DOM</code>操作后）</p>
</li>
</ul>
<p>本节我们看看<code>before mutation阶段</code>（执行<code>DOM</code>操作前）都做了什么。</p>
<h2 id="概览" tabindex="-1"> 概览</h2>
<p><code>before mutation阶段</code>的代码很短，整个过程就是遍历<code>effectList</code>并调用<code>commitBeforeMutationEffects</code>函数处理。</p>
<blockquote>
<p>这部分<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127" target="_blank" rel="noopener noreferrer">源码在这里</a>。为了增加可读性，示例代码中删除了不相关的逻辑</p>
</blockquote>
<div><pre><code><span>// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span>
<span>const</span> previousLanePriority <span>=</span> <span>getCurrentUpdateLanePriority</span><span>(</span><span>)</span><span>;</span>
<span>setCurrentUpdateLanePriority</span><span>(</span>SyncLanePriority<span>)</span><span>;</span>

<span>// 将当前上下文标记为CommitContext，作为commit阶段的标志</span>
<span>const</span> prevExecutionContext <span>=</span> executionContext<span>;</span>
executionContext <span>|=</span> CommitContext<span>;</span>

<span>// 处理focus状态</span>
focusedInstanceHandle <span>=</span> <span>prepareForCommit</span><span>(</span>root<span>.</span>containerInfo<span>)</span><span>;</span>
shouldFireAfterActiveInstanceBlur <span>=</span> <span>false</span><span>;</span>

<span>// beforeMutation阶段的主函数</span>
<span>commitBeforeMutationEffects</span><span>(</span>finishedWork<span>)</span><span>;</span>

focusedInstanceHandle <span>=</span> <span>null</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们重点关注<code>beforeMutation</code>阶段的主函数<code>commitBeforeMutationEffects</code>做了什么。</p>
<h2 id="commitbeforemutationeffects" tabindex="-1"> commitBeforeMutationEffects</h2>
<p>大体代码逻辑：</p>
<div><pre><code><span>function</span> <span>commitBeforeMutationEffects</span><span>(</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>nextEffect <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>

    <span>if</span> <span>(</span><span>!</span>shouldFireAfterActiveInstanceBlur <span>&amp;&amp;</span> focusedInstanceHandle <span>!==</span> <span>null</span><span>)</span> <span>{</span>
      <span>// ...focus blur相关</span>
    <span>}</span>

    <span>const</span> effectTag <span>=</span> nextEffect<span>.</span>effectTag<span>;</span>

    <span>// 调用getSnapshotBeforeUpdate</span>
    <span>if</span> <span>(</span><span>(</span>effectTag <span>&amp;</span> Snapshot<span>)</span> <span>!==</span> NoEffect<span>)</span> <span>{</span>
      <span>commitBeforeMutationEffectOnFiber</span><span>(</span>current<span>,</span> nextEffect<span>)</span><span>;</span>
    <span>}</span>

    <span>// 调度useEffect</span>
    <span>if</span> <span>(</span><span>(</span>effectTag <span>&amp;</span> Passive<span>)</span> <span>!==</span> NoEffect<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>rootDoesHavePassiveEffects<span>)</span> <span>{</span>
        rootDoesHavePassiveEffects <span>=</span> <span>true</span><span>;</span>
        <span>scheduleCallback</span><span>(</span>NormalSchedulerPriority<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>flushPassiveEffects</span><span>(</span><span>)</span><span>;</span>
          <span>return</span> <span>null</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
    nextEffect <span>=</span> nextEffect<span>.</span>nextEffect<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>整体可以分为三部分：</p>
<ol>
<li>
<p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code> 逻辑。</p>
</li>
<li>
<p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子。</p>
</li>
<li>
<p>调度<code>useEffect</code>。</p>
</li>
</ol>
<p>我们讲解下2、3两点。</p>
<h2 id="调用getsnapshotbeforeupdate" tabindex="-1"> 调用getSnapshotBeforeUpdate</h2>
<p><code>commitBeforeMutationEffectOnFiber</code>是<code>commitBeforeMutationLifeCycles</code>的别名。</p>
<p>在该方法内会调用<code>getSnapshotBeforeUpdate</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222" target="_blank" rel="noopener noreferrer">这里</a>看到这段逻辑</p>
</blockquote>
<p>从<code>React</code>v16开始，<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。</p>
<p>究其原因，是因为<code>Stack Reconciler</code>重构为<code>Fiber Reconciler</code>后，<code>render阶段</code>的任务可能中断/重新开始，对应的组件在<code>render阶段</code>的生命周期钩子（即<code>componentWillXXX</code>）可能触发多次。</p>
<p>这种行为和<code>React</code>v15不一致，所以标记为<code>UNSAFE_</code>。</p>
<blockquote>
<p>更详细的解释参照<a href="https://juejin.im/post/6847902224287285255#comment" target="_blank" rel="noopener noreferrer">这里</a></p>
</blockquote>
<p>为此，<code>React</code>提供了替代的生命周期钩子<code>getSnapshotBeforeUpdate</code>。</p>
<p>我们可以看见，<code>getSnapshotBeforeUpdate</code>是在<code>commit阶段</code>内的<code>before mutation阶段</code>调用的，由于<code>commit阶段</code>是同步的，所以不会遇到多次调用的问题。</p>
<h2 id="调度useeffect" tabindex="-1"> 调度<code>useEffect</code></h2>
<p>在这几行代码内，<code>scheduleCallback</code>方法由<code>Scheduler</code>模块提供，用于以某个优先级异步调度一个回调函数。</p>
<div><pre><code><span>// 调度useEffect</span>
<span>if</span> <span>(</span><span>(</span>effectTag <span>&amp;</span> Passive<span>)</span> <span>!==</span> NoEffect<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>rootDoesHavePassiveEffects<span>)</span> <span>{</span>
    rootDoesHavePassiveEffects <span>=</span> <span>true</span><span>;</span>
    <span>scheduleCallback</span><span>(</span>NormalSchedulerPriority<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>// 触发useEffect</span>
      <span>flushPassiveEffects</span><span>(</span><span>)</span><span>;</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在此处，被异步调度的回调函数就是触发<code>useEffect</code>的方法<code>flushPassiveEffects</code>。</p>
<p>我们接下来讨论<code>useEffect</code>如何被异步调度，以及为什么要异步（而不是同步）调度。</p>
<h3 id="如何异步调度" tabindex="-1"> 如何异步调度</h3>
<p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。</p>
<p>关于<code>flushPassiveEffects</code>的具体讲解参照<a href="/react/hooks/useeffect.html">useEffect与useLayoutEffect一节</a></p>
<p>在<a href="/react/process/completeWork.html#effectlist">completeWork一节</a>我们讲到，<code>effectList</code>中保存了需要执行副作用的<code>Fiber节点</code>。其中副作用包括</p>
<ul>
<li>插入<code>DOM节点</code>（Placement）</li>
<li>更新<code>DOM节点</code>（Update）</li>
<li>删除<code>DOM节点</code>（Deletion）</li>
</ul>
<p>除此外，当一个<code>FunctionComponent</code>含有<code>useEffect</code>或<code>useLayoutEffect</code>，他对应的<code>Fiber节点</code>也会被赋值<code>effectTag</code>。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js" target="_blank" rel="noopener noreferrer">这里</a>看到<code>hook</code>相关的<code>effectTag</code></p>
</blockquote>
<p>在<code>flushPassiveEffects</code>方法内部会遍历<code>rootWithPendingPassiveEffects</code>（即<code>effectList</code>）执行<code>effect</code>回调函数。</p>
<p>如果在此时直接执行，<code>rootWithPendingPassiveEffects === null</code>。</p>
<p>那么<code>rootWithPendingPassiveEffects</code>会在何时赋值呢？</p>
<p>在上一节<code>layout之后</code>的代码片段中会根据<code>rootDoesHavePassiveEffects === true?</code>决定是否赋值<code>rootWithPendingPassiveEffects</code>。</p>
<div><pre><code><span>const</span> rootDidHavePassiveEffects <span>=</span> rootDoesHavePassiveEffects<span>;</span>
<span>if</span> <span>(</span>rootDoesHavePassiveEffects<span>)</span> <span>{</span>
  rootDoesHavePassiveEffects <span>=</span> <span>false</span><span>;</span>
  rootWithPendingPassiveEffects <span>=</span> root<span>;</span>
  pendingPassiveEffectsLanes <span>=</span> lanes<span>;</span>
  pendingPassiveEffectsRenderPriority <span>=</span> renderPriorityLevel<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以整个<code>useEffect</code>异步调用分为三步：</p>
<ol>
<li><code>before mutation阶段</code>在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code></li>
<li><code>layout阶段</code>之后将<code>effectList</code>赋值给<code>rootWithPendingPassiveEffects</code></li>
<li><code>scheduleCallback</code>触发<code>flushPassiveEffects</code>，<code>flushPassiveEffects</code>内部遍历<code>rootWithPendingPassiveEffects</code></li>
</ol>
<h3 id="为什么需要异步调用" tabindex="-1"> 为什么需要异步调用</h3>
<p>摘录自<code>React</code>文档<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects" target="_blank" rel="noopener noreferrer">effect 的执行时机</a>：</p>
<blockquote>
<p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
</blockquote>
<p>可见，<code>useEffect</code>异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>经过本节学习，我们知道了在<code>before mutation阶段</code>，会遍历<code>effectList</code>，依次执行：</p>
<ol>
<li>
<p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code>逻辑</p>
</li>
<li>
<p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子</p>
</li>
<li>
<p>调度<code>useEffect</code></p>
</li>
</ol>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">layout阶段</title>
    <id>https://0808200.xyz/react/renderer/layout.html</id>
    <link href="https://0808200.xyz/react/renderer/layout.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>该阶段之所以称为<code>layout</code>，因为该阶段的代码都是在<code>DOM</code>修改完成（<code>mutation阶段</code>完成）后执行的。</p>
<p>注意：由于 JS 的同步执行阻塞了主线程，所以此时 JS 已经可以获取到新的<code>DOM</code>，但是浏览器对新的<code>DOM</code>并没有完成渲染。</p>
<p>该阶段触发的生命周期钩子和<code>hook</code>可以直接访问到已经改变后的<code>DOM</code>，即该阶段是可以参与<code>DOM layout</code>的阶段。</p>
<h2 id="概览" tabindex="-1"> 概览</h2>
<p>与前两个阶段类似，<code>layout阶段</code>也是遍历<code>effectList</code>，执行函数。</p>
<p>具体执行的函数是<code>commitLayoutEffects</code>。</p>
<div><pre><code>root<span>.</span>current <span>=</span> finishedWork<span>;</span>

nextEffect <span>=</span> firstEffect<span>;</span>
<span>do</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>commitLayoutEffects</span><span>(</span>root<span>,</span> lanes<span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
    <span>invariant</span><span>(</span>nextEffect <span>!==</span> <span>null</span><span>,</span> <span>"Should be working on an effect."</span><span>)</span><span>;</span>
    <span>captureCommitPhaseError</span><span>(</span>nextEffect<span>,</span> error<span>)</span><span>;</span>
    nextEffect <span>=</span> nextEffect<span>.</span>nextEffect<span>;</span>
  <span>}</span>
<span>}</span> <span>while</span> <span>(</span>nextEffect <span>!==</span> <span>null</span><span>)</span><span>;</span>

nextEffect <span>=</span> <span>null</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="commitlayouteffects" tabindex="-1"> commitLayoutEffects</h2>
<p>代码如下：</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2302" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitLayoutEffects</code>源码</p>
</blockquote>
<div><pre><code><span>function</span> <span>commitLayoutEffects</span><span>(</span><span><span>root</span><span>:</span> FiberRoot<span>,</span> <span>committedLanes</span><span>:</span> Lanes</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>nextEffect <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>const</span> effectTag <span>=</span> nextEffect<span>.</span>effectTag<span>;</span>

    <span>// 调用生命周期钩子和hook</span>
    <span>if</span> <span>(</span>effectTag <span>&amp;</span> <span>(</span>Update <span>|</span> Callback<span>)</span><span>)</span> <span>{</span>
      <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>
      <span>commitLayoutEffectOnFiber</span><span>(</span>root<span>,</span> current<span>,</span> nextEffect<span>,</span> committedLanes<span>)</span><span>;</span>
    <span>}</span>

    <span>// 赋值ref</span>
    <span>if</span> <span>(</span>effectTag <span>&amp;</span> Ref<span>)</span> <span>{</span>
      <span>commitAttachRef</span><span>(</span>nextEffect<span>)</span><span>;</span>
    <span>}</span>

    nextEffect <span>=</span> nextEffect<span>.</span>nextEffect<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>commitLayoutEffects</code>一共做了两件事：</p>
<ol>
<li>
<p>commitLayoutEffectOnFiber（调用<code>生命周期钩子</code>和<code>hook</code>相关操作）</p>
</li>
<li>
<p>commitAttachRef（赋值 ref）</p>
</li>
</ol>
<h2 id="commitlayouteffectonfiber" tabindex="-1"> commitLayoutEffectOnFiber</h2>
<p><code>commitLayoutEffectOnFiber</code>方法会根据<code>fiber.tag</code>对不同类型的节点分别处理。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L459" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitLayoutEffectOnFiber</code>源码（<code>commitLayoutEffectOnFiber</code>为别名，方法原名为<code>commitLifeCycles</code>）</p>
</blockquote>
<ul>
<li>对于<code>ClassComponent</code>，他会通过<code>current === null?</code>区分是<code>mount</code>还是<code>update</code>，调用<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L538" target="_blank" rel="noopener noreferrer"><code>componentDidMount</code></a>或<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L592" target="_blank" rel="noopener noreferrer"><code>componentDidUpdate</code></a>。</li>
</ul>
<p>触发<code>状态更新</code>的<code>this.setState</code>如果赋值了第二个参数<code>回调函数</code>，也会在此时调用。</p>
<div><pre><code><span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> <span>xxx</span><span>:</span> <span>1</span> <span>}</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"i am update~"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>对于<code>FunctionComponent</code>及相关类型，他会调用<code>useLayoutEffect hook</code>的<code>回调函数</code>，调度<code>useEffect</code>的<code>销毁</code>与<code>回调</code>函数</li>
</ul>
<blockquote>
<p><code>相关类型</code>指特殊处理后的<code>FunctionComponent</code>，比如<code>ForwardRef</code>、<code>React.memo</code>包裹的<code>FunctionComponent</code></p>
</blockquote>
<div><pre><code>  <span>switch</span> <span>(</span>finishedWork<span>.</span>tag<span>)</span> <span>{</span>
    <span>// 以下都是FunctionComponent及相关类型</span>
    <span>case</span> <span>FunctionComponent</span><span>:</span>
    <span>case</span> <span>ForwardRef</span><span>:</span>
    <span>case</span> <span>SimpleMemoComponent</span><span>:</span>
    <span>case</span> <span>Block</span><span>:</span> <span>{</span>
      <span>// 执行useLayoutEffect的回调函数</span>
      <span>commitHookEffectListMount</span><span>(</span>HookLayout <span>|</span> HookHasEffect<span>,</span> finishedWork<span>)</span><span>;</span>
      <span>// 调度useEffect的销毁函数与回调函数</span>
      <span>schedulePassiveEffects</span><span>(</span>finishedWork<span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L465-L491" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>在上一节介绍<a href="/react/renderer/mutation.html#update-effect">Update effect</a>时介绍过，<code>mutation阶段</code>会执行<code>useLayoutEffect hook</code>的<code>销毁函数</code>。</p>
<p>结合这里我们可以发现，<code>useLayoutEffect hook</code>从上一次更新的<code>销毁函数</code>调用到本次更新的<code>回调函数</code>调用是同步执行的。</p>
<p>而<code>useEffect</code>则需要先调度，在<code>Layout阶段</code>完成后再异步执行。</p>
<p>这就是<code>useLayoutEffect</code>与<code>useEffect</code>的区别。</p>
<ul>
<li>对于<code>HostRoot</code>，即<code>rootFiber</code>，如果赋值了第三个参数<code>回调函数</code>，也会在此时调用。</li>
</ul>
<div><pre><code>ReactDOM<span>.</span><span>render</span><span>(</span><span>&lt;</span>App <span>/</span><span>></span><span>,</span> document<span>.</span><span>querySelector</span><span>(</span><span>"#root"</span><span>)</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"i am mount~"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="commitattachref" tabindex="-1"> commitAttachRef</h2>
<p><code>commitLayoutEffects</code>会做的第二件事是<code>commitAttachRef</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L823" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitAttachRef</code>源码</p>
</blockquote>
<div><pre><code><span>function</span> <span>commitAttachRef</span><span>(</span><span><span>finishedWork</span><span>:</span> Fiber</span><span>)</span> <span>{</span>
  <span>const</span> ref <span>=</span> finishedWork<span>.</span>ref<span>;</span>
  <span>if</span> <span>(</span>ref <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>const</span> instance <span>=</span> finishedWork<span>.</span>stateNode<span>;</span>

    <span>// 获取DOM实例</span>
    <span>let</span> instanceToUse<span>;</span>
    <span>switch</span> <span>(</span>finishedWork<span>.</span>tag<span>)</span> <span>{</span>
      <span>case</span> <span>HostComponent</span><span>:</span>
        instanceToUse <span>=</span> <span>getPublicInstance</span><span>(</span>instance<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>default</span><span>:</span>
        instanceToUse <span>=</span> instance<span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>typeof</span> ref <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
      <span>// 如果ref是函数形式，调用回调函数</span>
      <span>ref</span><span>(</span>instanceToUse<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// 如果ref是ref实例形式，赋值ref.current</span>
      ref<span>.</span>current <span>=</span> instanceToUse<span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>代码逻辑很简单：获取<code>DOM</code>实例，更新<code>ref</code>。</p>
<h2 id="current-fiber树切换" tabindex="-1"> current Fiber树切换</h2>
<p>至此，整个<code>layout阶段</code>就结束了。</p>
<p>在结束本节的学习前，我们关注下这行代码：</p>
<div><pre><code>root<span>.</span>current <span>=</span> finishedWork<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2022" target="_blank" rel="noopener noreferrer">这里</a>看到这行代码</p>
</blockquote>
<p>在<a href="/react/process/doubleBuffer.html#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%8F%8C%E7%BC%93%E5%AD%98">双缓存机制一节</a>我们介绍过，<code>workInProgress Fiber树</code>在<code>commit阶段</code>完成渲染后会变为<code>current Fiber树</code>。这行代码的作用就是切换<code>fiberRootNode</code>指向的<code>current Fiber树</code>。</p>
<p>那么这行代码为什么在这里呢？（在<code>mutation阶段</code>结束后，<code>layout阶段</code>开始前。）</p>
<p>我们知道<code>componentWillUnmount</code>会在<code>mutation阶段</code>执行。此时<code>current Fiber树</code>还指向前一次更新的<code>Fiber树</code>，在生命周期钩子内获取的<code>DOM</code>还是更新前的。</p>
<p><code>componentDidMount</code>和<code>componentDidUpdate</code>会在<code>layout阶段</code>执行。此时<code>current Fiber树</code>已经指向更新后的<code>Fiber树</code>，在生命周期钩子内获取的<code>DOM</code>就是更新后的。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>从这节我们学到，<code>layout阶段</code>会遍历<code>effectList</code>，依次执行<code>commitLayoutEffects</code>。该方法的主要工作为“根据<code>effectTag</code>调用不同的处理函数处理<code>Fiber</code>并更新<code>ref</code>。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://blog.logrocket.com/useeffect-vs-uselayouteffect-examples/" target="_blank" rel="noopener noreferrer">useeffect-vs-uselayouteffect-examples</a></p>
<p><a href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" target="_blank" rel="noopener noreferrer">hooks-reference.html#uselayouteffect</a></p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">motivation阶段</title>
    <id>https://0808200.xyz/react/renderer/mutation.html</id>
    <link href="https://0808200.xyz/react/renderer/mutation.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>终于到了执行<code>DOM</code>操作的<code>mutation阶段</code>。</p>
<h2 id="概览" tabindex="-1"> 概览</h2>
<p>类似<code>before mutation阶段</code>，<code>mutation阶段</code>也是遍历<code>effectList</code>，执行函数。这里执行的是<code>commitMutationEffects</code>。</p>
<div><pre><code>nextEffect <span>=</span> firstEffect<span>;</span>
<span>do</span> <span>{</span>
  <span>try</span> <span>{</span>
      <span>commitMutationEffects</span><span>(</span>root<span>,</span> renderPriorityLevel<span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
      <span>invariant</span><span>(</span>nextEffect <span>!==</span> <span>null</span><span>,</span> <span>'Should be working on an effect.'</span><span>)</span><span>;</span>
      <span>captureCommitPhaseError</span><span>(</span>nextEffect<span>,</span> error<span>)</span><span>;</span>
      nextEffect <span>=</span> nextEffect<span>.</span>nextEffect<span>;</span>
    <span>}</span>
<span>}</span> <span>while</span> <span>(</span>nextEffect <span>!==</span> <span>null</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="commitmutationeffects" tabindex="-1"> commitMutationEffects</h2>
<p>代码如下：</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2091" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitMutationEffects</code>源码</p>
</blockquote>
<div><pre><code><span>function</span> <span>commitMutationEffects</span><span>(</span><span><span>root</span><span>:</span> FiberRoot<span>,</span> renderPriorityLevel</span><span>)</span> <span>{</span>
  <span>// 遍历effectList</span>
  <span>while</span> <span>(</span>nextEffect <span>!==</span> <span>null</span><span>)</span> <span>{</span>

    <span>const</span> effectTag <span>=</span> nextEffect<span>.</span>effectTag<span>;</span>

    <span>// 根据 ContentReset effectTag重置文字节点</span>
    <span>if</span> <span>(</span>effectTag <span>&amp;</span> ContentReset<span>)</span> <span>{</span>
      <span>commitResetTextContent</span><span>(</span>nextEffect<span>)</span><span>;</span>
    <span>}</span>

    <span>// 更新ref</span>
    <span>if</span> <span>(</span>effectTag <span>&amp;</span> Ref<span>)</span> <span>{</span>
      <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>
      <span>if</span> <span>(</span>current <span>!==</span> <span>null</span><span>)</span> <span>{</span>
        <span>commitDetachRef</span><span>(</span>current<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>

    <span>// 根据 effectTag 分别处理</span>
    <span>const</span> primaryEffectTag <span>=</span>
      effectTag <span>&amp;</span> <span>(</span>Placement <span>|</span> Update <span>|</span> Deletion <span>|</span> Hydrating<span>)</span><span>;</span>
    <span>switch</span> <span>(</span>primaryEffectTag<span>)</span> <span>{</span>
      <span>// 插入DOM</span>
      <span>case</span> <span>Placement</span><span>:</span> <span>{</span>
        <span>commitPlacement</span><span>(</span>nextEffect<span>)</span><span>;</span>
        nextEffect<span>.</span>effectTag <span>&amp;=</span> <span>~</span>Placement<span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
      <span>// 插入DOM 并 更新DOM</span>
      <span>case</span> <span>PlacementAndUpdate</span><span>:</span> <span>{</span>
        <span>// 插入</span>
        <span>commitPlacement</span><span>(</span>nextEffect<span>)</span><span>;</span>

        nextEffect<span>.</span>effectTag <span>&amp;=</span> <span>~</span>Placement<span>;</span>

        <span>// 更新</span>
        <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>
        <span>commitWork</span><span>(</span>current<span>,</span> nextEffect<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
      <span>// SSR</span>
      <span>case</span> <span>Hydrating</span><span>:</span> <span>{</span>
        nextEffect<span>.</span>effectTag <span>&amp;=</span> <span>~</span>Hydrating<span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
      <span>// SSR</span>
      <span>case</span> <span>HydratingAndUpdate</span><span>:</span> <span>{</span>
        nextEffect<span>.</span>effectTag <span>&amp;=</span> <span>~</span>Hydrating<span>;</span>

        <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>
        <span>commitWork</span><span>(</span>current<span>,</span> nextEffect<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
      <span>// 更新DOM</span>
      <span>case</span> <span>Update</span><span>:</span> <span>{</span>
        <span>const</span> current <span>=</span> nextEffect<span>.</span>alternate<span>;</span>
        <span>commitWork</span><span>(</span>current<span>,</span> nextEffect<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
      <span>// 删除DOM</span>
      <span>case</span> <span>Deletion</span><span>:</span> <span>{</span>
        <span>commitDeletion</span><span>(</span>root<span>,</span> nextEffect<span>,</span> renderPriorityLevel<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
    <span>}</span>

    nextEffect <span>=</span> nextEffect<span>.</span>nextEffect<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>commitMutationEffects</code>会遍历<code>effectList</code>，对每个<code>Fiber节点</code>执行如下三个操作：</p>
<ol>
<li>根据<code>ContentReset effectTag</code>重置文字节点</li>
<li>更新<code>ref</code></li>
<li>根据<code>effectTag</code>分别处理，其中<code>effectTag</code>包括(<code>Placement</code> | <code>Update</code> | <code>Deletion</code> | <code>Hydrating</code>)</li>
</ol>
<p>我们关注步骤三中的<code>Placement</code> | <code>Update</code> | <code>Deletion</code>。<code>Hydrating</code>作为服务端渲染相关，我们先不关注。</p>
<h2 id="placement-effect" tabindex="-1"> Placement effect</h2>
<p>当<code>Fiber节点</code>含有<code>Placement effectTag</code>，意味着该<code>Fiber节点</code>对应的<code>DOM节点</code>需要插入到页面中。</p>
<p>调用的方法为<code>commitPlacement</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1156" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitPlacement</code>源码</p>
</blockquote>
<p>该方法所做的工作分为三步：</p>
<ol>
<li>获取父级<code>DOM节点</code>。其中<code>finishedWork</code>为传入的<code>Fiber节点</code>。</li>
</ol>
<div><pre><code><span>const</span> parentFiber <span>=</span> <span>getHostParentFiber</span><span>(</span>finishedWork<span>)</span><span>;</span>
<span>// 父级DOM节点</span>
<span>const</span> parentStateNode <span>=</span> parentFiber<span>.</span>stateNode<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ol start="2">
<li>获取<code>Fiber节点</code>的<code>DOM</code>兄弟节点</li>
</ol>
<div><pre><code><span>const</span> before <span>=</span> <span>getHostSibling</span><span>(</span>finishedWork<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ol start="3">
<li>根据<code>DOM</code>兄弟节点是否存在决定调用<code>parentNode.insertBefore</code>或<code>parentNode.appendChild</code>执行<code>DOM</code>插入操作。</li>
</ol>
<div><pre><code><span>// parentStateNode是否是rootFiber</span>
<span>if</span> <span>(</span>isContainer<span>)</span> <span>{</span>
  <span>insertOrAppendPlacementNodeIntoContainer</span><span>(</span>finishedWork<span>,</span> before<span>,</span> parent<span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>insertOrAppendPlacementNode</span><span>(</span>finishedWork<span>,</span> before<span>,</span> parent<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>值得注意的是，<code>getHostSibling</code>（获取兄弟<code>DOM节点</code>）的执行很耗时，当在同一个父<code>Fiber节点</code>下依次执行多个插入操作，<code>getHostSibling</code>算法的复杂度为指数级。</p>
<p>这是由于<code>Fiber节点</code>不只包括<code>HostComponent</code>，所以<code>Fiber树</code>和渲染的<code>DOM树</code>节点并不是一一对应的。要从<code>Fiber节点</code>找到<code>DOM节点</code>很可能跨层级遍历。</p>
<p>考虑如下例子：</p>
<div><pre><code>
<span>function</span> <span>Item</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>li</span><span>></span></span><span>;
}

function App() </span><span>{</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>Item</span></span><span>/></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span>
<span>}</span><span>

ReactDOM.render(</span><span><span><span>&lt;</span><span>App</span></span><span>/></span></span><span>, document.getElementById('root'));
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对应的<code>Fiber树</code>和<code>DOM树</code>结构为：</p>
<div><pre><code><span>// Fiber树</span>
          child      child      child       child
rootFiber <span>--</span><span>--</span><span>-</span><span>></span> App <span>--</span><span>--</span><span>-</span><span>></span> div <span>--</span><span>--</span><span>-</span><span>></span> Item <span>--</span><span>--</span><span>-</span><span>></span> li

<span>// DOM树</span>
#root <span>--</span><span>-</span><span>></span> div <span>--</span><span>-</span><span>></span> li
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当在<code>div</code>的子节点<code>Item</code>前插入一个新节点<code>p</code>，即<code>App</code>变为：</p>
<div><pre><code><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>Item</span></span><span>/></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对应的<code>Fiber树</code>和<code>DOM树</code>结构为：</p>
<div><pre><code><span>// Fiber树</span>
          child      child      child
rootFiber <span>--</span><span>--</span><span>-</span><span>></span> App <span>--</span><span>--</span><span>-</span><span>></span> div <span>--</span><span>--</span><span>-</span><span>></span> p 
                                       <span>|</span> sibling       child
                                       <span>|</span> <span>--</span><span>--</span><span>--</span><span>-</span><span>></span> Item <span>--</span><span>--</span><span>-</span><span>></span> li 
<span>// DOM树</span>
#root <span>--</span><span>-</span><span>></span> div <span>--</span><span>-</span><span>></span> p
             <span>|</span>
               <span>--</span><span>-</span><span>></span> li
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>此时<code>DOM节点</code> <code>p</code>的兄弟节点为<code>li</code>，而<code>Fiber节点</code> <code>p</code>对应的兄弟<code>DOM节点</code>为：</p>
<div><pre><code>fiberP<span>.</span>sibling<span>.</span>child
</code></pre><div aria-hidden="true"><div></div></div></div><p>即<code>fiber p</code>的<code>兄弟fiber</code> <code>Item</code>的<code>子fiber</code> <code>li</code></p>
<h2 id="update-effect" tabindex="-1"> Update effect</h2>
<p>当<code>Fiber节点</code>含有<code>Update effectTag</code>，意味着该<code>Fiber节点</code>需要更新。调用的方法为<code>commitWork</code>，他会根据<code>Fiber.tag</code>分别处理。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1441" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitWork</code>源码</p>
</blockquote>
<p>这里我们主要关注<code>FunctionComponent</code>和<code>HostComponent</code>。</p>
<h3 id="functioncomponent-mutation" tabindex="-1"> FunctionComponent mutation</h3>
<p>当<code>fiber.tag</code>为<code>FunctionComponent</code>，会调用<code>commitHookEffectListUnmount</code>。该方法会遍历<code>effectList</code>，执行所有<code>useLayoutEffect hook</code>的销毁函数。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L314" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitHookEffectListUnmount</code>源码</p>
</blockquote>
<p>所谓“销毁函数”，见如下例子：</p>
<div><pre><code><span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>// ...一些副作用逻辑</span>

  <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>// ...这就是销毁函数</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>你不需要很了解<code>useLayoutEffect</code>，我们会在下一节详细介绍。你只需要知道在<code>mutation阶段</code>会执行<code>useLayoutEffect</code>的销毁函数。</p>
<h3 id="hostcomponent-mutation" tabindex="-1"> HostComponent mutation</h3>
<p>当<code>fiber.tag</code>为<code>HostComponent</code>，会调用<code>commitUpdate</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMHostConfig.js#L423" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitUpdate</code>源码</p>
</blockquote>
<p>最终会在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMComponent.js#L378" target="_blank" rel="noopener noreferrer"><code>updateDOMProperties</code></a>中将<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L229" target="_blank" rel="noopener noreferrer"><code>render阶段 completeWork</code></a>中为<code>Fiber节点</code>赋值的<code>updateQueue</code>对应的内容渲染在页面上。</p>
<div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> updatePayload<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span><span>)</span> <span>{</span>
  <span>const</span> propKey <span>=</span> updatePayload<span>[</span>i<span>]</span><span>;</span>
  <span>const</span> propValue <span>=</span> updatePayload<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>;</span>

  <span>// 处理 style</span>
  <span>if</span> <span>(</span>propKey <span>===</span> <span>STYLE</span><span>)</span> <span>{</span>
    <span>setValueForStyles</span><span>(</span>domElement<span>,</span> propValue<span>)</span><span>;</span>
  <span>// 处理 DANGEROUSLY_SET_INNER_HTML</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>propKey <span>===</span> <span>DANGEROUSLY_SET_INNER_HTML</span><span>)</span> <span>{</span>
    <span>setInnerHTML</span><span>(</span>domElement<span>,</span> propValue<span>)</span><span>;</span>
  <span>// 处理 children</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>propKey <span>===</span> <span>CHILDREN</span><span>)</span> <span>{</span>
    <span>setTextContent</span><span>(</span>domElement<span>,</span> propValue<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
  <span>// 处理剩余 props</span>
    <span>setValueForProperty</span><span>(</span>domElement<span>,</span> propKey<span>,</span> propValue<span>,</span> isCustomComponentTag<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="deletion-effect" tabindex="-1"> Deletion effect</h2>
<p>当<code>Fiber节点</code>含有<code>Deletion effectTag</code>，意味着该<code>Fiber节点</code>对应的<code>DOM节点</code>需要从页面中删除。调用的方法为<code>commitDeletion</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commitDeletion</code>源码</p>
</blockquote>
<p>该方法会执行如下操作：</p>
<ol>
<li>递归调用<code>Fiber节点</code>及其子孙<code>Fiber节点</code>中<code>fiber.tag</code>为<code>ClassComponent</code>的<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L920" target="_blank" rel="noopener noreferrer"><code>componentWillUnmount</code></a>生命周期钩子，从页面移除<code>Fiber节点</code>对应<code>DOM节点</code></li>
<li>解绑<code>ref</code></li>
<li>调度<code>useEffect</code>的销毁函数</li>
</ol>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>从这节我们学到，<code>mutation阶段</code>会遍历<code>effectList</code>，依次执行<code>commitMutationEffects</code>。该方法的主要工作为“根据<code>effectTag</code>调用不同的处理函数处理<code>Fiber</code>。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">流程概览</title>
    <id>https://0808200.xyz/react/renderer/prepare.html</id>
    <link href="https://0808200.xyz/react/renderer/prepare.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>上一章<a href="/react/process/completeWork.html#%E6%B5%81%E7%A8%8B%E7%BB%93%E5%B0%BE">最后一节</a>我们介绍了，<code>commitRoot</code>方法是<code>commit阶段</code>工作的起点。<code>fiberRootNode</code>会作为传参。</p>
<div><pre><code><span>commitRoot</span><span>(</span>root<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在<code>rootFiber.firstEffect</code>上保存了一条需要执行<code>副作用</code>的<code>Fiber节点</code>的单向链表<code>effectList</code>，这些<code>Fiber节点</code>的<code>updateQueue</code>中保存了变化的<code>props</code>。</p>
<p>这些<code>副作用</code>对应的<code>DOM操作</code>在<code>commit</code>阶段执行。</p>
<p>除此之外，一些生命周期钩子（比如<code>componentDidXXX</code>）、<code>hook</code>（比如<code>useEffect</code>）需要在<code>commit</code>阶段执行。</p>
<p><code>commit</code>阶段的主要工作（即<code>Renderer</code>的工作流程）分为三部分：</p>
<ul>
<li>
<p>before mutation阶段（执行<code>DOM</code>操作前）</p>
</li>
<li>
<p>mutation阶段（执行<code>DOM</code>操作）</p>
</li>
<li>
<p>layout阶段（执行<code>DOM</code>操作后）</p>
</li>
</ul>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2001" target="_blank" rel="noopener noreferrer">这里</a>看到<code>commit</code>阶段的完整代码</p>
<p>在<code>before mutation阶段</code>之前和<code>layout阶段</code>之后还有一些额外工作，涉及到比如<code>useEffect</code>的触发、<code>优先级相关</code>的重置、<code>ref</code>的绑定/解绑。</p>
<p>这些对我们当前属于超纲内容，为了内容完整性，在这节简单介绍。</p>
<h2 id="before-mutation之前" tabindex="-1"> before mutation之前</h2>
<p><code>commitRootImpl</code>方法中直到第一句<code>if (firstEffect !== null)</code>之前属于<code>before mutation</code>之前。</p>
<p>我们大体看下他做的工作，现在你还不需要理解他们：</p>
<div><pre><code><span>do</span> <span>{</span>
    <span>// 触发useEffect回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务</span>
    <span>flushPassiveEffects</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>while</span> <span>(</span>rootWithPendingPassiveEffects <span>!==</span> <span>null</span><span>)</span><span>;</span>

  <span>// root指 fiberRootNode</span>
  <span>// root.finishedWork指当前应用的rootFiber</span>
  <span>const</span> finishedWork <span>=</span> root<span>.</span>finishedWork<span>;</span>

  <span>// 凡是变量名带lane的都是优先级相关</span>
  <span>const</span> lanes <span>=</span> root<span>.</span>finishedLanes<span>;</span>
  <span>if</span> <span>(</span>finishedWork <span>===</span> <span>null</span><span>)</span> <span>{</span>
    <span>return</span> <span>null</span><span>;</span>
  <span>}</span>
  root<span>.</span>finishedWork <span>=</span> <span>null</span><span>;</span>
  root<span>.</span>finishedLanes <span>=</span> NoLanes<span>;</span>

  <span>// 重置Scheduler绑定的回调函数</span>
  root<span>.</span>callbackNode <span>=</span> <span>null</span><span>;</span>
  root<span>.</span>callbackId <span>=</span> NoLanes<span>;</span>

  <span>let</span> remainingLanes <span>=</span> <span>mergeLanes</span><span>(</span>finishedWork<span>.</span>lanes<span>,</span> finishedWork<span>.</span>childLanes<span>)</span><span>;</span>
  <span>// 重置优先级相关变量</span>
  <span>markRootFinished</span><span>(</span>root<span>,</span> remainingLanes<span>)</span><span>;</span>

  <span>// 清除已完成的discrete updates，例如：用户鼠标点击触发的更新。</span>
  <span>if</span> <span>(</span>rootsWithPendingDiscreteUpdates <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>!</span><span>hasDiscreteLanes</span><span>(</span>remainingLanes<span>)</span> <span>&amp;&amp;</span>
      rootsWithPendingDiscreteUpdates<span>.</span><span>has</span><span>(</span>root<span>)</span>
    <span>)</span> <span>{</span>
      rootsWithPendingDiscreteUpdates<span>.</span><span>delete</span><span>(</span>root<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>// 重置全局变量</span>
  <span>if</span> <span>(</span>root <span>===</span> workInProgressRoot<span>)</span> <span>{</span>
    workInProgressRoot <span>=</span> <span>null</span><span>;</span>
    workInProgress <span>=</span> <span>null</span><span>;</span>
    workInProgressRootRenderLanes <span>=</span> NoLanes<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
  <span>}</span>

  <span>// 将effectList赋值给firstEffect</span>
  <span>// 由于每个fiber的effectList只包含他的子孙节点</span>
  <span>// 所以根节点如果有effectTag则不会被包含进来</span>
  <span>// 所以这里将有effectTag的根节点插入到effectList尾部</span>
  <span>// 这样才能保证有effect的fiber都在effectList中</span>
  <span>let</span> firstEffect<span>;</span>
  <span>if</span> <span>(</span>finishedWork<span>.</span>effectTag <span>></span> PerformedWork<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>finishedWork<span>.</span>lastEffect <span>!==</span> <span>null</span><span>)</span> <span>{</span>
      finishedWork<span>.</span>lastEffect<span>.</span>nextEffect <span>=</span> finishedWork<span>;</span>
      firstEffect <span>=</span> finishedWork<span>.</span>firstEffect<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      firstEffect <span>=</span> finishedWork<span>;</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// 根节点没有effectTag</span>
    firstEffect <span>=</span> finishedWork<span>.</span>firstEffect<span>;</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，<code>before mutation</code>之前主要做一些变量赋值，状态重置的工作。</p>
<p>这一长串代码我们只需要关注最后赋值的<code>firstEffect</code>，在<code>commit</code>的三个子阶段都会用到他。</p>
<h2 id="layout之后" tabindex="-1"> layout之后</h2>
<p>接下来让我们简单看下<code>layout</code>阶段执行完后的代码，现在你还不需要理解他们：</p>
<div><pre><code><span>const</span> rootDidHavePassiveEffects <span>=</span> rootDoesHavePassiveEffects<span>;</span>

<span>// useEffect相关</span>
<span>if</span> <span>(</span>rootDoesHavePassiveEffects<span>)</span> <span>{</span>
  rootDoesHavePassiveEffects <span>=</span> <span>false</span><span>;</span>
  rootWithPendingPassiveEffects <span>=</span> root<span>;</span>
  pendingPassiveEffectsLanes <span>=</span> lanes<span>;</span>
  pendingPassiveEffectsRenderPriority <span>=</span> renderPriorityLevel<span>;</span>
<span>}</span> <span>else</span> <span>{</span><span>}</span>

<span>// 性能优化相关</span>
<span>if</span> <span>(</span>remainingLanes <span>!==</span> NoLanes<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>enableSchedulerTracing<span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// ...</span>
<span>}</span>

<span>// 性能优化相关</span>
<span>if</span> <span>(</span>enableSchedulerTracing<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>rootDidHavePassiveEffects<span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>

<span>// ...检测无限循环的同步任务</span>
<span>if</span> <span>(</span>remainingLanes <span>===</span> SyncLane<span>)</span> <span>{</span>
  <span>// ...</span>
<span>}</span> 

<span>// 在离开commitRoot函数前调用，触发一次新的调度，确保任何附加的任务被调度</span>
<span>ensureRootIsScheduled</span><span>(</span>root<span>,</span> <span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>// ...处理未捕获错误及老版本遗留的边界问题</span>


<span>// 执行同步任务，这样同步任务不需要等到下次事件循环再执行</span>
<span>// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行</span>
<span>// 或useLayoutEffect</span>
<span>flushSyncCallbackQueue</span><span>(</span><span>)</span><span>;</span>

<span>return</span> <span>null</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2195" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>主要包括三点内容：</p>
<ol>
<li><code>useEffect</code>相关的处理。</li>
</ol>
<p>我们会在讲解<code>layout阶段</code>时讲解。</p>
<ol start="2">
<li>性能追踪相关。</li>
</ol>
<p>源码里有很多和<code>interaction</code>相关的变量。他们都和追踪<code>React</code>渲染时间、性能相关，在<a href="https://zh-hans.reactjs.org/docs/profiler.html" target="_blank" rel="noopener noreferrer">Profiler API</a>和<a href="https://github.com/facebook/react-devtools/pull/1069" target="_blank" rel="noopener noreferrer">DevTools</a>中使用。</p>
<blockquote>
<p>你可以在这里看到<a href="https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16#overview" target="_blank" rel="noopener noreferrer">interaction的定义</a></p>
</blockquote>
<ol start="3">
<li>在<code>commit</code>阶段会触发一些生命周期钩子（如 <code>componentDidXXX</code>）和<code>hook</code>（如<code>useLayoutEffect</code>、<code>useEffect</code>）。</li>
</ol>
<p>在这些回调方法中可能触发新的更新，新的更新会开启新的<code>render-commit</code>流程。考虑如下Demo：</p>
<details><summary>useLayoutEffect Demo</summary>
<p>在该Demo中我们点击页面中的数字，状态会先变为0，再在<code>useLayoutEffect</code>回调中变为随机数。但在页面上数字不会变为0，而是直接变为新的随机数。</p>
<p>这是因为<code>useLayoutEffect</code>会在<code>layout阶段</code>同步执行回调。回调中我们触发了状态更新<code>setCount(randomNum)</code>，这会重新调度一个同步任务。</p>
<p>该任务会在在如上<code>commitRoot</code>倒数第二行代码处被同步执行。</p>
<div><pre><code><span>flushSyncCallbackQueue</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>所以我们看不到页面中元素先变为0。</p>
<p>如果换成<code>useEffect</code>多点击几次就能看到区别。</p>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>908</strong>获得在线Demo地址</p>
</details>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">心智模型</title>
    <id>https://0808200.xyz/react/state/mental.html</id>
    <link href="https://0808200.xyz/react/state/mental.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>在深入源码前，让我们先建立<code>更新机制</code>的<code>心智模型</code>。</p>
<p>在后面两节讲解源码时，我们会将代码与<code>心智模型</code>联系上，方便你更好理解。</p>
<h2 id="同步更新的react" tabindex="-1"> 同步更新的React</h2>
<p>我们可以将<code>更新机制</code>类比<code>代码版本控制</code>。</p>
<p>在没有<code>代码版本控制</code>前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上bug（红色节点）。</p>
<img :src="$withBase('/img/git1.png')" alt="流程1">
<p>为了修复这个bug，我们需要首先将之前的代码提交。</p>
<p>在<code>React</code>中，所有通过<code>ReactDOM.render</code>创建的应用（其他创建应用的方式参考<a href="/react/state/reactdom.html#react%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0">ReactDOM.render一节</a>）都是通过类似的方式<code>更新状态</code>。</p>
<p>即没有<code>优先级</code>概念，<code>高优更新</code>（红色节点）需要排在其他<code>更新</code>后面执行。</p>
<h2 id="并发更新的react" tabindex="-1"> 并发更新的React</h2>
<p>当有了<code>代码版本控制</code>，有紧急线上bug需要修复时，我们暂存当前分支的修改，在<code>master分支</code>修复bug并紧急上线。</p>
<img :src="$withBase('/img/git2.png')" alt="流程2">
<p>bug修复上线后通过<code>git rebase</code>命令和<code>开发分支</code>连接上。<code>开发分支</code>基于<code>修复bug的版本</code>继续开发。</p>
<img :src="$withBase('/img/git3.png')" alt="流程3">
<p>在<code>React</code>中，通过<code>ReactDOM.createBlockingRoot</code>和<code>ReactDOM.createRoot</code>创建的应用会采用<code>并发</code>的方式<code>更新状态</code>。</p>
<p><code>高优更新</code>（红色节点）中断正在进行中的<code>低优更新</code>（蓝色节点），先完成<code>render - commit流程</code>。</p>
<p>待<code>高优更新</code>完成后，<code>低优更新</code>基于<code>高优更新</code>的结果<code>重新更新</code>。</p>
<p>接下来两节我们会从源码角度讲解这套<code>并发更新</code>是如何实现的。</p>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" target="_blank" rel="noopener noreferrer"><code>外网</code> <code>英文</code> React Core Team Dan介绍React未来发展方向</a></p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">state流程概览</title>
    <id>https://0808200.xyz/react/state/prepare.html</id>
    <link href="https://0808200.xyz/react/state/prepare.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>经过前几章的学习，我们终于有足够的前置知识理解<strong>状态更新</strong>的整个流程。</p>
<p>这一章我们看看几种常见的触发<strong>状态更新</strong>的方法是如何完成工作的。</p>
<h2 id="几个关键节点" tabindex="-1"> 几个关键节点</h2>
<p>在开始学习前，我们先了解源码中几个关键节点（即几个关键函数的调用）。通过这章的学习，我们会将这些关键节点的调用路径串起来。</p>
<p>先从我们所熟知的概念开始。</p>
<h3 id="render阶段的开始" tabindex="-1"> render阶段的开始</h3>
<p>我们在<a href="/react/process/reconciler.html">render阶段流程概览一节</a>讲到，</p>
<p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p>
<h3 id="commit阶段的开始" tabindex="-1"> commit阶段的开始</h3>
<p>我们在<a href="/react/renderer/prepare.html">commit阶段流程概览一节</a>讲到，</p>
<p><code>commit阶段</code>开始于<code>commitRoot</code>方法的调用。其中<code>rootFiber</code>会作为传参。</p>
<p>我们已经知道，<code>render阶段</code>完成后会进入<code>commit阶段</code>。让我们继续补全从<code>触发状态更新</code>到<code>render阶段</code>的路径。</p>
<div><pre><code>触发状态更新（根据场景调用不同方法）

    <span>|</span>
    <span>|</span>
    <span>v</span>

    ？

    <span>|</span>
    <span>|</span>
    <span>v</span>

render阶段（<span><span>`</span>performSyncWorkOnRoot<span>`</span></span> 或 <span><span>`</span>performConcurrentWorkOnRoot<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

commit阶段（<span><span>`</span>commitRoot<span>`</span></span>）
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="创建update对象" tabindex="-1"> 创建Update对象</h3>
<p>在<code>React</code>中，有如下方法可以触发状态更新（排除<code>SSR</code>相关）：</p>
<ul>
<li>
<p>ReactDOM.render</p>
</li>
<li>
<p>this.setState</p>
</li>
<li>
<p>this.forceUpdate</p>
</li>
<li>
<p>useState</p>
</li>
<li>
<p>useReducer</p>
</li>
</ul>
<p>这些方法调用的场景各不相同，他们是如何接入同一套<strong>状态更新机制</strong>呢？</p>
<p>答案是：每次<code>状态更新</code>都会创建一个保存<strong>更新状态相关内容</strong>的对象，我们叫他<code>Update</code>。在<code>render阶段</code>的<code>beginWork</code>中会根据<code>Update</code>计算新的<code>state</code>。</p>
<p>我们会在下一节详细讲解<code>Update</code>。</p>
<h3 id="从fiber到root" tabindex="-1"> 从fiber到root</h3>
<p>现在<code>触发状态更新的fiber</code>上已经包含<code>Update</code>对象。</p>
<p>我们知道，<code>render阶段</code>是从<code>rootFiber</code>开始向下遍历。那么如何从<code>触发状态更新的fiber</code>得到<code>rootFiber</code>呢？</p>
<p>答案是：调用<code>markUpdateLaneFromFiberToRoot</code>方法。</p>
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L636" target="_blank" rel="noopener noreferrer">这里</a>看到<code>markUpdateLaneFromFiberToRoot</code>的源码</p>
</blockquote>
<p>该方法做的工作可以概括为：从<code>触发状态更新的fiber</code>一直向上遍历到<code>rootFiber</code>，并返回<code>rootFiber</code>。</p>
<p>由于不同更新优先级不尽相同，所以过程中还会更新遍历到的<code>fiber</code>的优先级。这对于我们当前属于超纲内容。</p>
<h3 id="调度更新" tabindex="-1"> 调度更新</h3>
<p>现在我们拥有一个<code>rootFiber</code>，该<code>rootFiber</code>对应的<code>Fiber树</code>中某个<code>Fiber节点</code>包含一个<code>Update</code>。</p>
<p>接下来通知<code>Scheduler</code>根据<strong>更新</strong>的优先级，决定以<strong>同步</strong>还是<strong>异步</strong>的方式调度本次更新。</p>
<p>这里调用的方法是<code>ensureRootIsScheduled</code>。</p>
<p>以下是<code>ensureRootIsScheduled</code>最核心的一段代码：</p>
<div><pre><code><span>if</span> <span>(</span>newCallbackPriority <span>===</span> SyncLanePriority<span>)</span> <span>{</span>
  <span>// 任务已经过期，需要同步执行render阶段</span>
  newCallbackNode <span>=</span> <span>scheduleSyncCallback</span><span>(</span>
    <span>performSyncWorkOnRoot</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> root<span>)</span>
  <span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// 根据任务优先级异步执行render阶段</span>
  <span>var</span> schedulerPriorityLevel <span>=</span> <span>lanePriorityToSchedulerPriority</span><span>(</span>
    newCallbackPriority
  <span>)</span><span>;</span>
  newCallbackNode <span>=</span> <span>scheduleCallback</span><span>(</span>
    schedulerPriorityLevel<span>,</span>
    <span>performConcurrentWorkOnRoot</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> root<span>)</span>
  <span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602" target="_blank" rel="noopener noreferrer">这里</a>看到<code>ensureRootIsScheduled</code>的源码</p>
</blockquote>
<p>其中，<code>scheduleCallback</code>和<code>scheduleSyncCallback</code>会调用<code>Scheduler</code>提供的调度方法根据<code>优先级</code>调度回调函数执行。</p>
<p>可以看到，这里调度的回调函数为：</p>
<div><pre><code><span>performSyncWorkOnRoot</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> root<span>)</span><span>;</span>
<span>performConcurrentWorkOnRoot</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> root<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>即<code>render阶段</code>的入口函数。</p>
<p>至此，<code>状态更新</code>就和我们所熟知的<code>render阶段</code>连接上了。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>让我们梳理下<code>状态更新</code>的整个调用路径的关键节点：</p>
<div><pre><code>触发状态更新（根据场景调用不同方法）

    <span>|</span>
    <span>|</span>
    <span>v</span>

创建Update对象（接下来三节详解）

    <span>|</span>
    <span>|</span>
    <span>v</span>

从fiber到root（<span><span>`</span>markUpdateLaneFromFiberToRoot<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

调度更新（<span><span>`</span>ensureRootIsScheduled<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

render阶段（<span><span>`</span>performSyncWorkOnRoot<span>`</span></span> 或 <span><span>`</span>performConcurrentWorkOnRoot<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

commit阶段（<span><span>`</span>commitRoot<span>`</span></span>）
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="总结-1" tabindex="-1"> 总结</h2>
<p>本节我们了解了<strong>状态更新</strong>的整个流程。</p>
<p>在接下来三节中，我们会花大量篇幅讲解<code>Update</code>的工作机制，因为他是构成<code>React concurrent mode</code>的核心机制之一。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">深入理解优先级</title>
    <id>https://0808200.xyz/react/state/priority.html</id>
    <link href="https://0808200.xyz/react/state/priority.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>通过<a href="/react/state/mental.html">更新的心智模型</a>，我们了解到<code>更新</code>具有<code>优先级</code>。</p>
<p>那么什么是<code>优先级</code>？<code>优先级</code>以什么为依据？如何通过<code>优先级</code>决定哪个状态应该先被更新？</p>
<p>本节我们会详细讲解。</p>
<h2 id="什么是优先级" tabindex="-1"> 什么是优先级</h2>
<p>在<a href="/react/preparation/idea.html#%E7%90%86%E8%A7%A3-%E5%93%8D%E5%BA%94%E8%87%AA%E7%84%B6">React理念一节</a>我们聊到<code>React</code>将人机交互研究的结果整合到真实的<code>UI</code>中。具体到<code>React</code>运行上这是什么意思呢？</p>
<p><code>状态更新</code>由<code>用户交互</code>产生，用户心里对<code>交互</code>执行顺序有个预期。<code>React</code>根据<code>人机交互研究的结果</code>中用户对<code>交互</code>的预期顺序为<code>交互</code>产生的<code>状态更新</code>赋予不同优先级。</p>
<p>具体如下：</p>
<ul>
<li>
<p>生命周期方法：同步执行。</p>
</li>
<li>
<p>受控的用户输入：比如输入框内输入文字，同步执行。</p>
</li>
<li>
<p>交互事件：比如动画，高优先级执行。</p>
</li>
<li>
<p>其他：比如数据请求，低优先级执行。</p>
</li>
</ul>
<h2 id="如何调度优先级" tabindex="-1"> 如何调度优先级</h2>
<p>我们在<a href="/react/preparation/newConstructure.html">新的React结构一节</a>讲到，<code>React</code>通过<code>Scheduler</code>调度任务。</p>
<p>具体到代码，每当需要调度任务时，<code>React</code>会调用<code>Scheduler</code>提供的方法<code>runWithPriority</code>。</p>
<p>该方法接收一个<code>优先级</code>常量与一个<code>回调函数</code>作为参数。<code>回调函数</code>会以<code>优先级</code>高低为顺序排列在一个<code>定时器</code>中并在合适的时间触发。</p>
<p>对于更新来讲，传递的<code>回调函数</code>一般为<a href="/react/state/prepare.html#render%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%80%E5%A7%8B">状态更新流程概览一节</a>讲到的<code>render阶段的入口函数</code>。</p>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217" target="_blank" rel="noopener noreferrer">==unstable_runWithPriority== 这里</a>看到<code>runWithPriority</code>方法的定义。在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js" target="_blank" rel="noopener noreferrer">这里</a>看到<code>Scheduler</code>对优先级常量的定义。</p>
</blockquote>
<h2 id="例子" tabindex="-1"> 例子</h2>
<p>优先级最终会反映到<code>update.lane</code>变量上。当前我们只需要知道这个变量能够区分<code>Update</code>的优先级。</p>
<p>接下来我们通过一个例子结合上一节介绍的<code>Update</code>相关字段讲解优先级如何决定更新的顺序。</p>
<blockquote>
<p>该例子来自<a href="https://twitter.com/acdlite/status/978412930973687808" target="_blank" rel="noopener noreferrer">React Core Team Andrew向网友讲解Update工作流程的推文</a></p>
</blockquote>
<img :src="$withBase('/img/update-process.png')" alt="优先级如何决定更新的顺序">
<p>在这个例子中，有两个<code>Update</code>。我们将“关闭黑夜模式”产生的<code>Update</code>称为<code>u1</code>，输入字母“I”产生的<code>Update</code>称为<code>u2</code>。</p>
<p>其中<code>u1</code>先触发并进入<code>render阶段</code>。其优先级较低，执行时间较长。此时：</p>
<div><pre><code>fiber<span>.</span>updateQueue <span>=</span> <span>{</span>
  <span>baseState</span><span>:</span> <span>{</span>
    <span>blackTheme</span><span>:</span> <span>true</span><span>,</span>
    <span>text</span><span>:</span> <span>'H'</span>
  <span>}</span><span>,</span>
  <span>firstBaseUpdate</span><span>:</span> <span>null</span><span>,</span>
  <span>lastBaseUpdate</span><span>:</span> <span>null</span>
  <span>shared</span><span>:</span> <span>{</span>
    <span>pending</span><span>:</span> u1
  <span>}</span><span>,</span>
  <span>effects</span><span>:</span> <span>null</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在<code>u1</code>完成<code>render阶段</code>前用户通过键盘输入字母“I”，产生了<code>u2</code>。<code>u2</code>属于<strong>受控的用户输入</strong>，优先级高于<code>u1</code>，于是中断<code>u1</code>产生的<code>render阶段</code>。</p>
<p>此时：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>shared<span>.</span>pending <span>===</span> u2 <span>--</span><span>--</span><span>></span> u1
                                     <span>^</span>        <span>|</span>
                                     <span>|</span>________<span>|</span>
<span>// 即</span>
u2<span>.</span>next <span>===</span> u1<span>;</span>
u1<span>.</span>next <span>===</span> u2<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中<code>u2</code>优先级高于<code>u1</code>。</p>
<p>接下来进入<code>u2</code>产生的<code>render阶段</code>。</p>
<p>在<code>processUpdateQueue</code>方法中，<code>shared.pending</code>环状链表会被剪开并拼接在<code>baseUpdate</code>后面。</p>
<p>需要明确一点，<code>shared.pending</code>指向最后一个<code>pending</code>的<code>update</code>，所以实际执行时<code>update</code>的顺序为：</p>
<div><pre><code>u1 <span>--</span> u2
</code></pre><div aria-hidden="true"><div></div></div></div><p>接下来遍历<code>baseUpdate</code>，处理优先级合适的<code>Update</code>（这一次处理的是更高优的<code>u2</code>）。</p>
<p>由于<code>u2</code>不是<code>baseUpdate</code>中的第一个<code>update</code>，在其之前的<code>u1</code>由于优先级不够被跳过。</p>
<p><code>update</code>之间可能有依赖关系，所以被跳过的<code>update</code>及其后面所有<code>update</code>会成为下次更新的<code>baseUpdate</code>。（即<code>u1 -- u2</code>）。</p>
<p>最终<code>u2</code>完成<code>render - commit阶段</code>。</p>
<p>此时：</p>
<div><pre><code>fiber<span>.</span>updateQueue <span>=</span> <span>{</span>
  <span>baseState</span><span>:</span> <span>{</span>
    <span>blackTheme</span><span>:</span> <span>true</span><span>,</span>
    <span>text</span><span>:</span> <span>'HI'</span>
  <span>}</span><span>,</span>
  <span>firstBaseUpdate</span><span>:</span> u1<span>,</span>
  <span>lastBaseUpdate</span><span>:</span> u2
  <span>shared</span><span>:</span> <span>{</span>
    <span>pending</span><span>:</span> <span>null</span>
  <span>}</span><span>,</span>
  <span>effects</span><span>:</span> <span>null</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在<code>commit</code>阶段结尾会再调度一次更新。在该次更新中会基于<code>baseState</code>中<code>firstBaseUpdate</code>保存的<code>u1</code>，开启一次新的<code>render阶段</code>。</p>
<p>最终两次<code>Update</code>都完成后的结果如下：</p>
<div><pre><code>fiber<span>.</span>updateQueue <span>=</span> <span>{</span>
  <span>baseState</span><span>:</span> <span>{</span>
    <span>blackTheme</span><span>:</span> <span>false</span><span>,</span>
    <span>text</span><span>:</span> <span>'HI'</span>
  <span>}</span><span>,</span>
  <span>firstBaseUpdate</span><span>:</span> <span>null</span><span>,</span>
  <span>lastBaseUpdate</span><span>:</span> <span>null</span>
  <span>shared</span><span>:</span> <span>{</span>
    <span>pending</span><span>:</span> <span>null</span>
  <span>}</span><span>,</span>
  <span>effects</span><span>:</span> <span>null</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以看见，<code>u2</code>对应的更新执行了两次，相应的<code>render阶段</code>的生命周期勾子<code>componentWillXXX</code>也会触发两次。这也是为什么这些勾子会被标记为<code>unsafe_</code>。</p>
<h2 id="如何保证状态正确" tabindex="-1"> 如何保证状态正确</h2>
<p>现在我们基本掌握了<code>updateQueue</code>的工作流程。还有两个疑问：</p>
<ul>
<li>
<p><code>render阶段</code>可能被中断。如何保证<code>updateQueue</code>中保存的<code>Update</code>不丢失？</p>
</li>
<li>
<p>有时候当前<code>状态</code>需要依赖前一个<code>状态</code>。如何在支持跳过<code>低优先级状态</code>的同时保证<strong>状态依赖的连续性</strong>？</p>
</li>
</ul>
<p>我们分别讲解下。</p>
<h3 id="如何保证update不丢失" tabindex="-1"> 如何保证<code>Update</code>不丢失</h3>
<p>在<a href="/react/state/update.html#%E4%BE%8B%E5%AD%90">上一节例子</a>中我们讲到，在<code>render阶段</code>，<code>shared.pending</code>的环被剪开并连接在<code>updateQueue.lastBaseUpdate</code>后面。</p>
<p>实际上<code>shared.pending</code>会被同时连接在<code>workInProgress updateQueue.lastBaseUpdate</code>与<code>current updateQueue.lastBaseUpdate</code>后面。</p>
<blockquote>
<p>具体代码见<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L424" target="_blank" rel="noopener noreferrer">这里</a></p>
</blockquote>
<p>当<code>render阶段</code>被中断后重新开始时，会基于<code>current updateQueue</code>克隆出<code>workInProgress updateQueue</code>。由于<code>current updateQueue.lastBaseUpdate</code>已经保存了上一次的<code>Update</code>，所以不会丢失。</p>
<p>当<code>commit阶段</code>完成渲染，由于<code>workInProgress updateQueue.lastBaseUpdate</code>中保存了上一次的<code>Update</code>，所以 <code>workInProgress Fiber树</code>变成<code>current Fiber树</code>后也不会造成<code>Update</code>丢失。</p>
<h3 id="如何保证状态依赖的连续性" tabindex="-1"> 如何保证状态依赖的连续性</h3>
<p>当某个<code>Update</code>由于优先级低而被跳过时，保存在<code>baseUpdate</code>中的不仅是该<code>Update</code>，还包括链表中该<code>Update</code>之后的所有<code>Update</code>。</p>
<p>考虑如下例子：</p>
<div><pre><code><span>baseState</span><span>:</span> <span>''</span>
shared<span>.</span>pending<span>:</span> <span>A1</span> <span>--</span><span>></span> <span>B2</span> <span>--</span><span>></span> <span>C1</span> <span>--</span><span>></span> <span>D2</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>其中<code>字母</code>代表该<code>Update</code>要在页面插入的字母，<code>数字</code>代表<code>优先级</code>，值越低<code>优先级</code>越高。</p>
<p>第一次<code>render</code>，<code>优先级</code>为1。</p>
<div><pre><code><span>baseState</span><span>:</span> <span>''</span>
<span>baseUpdate</span><span>:</span> <span>null</span>
<span>render阶段使用的Update</span><span>:</span> <span>[</span><span>A1</span><span>,</span> <span>C1</span><span>]</span>
<span>memoizedState</span><span>:</span> <span>'AC'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>其中<code>B2</code>由于优先级为2，低于当前优先级，所以他及其后面的所有<code>Update</code>会被保存在<code>baseUpdate</code>中作为下次更新的<code>Update</code>（即<code>B2 C1 D2</code>）。</p>
<p>这么做是为了保持<code>状态</code>的前后依赖顺序。</p>
<p>第二次<code>render</code>，<code>优先级</code>为2。</p>
<div><pre><code><span>baseState</span><span>:</span> <span>'A'</span>
<span>baseUpdate</span><span>:</span> <span>B2</span> <span>--</span><span>></span> <span>C1</span> <span>--</span><span>></span> <span>D2</span>
<span>render阶段使用的Update</span><span>:</span> <span>[</span><span>B2</span><span>,</span> <span>C1</span><span>,</span> <span>D2</span><span>]</span>
<span>memoizedState</span><span>:</span> <span>'ABCD'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>注意这里<code>baseState</code>并不是上一次更新的<code>memoizedState</code>。这是由于<code>B2</code>被跳过了。</p>
<p>即当有<code>Update</code>被跳过时，<code>下次更新的baseState !== 上次更新的memoizedState</code>。</p>
<blockquote>
<p>跳过<code>B2</code>的逻辑见<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L479" target="_blank" rel="noopener noreferrer">这里</a></p>
</blockquote>
<p>通过以上例子我们可以发现，<code>React</code>保证最终的状态一定和用户触发的<code>交互</code>一致，但是中间过程<code>状态</code>可能由于设备不同而不同。</p>
<details><summary>高优先级任务打断低优先级任务Demo</summary>
<p><a href="/react/me.html">关注公众号</a>，后台回复<strong>815</strong>获得在线Demo地址</p>
</details>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<p><a href="https://juejin.im/post/5f05a3e25188252e5c576cdb" target="_blank" rel="noopener noreferrer">深入源码剖析componentWillXXX为什么UNSAFE</a></p>
<p><a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L10" target="_blank" rel="noopener noreferrer">React源码中讲解Update工作流程及优先级的注释</a></p>
<p><a href="https://twitter.com/acdlite/status/978412930973687808" target="_blank" rel="noopener noreferrer">React Core Team Andrew向网友讲解Update工作流程的推文</a></p>

]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">ReactDOM.render</title>
    <id>https://0808200.xyz/react/state/reactdom.html</id>
    <link href="https://0808200.xyz/react/state/reactdom.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>经过五章的学习，我们终于回到了<code>React</code>应用的起点。</p>
<p>这一节我们完整的走通<code>ReactDOM.render</code>完成页面渲染的整个流程。</p>
<h2 id="创建fiber" tabindex="-1"> 创建fiber</h2>
<p>从<a href="/react/process/doubleBuffer.html#mount%E6%97%B6">双缓存机制一节</a>我们知道，首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是要渲染组件所在组件树的<code>根节点</code>。</p>
<p>这一步发生在调用<code>ReactDOM.render</code>后进入的<code>legacyRenderSubtreeIntoContainer</code>方法中。</p>
<div><pre><code><span>// container指ReactDOM.render的第二个参数（即应用挂载的DOM节点）</span>
root <span>=</span> container<span>.</span>_reactRootContainer <span>=</span> <span>legacyCreateRootFromDOMContainer</span><span>(</span>
  container<span>,</span>
  forceHydrate<span>,</span>
<span>)</span><span>;</span>
fiberRoot <span>=</span> root<span>.</span>_internalRoot<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-dom/src/client/ReactDOMLegacy.js#L193" target="_blank" rel="noopener noreferrer">这里</a>看到这一步的代码</p>
</blockquote>
<p><code>legacyCreateRootFromDOMContainer</code>方法内部会调用<code>createFiberRoot</code>方法完成<code>fiberRootNode</code>和<code>rootFiber</code>的创建以及关联。并初始化<code>updateQueue</code>。</p>
<div><pre><code><span>export</span> <span>function</span> <span>createFiberRoot</span><span>(</span>
  <span><span>containerInfo</span><span>:</span> any<span>,</span>
  <span>tag</span><span>:</span> RootTag<span>,</span>
  <span>hydrate</span><span>:</span> boolean<span>,</span>
  <span>hydrationCallbacks</span><span>:</span> <span>null</span> <span>|</span> SuspenseHydrationCallbacks<span>,</span></span>
<span>)</span><span>:</span> FiberRoot <span>{</span>
  <span>// 创建fiberRootNode</span>
  <span>const</span> <span>root</span><span>:</span> FiberRoot <span>=</span> <span>(</span><span>new</span> <span>FiberRootNode</span><span>(</span>containerInfo<span>,</span> tag<span>,</span> hydrate<span>)</span><span>:</span> any<span>)</span><span>;</span>
  
  <span>// 创建rootFiber</span>
  <span>const</span> uninitializedFiber <span>=</span> <span>createHostRootFiber</span><span>(</span>tag<span>)</span><span>;</span>

  <span>// 连接rootFiber与fiberRootNode</span>
  root<span>.</span>current <span>=</span> uninitializedFiber<span>;</span>
  uninitializedFiber<span>.</span>stateNode <span>=</span> root<span>;</span>

  <span>// 初始化updateQueue</span>
  <span>initializeUpdateQueue</span><span>(</span>uninitializedFiber<span>)</span><span>;</span>

  <span>return</span> root<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>根据以上代码，现在我们可以在<a href="/react/process/doubleBuffer.html#mount%E6%97%B6">双缓存机制一节</a>基础上补充上<code>rootFiber</code>到<code>fiberRootNode</code>的引用。</p>
<img :src="$withBase('/img/fiberroot.png')" alt="fiberRoot">
<blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberRoot.new.js#L97" target="_blank" rel="noopener noreferrer">这里</a>看到这一步的代码</p>
</blockquote>
<h2 id="创建update" tabindex="-1"> 创建update</h2>
<p>我们已经做好了组件的初始化工作，接下来就等待创建<code>Update</code>来开启一次更新。</p>
<p>这一步发生在<code>updateContainer</code>方法中。</p>
<div><pre><code><span>export</span> <span>function</span> <span>updateContainer</span><span>(</span>
  <span><span>element</span><span>:</span> ReactNodeList<span>,</span>
  <span>container</span><span>:</span> OpaqueRoot<span>,</span>
  <span>parentComponent</span><span>:</span> <span>?</span>React$Component<span>&lt;</span>any<span>,</span> any<span>></span><span>,</span>
  <span>callback</span><span>:</span> <span>?</span>Function<span>,</span></span>
<span>)</span><span>:</span> Lane <span>{</span>
  <span>// ...省略与逻辑不相关代码</span>

  <span>// 创建update</span>
  <span>const</span> update <span>=</span> <span>createUpdate</span><span>(</span>eventTime<span>,</span> lane<span>,</span> suspenseConfig<span>)</span><span>;</span>
  
  <span>// update.payload为需要挂载在根节点的组件</span>
  update<span>.</span>payload <span>=</span> <span>{</span>element<span>}</span><span>;</span>

  <span>// callback为ReactDOM.render的第三个参数 —— 回调函数</span>
  callback <span>=</span> callback <span>===</span> <span>undefined</span> <span>?</span> <span>null</span> <span>:</span> callback<span>;</span>
  <span>if</span> <span>(</span>callback <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    update<span>.</span>callback <span>=</span> callback<span>;</span>
  <span>}</span>

  <span>// 将生成的update加入updateQueue</span>
  <span>enqueueUpdate</span><span>(</span>current<span>,</span> update<span>)</span><span>;</span>
  <span>// 调度更新</span>
  <span>scheduleUpdateOnFiber</span><span>(</span>current<span>,</span> lane<span>,</span> eventTime<span>)</span><span>;</span>

  <span>// ...省略与逻辑不相关代码</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberReconciler.new.js#L255" target="_blank" rel="noopener noreferrer">这里</a>看到<code>updateContainer</code>的代码</p>
</blockquote>
<p>值得注意的是其中<code>update.payload = {element};</code></p>
<p>这就是我们在<a href="/react/state/update.html#update%E7%9A%84%E7%BB%93%E6%9E%84">Update一节</a>介绍的，对于<code>HostRoot</code>，<code>payload</code>为<code>ReactDOM.render</code>的第一个传参。</p>
<h2 id="流程概览" tabindex="-1"> 流程概览</h2>
<p>至此，<code>ReactDOM.render</code>的流程就和我们已知的流程连接上了。</p>
<p>整个流程如下：</p>
<div><pre><code>创建fiberRootNode、rootFiber、updateQueue（<span><span>`</span>legacyCreateRootFromDOMContainer<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

创建Update对象（<span><span>`</span>updateContainer<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

从fiber到root（<span><span>`</span>markUpdateLaneFromFiberToRoot<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

调度更新（<span><span>`</span>ensureRootIsScheduled<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

render阶段（<span><span>`</span>performSyncWorkOnRoot<span>`</span></span> 或 <span><span>`</span>performConcurrentWorkOnRoot<span>`</span></span>）

    <span>|</span>
    <span>|</span>
    <span>v</span>

commit阶段（<span><span>`</span>commitRoot<span>`</span></span>）
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="react的其他入口函数" tabindex="-1"> React的其他入口函数</h2>
<p>当前<code>React</code>共有三种模式：</p>
<ul>
<li>
<p><code>legacy</code>，这是当前<code>React</code>使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能。</p>
</li>
<li>
<p><code>blocking</code>，开启部分<code>concurrent</code>模式特性的中间模式。目前正在实验中。作为迁移到<code>concurrent</code>模式的第一个步骤。</p>
</li>
<li>
<p><code>concurrent</code>，面向未来的开发模式。我们之前讲的<code>任务中断/任务优先级</code>都是针对<code>concurrent</code>模式。</p>
</li>
</ul>
<p>你可以从下表看出各种模式对特性的支持：</p>
<table>
<thead>
<tr>
<th></th>
<th>legacy 模式</th>
<th>blocking 模式</th>
<th>concurrent 模式</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs" target="_blank" rel="noopener noreferrer">String Refs</a></td>
<td>✅</td>
<td>🚫**</td>
<td>🚫**</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/legacy-context.html" target="_blank" rel="noopener noreferrer">Legacy Context</a></td>
<td>✅</td>
<td>🚫**</td>
<td>🚫**</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage" target="_blank" rel="noopener noreferrer">findDOMNode</a></td>
<td>✅</td>
<td>🚫**</td>
<td>🚫**</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly" target="_blank" rel="noopener noreferrer">Suspense</a></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist" target="_blank" rel="noopener noreferrer">SuspenseList</a></td>
<td>🚫</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Suspense SSR + Hydration</td>
<td>🚫</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Progressive Hydration</td>
<td>🚫</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Selective Hydration</td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td>Cooperative Multitasking</td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td>Automatic batching of multiple setStates</td>
<td>🚫*</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state" target="_blank" rel="noopener noreferrer">Priority-based Rendering</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering" target="_blank" rel="noopener noreferrer">Interruptible Prerendering</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions" target="_blank" rel="noopener noreferrer">useTransition</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value" target="_blank" rel="noopener noreferrer">useDeferredValue</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train" target="_blank" rel="noopener noreferrer">Suspense Reveal &quot;Train&quot;</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>*：<code>legacy</code>模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非<code>React</code>事件想使用这个功能必须使用 <code>unstable_batchedUpdates</code>。在<code>blocking</code>模式和<code>concurrent</code>模式下，所有的<code>setState</code>在默认情况下都是批处理的。</p>
<p>**：会在开发中发出警告。</p>
<p>模式的变化影响整个应用的工作方式，所以无法只针对某个组件开启不同模式。</p>
<p>基于此原因，可以通过不同的<code>入口函数</code>开启不同模式：</p>
<ul>
<li><code>legacy</code> -- <code>ReactDOM.render(&lt;App /&gt;, rootNode)</code></li>
<li><code>blocking</code> -- <code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li>
<li><code>concurrent</code> -- <code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li>
</ul>
<blockquote>
<p>你可以在<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes" target="_blank" rel="noopener noreferrer">这里</a>看到<code>React</code>团队解释为什么会有这么多模式</p>
</blockquote>
<p>虽然不同模式的<code>入口函数</code>不同，但是他们仅对<code>fiber.mode</code>变量产生影响，对我们在<a href="/react/state/reactdom.html#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88">流程概览</a>中描述的流程并无影响。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">this.setState</title>
    <id>https://0808200.xyz/react/state/setstate.html</id>
    <link href="https://0808200.xyz/react/state/setstate.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>当我们有了前面知识的铺垫，就很容易理解<code>this.setState</code>的工作流程。</p>
<h2 id="流程概览" tabindex="-1"> 流程概览</h2>
<p>可以看到，<code>this.setState</code>内会调用<code>this.updater.enqueueSetState</code>方法。</p>
<div><pre><code><span>Component</span><span>.</span>prototype<span>.</span><span>setState</span> <span>=</span> <span>function</span> <span>(</span><span>partialState<span>,</span> callback</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>(</span><span>typeof</span> partialState <span>===</span> <span>'object'</span> <span>||</span> <span>typeof</span> partialState <span>===</span> <span>'function'</span> <span>||</span> partialState <span>==</span> <span>null</span><span>)</span><span>)</span> <span>{</span>
    <span>{</span>
      <span>throw</span> <span>Error</span><span>(</span> <span>"setState(...): takes an object of state variables to update or a function which returns an object of state variables."</span> <span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>this</span><span>.</span>updater<span>.</span><span>enqueueSetState</span><span>(</span><span>this</span><span>,</span> partialState<span>,</span> callback<span>,</span> <span>'setState'</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactBaseClasses.js#L57" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<p>在<code>enqueueSetState</code>方法中就是我们熟悉的从<code>创建update</code>到<code>调度update</code>的流程了。</p>
<div><pre><code><span>enqueueSetState</span><span>(</span><span>inst<span>,</span> payload<span>,</span> callback</span><span>)</span> <span>{</span>
  <span>// 通过组件实例获取对应fiber</span>
  <span>const</span> fiber <span>=</span> <span>getInstance</span><span>(</span>inst<span>)</span><span>;</span>

  <span>const</span> eventTime <span>=</span> <span>requestEventTime</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> suspenseConfig <span>=</span> <span>requestCurrentSuspenseConfig</span><span>(</span><span>)</span><span>;</span>

  <span>// 获取优先级</span>
  <span>const</span> lane <span>=</span> <span>requestUpdateLane</span><span>(</span>fiber<span>,</span> suspenseConfig<span>)</span><span>;</span>

  <span>// 创建update</span>
  <span>const</span> update <span>=</span> <span>createUpdate</span><span>(</span>eventTime<span>,</span> lane<span>,</span> suspenseConfig<span>)</span><span>;</span>

  update<span>.</span>payload <span>=</span> payload<span>;</span>

  <span>// 赋值回调函数</span>
  <span>if</span> <span>(</span>callback <span>!==</span> <span>undefined</span> <span>&amp;&amp;</span> callback <span>!==</span> <span>null</span><span>)</span> <span>{</span>
    update<span>.</span>callback <span>=</span> callback<span>;</span>
  <span>}</span>

  <span>// 将update插入updateQueue</span>
  <span>enqueueUpdate</span><span>(</span>fiber<span>,</span> update<span>)</span><span>;</span>
  <span>// 调度update</span>
  <span>scheduleUpdateOnFiber</span><span>(</span>fiber<span>,</span> lane<span>,</span> eventTime<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L196" target="_blank" rel="noopener noreferrer">这里</a>看到<code>enqueueSetState</code>代码</p>
</blockquote>
<p>这里值得注意的是对于<code>ClassComponent</code>，<code>update.payload</code>为<code>this.setState</code>的第一个传参（即要改变的<code>state</code>）。</p>
<h2 id="this-forceupdate" tabindex="-1"> this.forceUpdate</h2>
<p>在<code>this.updater</code>上，除了<code>enqueueSetState</code>外，还存在<code>enqueueForceUpdate</code>，当我们调用<code>this.forceUpdate</code>时会调用他。</p>
<p>可以看到，除了赋值<code>update.tag = ForceUpdate;</code>以及没有<code>payload</code>外，其他逻辑与<code>this.setState</code>一致。</p>
<div><pre><code><span>enqueueForceUpdate</span><span>(</span><span>inst<span>,</span> callback</span><span>)</span> <span>{</span>
    <span>const</span> fiber <span>=</span> <span>getInstance</span><span>(</span>inst<span>)</span><span>;</span>
    <span>const</span> eventTime <span>=</span> <span>requestEventTime</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> suspenseConfig <span>=</span> <span>requestCurrentSuspenseConfig</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> lane <span>=</span> <span>requestUpdateLane</span><span>(</span>fiber<span>,</span> suspenseConfig<span>)</span><span>;</span>

    <span>const</span> update <span>=</span> <span>createUpdate</span><span>(</span>eventTime<span>,</span> lane<span>,</span> suspenseConfig<span>)</span><span>;</span>

    <span>// 赋值tag为ForceUpdate</span>
    update<span>.</span>tag <span>=</span> ForceUpdate<span>;</span>

    <span>if</span> <span>(</span>callback <span>!==</span> <span>undefined</span> <span>&amp;&amp;</span> callback <span>!==</span> <span>null</span><span>)</span> <span>{</span>
      update<span>.</span>callback <span>=</span> callback<span>;</span>
    <span>}</span>

    <span>enqueueUpdate</span><span>(</span>fiber<span>,</span> update<span>)</span><span>;</span>
    <span>scheduleUpdateOnFiber</span><span>(</span>fiber<span>,</span> lane<span>,</span> eventTime<span>)</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L260" target="_blank" rel="noopener noreferrer">这里</a>看到<code>enqueueForceUpdate</code>代码</p>
</blockquote>
<p>那么赋值<code>update.tag = ForceUpdate;</code>有何作用呢？</p>
<p>在判断<code>ClassComponent</code>是否需要更新时有两个条件需要满足：</p>
<div><pre><code> <span>const</span> shouldUpdate <span>=</span>
  <span>checkHasForceUpdateAfterProcessing</span><span>(</span><span>)</span> <span>||</span>
  <span>checkShouldComponentUpdate</span><span>(</span>
    workInProgress<span>,</span>
    ctor<span>,</span>
    oldProps<span>,</span>
    newProps<span>,</span>
    oldState<span>,</span>
    newState<span>,</span>
    nextContext<span>,</span>
  <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L1137" target="_blank" rel="noopener noreferrer">这里</a>看到这段代码</p>
</blockquote>
<ul>
<li>
<p>checkHasForceUpdateAfterProcessing：内部会判断本次更新的<code>Update</code>是否为<code>ForceUpdate</code>。即如果本次更新的<code>Update</code>中存在<code>tag</code>为<code>ForceUpdate</code>，则返回<code>true</code>。</p>
</li>
<li>
<p>checkShouldComponentUpdate：内部会调用<code>shouldComponentUpdate</code>方法。以及当该<code>ClassComponent</code>为<code>PureComponent</code>时会浅比较<code>state</code>与<code>props</code>。</p>
</li>
</ul>
<blockquote>
<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L294" target="_blank" rel="noopener noreferrer">这里</a>看到<code>checkShouldComponentUpdate</code>代码</p>
</blockquote>
<p>所以，当某次更新含有<code>tag</code>为<code>ForceUpdate</code>的<code>Update</code>，那么当前<code>ClassComponent</code>不会受其他<code>性能优化手段</code>（<code>shouldComponentUpdate</code>|<code>PureComponent</code>）影响，一定会更新。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>至此，我们学习完了<code>HostRoot | ClassComponent</code>所使用的<code>Update</code>的更新流程。</p>
<p>在下一章我们会学习另一种数据结构的<code>Update</code> —— 用于<code>Hooks</code>的<code>Update</code>。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">Update</title>
    <id>https://0808200.xyz/react/state/update.html</id>
    <link href="https://0808200.xyz/react/state/update.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<p>通过本章第一节学习，我们知道<code>状态更新</code>流程开始后首先会<code>创建Update对象</code>。</p>
<p>本节我们学习<code>Update</code>的结构与工作流程。</p>
<blockquote>
<p>你可以将<code>Update</code>类比<code>心智模型</code>中的一次<code>commit</code>。</p>
</blockquote>
<h2 id="update的分类" tabindex="-1"> Update的分类</h2>
<p>我们先来了解<code>Update</code>的结构。</p>
<p>首先，我们将可以触发更新的方法所隶属的组件分类：</p>
<ul>
<li>
<p>ReactDOM.render —— HostRoot</p>
</li>
<li>
<p>this.setState —— ClassComponent</p>
</li>
<li>
<p>this.forceUpdate —— ClassComponent</p>
</li>
<li>
<p>useState —— FunctionComponent</p>
</li>
<li>
<p>useReducer —— FunctionComponent</p>
</li>
</ul>
<p>可以看到，一共三种组件（<code>HostRoot</code> | <code>ClassComponent</code> | <code>FunctionComponent</code>）可以触发更新。</p>
<p>由于不同类型组件工作方式不同，所以存在两种不同结构的<code>Update</code>，其中<code>ClassComponent</code>与<code>HostRoot</code>共用一套<code>Update</code>结构，<code>FunctionComponent</code>单独使用一种<code>Update</code>结构。</p>
<p>虽然他们的结构不同，但是他们工作机制与工作流程大体相同。在本节我们介绍前一种<code>Update</code>，<code>FunctionComponent</code>对应的<code>Update</code>在<code>Hooks</code>章节介绍。</p>
<h2 id="update的结构" tabindex="-1"> Update的结构</h2>
<p><code>ClassComponent</code>与<code>HostRoot</code>（即<code>rootFiber.tag</code>对应类型）共用同一种<code>Update结构</code>。</p>
<p>对应的结构如下：</p>
<div><pre><code><span>const</span> <span>update</span><span>:</span> Update<span>&lt;</span><span>*</span><span>></span> <span>=</span> <span>{</span>
  eventTime<span>,</span>
  lane<span>,</span>
  suspenseConfig<span>,</span>
  <span>tag</span><span>:</span> UpdateState<span>,</span>
  <span>payload</span><span>:</span> <span>null</span><span>,</span>
  <span>callback</span><span>:</span> <span>null</span><span>,</span>

  <span>next</span><span>:</span> <span>null</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>Update</code>由<code>createUpdate</code>方法返回，你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.old.js#L189" target="_blank" rel="noopener noreferrer">这里</a>看到<code>createUpdate</code>的源码</p>
</blockquote>
<p>字段意义如下：</p>
<ul>
<li>
<p>eventTime：任务时间，通过<code>performance.now()</code>获取的毫秒数。由于该字段在未来会重构，当前我们不需要理解他。</p>
</li>
<li>
<p>lane：优先级相关字段。当前还不需要掌握他，只需要知道不同<code>Update</code>优先级可能是不同的。</p>
</li>
</ul>
<blockquote>
<p>你可以将<code>lane</code>类比<code>心智模型</code>中<code>需求的紧急程度</code>。</p>
</blockquote>
<ul>
<li>
<p>suspenseConfig：<code>Suspense</code>相关，暂不关注。</p>
</li>
<li>
<p>tag：更新的类型，包括<code>UpdateState</code> | <code>ReplaceState</code> | <code>ForceUpdate</code> | <code>CaptureUpdate</code>。</p>
</li>
<li>
<p>payload：更新挂载的数据，不同类型组件挂载的数据不同。对于<code>ClassComponent</code>，<code>payload</code>为<code>this.setState</code>的第一个传参。对于<code>HostRoot</code>，<code>payload</code>为<code>ReactDOM.render</code>的第一个传参。</p>
</li>
<li>
<p>callback：更新的回调函数。即在<a href="/react/renderer/layout.html#commitlayouteffectonfiber">commit 阶段的 layout 子阶段一节</a>中提到的<code>回调函数</code>。</p>
</li>
<li>
<p>next：与其他<code>Update</code>连接形成链表。</p>
</li>
</ul>
<h2 id="update与fiber的联系" tabindex="-1"> Update与Fiber的联系</h2>
<p>我们发现，<code>Update</code>存在一个连接其他<code>Update</code>形成链表的字段<code>next</code>。联系<code>React</code>中另一种以链表形式组成的结构<code>Fiber</code>，他们之间有什么关联么？</p>
<p>答案是肯定的。</p>
<p>从<a href="/react/process/doubleBuffer.html">双缓存机制一节</a>我们知道，<code>Fiber节点</code>组成<code>Fiber树</code>，页面中最多同时存在两棵<code>Fiber树</code>：</p>
<ul>
<li>
<p>代表当前页面状态的<code>current Fiber树</code></p>
</li>
<li>
<p>代表正在<code>render阶段</code>的<code>workInProgress Fiber树</code></p>
</li>
</ul>
<p>类似<code>Fiber节点</code>组成<code>Fiber树</code>，<code>Fiber节点</code>上的多个<code>Update</code>会组成链表并被包含在<code>fiber.updateQueue</code>中。</p>
<div><p>什么情况下一个Fiber节点会存在多个Update？</p>
<p>你可能疑惑为什么一个<code>Fiber节点</code>会存在多个<code>Update</code>。这其实是很常见的情况。</p>
<p>在这里介绍一种最简单的情况：</p>
<div><pre><code><span>onClick</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>
    <span>a</span><span>:</span> <span>1</span>
  <span>}</span><span>)</span>

  <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>
    <span>b</span><span>:</span> <span>2</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在一个<code>ClassComponent</code>中触发<code>this.onClick</code>方法，方法内部调用了两次<code>this.setState</code>。这会在该<code>fiber</code>中产生两个<code>Update</code>。</p>
</div>
<p><code>Fiber节点</code>最多同时存在两个<code>updateQueue</code>：</p>
<ul>
<li>
<p><code>current fiber</code>保存的<code>updateQueue</code>即<code>current updateQueue</code></p>
</li>
<li>
<p><code>workInProgress fiber</code>保存的<code>updateQueue</code>即<code>workInProgress updateQueue</code></p>
</li>
</ul>
<p>在<code>commit阶段</code>完成页面渲染后，<code>workInProgress Fiber树</code>变为<code>current Fiber树</code>，<code>workInProgress Fiber树</code>内<code>Fiber节点</code>的<code>updateQueue</code>就变成<code>current updateQueue</code>。</p>
<h2 id="updatequeue" tabindex="-1"> updateQueue</h2>
<p><code>updateQueue</code>有三种类型，其中针对<code>HostComponent</code>的类型我们在<a href="/react/process/completeWork.html#update%E6%97%B6">completeWork一节</a>介绍过。</p>
<p>剩下两种类型和<code>Update</code>的两种类型对应。</p>
<p><code>ClassComponent</code>与<code>HostRoot</code>使用的<code>UpdateQueue</code>结构如下：</p>
<div><pre><code><span>const</span> <span>queue</span><span>:</span> UpdateQueue<span>&lt;</span>State<span>></span> <span>=</span> <span>{</span>
    <span>baseState</span><span>:</span> fiber<span>.</span>memoizedState<span>,</span>
    <span>firstBaseUpdate</span><span>:</span> <span>null</span><span>,</span>
    <span>lastBaseUpdate</span><span>:</span> <span>null</span><span>,</span>
    <span>shared</span><span>:</span> <span>{</span>
      <span>pending</span><span>:</span> <span>null</span><span>,</span>
    <span>}</span><span>,</span>
    <span>effects</span><span>:</span> <span>null</span><span>,</span>
  <span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><code>UpdateQueue</code>由<code>initializeUpdateQueue</code>方法返回，你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L157" target="_blank" rel="noopener noreferrer">这里</a>看到<code>initializeUpdateQueue</code>的源码</p>
</blockquote>
<p>字段说明如下：</p>
<ul>
<li>baseState：本次更新前该<code>Fiber节点</code>的<code>state</code>，<code>Update</code>基于该<code>state</code>计算更新后的<code>state</code>。</li>
</ul>
<blockquote>
<p>你可以将<code>baseState</code>类比<code>心智模型</code>中的<code>master分支</code>。</p>
</blockquote>
<ul>
<li><code>firstBaseUpdate</code>与<code>lastBaseUpdate</code>：本次更新前该<code>Fiber节点</code>已保存的<code>Update</code>。以链表形式存在，链表头为<code>firstBaseUpdate</code>，链表尾为<code>lastBaseUpdate</code>。之所以在更新产生前该<code>Fiber节点</code>内就存在<code>Update</code>，是由于某些<code>Update</code>优先级较低所以在上次<code>render阶段</code>由<code>Update</code>计算<code>state</code>时被跳过。</li>
</ul>
<blockquote>
<p>你可以将<code>baseUpdate</code>类比<code>心智模型</code>中执行<code>git rebase</code>基于的<code>commit</code>（节点D）。</p>
</blockquote>
<ul>
<li><code>shared.pending</code>：触发更新时，产生的<code>Update</code>会保存在<code>shared.pending</code>中形成单向环状链表。当由<code>Update</code>计算<code>state</code>时这个环会被剪开并连接在<code>lastBaseUpdate</code>后面。</li>
</ul>
<blockquote>
<p>你可以将<code>shared.pending</code>类比<code>心智模型</code>中本次需要提交的<code>commit</code>（节点ABC）。</p>
</blockquote>
<ul>
<li>effects：数组。保存<code>update.callback !== null</code>的<code>Update</code>。</li>
</ul>
<h2 id="例子" tabindex="-1"> 例子</h2>
<p><code>updateQueue</code>相关代码逻辑涉及到大量链表操作，比较难懂。在此我们举例对<code>updateQueue</code>的工作流程讲解下。</p>
<p>假设有一个<code>fiber</code>刚经历<code>commit阶段</code>完成渲染。</p>
<p>该<code>fiber</code>上有两个由于优先级过低所以在上次的<code>render阶段</code>并没有处理的<code>Update</code>。他们会成为下次更新的<code>baseUpdate</code>。</p>
<p>我们称其为<code>u1</code>和<code>u2</code>，其中<code>u1.next === u2</code>。</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>firstBaseUpdate <span>===</span> u1<span>;</span>
fiber<span>.</span>updateQueue<span>.</span>lastBaseUpdate <span>===</span> u2<span>;</span>
u1<span>.</span>next <span>===</span> u2<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>我们用<code>--&gt;</code>表示链表的指向：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>baseUpdate<span>:</span> u1 <span>--</span><span>></span> u2
</code></pre><div aria-hidden="true"><div></div></div></div><p>现在我们在<code>fiber</code>上触发两次状态更新，这会先后产生两个新的<code>Update</code>，我们称为<code>u3</code>和<code>u4</code>。</p>
<p>每个 <code>update</code> 都会通过 <code>enqueueUpdate</code> 方法插入到 <code>updateQueue</code> 队列上</p>
<p>当插入<code>u3</code>后：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>shared<span>.</span>pending <span>===</span> u3<span>;</span>
u3<span>.</span>next <span>===</span> u3<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>shared.pending</code>的环状链表，用图表示为：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>shared<span>.</span>pending<span>:</span>   u3 ─────┐ 
                                     <span>^</span>      <span>|</span>                                    
                                     └──────┘
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>接着插入<code>u4</code>之后：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>shared<span>.</span>pending <span>===</span> u4<span>;</span>
u4<span>.</span>next <span>===</span> u3<span>;</span>
u3<span>.</span>next <span>===</span> u4<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>shared.pending</code>是环状链表，用图表示为：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>shared<span>.</span>pending<span>:</span>   u4 ──<span>></span> u3
                                     <span>^</span>      <span>|</span>                                    
                                     └──────┘
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>shared.pending</code> 会保证始终指向最后一个插入的<code>update</code>，你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L208" target="_blank" rel="noopener noreferrer">这里</a>看到<code>enqueueUpdate</code>的源码</p>
<p>更新调度完成后进入<code>render阶段</code>。</p>
<p>此时<code>shared.pending</code>的环被剪开并连接在<code>updateQueue.lastBaseUpdate</code>后面：</p>
<div><pre><code>fiber<span>.</span>updateQueue<span>.</span>baseUpdate<span>:</span> u1 <span>--</span><span>></span> u2 <span>--</span><span>></span> u3 <span>--</span><span>></span> u4
</code></pre><div aria-hidden="true"><div></div></div></div><p>接下来遍历<code>updateQueue.baseUpdate</code>链表，以<code>fiber.updateQueue.baseState</code>为<code>初始state</code>，依次与遍历到的每个<code>Update</code>计算并产生新的<code>state</code>（该操作类比<code>Array.prototype.reduce</code>）。</p>
<p>在遍历时如果有优先级低的<code>Update</code>会被跳过。</p>
<p>当遍历完成后获得的<code>state</code>，就是该<code>Fiber节点</code>在本次更新的<code>state</code>（源码中叫做<code>memoizedState</code>）。</p>
<blockquote>
<p><code>render阶段</code>的<code>Update操作</code>由<code>processUpdateQueue</code>完成，你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L405" target="_blank" rel="noopener noreferrer">这里</a>看到<code>processUpdateQueue</code>的源码</p>
</blockquote>
<p><code>state</code>的变化在<code>render阶段</code>产生与上次更新不同的<code>JSX</code>对象，通过<code>Diff算法</code>产生<code>effectTag</code>，在<code>commit阶段</code>渲染在页面上。</p>
<p>渲染完成后<code>workInProgress Fiber树</code>变为<code>current Fiber树</code>，整个更新流程结束。</p>
]]></content>
    <author>
      <name>BetaSu</name>
    </author>
    <contributor>
      <name>BetaSu</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by BetaSu</rights>
  </entry>
  <entry>
    <title type="html">codegen</title>
    <id>https://0808200.xyz/vue2/compile/codegen.html</id>
    <link href="https://0808200.xyz/vue2/compile/codegen.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="codegen" tabindex="-1"> codegen</h1>
<p>编译的最后一步就是把优化后的 AST 树转换成可执行的代码，这部分内容也比较多，我并不打算把所有的细节都讲了，了解整体流程即可。部分细节我们会在之后的章节配合一个具体 case 去详细讲。</p>
<p>为了方便理解，我们还是用之前的例子：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>:class</span><span><span>=</span><span>"</span>bindCls<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>list<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>isShow<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>(item,index) in data<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>clickItem(index)<span>"</span></span><span>></span></span>{{item}}:{{index}}<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>它经过编译，执行 <code>const code = generate(ast, options)</code>，生成的 <code>render</code> 代码串如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span><span>{</span>
  <span>return</span> <span>(</span>isShow<span>)</span> <span>?</span>
    <span>_c</span><span>(</span><span>'ul'</span><span>,</span> <span>{</span>
        <span>staticClass</span><span>:</span> <span>"list"</span><span>,</span>
        <span>class</span><span>:</span> bindCls
      <span>}</span><span>,</span>
      <span>_l</span><span>(</span><span>(</span>data<span>)</span><span>,</span> <span>function</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>
        <span>return</span> <span>_c</span><span>(</span><span>'li'</span><span>,</span> <span>{</span>
          <span>on</span><span>:</span> <span>{</span>
            <span>"click"</span><span>:</span> <span>function</span><span>(</span><span>$event</span><span>)</span> <span>{</span>
              <span>clickItem</span><span>(</span>index<span>)</span>
            <span>}</span>
          <span>}</span>
        <span>}</span><span>,</span>
        <span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>item<span>)</span> <span>+</span> <span>":"</span> <span>+</span> <span>_s</span><span>(</span>index<span>)</span><span>)</span><span>]</span><span>)</span>
      <span>}</span><span>)</span>
    <span>)</span> <span>:</span> <span>_e</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的 <code>_c</code> 函数定义在 <code>src/core/instance/render.js</code> 中。</p>
<div><pre><code>vm<span>.</span><span>_c</span> <span>=</span> <span>(</span><span>a<span>,</span> b<span>,</span> c<span>,</span> d</span><span>)</span> <span>=></span> <span>createElement</span><span>(</span>vm<span>,</span> a<span>,</span> b<span>,</span> c<span>,</span> d<span>,</span> <span>false</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>而 <code>_l</code>、<code>_v</code> 定义在 <code>src/core/instance/render-helpers/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>installRenderHelpers</span> <span>(</span><span><span>target</span><span>:</span> any</span><span>)</span> <span>{</span>
  target<span>.</span>_o <span>=</span> markOnce
  target<span>.</span>_n <span>=</span> toNumber
  target<span>.</span>_s <span>=</span> toString
  target<span>.</span>_l <span>=</span> renderList
  target<span>.</span>_t <span>=</span> renderSlot
  target<span>.</span>_q <span>=</span> looseEqual
  target<span>.</span>_i <span>=</span> looseIndexOf
  target<span>.</span>_m <span>=</span> renderStatic
  target<span>.</span>_f <span>=</span> resolveFilter
  target<span>.</span>_k <span>=</span> checkKeyCodes
  target<span>.</span>_b <span>=</span> bindObjectProps
  target<span>.</span>_v <span>=</span> createTextVNode
  target<span>.</span>_e <span>=</span> createEmptyVNode
  target<span>.</span>_u <span>=</span> resolveScopedSlots
  target<span>.</span>_g <span>=</span> bindObjectListeners
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>顾名思义，<code>_c</code> 就是执行 <code>createElement</code> 去创建 VNode，而 <code>_l</code> 对应 <code>renderList</code> 渲染列表；<code>_v</code> 对应 <code>createTextVNode</code> 创建文本 VNode；<code>_e</code> 对于 <code>createEmptyVNode</code>创建空的 VNode。</p>
<p>在 <code>compileToFunctions</code> 中，会把这个 <code>render</code> 代码串转换成函数，它的定义在 <code>src/compler/to-function.js</code> 中：</p>
<div><pre><code><span>const</span> compiled <span>=</span> <span>compile</span><span>(</span>template<span>,</span> options<span>)</span>
res<span>.</span>render <span>=</span> <span>createFunction</span><span>(</span>compiled<span>.</span>render<span>,</span> fnGenErrors<span>)</span>

<span>function</span> <span>createFunction</span> <span>(</span><span>code<span>,</span> errors</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Function</span><span>(</span>code<span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
    errors<span>.</span><span>push</span><span>(</span><span>{</span> err<span>,</span> code <span>}</span><span>)</span>
    <span>return</span> noop
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上就是把 <code>render</code> 代码串通过 <code>new Function</code> 的方式转换成可执行的函数，赋值给 <code>vm.options.render</code>，这样当组件通过 <code>vm._render</code> 的时候，就会执行这个 <code>render</code> 函数。那么接下来我们就重点关注一下这个 <code>render</code> 代码串的生成过程。</p>
<h2 id="generate" tabindex="-1"> generate</h2>
<div><pre><code><span>const</span> code <span>=</span> <span>generate</span><span>(</span>ast<span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>generate</code> 函数的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>generate</span> <span>(</span>
  <span><span>ast</span><span>:</span> ASTElement <span>|</span> <span>void</span><span>,</span>
  <span>options</span><span>:</span> CompilerOptions</span>
<span>)</span><span>:</span> CodegenResult <span>{</span>
  <span>const</span> state <span>=</span> <span>new</span> <span>CodegenState</span><span>(</span>options<span>)</span>
  <span>const</span> code <span>=</span> ast <span>?</span> <span>genElement</span><span>(</span>ast<span>,</span> state<span>)</span> <span>:</span> <span>'_c("div")'</span>
  <span>return</span> <span>{</span>
    <span>render</span><span>:</span> <span><span>`</span><span>with(this){return </span><span><span>${</span>code<span>}</span></span><span>}</span><span>`</span></span><span>,</span>
    <span>staticRenderFns</span><span>:</span> state<span>.</span>staticRenderFns
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>generate</code> 函数首先通过 <code>genElement(ast, state)</code> 生成 <code>code</code>，再把 <code>code</code> 用 <code>with(this){return ${code}}}</code> 包裹起来。这里的 <code>state</code> 是 <code>CodegenState</code> 的一个实例，稍后我们在用到它的时候会介绍它。先来看一下 <code>genElement</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genElement</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
  <span>if</span> <span>(</span>el<span>.</span>staticRoot <span>&amp;&amp;</span> <span>!</span>el<span>.</span>staticProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genStatic</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>once <span>&amp;&amp;</span> <span>!</span>el<span>.</span>onceProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genOnce</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>for <span>&amp;&amp;</span> <span>!</span>el<span>.</span>forProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genFor</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>if <span>&amp;&amp;</span> <span>!</span>el<span>.</span>ifProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genIf</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'template'</span> <span>&amp;&amp;</span> <span>!</span>el<span>.</span>slotTarget<span>)</span> <span>{</span>
    <span>return</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span> <span>||</span> <span>'void 0'</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'slot'</span><span>)</span> <span>{</span>
    <span>return</span> <span>genSlot</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// component or element</span>
    <span>let</span> code
    <span>if</span> <span>(</span>el<span>.</span>component<span>)</span> <span>{</span>
      code <span>=</span> <span>genComponent</span><span>(</span>el<span>.</span>component<span>,</span> el<span>,</span> state<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> data <span>=</span> el<span>.</span>plain <span>?</span> <span>undefined</span> <span>:</span> <span>genData</span><span>(</span>el<span>,</span> state<span>)</span>

      <span>const</span> children <span>=</span> el<span>.</span>inlineTemplate <span>?</span> <span>null</span> <span>:</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>,</span> <span>true</span><span>)</span>
      code <span>=</span> <span><span>`</span><span>_c('</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>'</span><span><span>${</span>
        data <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>data<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span> <span>// data</span>
      <span>}</span></span><span><span>${</span>
        children <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>children<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span> <span>// children</span>
      <span>}</span></span><span>)</span><span>`</span></span>
    <span>}</span>
    <span>// module transforms</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> state<span>.</span>transforms<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      code <span>=</span> state<span>.</span>transforms<span>[</span>i<span>]</span><span>(</span>el<span>,</span> code<span>)</span>
    <span>}</span>
    <span>return</span> code
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>基本就是判断当前 AST 元素节点的属性执行不同的代码生成函数，在我们的例子中，我们先了解一下 <code>genFor</code> 和 <code>genIf</code>。</p>
<h2 id="genif" tabindex="-1"> <code>genIf</code></h2>
<div><pre><code><span>export</span> <span>function</span> <span>genIf</span> <span>(</span>
  <span><span>el</span><span>:</span> any<span>,</span>
  <span>state</span><span>:</span> CodegenState<span>,</span>
  altGen<span>?</span><span>:</span> Function<span>,</span>
  altEmpty<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> string <span>{</span>
  el<span>.</span>ifProcessed <span>=</span> <span>true</span> <span>// avoid recursion</span>
  <span>return</span> <span>genIfConditions</span><span>(</span>el<span>.</span>ifConditions<span>.</span><span>slice</span><span>(</span><span>)</span><span>,</span> state<span>,</span> altGen<span>,</span> altEmpty<span>)</span>
<span>}</span>

<span>function</span> <span>genIfConditions</span> <span>(</span>
  <span><span>conditions</span><span>:</span> ASTIfConditions<span>,</span>
  <span>state</span><span>:</span> CodegenState<span>,</span>
  altGen<span>?</span><span>:</span> Function<span>,</span>
  altEmpty<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>if</span> <span>(</span><span>!</span>conditions<span>.</span>length<span>)</span> <span>{</span>
    <span>return</span> altEmpty <span>||</span> <span>'_e()'</span>
  <span>}</span>

  <span>const</span> condition <span>=</span> conditions<span>.</span><span>shift</span><span>(</span><span>)</span>
  <span>if</span> <span>(</span>condition<span>.</span>exp<span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>(</span><span><span>${</span>condition<span>.</span>exp<span>}</span></span><span>)?</span><span><span>${</span>
      <span>genTernaryExp</span><span>(</span>condition<span>.</span>block<span>)</span>
    <span>}</span></span><span>:</span><span><span>${</span>
      <span>genIfConditions</span><span>(</span>conditions<span>,</span> state<span>,</span> altGen<span>,</span> altEmpty<span>)</span>
    <span>}</span></span><span>`</span></span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span><span>`</span><span><span>${</span><span>genTernaryExp</span><span>(</span>condition<span>.</span>block<span>)</span><span>}</span></span><span>`</span></span>
  <span>}</span>

  <span>// v-if with v-once should generate code like (a)?_m(0):_m(1)</span>
  <span>function</span> <span>genTernaryExp</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
    <span>return</span> altGen
      <span>?</span> <span>altGen</span><span>(</span>el<span>,</span> state<span>)</span>
      <span>:</span> el<span>.</span>once
        <span>?</span> <span>genOnce</span><span>(</span>el<span>,</span> state<span>)</span>
        <span>:</span> <span>genElement</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genIf</code> 主要是通过执行 <code>genIfConditions</code>，它是依次从 <code>conditions</code> 获取第一个 <code>condition</code>，然后通过对 <code>condition.exp</code> 去生成一段三元运算符的代码，<code>:</code> 后是递归调用 <code>genIfConditions</code>，这样如果有多个 <code>conditions</code>，就生成多层三元运算逻辑。这里我们暂时不考虑 <code>v-once</code> 的情况，所以
<code>genTernaryExp</code> 最终是调用了 <code>genElement</code>。</p>
<p>在我们的例子中，只有一个 <code>condition</code>，<code>exp</code> 为 <code>isShow</code>，因此生成如下伪代码：</p>
<div><pre><code><span>return</span> <span>(</span>isShow<span>)</span> <span>?</span> <span>genElement</span><span>(</span>el<span>,</span> state<span>)</span> <span>:</span> <span>_e</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="genfor" tabindex="-1"> <code>genFor</code></h2>
<div><pre><code><span>export</span> <span>function</span> <span>genFor</span> <span>(</span>
  <span><span>el</span><span>:</span> any<span>,</span>
  <span>state</span><span>:</span> CodegenState<span>,</span>
  altGen<span>?</span><span>:</span> Function<span>,</span>
  altHelper<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>const</span> exp <span>=</span> el<span>.</span>for
  <span>const</span> alias <span>=</span> el<span>.</span>alias
  <span>const</span> iterator1 <span>=</span> el<span>.</span>iterator1 <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>el<span>.</span>iterator1<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
  <span>const</span> iterator2 <span>=</span> el<span>.</span>iterator2 <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>el<span>.</span>iterator2<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    state<span>.</span><span>maybeComponent</span><span>(</span>el<span>)</span> <span>&amp;&amp;</span>
    el<span>.</span>tag <span>!==</span> <span>'slot'</span> <span>&amp;&amp;</span>
    el<span>.</span>tag <span>!==</span> <span>'template'</span> <span>&amp;&amp;</span>
    <span>!</span>el<span>.</span>key
  <span>)</span> <span>{</span>
    state<span>.</span><span>warn</span><span>(</span>
      <span><span>`</span><span>&lt;</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span> v-for="</span><span><span>${</span>alias<span>}</span></span><span> in </span><span><span>${</span>exp<span>}</span></span><span>">: component lists rendered with </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>v-for should have explicit keys. </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>See https://vuejs.org/guide/list.html#key for more info.</span><span>`</span></span><span>,</span>
      <span>true</span> <span>/* tip */</span>
    <span>)</span>
  <span>}</span>

  el<span>.</span>forProcessed <span>=</span> <span>true</span> <span>// avoid recursion</span>
  <span>return</span> <span><span>`</span><span><span>${</span>altHelper <span>||</span> <span>'_l'</span><span>}</span></span><span>((</span><span><span>${</span>exp<span>}</span></span><span>),</span><span>`</span></span> <span>+</span>
    <span><span>`</span><span>function(</span><span><span>${</span>alias<span>}</span></span><span><span>${</span>iterator1<span>}</span></span><span><span>${</span>iterator2<span>}</span></span><span>){</span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>return </span><span><span>${</span><span>(</span>altGen <span>||</span> genElement<span>)</span><span>(</span>el<span>,</span> state<span>)</span><span>}</span></span><span>`</span></span> <span>+</span>
    <span>'})'</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genFor</code> 的逻辑很简单，首先 AST 元素节点中获取了和 <code>for</code> 相关的一些属性，然后返回了一个代码字符串。</p>
<p>在我们的例子中，<code>exp</code> 是 <code>data</code>，<code>alias</code> 是 <code>item</code>，<code>iterator1</code> ，因此生成如下伪代码：</p>
<div><pre><code><span>_l</span><span>(</span><span>(</span>data<span>)</span><span>,</span> <span>function</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>
  <span>return</span> <span>genElememt</span><span>(</span>el<span>,</span> state<span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="gendata-genchildren" tabindex="-1"> <code>genData</code> &amp; <code>genChildren</code></h2>
<p>再次回顾我们的例子，它的最外层是 <code>ul</code>，首先执行 <code>genIf</code>，它最终调用了 <code>genElement(el, state)</code> 去生成子节点，注意，这里的 <code>el</code> 仍然指向的是 <code>ul</code> 对应的 AST 节点，但是此时的 <code>el.ifProcessed</code> 为 true，所以命中最后一个 else 逻辑：</p>
<div><pre><code><span>// component or element</span>
<span>let</span> code
<span>if</span> <span>(</span>el<span>.</span>component<span>)</span> <span>{</span>
  code <span>=</span> <span>genComponent</span><span>(</span>el<span>.</span>component<span>,</span> el<span>,</span> state<span>)</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>const</span> data <span>=</span> el<span>.</span>plain <span>?</span> <span>undefined</span> <span>:</span> <span>genData</span><span>(</span>el<span>,</span> state<span>)</span>

  <span>const</span> children <span>=</span> el<span>.</span>inlineTemplate <span>?</span> <span>null</span> <span>:</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>,</span> <span>true</span><span>)</span>
  code <span>=</span> <span><span>`</span><span>_c('</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>'</span><span><span>${</span>
    data <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>data<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span> <span>// data</span>
  <span>}</span></span><span><span>${</span>
    children <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>children<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span> <span>// children</span>
  <span>}</span></span><span>)</span><span>`</span></span>
<span>}</span>
<span>// module transforms</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> state<span>.</span>transforms<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  code <span>=</span> state<span>.</span>transforms<span>[</span>i<span>]</span><span>(</span>el<span>,</span> code<span>)</span>
<span>}</span>
<span>return</span> code
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们只关注 2 个逻辑，<code>genData</code> 和 <code>genChildren</code>：</p>
<ul>
<li>genData</li>
</ul>
<div><pre><code><span>export</span> <span>function</span> <span>genData</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
  <span>let</span> data <span>=</span> <span>'{'</span>

  <span>// directives first.</span>
  <span>// directives may mutate the el's other properties before they are generated.</span>
  <span>const</span> dirs <span>=</span> <span>genDirectives</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>if</span> <span>(</span>dirs<span>)</span> data <span>+=</span> dirs <span>+</span> <span>','</span>

  <span>// key</span>
  <span>if</span> <span>(</span>el<span>.</span>key<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>key:</span><span><span>${</span>el<span>.</span>key<span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>// ref</span>
  <span>if</span> <span>(</span>el<span>.</span>ref<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>ref:</span><span><span>${</span>el<span>.</span>ref<span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>el<span>.</span>refInFor<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>refInFor:true,</span><span>`</span></span>
  <span>}</span>
  <span>// pre</span>
  <span>if</span> <span>(</span>el<span>.</span>pre<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>pre:true,</span><span>`</span></span>
  <span>}</span>
  <span>// record original tag name for components using "is" attribute</span>
  <span>if</span> <span>(</span>el<span>.</span>component<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>tag:"</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>",</span><span>`</span></span>
  <span>}</span>
  <span>// module data generation functions</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> state<span>.</span>dataGenFns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    data <span>+=</span> state<span>.</span>dataGenFns<span>[</span>i<span>]</span><span>(</span>el<span>)</span>
  <span>}</span>
  <span>// attributes</span>
  <span>if</span> <span>(</span>el<span>.</span>attrs<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>attrs:{</span><span><span>${</span><span>genProps</span><span>(</span>el<span>.</span>attrs<span>)</span><span>}</span></span><span>},</span><span>`</span></span>
  <span>}</span>
  <span>// DOM props</span>
  <span>if</span> <span>(</span>el<span>.</span>props<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>domProps:{</span><span><span>${</span><span>genProps</span><span>(</span>el<span>.</span>props<span>)</span><span>}</span></span><span>},</span><span>`</span></span>
  <span>}</span>
  <span>// event handlers</span>
  <span>if</span> <span>(</span>el<span>.</span>events<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span><span>${</span><span>genHandlers</span><span>(</span>el<span>.</span>events<span>,</span> <span>false</span><span>,</span> state<span>.</span>warn<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>el<span>.</span>nativeEvents<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span><span>${</span><span>genHandlers</span><span>(</span>el<span>.</span>nativeEvents<span>,</span> <span>true</span><span>,</span> state<span>.</span>warn<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>// slot target</span>
  <span>// only for non-scoped slots</span>
  <span>if</span> <span>(</span>el<span>.</span>slotTarget <span>&amp;&amp;</span> <span>!</span>el<span>.</span>slotScope<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>slot:</span><span><span>${</span>el<span>.</span>slotTarget<span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>// scoped slots</span>
  <span>if</span> <span>(</span>el<span>.</span>scopedSlots<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span><span>${</span><span>genScopedSlots</span><span>(</span>el<span>.</span>scopedSlots<span>,</span> state<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>// component v-model</span>
  <span>if</span> <span>(</span>el<span>.</span>model<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>model:{value:</span><span><span>${</span>
      el<span>.</span>model<span>.</span>value
    <span>}</span></span><span>,callback:</span><span><span>${</span>
      el<span>.</span>model<span>.</span>callback
    <span>}</span></span><span>,expression:</span><span><span>${</span>
      el<span>.</span>model<span>.</span>expression
    <span>}</span></span><span>},</span><span>`</span></span>
  <span>}</span>
  <span>// inline-template</span>
  <span>if</span> <span>(</span>el<span>.</span>inlineTemplate<span>)</span> <span>{</span>
    <span>const</span> inlineTemplate <span>=</span> <span>genInlineTemplate</span><span>(</span>el<span>,</span> state<span>)</span>
    <span>if</span> <span>(</span>inlineTemplate<span>)</span> <span>{</span>
      data <span>+=</span> <span><span>`</span><span><span>${</span>inlineTemplate<span>}</span></span><span>,</span><span>`</span></span>
    <span>}</span>
  <span>}</span>
  data <span>=</span> data<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>,$</span><span>/</span></span><span>,</span> <span>''</span><span>)</span> <span>+</span> <span>'}'</span>
  <span>// v-bind data wrap</span>
  <span>if</span> <span>(</span>el<span>.</span>wrapData<span>)</span> <span>{</span>
    data <span>=</span> el<span>.</span><span>wrapData</span><span>(</span>data<span>)</span>
  <span>}</span>
  <span>// v-on data wrap</span>
  <span>if</span> <span>(</span>el<span>.</span>wrapListeners<span>)</span> <span>{</span>
    data <span>=</span> el<span>.</span><span>wrapListeners</span><span>(</span>data<span>)</span>
  <span>}</span>
  <span>return</span> data
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genData</code> 函数就是根据 AST 元素节点的属性构造出一个 <code>data</code> 对象字符串，这个在后面创建 VNode 的时候的时候会作为参数传入。</p>
<p>之前我们提到了 <code>CodegenState</code> 的实例 <code>state</code>，这里有一段关于 <code>state</code> 的逻辑：</p>
<div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> state<span>.</span>dataGenFns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  data <span>+=</span> state<span>.</span>dataGenFns<span>[</span>i<span>]</span><span>(</span>el<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>state.dataGenFns</code> 的初始化在它的构造器中。</p>
<div><pre><code><span>export</span> <span>class</span> <span>CodegenState</span> <span>{</span>
  <span>constructor</span> <span>(</span><span><span>options</span><span>:</span> CompilerOptions</span><span>)</span> <span>{</span>
    <span>// ...</span>
    <span>this</span><span>.</span>dataGenFns <span>=</span> <span>pluckModuleFunction</span><span>(</span>options<span>.</span>modules<span>,</span> <span>'genData'</span><span>)</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上就是获取所有 <code>modules</code> 中的 <code>genData</code> 函数，其中，<code>class module</code> 和 <code>style module</code> 定义了 <code>genData</code> 函数。比如定义在 <code>src/platforms/web/compiler/modules/class.js</code> 中的 <code>genData</code> 方法：</p>
<div><pre><code><span>function</span> <span>genData</span> <span>(</span><span><span>el</span><span>:</span> ASTElement</span><span>)</span><span>:</span> string <span>{</span>
  <span>let</span> data <span>=</span> <span>''</span>
  <span>if</span> <span>(</span>el<span>.</span>staticClass<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>staticClass:</span><span><span>${</span>el<span>.</span>staticClass<span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>el<span>.</span>classBinding<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span>class:</span><span><span>${</span>el<span>.</span>classBinding<span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>return</span> data
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在我们的例子中，<code>ul</code> AST 元素节点定义了 <code>el.staticClass</code> 和 <code>el.classBinding</code>，因此最终生成的 <code>data</code> 字符串如下：</p>
<div><pre><code><span>{</span>
  <span>staticClass</span><span>:</span> <span>"list"</span><span>,</span>
  <span>class</span><span>:</span> bindCls
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ul>
<li>genChildren</li>
</ul>
<p>接下来我们再来看一下 <code>genChildren</code>，它的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genChildren</span> <span>(</span>
  <span><span>el</span><span>:</span> ASTElement<span>,</span>
  <span>state</span><span>:</span> CodegenState<span>,</span>
  checkSkip<span>?</span><span>:</span> boolean<span>,</span>
  altGenElement<span>?</span><span>:</span> Function<span>,</span>
  altGenNode<span>?</span><span>:</span> Function</span>
<span>)</span><span>:</span> string <span>|</span> <span>void</span> <span>{</span>
  <span>const</span> children <span>=</span> el<span>.</span>children
  <span>if</span> <span>(</span>children<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> <span>el</span><span>:</span> any <span>=</span> children<span>[</span><span>0</span><span>]</span>
    <span>if</span> <span>(</span>children<span>.</span>length <span>===</span> <span>1</span> <span>&amp;&amp;</span>
      el<span>.</span>for <span>&amp;&amp;</span>
      el<span>.</span>tag <span>!==</span> <span>'template'</span> <span>&amp;&amp;</span>
      el<span>.</span>tag <span>!==</span> <span>'slot'</span>
    <span>)</span> <span>{</span>
      <span>return</span> <span>(</span>altGenElement <span>||</span> genElement<span>)</span><span>(</span>el<span>,</span> state<span>)</span>
    <span>}</span>
    <span>const</span> normalizationType <span>=</span> checkSkip
      <span>?</span> <span>getNormalizationType</span><span>(</span>children<span>,</span> state<span>.</span>maybeComponent<span>)</span>
      <span>:</span> <span>0</span>
    <span>const</span> gen <span>=</span> altGenNode <span>||</span> genNode
    <span>return</span> <span><span>`</span><span>[</span><span><span>${</span>children<span>.</span><span>map</span><span>(</span><span>c</span> <span>=></span> <span>gen</span><span>(</span>c<span>,</span> state<span>)</span><span>)</span><span>.</span><span>join</span><span>(</span><span>','</span><span>)</span><span>}</span></span><span>]</span><span><span>${</span>
      normalizationType <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>normalizationType<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
    <span>}</span></span><span>`</span></span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在我们的例子中，<code>li</code> AST 元素节点是 <code>ul</code> AST 元素节点的 <code>children</code> 之一，满足 <code>(children.length === 1 &amp;&amp; el.for &amp;&amp; el.tag !== 'template' &amp;&amp; el.tag !== 'slot')</code> 条件，因此通过 <code>genElement(el, state)</code> 生成 <code>li</code> AST元素节点的代码，也就回到了我们之前调用 <code>genFor</code> 生成的代码，把它们拼在一起生成的伪代码如下：</p>
<div><pre><code><span>return</span> <span>(</span>isShow<span>)</span> <span>?</span>
    <span>_c</span><span>(</span><span>'ul'</span><span>,</span> <span>{</span>
        <span>staticClass</span><span>:</span> <span>"list"</span><span>,</span>
        <span>class</span><span>:</span> bindCls
      <span>}</span><span>,</span>
      <span>_l</span><span>(</span><span>(</span>data<span>)</span><span>,</span> <span>function</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>
        <span>return</span> <span>genElememt</span><span>(</span>el<span>,</span> state<span>)</span>
      <span>}</span><span>)</span>
    <span>)</span> <span>:</span> <span>_e</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在我们的例子中，在执行 <code>genElememt(el, state)</code> 的时候，<code>el</code> 还是 <code>li</code> AST 元素节点，<code>el.forProcessed</code> 已为 true，所以会继续执行 <code>genData</code> 和 <code>genChildren</code> 的逻辑。由于 <code>el.events</code> 不为空，在执行 <code>genData</code> 的时候，会执行 如下逻辑：</p>
<div><pre><code><span>if</span> <span>(</span>el<span>.</span>events<span>)</span> <span>{</span>
  data <span>+=</span> <span><span>`</span><span><span>${</span><span>genHandlers</span><span>(</span>el<span>.</span>events<span>,</span> <span>false</span><span>,</span> state<span>.</span>warn<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>genHandlers</code> 的定义在 <code>src/compiler/codegen/events.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genHandlers</span> <span>(</span>
  <span><span>events</span><span>:</span> ASTElementHandlers<span>,</span>
  <span>isNative</span><span>:</span> boolean<span>,</span>
  <span>warn</span><span>:</span> Function</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>let</span> res <span>=</span> isNative <span>?</span> <span>'nativeOn:{'</span> <span>:</span> <span>'on:{'</span>
  <span>for</span> <span>(</span><span>const</span> name <span>in</span> events<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span>"</span><span><span>${</span>name<span>}</span></span><span>":</span><span><span>${</span><span>genHandler</span><span>(</span>name<span>,</span> events<span>[</span>name<span>]</span><span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>return</span> res<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span> <span>+</span> <span>'}'</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genHandler</code> 的逻辑就不介绍了，很大部分都是对修饰符 <code>modifier</code> 的处理，感兴趣同学可以自己看，对于我们的例子，它最终 <code>genData</code> 生成的 <code>data</code> 字符串如下：</p>
<div><pre><code><span>{</span>
  <span>on</span><span>:</span> <span>{</span>
    <span>"click"</span><span>:</span> <span>function</span><span>(</span><span>$event</span><span>)</span> <span>{</span>
      <span>clickItem</span><span>(</span>index<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genChildren</code> 的时候，会执行到如下逻辑：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genChildren</span> <span>(</span>
  <span><span>el</span><span>:</span> ASTElement<span>,</span>
  <span>state</span><span>:</span> CodegenState<span>,</span>
  checkSkip<span>?</span><span>:</span> boolean<span>,</span>
  altGenElement<span>?</span><span>:</span> Function<span>,</span>
  altGenNode<span>?</span><span>:</span> Function</span>
<span>)</span><span>:</span> string <span>|</span> <span>void</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> normalizationType <span>=</span> checkSkip
    <span>?</span> <span>getNormalizationType</span><span>(</span>children<span>,</span> state<span>.</span>maybeComponent<span>)</span>
    <span>:</span> <span>0</span>
  <span>const</span> gen <span>=</span> altGenNode <span>||</span> genNode
  <span>return</span> <span><span>`</span><span>[</span><span><span>${</span>children<span>.</span><span>map</span><span>(</span><span>c</span> <span>=></span> <span>gen</span><span>(</span>c<span>,</span> state<span>)</span><span>)</span><span>.</span><span>join</span><span>(</span><span>','</span><span>)</span><span>}</span></span><span>]</span><span><span>${</span>
    normalizationType <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>normalizationType<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
  <span>}</span></span><span>`</span></span>
<span>}</span>

<span>function</span> <span>genNode</span> <span>(</span><span><span>node</span><span>:</span> ASTNode<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
  <span>if</span> <span>(</span>node<span>.</span>type <span>===</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>genElement</span><span>(</span>node<span>,</span> state<span>)</span>
  <span>}</span> <span>if</span> <span>(</span>node<span>.</span>type <span>===</span> <span>3</span> <span>&amp;&amp;</span> node<span>.</span>isComment<span>)</span> <span>{</span>
    <span>return</span> <span>genComment</span><span>(</span>node<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span>genText</span><span>(</span>node<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genChildren</code> 的就是遍历 <code>children</code>，然后执行 <code>genNode</code> 方法，根据不同的 <code>type</code> 执行具体的方法。在我们的例子中，<code>li</code> AST 元素节点的 <code>children</code> 是 type 为 2 的表达式 AST 元素节点，那么会执行到 <code>genText(node)</code> 逻辑。</p>
<div><pre><code><span>export</span> <span>function</span> <span>genText</span> <span>(</span><span><span>text</span><span>:</span> ASTText <span>|</span> ASTExpression</span><span>)</span><span>:</span> string <span>{</span>
  <span>return</span> <span><span>`</span><span>_v(</span><span><span>${</span>text<span>.</span>type <span>===</span> <span>2</span>
    <span>?</span> text<span>.</span>expression
    <span>:</span> <span>transformSpecialNewlines</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>text<span>.</span>text<span>)</span><span>)</span>
  <span>}</span></span><span>)</span><span>`</span></span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>因此在我们的例子中，<code>genChildren</code> 生成的代码串如下：</p>
<div><pre><code><span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>item<span>)</span> <span>+</span> <span>":"</span> <span>+</span> <span>_s</span><span>(</span>index<span>)</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>和之前拼在一起，最终生成的 <code>code</code> 如下：</p>
<div><pre><code> <span>return</span> <span>(</span>isShow<span>)</span> <span>?</span>
    <span>_c</span><span>(</span><span>'ul'</span><span>,</span> <span>{</span>
        <span>staticClass</span><span>:</span> <span>"list"</span><span>,</span>
        <span>class</span><span>:</span> bindCls
      <span>}</span><span>,</span>
      <span>_l</span><span>(</span><span>(</span>data<span>)</span><span>,</span> <span>function</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>{</span>
        <span>return</span> <span>_c</span><span>(</span><span>'li'</span><span>,</span> <span>{</span>
          <span>on</span><span>:</span> <span>{</span>
            <span>"click"</span><span>:</span> <span>function</span><span>(</span><span>$event</span><span>)</span> <span>{</span>
              <span>clickItem</span><span>(</span>index<span>)</span>
            <span>}</span>
          <span>}</span>
        <span>}</span><span>,</span>
        <span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>item<span>)</span> <span>+</span> <span>":"</span> <span>+</span> <span>_s</span><span>(</span>index<span>)</span><span>)</span><span>]</span><span>)</span>
      <span>}</span><span>)</span>
    <span>)</span> <span>:</span> <span>_e</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="总结" tabindex="-1"> 总结</h2>
<p>这一节通过例子配合解析，我们对从 <code>ast -&gt; code </code> 这一步有了一些了解，编译后生成的代码就是在运行时执行的代码。由于 <code>genCode</code> 的内容有很多，所以我对大家的建议是没必要把所有的细节都一次性看完，我们应该根据具体一个 case，走完一条主线即可。</p>
<p>在之后的章节我们会对 <code>slot</code> 的实现做解析，我们会重新复习编译的章节，针对具体问题做具体分析，有利于我们排除干扰，对编译过程的学习有更深入的理解。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">编译入口</title>
    <id>https://0808200.xyz/vue2/compile/entrance.html</id>
    <link href="https://0808200.xyz/vue2/compile/entrance.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="编译入口" tabindex="-1"> 编译入口</h1>
<p>当我们使用 Runtime + Compiler 的 Vue.js，它的入口是 <code>src/platforms/web/entry-runtime-with-compiler.js</code>，看一下它对 <code>$mount</code> 函数的定义：</p>
<div><pre><code><span>const</span> mount <span>=</span> <span>Vue</span><span>.</span>prototype<span>.</span>$mount
<span>Vue</span><span>.</span>prototype<span>.</span><span>$mount</span> <span>=</span> <span>function</span> <span>(</span>
  <span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  el <span>=</span> el <span>&amp;&amp;</span> <span>query</span><span>(</span>el<span>)</span>

  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>el <span>===</span> document<span>.</span>body <span>||</span> el <span>===</span> document<span>.</span>documentElement<span>)</span> <span>{</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
      <span><span>`</span><span>Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.</span><span>`</span></span>
    <span>)</span>
    <span>return</span> <span>this</span>
  <span>}</span>

  <span>const</span> options <span>=</span> <span>this</span><span>.</span>$options
  <span>// resolve template/el and convert to render function</span>
  <span>if</span> <span>(</span><span>!</span>options<span>.</span>render<span>)</span> <span>{</span>
    <span>let</span> template <span>=</span> options<span>.</span>template
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> template <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>template<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'#'</span><span>)</span> <span>{</span>
          template <span>=</span> <span>idToTemplate</span><span>(</span>template<span>)</span>
          <span>/* istanbul ignore if */</span>
          <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>template<span>)</span> <span>{</span>
            <span>warn</span><span>(</span>
              <span><span>`</span><span>Template element not found or is empty: </span><span><span>${</span>options<span>.</span>template<span>}</span></span><span>`</span></span><span>,</span>
              <span>this</span>
            <span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>template<span>.</span>nodeType<span>)</span> <span>{</span>
        template <span>=</span> template<span>.</span>innerHTML
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
          <span>warn</span><span>(</span><span>'invalid template option:'</span> <span>+</span> template<span>,</span> <span>this</span><span>)</span>
        <span>}</span>
        <span>return</span> <span>this</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>)</span> <span>{</span>
      template <span>=</span> <span>getOuterHTML</span><span>(</span>el<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
        <span>mark</span><span>(</span><span>'compile'</span><span>)</span>
      <span>}</span>

      <span>const</span> <span>{</span> render<span>,</span> staticRenderFns <span>}</span> <span>=</span> <span>compileToFunctions</span><span>(</span>template<span>,</span> <span>{</span>
        shouldDecodeNewlines<span>,</span>
        shouldDecodeNewlinesForHref<span>,</span>
        <span>delimiters</span><span>:</span> options<span>.</span>delimiters<span>,</span>
        <span>comments</span><span>:</span> options<span>.</span>comments
      <span>}</span><span>,</span> <span>this</span><span>)</span>
      options<span>.</span>render <span>=</span> render
      options<span>.</span>staticRenderFns <span>=</span> staticRenderFns

      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
        <span>mark</span><span>(</span><span>'compile end'</span><span>)</span>
        <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span><span>this</span><span>.</span>_name<span>}</span></span><span> compile</span><span>`</span></span><span>,</span> <span>'compile'</span><span>,</span> <span>'compile end'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>mount</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> el<span>,</span> hydrating<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段函数逻辑之前分析过，关于编译的入口就是在这里：</p>
<div><pre><code><span>const</span> <span>{</span> render<span>,</span> staticRenderFns <span>}</span> <span>=</span>  <span>compileToFunctions</span><span>(</span>template<span>,</span> <span>{</span>
    shouldDecodeNewlines<span>,</span>
    shouldDecodeNewlinesForHref<span>,</span>
    <span>delimiters</span><span>:</span> options<span>.</span>delimiters<span>,</span>
    <span>comments</span><span>:</span> options<span>.</span>comments
  <span>}</span><span>,</span> <span>this</span><span>)</span>
options<span>.</span>render <span>=</span> render
options<span>.</span>staticRenderFns <span>=</span> staticRenderFns
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>compileToFunctions</code> 方法就是把模板 <code>template</code> 编译生成 <code>render</code> 以及 <code>staticRenderFns</code>，它的定义在 <code>src/platforms/web/compiler/index.js</code> 中：</p>
<div><pre><code><span>import</span> <span>{</span> baseOptions <span>}</span> <span>from</span> <span>'./options'</span>
<span>import</span> <span>{</span> createCompiler <span>}</span> <span>from</span> <span>'compiler/index'</span>

<span>const</span> <span>{</span> compile<span>,</span> compileToFunctions <span>}</span> <span>=</span> <span>createCompiler</span><span>(</span>baseOptions<span>)</span>

<span>export</span> <span>{</span> compile<span>,</span> compileToFunctions <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 <code>compileToFunctions</code> 方法实际上是 <code>createCompiler</code> 方法的返回值，该方法接收一个编译配置参数，接下来我们来看一下 <code>createCompiler</code> 方法的定义，在 <code>src/compiler/index.js</code> 中：</p>
<div><pre><code><span>// `createCompilerCreator` allows creating compilers that use alternative</span>
<span>// parser/optimizer/codegen, e.g the SSR optimizing compiler.</span>
<span>// Here we just export a default compiler using the default parts.</span>
<span>export</span> <span>const</span> createCompiler <span>=</span> <span>createCompilerCreator</span><span>(</span><span>function</span> <span>baseCompile</span> <span>(</span>
  <span><span>template</span><span>:</span> string<span>,</span>
  <span>options</span><span>:</span> CompilerOptions</span>
<span>)</span><span>:</span> CompiledResult <span>{</span>
  <span>const</span> ast <span>=</span> <span>parse</span><span>(</span>template<span>.</span><span>trim</span><span>(</span><span>)</span><span>,</span> options<span>)</span>
  <span>if</span> <span>(</span>options<span>.</span>optimize <span>!==</span> <span>false</span><span>)</span> <span>{</span>
    <span>optimize</span><span>(</span>ast<span>,</span> options<span>)</span>
  <span>}</span>
  <span>const</span> code <span>=</span> <span>generate</span><span>(</span>ast<span>,</span> options<span>)</span>
  <span>return</span> <span>{</span>
    ast<span>,</span>
    <span>render</span><span>:</span> code<span>.</span>render<span>,</span>
    <span>staticRenderFns</span><span>:</span> code<span>.</span>staticRenderFns
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createCompiler</code> 方法实际上是通过调用 <code>createCompilerCreator</code> 方法返回的，该方法传入的参数是一个函数，真正的编译过程都在这个 <code>baseCompile</code> 函数里执行，那么 <code>createCompilerCreator</code> 又是什么呢，它的定义在 <code>src/compiler/create-compiler.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createCompilerCreator</span> <span>(</span><span><span>baseCompile</span><span>:</span> Function</span><span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> <span>function</span> <span>createCompiler</span> <span>(</span><span><span>baseOptions</span><span>:</span> CompilerOptions</span><span>)</span> <span>{</span>
    <span>function</span> <span>compile</span> <span>(</span>
      <span><span>template</span><span>:</span> string<span>,</span>
      options<span>?</span><span>:</span> CompilerOptions</span>
    <span>)</span><span>:</span> CompiledResult <span>{</span>
      <span>const</span> finalOptions <span>=</span> Object<span>.</span><span>create</span><span>(</span>baseOptions<span>)</span>
      <span>const</span> errors <span>=</span> <span>[</span><span>]</span>
      <span>const</span> tips <span>=</span> <span>[</span><span>]</span>
      finalOptions<span>.</span><span>warn</span> <span>=</span> <span>(</span><span>msg<span>,</span> tip</span><span>)</span> <span>=></span> <span>{</span>
        <span>(</span>tip <span>?</span> tips <span>:</span> errors<span>)</span><span>.</span><span>push</span><span>(</span>msg<span>)</span>
      <span>}</span>

      <span>if</span> <span>(</span>options<span>)</span> <span>{</span>
        <span>// merge custom modules</span>
        <span>if</span> <span>(</span>options<span>.</span>modules<span>)</span> <span>{</span>
          finalOptions<span>.</span>modules <span>=</span>
            <span>(</span>baseOptions<span>.</span>modules <span>||</span> <span>[</span><span>]</span><span>)</span><span>.</span><span>concat</span><span>(</span>options<span>.</span>modules<span>)</span>
        <span>}</span>
        <span>// merge custom directives</span>
        <span>if</span> <span>(</span>options<span>.</span>directives<span>)</span> <span>{</span>
          finalOptions<span>.</span>directives <span>=</span> <span>extend</span><span>(</span>
            Object<span>.</span><span>create</span><span>(</span>baseOptions<span>.</span>directives <span>||</span> <span>null</span><span>)</span><span>,</span>
            options<span>.</span>directives
          <span>)</span>
        <span>}</span>
        <span>// copy other options</span>
        <span>for</span> <span>(</span><span>const</span> key <span>in</span> options<span>)</span> <span>{</span>
          <span>if</span> <span>(</span>key <span>!==</span> <span>'modules'</span> <span>&amp;&amp;</span> key <span>!==</span> <span>'directives'</span><span>)</span> <span>{</span>
            finalOptions<span>[</span>key<span>]</span> <span>=</span> options<span>[</span>key<span>]</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>

      <span>const</span> compiled <span>=</span> <span>baseCompile</span><span>(</span>template<span>,</span> finalOptions<span>)</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
        errors<span>.</span><span>push</span><span>.</span><span>apply</span><span>(</span>errors<span>,</span> <span>detectErrors</span><span>(</span>compiled<span>.</span>ast<span>)</span><span>)</span>
      <span>}</span>
      compiled<span>.</span>errors <span>=</span> errors
      compiled<span>.</span>tips <span>=</span> tips
      <span>return</span> compiled
    <span>}</span>

    <span>return</span> <span>{</span>
      compile<span>,</span>
      <span>compileToFunctions</span><span>:</span> <span>createCompileToFunctionFn</span><span>(</span>compile<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到该方法返回了一个 <code>createCompiler</code> 的函数，它接收一个 <code>baseOptions</code> 的参数，返回的是一个对象，包括 <code>compile</code> 方法属性和 <code>compileToFunctions</code> 属性，这个 <code>compileToFunctions</code> 对应的就是 <code>$mount</code> 函数调用的 <code>compileToFunctions</code> 方法，它是调用 <code>createCompileToFunctionFn</code> 方法的返回值，我们接下来看一下 <code>createCompileToFunctionFn</code> 方法，它的定义在 <code>src/compiler/to-function/js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createCompileToFunctionFn</span> <span>(</span><span><span>compile</span><span>:</span> Function</span><span>)</span><span>:</span> Function <span>{</span>
  <span>const</span> cache <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>

  <span>return</span> <span>function</span> <span>compileToFunctions</span> <span>(</span>
    <span><span>template</span><span>:</span> string<span>,</span>
    options<span>?</span><span>:</span> CompilerOptions<span>,</span>
    vm<span>?</span><span>:</span> Component</span>
  <span>)</span><span>:</span> CompiledFunctionResult <span>{</span>
    options <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> options<span>)</span>
    <span>const</span> warn <span>=</span> options<span>.</span>warn <span>||</span> baseWarn
    <span>delete</span> options<span>.</span>warn

    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>// detect possible CSP restriction</span>
      <span>try</span> <span>{</span>
        <span>new</span> <span>Function</span><span>(</span><span>'return 1'</span><span>)</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>e<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>unsafe-eval|CSP</span><span>/</span></span><span>)</span><span>)</span> <span>{</span>
          <span>warn</span><span>(</span>
            <span>'It seems you are using the standalone build of Vue.js in an '</span> <span>+</span>
            <span>'environment with Content Security Policy that prohibits unsafe-eval. '</span> <span>+</span>
            <span>'The template compiler cannot work in this environment. Consider '</span> <span>+</span>
            <span>'relaxing the policy to allow unsafe-eval or pre-compiling your '</span> <span>+</span>
            <span>'templates into render functions.'</span>
          <span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>// check cache</span>
    <span>const</span> key <span>=</span> options<span>.</span>delimiters
      <span>?</span> <span>String</span><span>(</span>options<span>.</span>delimiters<span>)</span> <span>+</span> template
      <span>:</span> template
    <span>if</span> <span>(</span>cache<span>[</span>key<span>]</span><span>)</span> <span>{</span>
      <span>return</span> cache<span>[</span>key<span>]</span>
    <span>}</span>

    <span>// compile</span>
    <span>const</span> compiled <span>=</span> <span>compile</span><span>(</span>template<span>,</span> options<span>)</span>

    <span>// check compilation errors/tips</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>compiled<span>.</span>errors <span>&amp;&amp;</span> compiled<span>.</span>errors<span>.</span>length<span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>Error compiling template:\n\n</span><span><span>${</span>template<span>}</span></span><span>\n\n</span><span>`</span></span> <span>+</span>
          compiled<span>.</span>errors<span>.</span><span>map</span><span>(</span><span>e</span> <span>=></span> <span><span>`</span><span>- </span><span><span>${</span>e<span>}</span></span><span>`</span></span><span>)</span><span>.</span><span>join</span><span>(</span><span>'\n'</span><span>)</span> <span>+</span> <span>'\n'</span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>compiled<span>.</span>tips <span>&amp;&amp;</span> compiled<span>.</span>tips<span>.</span>length<span>)</span> <span>{</span>
        compiled<span>.</span>tips<span>.</span><span>forEach</span><span>(</span><span>msg</span> <span>=></span> <span>tip</span><span>(</span>msg<span>,</span> vm<span>)</span><span>)</span>
      <span>}</span>
    <span>}</span>

    <span>// turn code into functions</span>
    <span>const</span> res <span>=</span> <span>{</span><span>}</span>
    <span>const</span> fnGenErrors <span>=</span> <span>[</span><span>]</span>
    res<span>.</span>render <span>=</span> <span>createFunction</span><span>(</span>compiled<span>.</span>render<span>,</span> fnGenErrors<span>)</span>
    res<span>.</span>staticRenderFns <span>=</span> compiled<span>.</span>staticRenderFns<span>.</span><span>map</span><span>(</span><span>code</span> <span>=></span> <span>{</span>
      <span>return</span> <span>createFunction</span><span>(</span>code<span>,</span> fnGenErrors<span>)</span>
    <span>}</span><span>)</span>

    <span>// check function generation errors.</span>
    <span>// this should only happen if there is a bug in the compiler itself.</span>
    <span>// mostly for codegen development use</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>(</span><span>!</span>compiled<span>.</span>errors <span>||</span> <span>!</span>compiled<span>.</span>errors<span>.</span>length<span>)</span> <span>&amp;&amp;</span> fnGenErrors<span>.</span>length<span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>Failed to generate render function:\n\n</span><span>`</span></span> <span>+</span>
          fnGenErrors<span>.</span><span>map</span><span>(</span><span>(</span><span><span>{</span> err<span>,</span> code <span>}</span></span><span>)</span> <span>=></span> <span><span>`</span><span><span>${</span>err<span>.</span><span>toString</span><span>(</span><span>)</span><span>}</span></span><span> in\n\n</span><span><span>${</span>code<span>}</span></span><span>\n</span><span>`</span></span><span>)</span><span>.</span><span>join</span><span>(</span><span>'\n'</span><span>)</span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
    <span>}</span>

    <span>return</span> <span>(</span>cache<span>[</span>key<span>]</span> <span>=</span> res<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>至此我们总算找到了 <code>compileToFunctions</code> 的最终定义，它接收 3 个参数、编译模板 <code>template</code>，编译配置 <code>options</code> 和 Vue 实例 <code>vm</code>。核心的编译过程就一行代码：</p>
<div><pre><code><span>const</span> compiled <span>=</span> <span>compile</span><span>(</span>template<span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>compile</code> 函数在执行 <code>createCompileToFunctionFn</code> 的时候作为参数传入，它是 <code>createCompiler</code> 函数中定义的 <code>compile</code> 函数，如下：</p>
<div><pre><code><span>function</span> <span>compile</span> <span>(</span>
  <span><span>template</span><span>:</span> string<span>,</span>
  options<span>?</span><span>:</span> CompilerOptions</span>
<span>)</span><span>:</span> CompiledResult <span>{</span>
  <span>const</span> finalOptions <span>=</span> Object<span>.</span><span>create</span><span>(</span>baseOptions<span>)</span>
  <span>const</span> errors <span>=</span> <span>[</span><span>]</span>
  <span>const</span> tips <span>=</span> <span>[</span><span>]</span>
  finalOptions<span>.</span><span>warn</span> <span>=</span> <span>(</span><span>msg<span>,</span> tip</span><span>)</span> <span>=></span> <span>{</span>
    <span>(</span>tip <span>?</span> tips <span>:</span> errors<span>)</span><span>.</span><span>push</span><span>(</span>msg<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span>options<span>)</span> <span>{</span>
    <span>// merge custom modules</span>
    <span>if</span> <span>(</span>options<span>.</span>modules<span>)</span> <span>{</span>
      finalOptions<span>.</span>modules <span>=</span>
        <span>(</span>baseOptions<span>.</span>modules <span>||</span> <span>[</span><span>]</span><span>)</span><span>.</span><span>concat</span><span>(</span>options<span>.</span>modules<span>)</span>
    <span>}</span>
    <span>// merge custom directives</span>
    <span>if</span> <span>(</span>options<span>.</span>directives<span>)</span> <span>{</span>
      finalOptions<span>.</span>directives <span>=</span> <span>extend</span><span>(</span>
        Object<span>.</span><span>create</span><span>(</span>baseOptions<span>.</span>directives <span>||</span> <span>null</span><span>)</span><span>,</span>
        options<span>.</span>directives
      <span>)</span>
    <span>}</span>
    <span>// copy other options</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> options<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>key <span>!==</span> <span>'modules'</span> <span>&amp;&amp;</span> key <span>!==</span> <span>'directives'</span><span>)</span> <span>{</span>
        finalOptions<span>[</span>key<span>]</span> <span>=</span> options<span>[</span>key<span>]</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>const</span> compiled <span>=</span> <span>baseCompile</span><span>(</span>template<span>,</span> finalOptions<span>)</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    errors<span>.</span><span>push</span><span>.</span><span>apply</span><span>(</span>errors<span>,</span> <span>detectErrors</span><span>(</span>compiled<span>.</span>ast<span>)</span><span>)</span>
  <span>}</span>
  compiled<span>.</span>errors <span>=</span> errors
  compiled<span>.</span>tips <span>=</span> tips
  <span>return</span> compiled
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>compile</code> 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码：</p>
<div><pre><code><span>const</span> compiled <span>=</span> <span>baseCompile</span><span>(</span>template<span>,</span> finalOptions<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>baseCompile</code> 在执行 <code>createCompilerCreator</code> 方法时作为参数传入，如下：</p>
<div><pre><code><span>export</span> <span>const</span> createCompiler <span>=</span> <span>createCompilerCreator</span><span>(</span><span>function</span> <span>baseCompile</span> <span>(</span>
  <span><span>template</span><span>:</span> string<span>,</span>
  <span>options</span><span>:</span> CompilerOptions</span>
<span>)</span><span>:</span> CompiledResult <span>{</span>
  <span>const</span> ast <span>=</span> <span>parse</span><span>(</span>template<span>.</span><span>trim</span><span>(</span><span>)</span><span>,</span> options<span>)</span>
  <span>optimize</span><span>(</span>ast<span>,</span> options<span>)</span>
  <span>const</span> code <span>=</span> <span>generate</span><span>(</span>ast<span>,</span> options<span>)</span>
  <span>return</span> <span>{</span>
    ast<span>,</span>
    <span>render</span><span>:</span> code<span>.</span>render<span>,</span>
    <span>staticRenderFns</span><span>:</span> code<span>.</span>staticRenderFns
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以编译的入口我们终于找到了，它主要就是执行了如下几个逻辑：</p>
<ul>
<li>解析模板字符串生成 AST</li>
</ul>
<div><pre><code><span>const</span> ast <span>=</span> <span>parse</span><span>(</span>template<span>.</span><span>trim</span><span>(</span><span>)</span><span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>优化语法树</li>
</ul>
<div><pre><code><span>optimize</span><span>(</span>ast<span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>生成代码</li>
</ul>
<div><pre><code><span>const</span> code <span>=</span> <span>generate</span><span>(</span>ast<span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>那么接下来的章节我会带大家去逐步分析这几个过程。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>编译入口逻辑之所以这么绕，是因为 Vue.js 在不同的平台下都会有编译的过程，因此编译过程中的依赖的配置 <code>baseOptions</code> 会有所不同。而编译过程会多次执行，但这同一个平台下每一次的编译过程配置又是相同的，为了不让这些配置在每次编译过程都通过参数传入，Vue.js 利用了函数柯里化的技巧很好的实现了 <code>baseOptions</code> 的参数保留。同样，Vue.js 也是利用函数柯里化技巧把基础的编译过程函数抽出来，通过 <code>createCompilerCreator(baseCompile)</code> 的方式把真正编译的过程和其它逻辑如对编译配置处理、缓存处理等剥离开，这样的设计还是非常巧妙的。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">编译</title>
    <id>https://0808200.xyz/vue2/compile/</id>
    <link href="https://0808200.xyz/vue2/compile/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="编译" tabindex="-1"> 编译</h1>
<p>之前我们分析过模板到真实 DOM 渲染的过程，中间有一个环节是把模板编译成 <code>render</code> 函数，这个过程我们把它称作编译。</p>
<p>虽然我们可以直接为组件编写 <code>render</code> 函数，但是编写 <code>template</code> 模板更加直观，也更符合我们的开发习惯。</p>
<p>Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 <code>vue-loader</code> 事先把模板编译成 <code>render </code>函数。</p>
<p>这一章我们就来分析编译的过程，对编译过程的了解会让我们对 Vue 的指令、内置组件等有更好的理解。不过由于编译的过程是一个相对复杂的过程，我们只要求理解整体的流程、输入和输出即可，对于细节我们不必抠太细。有些细节比如对于 <code>slot</code> 的处理我们可以在之后去分析插槽实现的时候再详细分析。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">optimize</title>
    <id>https://0808200.xyz/vue2/compile/optimize.html</id>
    <link href="https://0808200.xyz/vue2/compile/optimize.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="optimize" tabindex="-1"> optimize</h1>
<p>当我们的模板 <code>template</code> 经过 <code>parse</code> 过程后，会输出生成 AST 树，那么接下来我们需要对这颗树做优化，<code>optimize</code> 的逻辑是远简单于 <code>parse</code> 的逻辑，所以理解起来会轻松很多。</p>
<p>为什么要有优化过程，因为我们知道 Vue 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 <code>patch</code> 的过程跳过对他们的比对。</p>
<p>来看一下 <code>optimize</code> 方法的定义，在 <code>src/compiler/optimizer.js</code> 中：</p>
<div><pre><code><span>/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */</span>
<span>export</span> <span>function</span> <span>optimize</span> <span>(</span><span><span>root</span><span>:</span> <span>?</span>ASTElement<span>,</span> <span>options</span><span>:</span> CompilerOptions</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>return</span>
  isStaticKey <span>=</span> <span>genStaticKeysCached</span><span>(</span>options<span>.</span>staticKeys <span>||</span> <span>''</span><span>)</span>
  isPlatformReservedTag <span>=</span> options<span>.</span>isReservedTag <span>||</span> no
  <span>// first pass: mark all non-static nodes.</span>
  <span>markStatic</span><span>(</span>root<span>)</span>
  <span>// second pass: mark static roots.</span>
  <span>markStaticRoots</span><span>(</span>root<span>,</span> <span>false</span><span>)</span>
<span>}</span>

<span>function</span> <span>genStaticKeys</span> <span>(</span><span><span>keys</span><span>:</span> string</span><span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> <span>makeMap</span><span>(</span>
    <span>'type,tag,attrsList,attrsMap,plain,parent,children,attrs'</span> <span>+</span>
    <span>(</span>keys <span>?</span> <span>','</span> <span>+</span> keys <span>:</span> <span>''</span><span>)</span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们在编译阶段可以把一些 AST 节点优化成静态节点，所以整个 <code>optimize</code> 的过程实际上就干 2 件事情，<code>markStatic(root)</code> 标记静态节点 ，<code>markStaticRoots(root, false)</code> 标记静态根。</p>
<h2 id="标记静态节点" tabindex="-1"> 标记静态节点</h2>
<div><pre><code><span>function</span> <span>markStatic</span> <span>(</span><span><span>node</span><span>:</span> ASTNode</span><span>)</span> <span>{</span>
  node<span>.</span>static <span>=</span> <span>isStatic</span><span>(</span>node<span>)</span>
  <span>if</span> <span>(</span>node<span>.</span>type <span>===</span> <span>1</span><span>)</span> <span>{</span>
    <span>// do not make component slot content static. this avoids</span>
    <span>// 1. components not able to mutate slot nodes</span>
    <span>// 2. static slot content fails for hot-reloading</span>
    <span>if</span> <span>(</span>
      <span>!</span><span>isPlatformReservedTag</span><span>(</span>node<span>.</span>tag<span>)</span> <span>&amp;&amp;</span>
      node<span>.</span>tag <span>!==</span> <span>'slot'</span> <span>&amp;&amp;</span>
      node<span>.</span>attrsMap<span>[</span><span>'inline-template'</span><span>]</span> <span>==</span> <span>null</span>
    <span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> node<span>.</span>children<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>const</span> child <span>=</span> node<span>.</span>children<span>[</span>i<span>]</span>
      <span>markStatic</span><span>(</span>child<span>)</span>
      <span>if</span> <span>(</span><span>!</span>child<span>.</span>static<span>)</span> <span>{</span>
        node<span>.</span>static <span>=</span> <span>false</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>ifConditions<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>,</span> l <span>=</span> node<span>.</span>ifConditions<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>const</span> block <span>=</span> node<span>.</span>ifConditions<span>[</span>i<span>]</span><span>.</span>block
        <span>markStatic</span><span>(</span>block<span>)</span>
        <span>if</span> <span>(</span><span>!</span>block<span>.</span>static<span>)</span> <span>{</span>
          node<span>.</span>static <span>=</span> <span>false</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>isStatic</span> <span>(</span><span><span>node</span><span>:</span> ASTNode</span><span>)</span><span>:</span> boolean <span>{</span>
  <span>if</span> <span>(</span>node<span>.</span>type <span>===</span> <span>2</span><span>)</span> <span>{</span> <span>// expression</span>
    <span>return</span> <span>false</span>
  <span>}</span>
  <span>if</span> <span>(</span>node<span>.</span>type <span>===</span> <span>3</span><span>)</span> <span>{</span> <span>// text</span>
    <span>return</span> <span>true</span>
  <span>}</span>
  <span>return</span> <span>!</span><span>!</span><span>(</span>node<span>.</span>pre <span>||</span> <span>(</span>
    <span>!</span>node<span>.</span>hasBindings <span>&amp;&amp;</span> <span>// no dynamic bindings</span>
    <span>!</span>node<span>.</span>if <span>&amp;&amp;</span> <span>!</span>node<span>.</span>for <span>&amp;&amp;</span> <span>// not v-if or v-for or v-else</span>
    <span>!</span><span>isBuiltInTag</span><span>(</span>node<span>.</span>tag<span>)</span> <span>&amp;&amp;</span> <span>// not a built-in</span>
    <span>isPlatformReservedTag</span><span>(</span>node<span>.</span>tag<span>)</span> <span>&amp;&amp;</span> <span>// not a component</span>
    <span>!</span><span>isDirectChildOfTemplateFor</span><span>(</span>node<span>)</span> <span>&amp;&amp;</span>
    Object<span>.</span><span>keys</span><span>(</span>node<span>)</span><span>.</span><span>every</span><span>(</span>isStaticKey<span>)</span>
  <span>)</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先执行 <code>node.static = isStatic(node)</code></p>
<p><code>isStatic</code> 是对一个 AST 元素节点是否是静态的判断，如果是表达式，就是非静态；如果是纯文本，就是静态；对于一个普通元素，如果有 pre 属性，那么它使用了 <code>v-pre</code> 指令，是静态，否则要同时满足以下条件：没有使用 <code>v-if</code>、<code>v-for</code>，没有使用其它指令（不包括 <code>v-once</code>），非内置组件，是平台保留的标签，非带有 <code>v-for</code> 的 <code>template</code> 标签的直接子节点，节点的所有属性的 <code>key</code> 都满足静态 key；这些都满足则这个 AST 节点是一个静态节点。</p>
<p>如果这个节点是一个普通元素，则遍历它的所有 <code>children</code>，递归执行 <code>markStatic</code>。因为所有的 <code>elseif</code> 和 <code>else</code> 节点都不在 <code>children</code> 中， 如果节点的 <code>ifConditions</code> 不为空，则遍历 <code>ifConditions</code> 拿到所有条件中的 <code>block</code>，也就是它们对应的 AST 节点，递归执行 <code>markStatic</code>。在这些递归过程中，一旦子节点有不是 <code>static</code> 的情况，则它的父节点的 <code>static</code> 均变成 false。</p>
<h2 id="标记静态根" tabindex="-1"> 标记静态根</h2>
<div><pre><code><span>function</span> <span>markStaticRoots</span> <span>(</span><span><span>node</span><span>:</span> ASTNode<span>,</span> <span>isInFor</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>node<span>.</span>type <span>===</span> <span>1</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>static <span>||</span> node<span>.</span>once<span>)</span> <span>{</span>
      node<span>.</span>staticInFor <span>=</span> isInFor
    <span>}</span>
    <span>// For a node to qualify as a static root, it should have children that</span>
    <span>// are not just static text. Otherwise the cost of hoisting out will</span>
    <span>// outweigh the benefits and it's better off to just always render it fresh.</span>
    <span>if</span> <span>(</span>node<span>.</span>static <span>&amp;&amp;</span> node<span>.</span>children<span>.</span>length <span>&amp;&amp;</span> <span>!</span><span>(</span>
      node<span>.</span>children<span>.</span>length <span>===</span> <span>1</span> <span>&amp;&amp;</span>
      node<span>.</span>children<span>[</span><span>0</span><span>]</span><span>.</span>type <span>===</span> <span>3</span>
    <span>)</span><span>)</span> <span>{</span>
      node<span>.</span>staticRoot <span>=</span> <span>true</span>
      <span>return</span>
    <span>}</span> <span>else</span> <span>{</span>
      node<span>.</span>staticRoot <span>=</span> <span>false</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>children<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> node<span>.</span>children<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>markStaticRoots</span><span>(</span>node<span>.</span>children<span>[</span>i<span>]</span><span>,</span> isInFor <span>||</span> <span>!</span><span>!</span>node<span>.</span>for<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>ifConditions<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>,</span> l <span>=</span> node<span>.</span>ifConditions<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>markStaticRoots</span><span>(</span>node<span>.</span>ifConditions<span>[</span>i<span>]</span><span>.</span>block<span>,</span> isInFor<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>markStaticRoots</code> 第二个参数是 <code>isInFor</code>，对于已经是 <code>static</code> 的节点或者是 <code>v-once</code> 指令的节点，<code>node.staticInFor = isInFor</code>。
接着就是对于 <code>staticRoot</code> 的判断逻辑，从注释中我们可以看到，对于有资格成为 <code>staticRoot</code> 的节点，除了本身是一个静态节点外，必须满足拥有 <code>children</code>，并且 <code>children</code> 不能只是一个文本节点，不然的话把它标记成静态根节点的收益就很小了。</p>
<p>接下来和标记静态节点的逻辑一样，遍历 <code>children</code> 以及 <code>ifConditions</code>，递归执行 <code>markStaticRoots</code>。</p>
<p>回归我们之前的例子，经过 <code>optimize</code> 后，AST 树变成了如下：</p>
<div><pre><code>ast <span>=</span> <span>{</span>
  <span>'type'</span><span>:</span> <span>1</span><span>,</span>
  <span>'tag'</span><span>:</span> <span>'ul'</span><span>,</span>
  <span>'attrsList'</span><span>:</span> <span>[</span><span>]</span><span>,</span>
  <span>'attrsMap'</span><span>:</span> <span>{</span>
    <span>':class'</span><span>:</span> <span>'bindCls'</span><span>,</span>
    <span>'class'</span><span>:</span> <span>'list'</span><span>,</span>
    <span>'v-if'</span><span>:</span> <span>'isShow'</span>
  <span>}</span><span>,</span>
  <span>'if'</span><span>:</span> <span>'isShow'</span><span>,</span>
  <span>'ifConditions'</span><span>:</span> <span>[</span><span>{</span>
    <span>'exp'</span><span>:</span> <span>'isShow'</span><span>,</span>
    <span>'block'</span><span>:</span> <span>// ul ast element</span>
  <span>}</span><span>]</span><span>,</span>
  <span>'parent'</span><span>:</span> <span>undefined</span><span>,</span>
  <span>'plain'</span><span>:</span> <span>false</span><span>,</span>
  <span>'staticClass'</span><span>:</span> <span>'list'</span><span>,</span>
  <span>'classBinding'</span><span>:</span> <span>'bindCls'</span><span>,</span>
  <span>'static'</span><span>:</span> <span>false</span><span>,</span>
  <span>'staticRoot'</span><span>:</span> <span>false</span><span>,</span>
  <span>'children'</span><span>:</span> <span>[</span><span>{</span>
    <span>'type'</span><span>:</span> <span>1</span><span>,</span>
    <span>'tag'</span><span>:</span> <span>'li'</span><span>,</span>
    <span>'attrsList'</span><span>:</span> <span>[</span><span>{</span>
      <span>'name'</span><span>:</span> <span>'@click'</span><span>,</span>
      <span>'value'</span><span>:</span> <span>'clickItem(index)'</span>
    <span>}</span><span>]</span><span>,</span>
    <span>'attrsMap'</span><span>:</span> <span>{</span>
      <span>'@click'</span><span>:</span> <span>'clickItem(index)'</span><span>,</span>
      <span>'v-for'</span><span>:</span> <span>'(item,index) in data'</span>
     <span>}</span><span>,</span>
    <span>'parent'</span><span>:</span> <span>// ul ast element</span>
    <span>'plain'</span><span>:</span> <span>false</span><span>,</span>
    <span>'events'</span><span>:</span> <span>{</span>
      <span>'click'</span><span>:</span> <span>{</span>
        <span>'value'</span><span>:</span> <span>'clickItem(index)'</span>
      <span>}</span>
    <span>}</span><span>,</span>
    <span>'hasBindings'</span><span>:</span> <span>true</span><span>,</span>
    <span>'for'</span><span>:</span> <span>'data'</span><span>,</span>
    <span>'alias'</span><span>:</span> <span>'item'</span><span>,</span>
    <span>'iterator1'</span><span>:</span> <span>'index'</span><span>,</span>
    <span>'static'</span><span>:</span> <span>false</span><span>,</span>
    <span>'staticRoot'</span><span>:</span> <span>false</span><span>,</span>
    <span>'children'</span><span>:</span> <span>[</span>
      <span>'type'</span><span>:</span> <span>2</span><span>,</span>
      <span>'expression'</span><span>:</span> <span>'_s(item)+":"+_s(index)'</span>
      <span>'text'</span><span>:</span> <span>'{{item}}:{{index}}'</span><span>,</span>
      <span>'tokens'</span><span>:</span> <span>[</span>
        <span>{</span><span>'@binding'</span><span>:</span><span>'item'</span><span>}</span><span>,</span>
        <span>':'</span><span>,</span>
        <span>{</span><span>'@binding'</span><span>:</span><span>'index'</span><span>}</span>
      <span>]</span><span>,</span>
      <span>'static'</span><span>:</span> <span>false</span>
    <span>]</span>
  <span>}</span><span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们发现每一个 AST 元素节点都多了 <code>staic</code> 属性，并且 <code>type</code> 为 1 的普通元素 AST 节点多了 <code>staticRoot</code> 属性。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此我们分析完了 <code>optimize</code> 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。</p>
<p>我们通过 <code>optimize</code> 我们把整个 AST 树中的每一个 AST 元素节点标记了 <code>static</code> 和 <code>staticRoot</code>，它会影响我们接下来执行代码生成的过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">parse</title>
    <id>https://0808200.xyz/vue2/compile/parse.html</id>
    <link href="https://0808200.xyz/vue2/compile/parse.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="parse" tabindex="-1"> parse</h1>
<p>编译过程首先就是对模板做解析，生成 AST，它是一种抽象语法树，是对源代码的抽象语法结构的树状表现形式。在很多编译技术中，如 babel 编译 ES6 的代码都会先生成 AST。</p>
<p>这个过程是比较复杂的，它会用到大量正则表达式对字符串解析，如果对正则不是很了解，建议先去补习正则表达式的知识。为了直观地演示 <code>parse</code> 的过程，我们先来看一个例子：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>:class</span><span><span>=</span><span>"</span>bindCls<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>list<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>isShow<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>(item,index) in data<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>clickItem(index)<span>"</span></span><span>></span></span>{{item}}:{{index}}<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>经过 <code>parse</code> 过程后，生成的 AST 如下：</p>
<div><pre><code>ast <span>=</span> <span>{</span>
  <span>'type'</span><span>:</span> <span>1</span><span>,</span>
  <span>'tag'</span><span>:</span> <span>'ul'</span><span>,</span>
  <span>'attrsList'</span><span>:</span> <span>[</span><span>]</span><span>,</span>
  <span>'attrsMap'</span><span>:</span> <span>{</span>
    <span>':class'</span><span>:</span> <span>'bindCls'</span><span>,</span>
    <span>'class'</span><span>:</span> <span>'list'</span><span>,</span>
    <span>'v-if'</span><span>:</span> <span>'isShow'</span>
  <span>}</span><span>,</span>
  <span>'if'</span><span>:</span> <span>'isShow'</span><span>,</span>
  <span>'ifConditions'</span><span>:</span> <span>[</span><span>{</span>
    <span>'exp'</span><span>:</span> <span>'isShow'</span><span>,</span>
    <span>'block'</span><span>:</span> <span>// ul ast element</span>
  <span>}</span><span>]</span><span>,</span>
  <span>'parent'</span><span>:</span> <span>undefined</span><span>,</span>
  <span>'plain'</span><span>:</span> <span>false</span><span>,</span>
  <span>'staticClass'</span><span>:</span> <span>'list'</span><span>,</span>
  <span>'classBinding'</span><span>:</span> <span>'bindCls'</span><span>,</span>
  <span>'children'</span><span>:</span> <span>[</span><span>{</span>
    <span>'type'</span><span>:</span> <span>1</span><span>,</span>
    <span>'tag'</span><span>:</span> <span>'li'</span><span>,</span>
    <span>'attrsList'</span><span>:</span> <span>[</span><span>{</span>
      <span>'name'</span><span>:</span> <span>'@click'</span><span>,</span>
      <span>'value'</span><span>:</span> <span>'clickItem(index)'</span>
    <span>}</span><span>]</span><span>,</span>
    <span>'attrsMap'</span><span>:</span> <span>{</span>
      <span>'@click'</span><span>:</span> <span>'clickItem(index)'</span><span>,</span>
      <span>'v-for'</span><span>:</span> <span>'(item,index) in data'</span>
     <span>}</span><span>,</span>
    <span>'parent'</span><span>:</span> <span>// ul ast element</span>
    <span>'plain'</span><span>:</span> <span>false</span><span>,</span>
    <span>'events'</span><span>:</span> <span>{</span>
      <span>'click'</span><span>:</span> <span>{</span>
        <span>'value'</span><span>:</span> <span>'clickItem(index)'</span>
      <span>}</span>
    <span>}</span><span>,</span>
    <span>'hasBindings'</span><span>:</span> <span>true</span><span>,</span>
    <span>'for'</span><span>:</span> <span>'data'</span><span>,</span>
    <span>'alias'</span><span>:</span> <span>'item'</span><span>,</span>
    <span>'iterator1'</span><span>:</span> <span>'index'</span><span>,</span>
    <span>'children'</span><span>:</span> <span>[</span>
      <span>'type'</span><span>:</span> <span>2</span><span>,</span>
      <span>'expression'</span><span>:</span> <span>'_s(item)+":"+_s(index)'</span>
      <span>'text'</span><span>:</span> <span>'{{item}}:{{index}}'</span><span>,</span>
      <span>'tokens'</span><span>:</span> <span>[</span>
        <span>{</span><span>'@binding'</span><span>:</span><span>'item'</span><span>}</span><span>,</span>
        <span>':'</span><span>,</span>
        <span>{</span><span>'@binding'</span><span>:</span><span>'index'</span><span>}</span>
      <span>]</span>
    <span>]</span>
  <span>}</span><span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，生成的 AST 是一个树状结构，每一个节点都是一个 <code>ast element</code>，除了它自身的一些属性，还维护了它的父子关系，如 <code>parent</code> 指向它的父节点，<code>children</code> 指向它的所有子节点。先对 AST 有一些直观的印象，那么接下来我们来分析一下这个 AST 是如何得到的。</p>
<h2 id="整体流程" tabindex="-1"> 整体流程</h2>
<p>首先来看一下 <code>parse</code> 的定义，在 <code>src/compiler/parser/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>parse</span> <span>(</span>
  <span><span>template</span><span>:</span> string<span>,</span>
  <span>options</span><span>:</span> CompilerOptions</span>
<span>)</span><span>:</span> ASTElement <span>|</span> <span>void</span> <span>{</span>
  <span>getFnsAndConfigFromOptions</span><span>(</span>options<span>)</span>

  <span>parseHTML</span><span>(</span>template<span>,</span> <span>{</span>
    <span>// options ...</span>
    <span>start</span> <span>(</span><span>tag<span>,</span> attrs<span>,</span> unary</span><span>)</span> <span>{</span>
      <span>let</span> element <span>=</span> <span>createASTElement</span><span>(</span>tag<span>,</span> attrs<span>)</span>
      <span>processElement</span><span>(</span>element<span>)</span>
      <span>treeManagement</span><span>(</span><span>)</span>
    <span>}</span><span>,</span>

    <span>end</span> <span>(</span><span>)</span> <span>{</span>
      <span>treeManagement</span><span>(</span><span>)</span>
      <span>closeElement</span><span>(</span><span>)</span>
    <span>}</span><span>,</span>

    <span>chars</span> <span>(</span><span><span>text</span><span>:</span> string</span><span>)</span> <span>{</span>
      <span>handleText</span><span>(</span><span>)</span>
      <span>createChildrenASTOfText</span><span>(</span><span>)</span>
    <span>}</span><span>,</span>
    <span>comment</span> <span>(</span><span><span>text</span><span>:</span> string</span><span>)</span> <span>{</span>
      <span>createChildrenASTOfComment</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>return</span> astRootElement
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>parse</code> 函数的代码很长，贴一遍对同学的理解没有好处，我先把它拆成伪代码的形式，方便同学们对整体流程先有一个大致的了解。接下来我们就来分解分析每段伪代码的作用。</p>
<h3 id="从-options-中获取方法和配置" tabindex="-1"> 从 options 中获取方法和配置</h3>
<p>对应伪代码：</p>
<div><pre><code><span>getFnsAndConfigFromOptions</span><span>(</span>options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>parse</code> 函数的输入是 <code>template</code> 和 <code>options</code>，输出是 AST 的根节点。<code>template</code> 就是我们的模板字符串，而 <code>options</code> 实际上是和平台相关的一些配置，它的定义在 <code>src/platforms/web/compiler/options</code> 中：</p>
<div><pre><code><span>import</span> <span>{</span>
  isPreTag<span>,</span>
  mustUseProp<span>,</span>
  isReservedTag<span>,</span>
  getTagNamespace
<span>}</span> <span>from</span> <span>'../util/index'</span>

<span>import</span> modules <span>from</span> <span>'./modules/index'</span>
<span>import</span> directives <span>from</span> <span>'./directives/index'</span>
<span>import</span> <span>{</span> genStaticKeys <span>}</span> <span>from</span> <span>'shared/util'</span>
<span>import</span> <span>{</span> isUnaryTag<span>,</span> canBeLeftOpenTag <span>}</span> <span>from</span> <span>'./util'</span>

<span>export</span> <span>const</span> <span>baseOptions</span><span>:</span> CompilerOptions <span>=</span> <span>{</span>
  <span>expectHTML</span><span>:</span> <span>true</span><span>,</span>
  modules<span>,</span>
  directives<span>,</span>
  isPreTag<span>,</span>
  isUnaryTag<span>,</span>
  mustUseProp<span>,</span>
  canBeLeftOpenTag<span>,</span>
  isReservedTag<span>,</span>
  getTagNamespace<span>,</span>
  <span>staticKeys</span><span>:</span> <span>genStaticKeys</span><span>(</span>modules<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这些属性和方法之所以放到 <code>platforms</code> 目录下是因为它们在不同的平台（web 和 weex）的实现是不同的。</p>
<p>我们用伪代码 <code>getFnsAndConfigFromOptions</code> 表示了这一过程，它的实际代码如下：</p>
<div><pre><code>warn <span>=</span> options<span>.</span>warn <span>||</span> baseWarn

platformIsPreTag <span>=</span> options<span>.</span>isPreTag <span>||</span> no
platformMustUseProp <span>=</span> options<span>.</span>mustUseProp <span>||</span> no
platformGetTagNamespace <span>=</span> options<span>.</span>getTagNamespace <span>||</span> no

transforms <span>=</span> <span>pluckModuleFunction</span><span>(</span>options<span>.</span>modules<span>,</span> <span>'transformNode'</span><span>)</span>
preTransforms <span>=</span> <span>pluckModuleFunction</span><span>(</span>options<span>.</span>modules<span>,</span> <span>'preTransformNode'</span><span>)</span>
postTransforms <span>=</span> <span>pluckModuleFunction</span><span>(</span>options<span>.</span>modules<span>,</span> <span>'postTransformNode'</span><span>)</span>

delimiters <span>=</span> options<span>.</span>delimiters
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这些方法和配置都是后续解析时候需要的，可以不用去管它们的具体作用，我们先往后看。</p>
<h3 id="解析-html-模板" tabindex="-1"> 解析 HTML 模板</h3>
<p>对应伪代码：</p>
<div><pre><code><span>parseHTML</span><span>(</span>template<span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>对于 <code>template</code> 模板的解析主要是通过 <code>parseHTML</code> 函数，它的定义在 <code>src/compiler/parser/html-parser</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>parseHTML</span> <span>(</span><span>html<span>,</span> options</span><span>)</span> <span>{</span>
  <span>let</span> lastTag
  <span>while</span> <span>(</span>html<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>lastTag <span>||</span> <span>!</span><span>isPlainTextElement</span><span>(</span>lastTag<span>)</span><span>)</span><span>{</span>
      <span>let</span> textEnd <span>=</span> html<span>.</span><span>indexOf</span><span>(</span><span>'&lt;'</span><span>)</span>
      <span>if</span> <span>(</span>textEnd <span>===</span> <span>0</span><span>)</span> <span>{</span>
         <span>if</span><span>(</span>matchComment<span>)</span> <span>{</span>
           <span>advance</span><span>(</span>commentLength<span>)</span>
           <span>continue</span>
         <span>}</span>
         <span>if</span><span>(</span>matchDoctype<span>)</span> <span>{</span>
           <span>advance</span><span>(</span>doctypeLength<span>)</span>
           <span>continue</span>
         <span>}</span>
         <span>if</span><span>(</span>matchEndTag<span>)</span> <span>{</span>
           <span>advance</span><span>(</span>endTagLength<span>)</span>
           <span>parseEndTag</span><span>(</span><span>)</span>
           <span>continue</span>
         <span>}</span>
         <span>if</span><span>(</span>matchStartTag<span>)</span> <span>{</span>
           <span>parseStartTag</span><span>(</span><span>)</span>
           <span>handleStartTag</span><span>(</span><span>)</span>
           <span>continue</span>
         <span>}</span>
      <span>}</span>
      <span>handleText</span><span>(</span><span>)</span>
      <span>advance</span><span>(</span>textLength<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
       <span>handlePlainTextElement</span><span>(</span><span>)</span>
       <span>parseEndTag</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>由于 <code>parseHTML</code> 的逻辑也非常复杂，因此我也用了伪代码的方式表达，整体来说它的逻辑就是循环解析 <code>template</code> ，用正则做各种匹配，对于不同情况分别进行不同的处理，直到整个 template 被解析完毕。
在匹配的过程中会利用 <code>advance</code> 函数不断前进整个模板字符串，直到字符串末尾。</p>
<div><pre><code><span>function</span> <span>advance</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  index <span>+=</span> n
  html <span>=</span> html<span>.</span><span>substring</span><span>(</span>n<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>为了更加直观地说明 <code>advance</code> 的作用，可以通过一副图表示：</p>
<img :src="$withBase('/assets/advance-1.png')">
<p>调用 <code>advance</code> 函数：</p>
<div><pre><code><span>advance</span><span>(</span><span>4</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>得到结果：</p>
<img :src="$withBase('/assets/advance-2.png')">
<p>匹配的过程中主要利用了正则表达式，如下：</p>
<div><pre><code><span>const</span> attribute <span>=</span> <span><span>/</span><span>^\s*([^\s"'&lt;>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=&lt;>`]+)))?</span><span>/</span></span>
<span>const</span> ncname <span>=</span> <span>'[a-zA-Z_][\\w\\-\\.]*'</span>
<span>const</span> qnameCapture <span>=</span> <span><span>`</span><span>((?:</span><span><span>${</span>ncname<span>}</span></span><span>\\:)?</span><span><span>${</span>ncname<span>}</span></span><span>)</span><span>`</span></span>
<span>const</span> startTagOpen <span>=</span> <span>new</span> <span>RegExp</span><span>(</span><span><span>`</span><span>^&lt;</span><span><span>${</span>qnameCapture<span>}</span></span><span>`</span></span><span>)</span>
<span>const</span> startTagClose <span>=</span> <span><span>/</span><span>^\s*(\/?)></span><span>/</span></span>
<span>const</span> endTag <span>=</span> <span>new</span> <span>RegExp</span><span>(</span><span><span>`</span><span>^&lt;\\/</span><span><span>${</span>qnameCapture<span>}</span></span><span>[^>]*></span><span>`</span></span><span>)</span>
<span>const</span> doctype <span>=</span> <span><span>/</span><span>^&lt;!DOCTYPE [^>]+></span><span>/</span><span>i</span></span>
<span>const</span> comment <span>=</span> <span><span>/</span><span>^&lt;!\--</span><span>/</span></span>
<span>const</span> conditionalComment <span>=</span> <span><span>/</span><span>^&lt;!\[</span><span>/</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通过这些正则表达式，我们可以匹配注释节点、文档类型节点、开始闭合标签等。</p>
<ul>
<li>注释节点、文档类型节点</li>
</ul>
<p>对于注释节点和文档类型节点的匹配，如果匹配到我们仅仅做的是做前进即可。</p>
<div><pre><code><span>if</span> <span>(</span>comment<span>.</span><span>test</span><span>(</span>html<span>)</span><span>)</span> <span>{</span>
  <span>const</span> commentEnd <span>=</span> html<span>.</span><span>indexOf</span><span>(</span><span>'-->'</span><span>)</span>

  <span>if</span> <span>(</span>commentEnd <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>options<span>.</span>shouldKeepComment<span>)</span> <span>{</span>
      options<span>.</span><span>comment</span><span>(</span>html<span>.</span><span>substring</span><span>(</span><span>4</span><span>,</span> commentEnd<span>)</span><span>)</span>
    <span>}</span>
    <span>advance</span><span>(</span>commentEnd <span>+</span> <span>3</span><span>)</span>
    <span>continue</span>
  <span>}</span>
<span>}</span>

<span>if</span> <span>(</span>conditionalComment<span>.</span><span>test</span><span>(</span>html<span>)</span><span>)</span> <span>{</span>
  <span>const</span> conditionalEnd <span>=</span> html<span>.</span><span>indexOf</span><span>(</span><span>']>'</span><span>)</span>

  <span>if</span> <span>(</span>conditionalEnd <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    <span>advance</span><span>(</span>conditionalEnd <span>+</span> <span>2</span><span>)</span>
    <span>continue</span>
  <span>}</span>
<span>}</span>

<span>const</span> doctypeMatch <span>=</span> html<span>.</span><span>match</span><span>(</span>doctype<span>)</span>
<span>if</span> <span>(</span>doctypeMatch<span>)</span> <span>{</span>
  <span>advance</span><span>(</span>doctypeMatch<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span>
  <span>continue</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于注释和条件注释节点，前进至它们的末尾位置；对于文档类型节点，则前进它自身长度的距离。</p>
<ul>
<li>开始标签</li>
</ul>
<div><pre><code><span>const</span> startTagMatch <span>=</span> <span>parseStartTag</span><span>(</span><span>)</span>
<span>if</span> <span>(</span>startTagMatch<span>)</span> <span>{</span>
  <span>handleStartTag</span><span>(</span>startTagMatch<span>)</span>
  <span>if</span> <span>(</span><span>shouldIgnoreFirstNewline</span><span>(</span>lastTag<span>,</span> html<span>)</span><span>)</span> <span>{</span>
    <span>advance</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>
  <span>continue</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先通过 <code>parseStartTag</code> 解析开始标签：</p>
<div><pre><code><span>function</span> <span>parseStartTag</span> <span>(</span><span>)</span> <span>{</span>
  <span>const</span> start <span>=</span> html<span>.</span><span>match</span><span>(</span>startTagOpen<span>)</span>
  <span>if</span> <span>(</span>start<span>)</span> <span>{</span>
    <span>const</span> match <span>=</span> <span>{</span>
      <span>tagName</span><span>:</span> start<span>[</span><span>1</span><span>]</span><span>,</span>
      <span>attrs</span><span>:</span> <span>[</span><span>]</span><span>,</span>
      <span>start</span><span>:</span> index
    <span>}</span>
    <span>advance</span><span>(</span>start<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span>
    <span>let</span> end<span>,</span> attr
    <span>while</span> <span>(</span><span>!</span><span>(</span>end <span>=</span> html<span>.</span><span>match</span><span>(</span>startTagClose<span>)</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>attr <span>=</span> html<span>.</span><span>match</span><span>(</span>attribute<span>)</span><span>)</span><span>)</span> <span>{</span>
      <span>advance</span><span>(</span>attr<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span>
      match<span>.</span>attrs<span>.</span><span>push</span><span>(</span>attr<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>end<span>)</span> <span>{</span>
      match<span>.</span>unarySlash <span>=</span> end<span>[</span><span>1</span><span>]</span>
      <span>advance</span><span>(</span>end<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span>
      match<span>.</span>end <span>=</span> index
      <span>return</span> match
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于开始标签，除了标签名之外，还有一些标签相关的属性。函数先通过正则表达式 <code>startTagOpen</code> 匹配到开始标签，然后定义了 <code>match</code> 对象，接着循环去匹配开始标签中的属性并添加到 <code>match.attrs</code> 中，直到匹配的开始标签的闭合符结束。如果匹配到闭合符，则获取一元斜线符，前进到闭合符尾，并把当前索引赋值给 <code>match.end</code>。</p>
<p><code>parseStartTag</code> 对开始标签解析拿到 <code>match</code> 后，紧接着会执行 <code>handleStartTag</code> 对 <code>match</code> 做处理：</p>
<div><pre><code><span>function</span> <span>handleStartTag</span> <span>(</span><span>match</span><span>)</span> <span>{</span>
  <span>const</span> tagName <span>=</span> match<span>.</span>tagName
  <span>const</span> unarySlash <span>=</span> match<span>.</span>unarySlash
  
  <span>if</span> <span>(</span>expectHTML<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>lastTag <span>===</span> <span>'p'</span> <span>&amp;&amp;</span> <span>isNonPhrasingTag</span><span>(</span>tagName<span>)</span><span>)</span> <span>{</span>
      <span>parseEndTag</span><span>(</span>lastTag<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>canBeLeftOpenTag</span><span>(</span>tagName<span>)</span> <span>&amp;&amp;</span> lastTag <span>===</span> tagName<span>)</span> <span>{</span>
      <span>parseEndTag</span><span>(</span>tagName<span>)</span>
    <span>}</span>
  <span>}</span>
  
  <span>const</span> unary <span>=</span> <span>isUnaryTag</span><span>(</span>tagName<span>)</span> <span>||</span> <span>!</span><span>!</span>unarySlash
  
  <span>const</span> l <span>=</span> match<span>.</span>attrs<span>.</span>length
  <span>const</span> attrs <span>=</span> <span>new</span> <span>Array</span><span>(</span>l<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> args <span>=</span> match<span>.</span>attrs<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span><span>IS_REGEX_CAPTURING_BROKEN</span> <span>&amp;&amp;</span> args<span>[</span><span>0</span><span>]</span><span>.</span><span>indexOf</span><span>(</span><span>'""'</span><span>)</span> <span>===</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>args<span>[</span><span>3</span><span>]</span> <span>===</span> <span>''</span><span>)</span> <span>{</span> <span>delete</span> args<span>[</span><span>3</span><span>]</span> <span>}</span>
      <span>if</span> <span>(</span>args<span>[</span><span>4</span><span>]</span> <span>===</span> <span>''</span><span>)</span> <span>{</span> <span>delete</span> args<span>[</span><span>4</span><span>]</span> <span>}</span>
      <span>if</span> <span>(</span>args<span>[</span><span>5</span><span>]</span> <span>===</span> <span>''</span><span>)</span> <span>{</span> <span>delete</span> args<span>[</span><span>5</span><span>]</span> <span>}</span>
    <span>}</span>
    <span>const</span> value <span>=</span> args<span>[</span><span>3</span><span>]</span> <span>||</span> args<span>[</span><span>4</span><span>]</span> <span>||</span> args<span>[</span><span>5</span><span>]</span> <span>||</span> <span>''</span>
    <span>const</span> shouldDecodeNewlines <span>=</span> tagName <span>===</span> <span>'a'</span> <span>&amp;&amp;</span> args<span>[</span><span>1</span><span>]</span> <span>===</span> <span>'href'</span>
      <span>?</span> options<span>.</span>shouldDecodeNewlinesForHref
      <span>:</span> options<span>.</span>shouldDecodeNewlines
    attrs<span>[</span>i<span>]</span> <span>=</span> <span>{</span>
      <span>name</span><span>:</span> args<span>[</span><span>1</span><span>]</span><span>,</span>
      <span>value</span><span>:</span> <span>decodeAttr</span><span>(</span>value<span>,</span> shouldDecodeNewlines<span>)</span>
    <span>}</span>
  <span>}</span>
  
  <span>if</span> <span>(</span><span>!</span>unary<span>)</span> <span>{</span>
    stack<span>.</span><span>push</span><span>(</span><span>{</span> <span>tag</span><span>:</span> tagName<span>,</span> <span>lowerCasedTag</span><span>:</span> tagName<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>,</span> <span>attrs</span><span>:</span> attrs <span>}</span><span>)</span>
    lastTag <span>=</span> tagName
  <span>}</span>
  
  <span>if</span> <span>(</span>options<span>.</span>start<span>)</span> <span>{</span>
    options<span>.</span><span>start</span><span>(</span>tagName<span>,</span> attrs<span>,</span> unary<span>,</span> match<span>.</span>start<span>,</span> match<span>.</span>end<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>handleStartTag</code> 的核心逻辑很简单，先判断开始标签是否是一元标签，类似 <code>&lt;img&gt;、&lt;br/&gt;</code> 这样，接着对 <code>match.attrs</code> 遍历并做了一些处理，最后判断如果非一元标签，则往 <code>stack</code> 里 push 一个对象，并且把 <code>tagName</code> 赋值给 <code>lastTag</code>。至于 <code>stack</code> 的作用，稍后我会介绍。</p>
<p>最后调用了 <code>options.start</code> 回调函数，并传入一些参数，这个回调函数的作用稍后我会详细介绍。</p>
<ul>
<li>闭合标签</li>
</ul>
<div><pre><code><span>const</span> endTagMatch <span>=</span> html<span>.</span><span>match</span><span>(</span>endTag<span>)</span>
<span>if</span> <span>(</span>endTagMatch<span>)</span> <span>{</span>
  <span>const</span> curIndex <span>=</span> index
  <span>advance</span><span>(</span>endTagMatch<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span>
  <span>parseEndTag</span><span>(</span>endTagMatch<span>[</span><span>1</span><span>]</span><span>,</span> curIndex<span>,</span> index<span>)</span>
  <span>continue</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>先通过正则 <code>endTag</code> 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 <code>parseEndTag</code> 方法对闭合标签做解析。</p>
<div><pre><code>
<span>function</span> <span>parseEndTag</span> <span>(</span><span>tagName<span>,</span> start<span>,</span> end</span><span>)</span> <span>{</span>
  <span>let</span> pos<span>,</span> lowerCasedTagName
  <span>if</span> <span>(</span>start <span>==</span> <span>null</span><span>)</span> start <span>=</span> index
  <span>if</span> <span>(</span>end <span>==</span> <span>null</span><span>)</span> end <span>=</span> index
  
  <span>if</span> <span>(</span>tagName<span>)</span> <span>{</span>
    lowerCasedTagName <span>=</span> tagName<span>.</span><span>toLowerCase</span><span>(</span><span>)</span>
  <span>}</span>
  
  <span>if</span> <span>(</span>tagName<span>)</span> <span>{</span>
    <span>for</span> <span>(</span>pos <span>=</span> stack<span>.</span>length <span>-</span> <span>1</span><span>;</span> pos <span>>=</span> <span>0</span><span>;</span> pos<span>--</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>stack<span>[</span>pos<span>]</span><span>.</span>lowerCasedTag <span>===</span> lowerCasedTagName<span>)</span> <span>{</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    pos <span>=</span> <span>0</span>
  <span>}</span>
  
  <span>if</span> <span>(</span>pos <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> stack<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>>=</span> pos<span>;</span> i<span>--</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
        <span>(</span>i <span>></span> pos <span>||</span> <span>!</span>tagName<span>)</span> <span>&amp;&amp;</span>
        options<span>.</span>warn
      <span>)</span> <span>{</span>
        options<span>.</span><span>warn</span><span>(</span>
          <span><span>`</span><span>tag &lt;</span><span><span>${</span>stack<span>[</span>i<span>]</span><span>.</span>tag<span>}</span></span><span>> has no matching end tag.</span><span>`</span></span>
        <span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>options<span>.</span>end<span>)</span> <span>{</span>
        options<span>.</span><span>end</span><span>(</span>stack<span>[</span>i<span>]</span><span>.</span>tag<span>,</span> start<span>,</span> end<span>)</span>
      <span>}</span>
    <span>}</span>
    stack<span>.</span>length <span>=</span> pos
    lastTag <span>=</span> pos <span>&amp;&amp;</span> stack<span>[</span>pos <span>-</span> <span>1</span><span>]</span><span>.</span>tag
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>lowerCasedTagName <span>===</span> <span>'br'</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>options<span>.</span>start<span>)</span> <span>{</span>
      options<span>.</span><span>start</span><span>(</span>tagName<span>,</span> <span>[</span><span>]</span><span>,</span> <span>true</span><span>,</span> start<span>,</span> end<span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>lowerCasedTagName <span>===</span> <span>'p'</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>options<span>.</span>start<span>)</span> <span>{</span>
      options<span>.</span><span>start</span><span>(</span>tagName<span>,</span> <span>[</span><span>]</span><span>,</span> <span>false</span><span>,</span> start<span>,</span> end<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>options<span>.</span>end<span>)</span> <span>{</span>
      options<span>.</span><span>end</span><span>(</span>tagName<span>,</span> start<span>,</span> end<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>parseEndTag</code> 的核心逻辑很简单，在介绍之前我们回顾一下在执行 <code>handleStartTag</code> 的时候，对于非一元标签（有 endTag）我们都把它构造成一个对象压入到 <code>stack</code> 中，如图所示：</p>
<img :src="$withBase('/assets/stack.png')">
<p>那么对于闭合标签的解析，就是倒序 <code>stack</code>，找到第一个和当前 <code>endTag</code> 匹配的元素。如果是正常的标签匹配，那么 <code>stack</code> 的最后一个元素应该和当前的 <code>endTag</code> 匹配，但是考虑到如下错误情况：</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个时候当 <code>endTag</code> 为 <code>&lt;/div&gt;</code> 的时候，从 <code>stack</code> 尾部找到的标签是 <code>&lt;span&gt;</code>，就不能匹配，因此这种情况会报警告。匹配后把栈到 <code>pos</code> 位置的都弹出，并从 <code>stack</code> 尾部拿到 <code>lastTag</code>。</p>
<p>最后调用了 <code>options.end</code> 回调函数，并传入一些参数，这个回调函数的作用稍后我会详细介绍。</p>
<ul>
<li>文本</li>
</ul>
<div><pre><code><span>let</span> text<span>,</span> rest<span>,</span> next
<span>if</span> <span>(</span>textEnd <span>>=</span> <span>0</span><span>)</span> <span>{</span>
  rest <span>=</span> html<span>.</span><span>slice</span><span>(</span>textEnd<span>)</span>
  <span>while</span> <span>(</span>
    <span>!</span>endTag<span>.</span><span>test</span><span>(</span>rest<span>)</span> <span>&amp;&amp;</span>
    <span>!</span>startTagOpen<span>.</span><span>test</span><span>(</span>rest<span>)</span> <span>&amp;&amp;</span>
    <span>!</span>comment<span>.</span><span>test</span><span>(</span>rest<span>)</span> <span>&amp;&amp;</span>
    <span>!</span>conditionalComment<span>.</span><span>test</span><span>(</span>rest<span>)</span>
  <span>)</span> <span>{</span>
    next <span>=</span> rest<span>.</span><span>indexOf</span><span>(</span><span>'&lt;'</span><span>,</span> <span>1</span><span>)</span>
    <span>if</span> <span>(</span>next <span>&lt;</span> <span>0</span><span>)</span> <span>break</span>
    textEnd <span>+=</span> next
    rest <span>=</span> html<span>.</span><span>slice</span><span>(</span>textEnd<span>)</span>
  <span>}</span>
  text <span>=</span> html<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> textEnd<span>)</span>
  <span>advance</span><span>(</span>textEnd<span>)</span>
<span>}</span>

<span>if</span> <span>(</span>textEnd <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
  text <span>=</span> html
  html <span>=</span> <span>''</span>
<span>}</span>

<span>if</span> <span>(</span>options<span>.</span>chars <span>&amp;&amp;</span> text<span>)</span> <span>{</span>
  options<span>.</span><span>chars</span><span>(</span>text<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>接下来判断 <code>textEnd</code> 是否大于等于 0 的，满足则说明到从当前位置到 <code>textEnd</code> 位置都是文本，并且如果 <code>&lt;</code> 是纯文本中的字符，就继续找到真正的文本结束的位置，然后前进到结束的位置。</p>
<p>再继续判断 <code>textEnd</code> 小于 0 的情况，则说明整个 <code>template</code> 解析完毕了，把剩余的 <code>html</code> 都赋值给了 <code>text</code>。</p>
<p>最后调用了 <code>options.chars</code> 回调函数，并传 <code>text</code> 参数，这个回调函数的作用稍后我会详细介绍。</p>
<p>因此，在循环解析整个 <code>template</code> 的过程中，会根据不同的情况，去执行不同的回调函数，下面我们来看看这些回调函数的作用。</p>
<h3 id="处理开始标签" tabindex="-1"> 处理开始标签</h3>
<p>对应伪代码：</p>
<div><pre><code><span>start</span> <span>(</span><span>tag<span>,</span> attrs<span>,</span> unary</span><span>)</span> <span>{</span>
  <span>let</span> element <span>=</span> <span>createASTElement</span><span>(</span>tag<span>,</span> attrs<span>)</span>
  <span>processElement</span><span>(</span>element<span>)</span>
  <span>treeManagement</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>当解析到开始标签的时候，最后会执行 <code>start</code> 回调函数，函数主要就做 3 件事情，创建 AST 元素，处理 AST 元素，AST 树管理。下面我们来分别来看这几个过程。</p>
<ul>
<li>创建 AST 元素</li>
</ul>
<div><pre><code><span>// check namespace.</span>
<span>// inherit parent ns if there is one</span>
<span>const</span> ns <span>=</span> <span>(</span>currentParent <span>&amp;&amp;</span> currentParent<span>.</span>ns<span>)</span> <span>||</span> <span>platformGetTagNamespace</span><span>(</span>tag<span>)</span>

<span>// handle IE svg bug</span>
<span>/* istanbul ignore if */</span>
<span>if</span> <span>(</span>isIE <span>&amp;&amp;</span> ns <span>===</span> <span>'svg'</span><span>)</span> <span>{</span>
  attrs <span>=</span> <span>guardIESVGBug</span><span>(</span>attrs<span>)</span>
<span>}</span>

<span>let</span> <span>element</span><span>:</span> ASTElement <span>=</span> <span>createASTElement</span><span>(</span>tag<span>,</span> attrs<span>,</span> currentParent<span>)</span>
<span>if</span> <span>(</span>ns<span>)</span> <span>{</span>
  element<span>.</span>ns <span>=</span> ns
<span>}</span>

<span>export</span> <span>function</span> <span>createASTElement</span> <span>(</span>
  <span><span>tag</span><span>:</span> string<span>,</span>
  <span>attrs</span><span>:</span> Array<span>&lt;</span>Attr<span>></span><span>,</span>
  <span>parent</span><span>:</span> ASTElement <span>|</span> <span>void</span></span>
<span>)</span><span>:</span> ASTElement <span>{</span>
  <span>return</span> <span>{</span>
    <span>type</span><span>:</span> <span>1</span><span>,</span>
    tag<span>,</span>
    <span>attrsList</span><span>:</span> attrs<span>,</span>
    <span>attrsMap</span><span>:</span> <span>makeAttrsMap</span><span>(</span>attrs<span>)</span><span>,</span>
    parent<span>,</span>
    <span>children</span><span>:</span> <span>[</span><span>]</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通过 <code>createASTElement</code> 方法去创建一个 AST 元素，并添加了 namespace。可以看到，每一个 AST 元素就是一个普通的 JavaScript 对象，其中，<code>type</code> 表示 AST 元素类型，<code>tag</code> 表示标签名，<code>attrsList</code> 表示属性列表，<code>attrsMap</code> 表示属性映射表，<code>parent</code> 表示父的 AST 元素，<code>children</code> 表示子 AST 元素集合。</p>
<ul>
<li>处理 AST 元素</li>
</ul>
<div><pre><code><span>if</span> <span>(</span><span>isForbiddenTag</span><span>(</span>element<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isServerRendering</span><span>(</span><span>)</span><span>)</span> <span>{</span>
  element<span>.</span>forbidden <span>=</span> <span>true</span>
  process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
    <span>'Templates should only be responsible for mapping the state to the '</span> <span>+</span>
    <span>'UI. Avoid placing tags with side-effects in your templates, such as '</span> <span>+</span>
    <span><span>`</span><span>&lt;</span><span><span>${</span>tag<span>}</span></span><span>></span><span>`</span></span> <span>+</span> <span>', as they will not be parsed.'</span>
  <span>)</span>
<span>}</span>

<span>// apply pre-transforms</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> preTransforms<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  element <span>=</span> preTransforms<span>[</span>i<span>]</span><span>(</span>element<span>,</span> options<span>)</span> <span>||</span> element
<span>}</span>

<span>if</span> <span>(</span><span>!</span>inVPre<span>)</span> <span>{</span>
  <span>processPre</span><span>(</span>element<span>)</span>
  <span>if</span> <span>(</span>element<span>.</span>pre<span>)</span> <span>{</span>
    inVPre <span>=</span> <span>true</span>
  <span>}</span>
<span>}</span>
<span>if</span> <span>(</span><span>platformIsPreTag</span><span>(</span>element<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
  inPre <span>=</span> <span>true</span>
<span>}</span>
<span>if</span> <span>(</span>inVPre<span>)</span> <span>{</span>
  <span>processRawAttrs</span><span>(</span>element<span>)</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>element<span>.</span>processed<span>)</span> <span>{</span>
  <span>// structural directives</span>
  <span>processFor</span><span>(</span>element<span>)</span>
  <span>processIf</span><span>(</span>element<span>)</span>
  <span>processOnce</span><span>(</span>element<span>)</span>
  <span>// element-scope stuff</span>
  <span>processElement</span><span>(</span>element<span>,</span> options<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先是对模块 <code>preTransforms</code> 的调用，其实所有模块的 <code>preTransforms</code>、 <code>transforms</code> 和 <code>postTransforms</code> 的定义都在 <code>src/platforms/web/compiler/modules</code> 目录中，这部分我们暂时不会介绍，之后会结合具体的例子说。接着判断 <code>element</code> 是否包含各种指令通过 <code>processXXX</code> 做相应的处理，处理的结果就是扩展 AST 元素的属性。这里我并不会一一介绍所有的指令处理，而是结合我们当前的例子，我们来看一下 <code>processFor</code> 和 <code>processIf</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>processFor</span> <span>(</span><span><span>el</span><span>:</span> ASTElement</span><span>)</span> <span>{</span>
  <span>let</span> exp
  <span>if</span> <span>(</span><span>(</span>exp <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'v-for'</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>const</span> res <span>=</span> <span>parseFor</span><span>(</span>exp<span>)</span>
    <span>if</span> <span>(</span>res<span>)</span> <span>{</span>
      <span>extend</span><span>(</span>el<span>,</span> res<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>Invalid v-for expression: </span><span><span>${</span>exp<span>}</span></span><span>`</span></span>
      <span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>const</span> forAliasRE <span>=</span> <span><span>/</span><span>(.*?)\s+(?:in|of)\s+(.*)</span><span>/</span></span>
<span>export</span> <span>const</span> forIteratorRE <span>=</span> <span><span>/</span><span>,([^,\}\]]*)(?:,([^,\}\]]*))?$</span><span>/</span></span>
<span>const</span> stripParensRE <span>=</span> <span><span>/</span><span>^\(|\)$</span><span>/</span><span>g</span></span>
<span>export</span> <span>function</span> <span>parseFor</span> <span>(</span><span><span>exp</span><span>:</span> string</span><span>)</span><span>:</span> <span>?</span>ForParseResult <span>{</span>
  <span>const</span> inMatch <span>=</span> exp<span>.</span><span>match</span><span>(</span>forAliasRE<span>)</span>
  <span>if</span> <span>(</span><span>!</span>inMatch<span>)</span> <span>return</span>
  <span>const</span> res <span>=</span> <span>{</span><span>}</span>
  res<span>.</span>for <span>=</span> inMatch<span>[</span><span>2</span><span>]</span><span>.</span><span>trim</span><span>(</span><span>)</span>
  <span>const</span> alias <span>=</span> inMatch<span>[</span><span>1</span><span>]</span><span>.</span><span>trim</span><span>(</span><span>)</span><span>.</span><span>replace</span><span>(</span>stripParensRE<span>,</span> <span>''</span><span>)</span>
  <span>const</span> iteratorMatch <span>=</span> alias<span>.</span><span>match</span><span>(</span>forIteratorRE<span>)</span>
  <span>if</span> <span>(</span>iteratorMatch<span>)</span> <span>{</span>
    res<span>.</span>alias <span>=</span> alias<span>.</span><span>replace</span><span>(</span>forIteratorRE<span>,</span> <span>''</span><span>)</span>
    res<span>.</span>iterator1 <span>=</span> iteratorMatch<span>[</span><span>1</span><span>]</span><span>.</span><span>trim</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span>iteratorMatch<span>[</span><span>2</span><span>]</span><span>)</span> <span>{</span>
      res<span>.</span>iterator2 <span>=</span> iteratorMatch<span>[</span><span>2</span><span>]</span><span>.</span><span>trim</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    res<span>.</span>alias <span>=</span> alias
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>processFor</code> 就是从元素中拿到 <code>v-for</code> 指令的内容，然后分别解析出 <code>for</code>、<code>alias</code>、<code>iterator1</code>、<code>iterator2</code> 等属性的值添加到 AST 的元素上。就我们的示例 <code>v-for=&quot;(item,index) in data&quot;</code> 而言，解析出的的 <code>for</code> 是 <code>data</code>，<code>alias</code> 是 <code>item</code>，<code>iterator1</code> 是 <code>index</code>，没有 <code>iterator2</code>。</p>
<div><pre><code><span>function</span> <span>processIf</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
  <span>const</span> exp <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'v-if'</span><span>)</span>
  <span>if</span> <span>(</span>exp<span>)</span> <span>{</span>
    el<span>.</span>if <span>=</span> exp
    <span>addIfCondition</span><span>(</span>el<span>,</span> <span>{</span>
      <span>exp</span><span>:</span> exp<span>,</span>
      <span>block</span><span>:</span> el
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>if</span> <span>(</span><span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'v-else'</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      el<span>.</span>else <span>=</span> <span>true</span>
    <span>}</span>
    <span>const</span> elseif <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'v-else-if'</span><span>)</span>
    <span>if</span> <span>(</span>elseif<span>)</span> <span>{</span>
      el<span>.</span>elseif <span>=</span> elseif
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>export</span> <span>function</span> <span>addIfCondition</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>condition</span><span>:</span> ASTIfCondition</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>el<span>.</span>ifConditions<span>)</span> <span>{</span>
    el<span>.</span>ifConditions <span>=</span> <span>[</span><span>]</span>
  <span>}</span>
  el<span>.</span>ifConditions<span>.</span><span>push</span><span>(</span>condition<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>processIf</code> 就是从元素中拿 <code>v-if</code> 指令的内容，如果拿到则给 AST 元素添加 <code>if</code> 属性和 <code>ifConditions</code> 属性；否则尝试拿 <code>v-else</code> 指令及 <code>v-else-if</code> 指令的内容，如果拿到则给 AST 元素分别添加 <code>else</code> 和 <code>elseif</code> 属性。</p>
<ul>
<li>AST 树管理</li>
</ul>
<p>我们在处理开始标签的时候为每一个标签创建了一个 AST 元素，在不断解析模板创建 AST 元素的时候，我们也要为它们建立父子关系，就像 DOM 元素的父子关系那样。</p>
<p>AST 树管理相关代码如下：</p>
<div><pre><code><span>function</span> <span>checkRootConstraints</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'slot'</span> <span>||</span> el<span>.</span>tag <span>===</span> <span>'template'</span><span>)</span> <span>{</span>
      <span>warnOnce</span><span>(</span>
        <span><span>`</span><span>Cannot use &lt;</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>> as component root element because it may </span><span>`</span></span> <span>+</span>
        <span>'contain multiple nodes.'</span>
      <span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>el<span>.</span>attrsMap<span>.</span><span>hasOwnProperty</span><span>(</span><span>'v-for'</span><span>)</span><span>)</span> <span>{</span>
      <span>warnOnce</span><span>(</span>
        <span>'Cannot use v-for on stateful component root element because '</span> <span>+</span>
        <span>'it renders multiple elements.'</span>
      <span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>


<span>// tree management</span>
<span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>{</span>
  root <span>=</span> element
  <span>checkRootConstraints</span><span>(</span>root<span>)</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>stack<span>.</span>length<span>)</span> <span>{</span>
  <span>// allow root elements with v-if, v-else-if and v-else</span>
  <span>if</span> <span>(</span>root<span>.</span>if <span>&amp;&amp;</span> <span>(</span>element<span>.</span>elseif <span>||</span> element<span>.</span>else<span>)</span><span>)</span> <span>{</span>
    <span>checkRootConstraints</span><span>(</span>element<span>)</span>
    <span>addIfCondition</span><span>(</span>root<span>,</span> <span>{</span>
      <span>exp</span><span>:</span> element<span>.</span>elseif<span>,</span>
      <span>block</span><span>:</span> element
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>warnOnce</span><span>(</span>
      <span><span>`</span><span>Component template should contain exactly one root element. </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>If you are using v-if on multiple elements, </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>use v-else-if to chain them instead.</span><span>`</span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
<span>if</span> <span>(</span>currentParent <span>&amp;&amp;</span> <span>!</span>element<span>.</span>forbidden<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>element<span>.</span>elseif <span>||</span> element<span>.</span>else<span>)</span> <span>{</span>
    <span>processIfConditions</span><span>(</span>element<span>,</span> currentParent<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>element<span>.</span>slotScope<span>)</span> <span>{</span> <span>// scoped slot</span>
    currentParent<span>.</span>plain <span>=</span> <span>false</span>
    <span>const</span> name <span>=</span> element<span>.</span>slotTarget <span>||</span> <span>'"default"'</span>
    <span>;</span><span>(</span>currentParent<span>.</span>scopedSlots <span>||</span> <span>(</span>currentParent<span>.</span>scopedSlots <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>[</span>name<span>]</span> <span>=</span> element
  <span>}</span> <span>else</span> <span>{</span>
    currentParent<span>.</span>children<span>.</span><span>push</span><span>(</span>element<span>)</span>
    element<span>.</span>parent <span>=</span> currentParent
  <span>}</span>
<span>}</span>
<span>if</span> <span>(</span><span>!</span>unary<span>)</span> <span>{</span>
  currentParent <span>=</span> element
  stack<span>.</span><span>push</span><span>(</span>element<span>)</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>closeElement</span><span>(</span>element<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>AST 树管理的目标是构建一颗 AST 树，本质上它要维护 <code>root</code> 根节点和当前父节点 <code>currentParent</code>。为了保证元素可以正确闭合，这里也利用了 <code>stack</code> 栈的数据结构，和我们之前解析模板时用到的 <code>stack</code> 类似。</p>
<p>当我们在处理开始标签的时候，判断如果有 <code>currentParent</code>，会把当前 AST 元素 push 到 <code>currentParent.chilldren</code> 中，同时把 AST 元素的 <code>parent</code> 指向 <code>currentParent</code>。</p>
<p>接着就是更新 <code>currentParent</code> 和 <code>stack</code> ，判断当前如果不是一个一元标签，我们要把它生成的 AST 元素 push 到 <code>stack</code> 中，并且把当前的 AST 元素赋值给 <code>currentParent</code>。</p>
<p><code>stack</code> 和 <code>currentParent</code> 除了在处理开始标签的时候会变化，在处理闭合标签的时候也会变化，因此整个 AST 树管理要结合闭合标签的处理逻辑看。</p>
<h3 id="处理闭合标签" tabindex="-1"> 处理闭合标签</h3>
<p>对应伪代码：</p>
<div><pre><code><span>end</span> <span>(</span><span>)</span> <span>{</span>
  <span>treeManagement</span><span>(</span><span>)</span>
  <span>closeElement</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>当解析到闭合标签的时候，最后会执行 <code>end</code> 回调函数：</p>
<div><pre><code><span>// remove trailing whitespace</span>
<span>const</span> element <span>=</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span>
<span>const</span> lastNode <span>=</span> element<span>.</span>children<span>[</span>element<span>.</span>children<span>.</span>length <span>-</span> <span>1</span><span>]</span>
<span>if</span> <span>(</span>lastNode <span>&amp;&amp;</span> lastNode<span>.</span>type <span>===</span> <span>3</span> <span>&amp;&amp;</span> lastNode<span>.</span>text <span>===</span> <span>' '</span> <span>&amp;&amp;</span> <span>!</span>inPre<span>)</span> <span>{</span>
  element<span>.</span>children<span>.</span><span>pop</span><span>(</span><span>)</span>
<span>}</span>
<span>// pop stack</span>
stack<span>.</span>length <span>-=</span> <span>1</span>
currentParent <span>=</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span>
<span>closeElement</span><span>(</span>element<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先处理了尾部空格的情况，然后把 <code>stack</code> 的元素弹一个出栈，并把 <code>stack</code> 最后一个元素赋值给 <code>currentParent</code>，这样就保证了当遇到闭合标签的时候，可以正确地更新 <code>stack</code> 的长度以及 <code>currentParent</code> 的值，这样就维护了整个 AST 树。</p>
<p>最后执行了 <code>closeElement(element)</code>：</p>
<div><pre><code><span>function</span> <span>closeElement</span> <span>(</span><span>element</span><span>)</span> <span>{</span>
  <span>// check pre state</span>
  <span>if</span> <span>(</span>element<span>.</span>pre<span>)</span> <span>{</span>
    inVPre <span>=</span> <span>false</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>platformIsPreTag</span><span>(</span>element<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
    inPre <span>=</span> <span>false</span>
  <span>}</span>
  <span>// apply post-transforms</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> postTransforms<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    postTransforms<span>[</span>i<span>]</span><span>(</span>element<span>,</span> options<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>closeElement</code> 逻辑很简单，就是更新一下 <code>inVPre</code> 和 <code>inPre</code> 的状态，以及执行 <code>postTransforms</code> 函数，这些我们暂时都不必了解。</p>
<h3 id="处理文本内容" tabindex="-1"> 处理文本内容</h3>
<p>对应伪代码：</p>
<div><pre><code><span>chars</span> <span>(</span><span><span>text</span><span>:</span> string</span><span>)</span> <span>{</span>
  <span>handleText</span><span>(</span><span>)</span>
  <span>createChildrenASTOfText</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>除了处理开始标签和闭合标签，我们还会在解析模板的过程中去处理一些文本内容：</p>
<div><pre><code><span>const</span> children <span>=</span> currentParent<span>.</span>children
text <span>=</span> inPre <span>||</span> text<span>.</span><span>trim</span><span>(</span><span>)</span>
  <span>?</span> <span>isTextTag</span><span>(</span>currentParent<span>)</span> <span>?</span> text <span>:</span> <span>decodeHTMLCached</span><span>(</span>text<span>)</span>
  <span>// only preserve whitespace if its not right after a starting tag</span>
  <span>:</span> preserveWhitespace <span>&amp;&amp;</span> children<span>.</span>length <span>?</span> <span>' '</span> <span>:</span> <span>''</span>
<span>if</span> <span>(</span>text<span>)</span> <span>{</span>
  <span>let</span> res
  <span>if</span> <span>(</span><span>!</span>inVPre <span>&amp;&amp;</span> text <span>!==</span> <span>' '</span> <span>&amp;&amp;</span> <span>(</span>res <span>=</span> <span>parseText</span><span>(</span>text<span>,</span> delimiters<span>)</span><span>)</span><span>)</span> <span>{</span>
    children<span>.</span><span>push</span><span>(</span><span>{</span>
      <span>type</span><span>:</span> <span>2</span><span>,</span>
      <span>expression</span><span>:</span> res<span>.</span>expression<span>,</span>
      <span>tokens</span><span>:</span> res<span>.</span>tokens<span>,</span>
      text
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>text <span>!==</span> <span>' '</span> <span>||</span> <span>!</span>children<span>.</span>length <span>||</span> children<span>[</span>children<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span>text <span>!==</span> <span>' '</span><span>)</span> <span>{</span>
    children<span>.</span><span>push</span><span>(</span><span>{</span>
      <span>type</span><span>:</span> <span>3</span><span>,</span>
      text
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>文本构造的 AST 元素有 2 种类型，一种是有表达式的，<code>type</code> 为 2，一种是纯文本，<code>type</code> 为 3。在我们的例子中，文本就是 <code>{{item}}:{{index}}</code>，是个表达式，通过执行 <code>parseText(text, delimiters)</code> 对文本解析，它的定义在 <code>src/compiler/parser/text-parser.js</code> 中：</p>
<div><pre><code><span>const</span> defaultTagRE <span>=</span> <span><span>/</span><span>\{\{((?:.|\n)+?)\}\}</span><span>/</span><span>g</span></span>
<span>const</span> regexEscapeRE <span>=</span> <span><span>/</span><span>[-.*+?^${}()|[\]\/\\]</span><span>/</span><span>g</span></span>

<span>const</span> buildRegex <span>=</span> <span>cached</span><span>(</span><span>delimiters</span> <span>=></span> <span>{</span>
  <span>const</span> open <span>=</span> delimiters<span>[</span><span>0</span><span>]</span><span>.</span><span>replace</span><span>(</span>regexEscapeRE<span>,</span> <span>'\\$&amp;'</span><span>)</span>
  <span>const</span> close <span>=</span> delimiters<span>[</span><span>1</span><span>]</span><span>.</span><span>replace</span><span>(</span>regexEscapeRE<span>,</span> <span>'\\$&amp;'</span><span>)</span>
  <span>return</span> <span>new</span> <span>RegExp</span><span>(</span>open <span>+</span> <span>'((?:.|\\n)+?)'</span> <span>+</span> close<span>,</span> <span>'g'</span><span>)</span>
<span>}</span><span>)</span>

<span>export</span> <span>function</span> <span>parseText</span> <span>(</span>
  <span><span>text</span><span>:</span> string<span>,</span>
  delimiters<span>?</span><span>:</span> <span>[</span>string<span>,</span> string<span>]</span></span>
<span>)</span><span>:</span> TextParseResult <span>|</span> <span>void</span> <span>{</span>
  <span>const</span> tagRE <span>=</span> delimiters <span>?</span> <span>buildRegex</span><span>(</span>delimiters<span>)</span> <span>:</span> defaultTagRE
  <span>if</span> <span>(</span><span>!</span>tagRE<span>.</span><span>test</span><span>(</span>text<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> tokens <span>=</span> <span>[</span><span>]</span>
  <span>const</span> rawTokens <span>=</span> <span>[</span><span>]</span>
  <span>let</span> lastIndex <span>=</span> tagRE<span>.</span>lastIndex <span>=</span> <span>0</span>
  <span>let</span> match<span>,</span> index<span>,</span> tokenValue
  <span>while</span> <span>(</span><span>(</span>match <span>=</span> tagRE<span>.</span><span>exec</span><span>(</span>text<span>)</span><span>)</span><span>)</span> <span>{</span>
    index <span>=</span> match<span>.</span>index
    <span>// push text token</span>
    <span>if</span> <span>(</span>index <span>></span> lastIndex<span>)</span> <span>{</span>
      rawTokens<span>.</span><span>push</span><span>(</span>tokenValue <span>=</span> text<span>.</span><span>slice</span><span>(</span>lastIndex<span>,</span> index<span>)</span><span>)</span>
      tokens<span>.</span><span>push</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>tokenValue<span>)</span><span>)</span>
    <span>}</span>
    <span>// tag token</span>
    <span>const</span> exp <span>=</span> <span>parseFilters</span><span>(</span>match<span>[</span><span>1</span><span>]</span><span>.</span><span>trim</span><span>(</span><span>)</span><span>)</span>
    tokens<span>.</span><span>push</span><span>(</span><span><span>`</span><span>_s(</span><span><span>${</span>exp<span>}</span></span><span>)</span><span>`</span></span><span>)</span>
    rawTokens<span>.</span><span>push</span><span>(</span><span>{</span> <span>'@binding'</span><span>:</span> exp <span>}</span><span>)</span>
    lastIndex <span>=</span> index <span>+</span> match<span>[</span><span>0</span><span>]</span><span>.</span>length
  <span>}</span>
  <span>if</span> <span>(</span>lastIndex <span>&lt;</span> text<span>.</span>length<span>)</span> <span>{</span>
    rawTokens<span>.</span><span>push</span><span>(</span>tokenValue <span>=</span> text<span>.</span><span>slice</span><span>(</span>lastIndex<span>)</span><span>)</span>
    tokens<span>.</span><span>push</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>tokenValue<span>)</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>{</span>
    <span>expression</span><span>:</span> tokens<span>.</span><span>join</span><span>(</span><span>'+'</span><span>)</span><span>,</span>
    <span>tokens</span><span>:</span> rawTokens
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>parseText</code> 首先根据分隔符（默认是 <code>{{}}</code>）构造了文本匹配的正则表达式，然后再循环匹配文本，遇到普通文本就 push 到 <code>rawTokens</code> 和 <code>tokens</code> 中，如果是表达式就转换成 <code>_s(${exp})</code> push 到 <code>tokens</code> 中，以及转换成 <code>{@binding:exp}</code> push 到 <code>rawTokens</code> 中。</p>
<p>对于我们的例子 <code>{{item}}:{{index}}</code>，<code>tokens</code> 就是 <code>[_s(item),'&quot;:&quot;',_s(index)]</code>；<code>rawTokens</code> 就是 <code>[{'@binding':'item'},':',{'@binding':'index'}]</code>。那么返回的对象如下：</p>
<div><pre><code><span>return</span> <span>{</span>
 <span>expression</span><span>:</span> <span>'_s(item)+":"+_s(index)'</span><span>,</span>
 <span>tokens</span><span>:</span> <span>[</span><span>{</span><span>'@binding'</span><span>:</span><span>'item'</span><span>}</span><span>,</span><span>':'</span><span>,</span><span>{</span><span>'@binding'</span><span>:</span><span>'index'</span><span>}</span><span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="流程图" tabindex="-1"> 流程图</h2>
<img :src="$withBase('/assets/parse.png')">
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，<code>parse</code> 的过程就分析完了，看似复杂，但我们可以抛开细节理清它的整体流程。<code>parse</code> 的目标是把 <code>template</code> 模板字符串转换成 AST 树，它是一种用 JavaScript 对象的形式来描述整个模板。那么整个 <code>parse</code> 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。</p>
<p>AST 元素节点总共有 3 种类型，<code>type</code> 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本。其实这里我觉得源码写的不够友好，这种是典型的魔术数字，如果转换成用常量表达会更利于源码阅读。</p>
<p>当 AST 树构造完毕，下一步就是 <code>optimize</code> 优化这颗树。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">异步组件</title>
    <id>https://0808200.xyz/vue2/components/async-component.html</id>
    <link href="https://0808200.xyz/vue2/components/async-component.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="异步组件" tabindex="-1"> 异步组件</h1>
<p>在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下：</p>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>'async-example'</span><span>,</span> <span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
   <span>// 这个特殊的 require 语法告诉 webpack</span>
   <span>// 自动将编译后的代码分割成不同的块，</span>
   <span>// 这些块将通过 Ajax 请求自动下载。</span>
   <span>require</span><span>(</span><span>[</span><span>'./my-async-component'</span><span>]</span><span>,</span> resolve<span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>示例中可以看到，Vue 注册的组件不再是一个对象，而是一个工厂函数，函数有两个参数 <code>resolve</code> 和 <code>reject</code>，函数内部用 <code>setTimout</code> 模拟了异步，实际使用可能是通过动态请求异步组件的 JS 地址，最终通过执行 <code>resolve</code> 方法，它的参数就是我们的异步组件对象。</p>
<p>在了解了异步组件如何注册后，我们从源码的角度来分析一下它的实现。</p>
<p>上一节我们分析了组件的注册逻辑，由于组件的定义并不是一个普通对象，所以不会执行 <code>Vue.extend</code> 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 <code>createComponent</code> 函数，我们再来对这个函数做回顾，它的定义在 <code>src/core/vdom/create-component/js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponent</span> <span>(</span>
  <span><span>Ctor</span><span>:</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object <span>|</span> <span>void</span><span>,</span>
  <span>data</span><span>:</span> <span>?</span>VNodeData<span>,</span>
  <span>context</span><span>:</span> Component<span>,</span>
  <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  tag<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>|</span> <span>void</span> <span>{</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>Ctor<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> baseCtor <span>=</span> context<span>.</span>$options<span>.</span>_base

  <span>// plain options object: turn it into a constructor</span>
  <span>if</span> <span>(</span><span>isObject</span><span>(</span>Ctor<span>)</span><span>)</span> <span>{</span>
    Ctor <span>=</span> baseCtor<span>.</span><span>extend</span><span>(</span>Ctor<span>)</span>
  <span>}</span>
  
  <span>// ...</span>

  <span>// async component</span>
  <span>let</span> asyncFactory
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>Ctor<span>.</span>cid<span>)</span><span>)</span> <span>{</span>
    asyncFactory <span>=</span> Ctor
    Ctor <span>=</span> <span>resolveAsyncComponent</span><span>(</span>asyncFactory<span>,</span> baseCtor<span>,</span> context<span>)</span>
    <span>if</span> <span>(</span>Ctor <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
      <span>// return a placeholder node for async component, which is rendered</span>
      <span>// as a comment node but preserves all the raw information for the node.</span>
      <span>// the information will be used for async server-rendering and hydration.</span>
      <span>return</span> <span>createAsyncPlaceholder</span><span>(</span>
        asyncFactory<span>,</span>
        data<span>,</span>
        context<span>,</span>
        children<span>,</span>
        tag
      <span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们省略了不必要的逻辑，只保留关键逻辑，由于我们这个时候传入的 <code>Ctor</code> 是一个函数，那么它也并不会执行 <code>Vue.extend</code> 逻辑，因此它的 <code>cid</code> 是 <code>undefiend</code>，进入了异步组件创建的逻辑。这里首先执行了 <code>Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</code> 方法，它的定义在 <code>src/core/vdom/helpers/resolve-async-component.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>resolveAsyncComponent</span> <span>(</span>
  <span><span>factory</span><span>:</span> Function<span>,</span>
  <span>baseCtor</span><span>:</span> Class<span>&lt;</span>Component<span>></span><span>,</span>
  <span>context</span><span>:</span> Component</span>
<span>)</span><span>:</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> <span>void</span> <span>{</span>
  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>factory<span>.</span>error<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>factory<span>.</span>errorComp<span>)</span><span>)</span> <span>{</span>
    <span>return</span> factory<span>.</span>errorComp
  <span>}</span>

  <span>if</span> <span>(</span><span>isDef</span><span>(</span>factory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
    <span>return</span> factory<span>.</span>resolved
  <span>}</span>

  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>factory<span>.</span>loading<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>factory<span>.</span>loadingComp<span>)</span><span>)</span> <span>{</span>
    <span>return</span> factory<span>.</span>loadingComp
  <span>}</span>

  <span>if</span> <span>(</span><span>isDef</span><span>(</span>factory<span>.</span>contexts<span>)</span><span>)</span> <span>{</span>
    <span>// already pending</span>
    factory<span>.</span>contexts<span>.</span><span>push</span><span>(</span>context<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>const</span> contexts <span>=</span> factory<span>.</span>contexts <span>=</span> <span>[</span>context<span>]</span>
    <span>let</span> sync <span>=</span> <span>true</span>

    <span>const</span> <span>forceRender</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> contexts<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        contexts<span>[</span>i<span>]</span><span>.</span><span>$forceUpdate</span><span>(</span><span>)</span>
      <span>}</span>
    <span>}</span>

    <span>const</span> resolve <span>=</span> <span>once</span><span>(</span><span>(</span><span><span>res</span><span>:</span> Object <span>|</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>=></span> <span>{</span>
      <span>// cache resolved</span>
      factory<span>.</span>resolved <span>=</span> <span>ensureCtor</span><span>(</span>res<span>,</span> baseCtor<span>)</span>
      <span>// invoke callbacks only if this is not a synchronous resolve</span>
      <span>// (async resolves are shimmed as synchronous during SSR)</span>
      <span>if</span> <span>(</span><span>!</span>sync<span>)</span> <span>{</span>
        <span>forceRender</span><span>(</span><span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>

    <span>const</span> reject <span>=</span> <span>once</span><span>(</span><span>reason</span> <span>=></span> <span>{</span>
      process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
        <span><span>`</span><span>Failed to resolve async component: </span><span><span>${</span><span>String</span><span>(</span>factory<span>)</span><span>}</span></span><span>`</span></span> <span>+</span>
        <span>(</span>reason <span>?</span> <span><span>`</span><span>\nReason: </span><span><span>${</span>reason<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>)</span>
      <span>)</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>factory<span>.</span>errorComp<span>)</span><span>)</span> <span>{</span>
        factory<span>.</span>error <span>=</span> <span>true</span>
        <span>forceRender</span><span>(</span><span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>

    <span>const</span> res <span>=</span> <span>factory</span><span>(</span>resolve<span>,</span> reject<span>)</span>

    <span>if</span> <span>(</span><span>isObject</span><span>(</span>res<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> res<span>.</span>then <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
        <span>// () => Promise</span>
        <span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
          res<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>component<span>)</span> <span>&amp;&amp;</span> <span>typeof</span> res<span>.</span>component<span>.</span>then <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
        res<span>.</span>component<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span>

        <span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>error<span>)</span><span>)</span> <span>{</span>
          factory<span>.</span>errorComp <span>=</span> <span>ensureCtor</span><span>(</span>res<span>.</span>error<span>,</span> baseCtor<span>)</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>loading<span>)</span><span>)</span> <span>{</span>
          factory<span>.</span>loadingComp <span>=</span> <span>ensureCtor</span><span>(</span>res<span>.</span>loading<span>,</span> baseCtor<span>)</span>
          <span>if</span> <span>(</span>res<span>.</span>delay <span>===</span> <span>0</span><span>)</span> <span>{</span>
            factory<span>.</span>loading <span>=</span> <span>true</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
              <span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span> <span>&amp;&amp;</span> <span>isUndef</span><span>(</span>factory<span>.</span>error<span>)</span><span>)</span> <span>{</span>
                factory<span>.</span>loading <span>=</span> <span>true</span>
                <span>forceRender</span><span>(</span><span>)</span>
              <span>}</span>
            <span>}</span><span>,</span> res<span>.</span>delay <span>||</span> <span>200</span><span>)</span>
          <span>}</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>timeout<span>)</span><span>)</span> <span>{</span>
          <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
              <span>reject</span><span>(</span>
                process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span>
                  <span>?</span> <span><span>`</span><span>timeout (</span><span><span>${</span>res<span>.</span>timeout<span>}</span></span><span>ms)</span><span>`</span></span>
                  <span>:</span> <span>null</span>
              <span>)</span>
            <span>}</span>
          <span>}</span><span>,</span> res<span>.</span>timeout<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    sync <span>=</span> <span>false</span>
    <span>// return in case resolved synchronously</span>
    <span>return</span> factory<span>.</span>loading
      <span>?</span> factory<span>.</span>loadingComp
      <span>:</span> factory<span>.</span>resolved
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>resolveAsyncComponent</code> 函数的逻辑略复杂，因为它实际上处理了 3 种异步组件的创建方式，除了刚才示例的组件注册方式，还支持 2 种，一种是支持 <code>Promise</code> 创建组件的方式，如下：</p>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span>
  <span>'async-webpack-example'</span><span>,</span>
  <span>// 该 `import` 函数返回一个 `Promise` 对象。</span>
  <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'./my-async-component'</span><span>)</span>
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>另一种是高级异步组件，如下：</p>
<div><pre><code><span>const</span> <span>AsyncComp</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span>
  <span>// 需要加载的组件。应当是一个 Promise</span>
  <span>component</span><span>:</span> <span>import</span><span>(</span><span>'./MyComp.vue'</span><span>)</span><span>,</span>
  <span>// 加载中应当渲染的组件</span>
  <span>loading</span><span>:</span> LoadingComp<span>,</span>
  <span>// 出错时渲染的组件</span>
  <span>error</span><span>:</span> ErrorComp<span>,</span>
  <span>// 渲染加载中组件前的等待时间。默认：200ms。</span>
  <span>delay</span><span>:</span> <span>200</span><span>,</span>
  <span>// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span>
  <span>timeout</span><span>:</span> <span>3000</span>
<span>}</span><span>)</span>
Vue<span>.</span><span>component</span><span>(</span><span>'async-example'</span><span>,</span> AsyncComp<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么解下来，我们就根据这 3 种异步组件的情况，来分别去分析 <code>resolveAsyncComponent</code> 的逻辑。</p>
<h2 id="普通函数异步组件" tabindex="-1"> 普通函数异步组件</h2>
<p>针对普通函数的情况，前面几个 if 判断可以忽略，它们是为高级组件所用，对于 <code>factory.contexts</code> 的判断，是考虑到多个地方同时初始化一个异步组件，那么它的实际加载应该只有一次。接着进入实际加载逻辑，定义了 <code>forceRender</code>、<code>resolve</code> 和 <code>reject</code> 函数，注意 <code>resolve</code> 和 <code>reject</code> 函数用 <code>once</code> 函数做了一层包装，它的定义在 <code>src/shared/util.js</code> 中：</p>
<div><pre><code><span>/**
 * Ensure a function is called only once.
 */</span>
<span>export</span> <span>function</span> <span>once</span> <span>(</span><span><span>fn</span><span>:</span> Function</span><span>)</span><span>:</span> Function <span>{</span>
  <span>let</span> called <span>=</span> <span>false</span>
  <span>return</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>called<span>)</span> <span>{</span>
      called <span>=</span> <span>true</span>
      <span>fn</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>once</code> 逻辑非常简单，传入一个函数，并返回一个新函数，它非常巧妙地利用闭包和一个标志位保证了它包装的函数只会执行一次，也就是确保 <code>resolve</code> 和 <code>reject</code> 函数只执行一次。</p>
<p>接下来执行 <code>const res = factory(resolve, reject)</code> 逻辑，这块儿就是执行我们组件的工厂函数，同时把 <code>resolve</code> 和 <code>reject</code> 函数作为参数传入，组件的工厂函数通常会先发送请求去加载我们的异步组件的 JS 文件，拿到组件定义的对象 <code>res</code> 后，执行 <code>resolve(res)</code> 逻辑，它会先执行 <code>factory.resolved = ensureCtor(res, baseCtor)</code>：</p>
<div><pre><code><span>function</span> <span>ensureCtor</span> <span>(</span><span><span>comp</span><span>:</span> any<span>,</span> base</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>
    comp<span>.</span>__esModule <span>||</span>
    <span>(</span>hasSymbol <span>&amp;&amp;</span> comp<span>[</span>Symbol<span>.</span>toStringTag<span>]</span> <span>===</span> <span>'Module'</span><span>)</span>
  <span>)</span> <span>{</span>
    comp <span>=</span> comp<span>.</span>default
  <span>}</span>
  <span>return</span> <span>isObject</span><span>(</span>comp<span>)</span>
    <span>?</span> base<span>.</span><span>extend</span><span>(</span>comp<span>)</span>
    <span>:</span> comp
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个函数目的是为了保证能找到异步组件 JS 定义的组件对象，并且如果它是一个普通对象，则调用 <code>Vue.extend</code> 把它转换成一个组件的构造函数。</p>
<p><code>resolve</code> 逻辑最后判断了 <code>sync</code>，显然我们这个场景下 <code>sync</code> 为 false，那么就会执行 <code>forceRender</code> 函数，它会遍历 <code>factory.contexts</code>，拿到每一个调用异步组件的实例 <code>vm</code>, 执行 <code>vm.$forceUpdate()</code> 方法，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>$forceUpdate</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>if</span> <span>(</span>vm<span>.</span>_watcher<span>)</span> <span>{</span>
    vm<span>.</span>_watcher<span>.</span><span>update</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>$forceUpdate</code> 的逻辑非常简单，就是调用渲染 <code>watcher</code> 的 <code>update</code> 方法，让渲染 <code>watcher</code> 对应的回调函数执行，也就是触发了组件的重新渲染。之所以这么做是因为 Vue 通常是数据驱动视图重新渲染，但是在整个异步组件加载过程中是没有数据发生变化的，所以通过执行 <code>$forceUpdate</code> 可以强制组件重新渲染一次。</p>
<h2 id="promise-异步组件" tabindex="-1"> <code>Promise</code> 异步组件</h2>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span>
  <span>'async-webpack-example'</span><span>,</span>
  <span>// 该 `import` 函数返回一个 `Promise` 对象。</span>
  <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'./my-async-component'</span><span>)</span>
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>webpack 2+ 支持了异步加载的语法糖：<code>() =&gt; import('./my-async-component')</code>，当执行完 <code>res = factory(resolve, reject)</code>，返回的值就是 <code> import('./my-async-component')</code> 的返回值，它是一个 <code>Promise</code> 对象。接着进入 if 条件，又判断了 <code>typeof res.then === 'function')</code>，条件满足，执行：</p>
<div><pre><code><span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
  res<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>当组件异步加载成功后，执行 <code>resolve</code>，加载失败则执行 <code>reject</code>，这样就非常巧妙地实现了配合 webpack 2+ 的异步加载组件的方式（<code>Promise</code>）加载异步组件。</p>
<h2 id="高级异步组件" tabindex="-1"> 高级异步组件</h2>
<p>由于异步加载组件需要动态加载 JS，有一定网络延时，而且有加载失败的情况，所以通常我们在开发异步组件相关逻辑的时候需要设计 loading 组件和 error 组件，并在适当的时机渲染它们。Vue.js 2.3+ 支持了一种高级异步组件的方式，它通过一个简单的对象配置，帮你搞定 loading 组件和 error 组件的渲染时机，你完全不用关心细节，非常方便。接下来我们就从源码的角度来分析高级异步组件是怎么实现的。</p>
<div><pre><code><span>const</span> <span>AsyncComp</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span>
  <span>// 需要加载的组件。应当是一个 Promise</span>
  <span>component</span><span>:</span> <span>import</span><span>(</span><span>'./MyComp.vue'</span><span>)</span><span>,</span>
  <span>// 加载中应当渲染的组件</span>
  <span>loading</span><span>:</span> LoadingComp<span>,</span>
  <span>// 出错时渲染的组件</span>
  <span>error</span><span>:</span> ErrorComp<span>,</span>
  <span>// 渲染加载中组件前的等待时间。默认：200ms。</span>
  <span>delay</span><span>:</span> <span>200</span><span>,</span>
  <span>// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span>
  <span>timeout</span><span>:</span> <span>3000</span>
<span>}</span><span>)</span>
Vue<span>.</span><span>component</span><span>(</span><span>'async-example'</span><span>,</span> AsyncComp<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>高级异步组件的初始化逻辑和普通异步组件一样，也是执行 <code>resolveAsyncComponent</code>，当执行完 <code>res = factory(resolve, reject)</code>，返回值就是定义的组件对象，显然满足 <code>else if (isDef(res.component) &amp;&amp; typeof res.component.then === 'function')</code> 的逻辑，接着执行 <code>res.component.then(resolve, reject)</code>，当异步组件加载成功后，执行 <code>resolve</code>，失败执行 <code>reject</code>。</p>
<p>因为异步组件加载是一个异步过程，它接着又同步执行了如下逻辑：</p>
<div><pre><code><span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>error<span>)</span><span>)</span> <span>{</span>
  factory<span>.</span>errorComp <span>=</span> <span>ensureCtor</span><span>(</span>res<span>.</span>error<span>,</span> baseCtor<span>)</span>
<span>}</span>

<span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>loading<span>)</span><span>)</span> <span>{</span>
  factory<span>.</span>loadingComp <span>=</span> <span>ensureCtor</span><span>(</span>res<span>.</span>loading<span>,</span> baseCtor<span>)</span>
  <span>if</span> <span>(</span>res<span>.</span>delay <span>===</span> <span>0</span><span>)</span> <span>{</span>
    factory<span>.</span>loading <span>=</span> <span>true</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span> <span>&amp;&amp;</span> <span>isUndef</span><span>(</span>factory<span>.</span>error<span>)</span><span>)</span> <span>{</span>
        factory<span>.</span>loading <span>=</span> <span>true</span>
        <span>forceRender</span><span>(</span><span>)</span>
      <span>}</span>
    <span>}</span><span>,</span> res<span>.</span>delay <span>||</span> <span>200</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>if</span> <span>(</span><span>isDef</span><span>(</span>res<span>.</span>timeout<span>)</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
      <span>reject</span><span>(</span>
        process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span>
          <span>?</span> <span><span>`</span><span>timeout (</span><span><span>${</span>res<span>.</span>timeout<span>}</span></span><span>ms)</span><span>`</span></span>
          <span>:</span> <span>null</span>
      <span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> res<span>.</span>timeout<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>先判断 <code>res.error</code> 是否定义了 error 组件，如果有的话则赋值给 <code>factory.errorComp</code>。
接着判断 <code>res.loading</code> 是否定义了 loading 组件，如果有的话则赋值给 <code>factory.loadingComp</code>，如果设置了 <code>res.delay</code> 且为 0，则设置 <code>factory.loading = true</code>，否则延时 <code>delay</code> 的时间执行：</p>
<div><pre><code><span>if</span> <span>(</span><span>isUndef</span><span>(</span>factory<span>.</span>resolved<span>)</span> <span>&amp;&amp;</span> <span>isUndef</span><span>(</span>factory<span>.</span>error<span>)</span><span>)</span> <span>{</span>
    factory<span>.</span>loading <span>=</span> <span>true</span>
    <span>forceRender</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>最后判断 <code>res.timeout</code>，如果配置了该项，则在 <code>res.timout</code> 时间后，如果组件没有成功加载，执行 <code>reject</code>。</p>
<p>在 <code>resolveAsyncComponent</code> 的最后有一段逻辑：</p>
<div><pre><code>sync <span>=</span> <span>false</span>
<span>return</span> factory<span>.</span>loading
  <span>?</span> factory<span>.</span>loadingComp
  <span>:</span> factory<span>.</span>resolved
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>如果 <code>delay</code> 配置为 0，则这次直接渲染 loading 组件，否则则延时 <code>delay</code> 执行 <code>forceRender</code>，那么又会再一次执行到 <code>resolveAsyncComponent</code>。</p>
<p>那么这时候我们有几种情况，按逻辑的执行顺序，对不同的情况做判断。</p>
<h3 id="异步组件加载失败" tabindex="-1"> 异步组件加载失败</h3>
<p>当异步组件加载失败，会执行 <code>reject</code> 函数：</p>
<div><pre><code><span>const</span> reject <span>=</span> <span>once</span><span>(</span><span>reason</span> <span>=></span> <span>{</span>
  process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
    <span><span>`</span><span>Failed to resolve async component: </span><span><span>${</span><span>String</span><span>(</span>factory<span>)</span><span>}</span></span><span>`</span></span> <span>+</span>
    <span>(</span>reason <span>?</span> <span><span>`</span><span>\nReason: </span><span><span>${</span>reason<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>)</span>
  <span>)</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>factory<span>.</span>errorComp<span>)</span><span>)</span> <span>{</span>
    factory<span>.</span>error <span>=</span> <span>true</span>
    <span>forceRender</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个时候会把 <code>factory.error</code> 设置为 <code>true</code>，同时执行 <code>forceRender()</code> 再次执行到 <code>resolveAsyncComponent</code>：</p>
<div><pre><code><span>if</span> <span>(</span><span>isTrue</span><span>(</span>factory<span>.</span>error<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>factory<span>.</span>errorComp<span>)</span><span>)</span> <span>{</span>
  <span>return</span> factory<span>.</span>errorComp
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>那么这个时候就返回 <code>factory.errorComp</code>，直接渲染 error 组件。</p>
<h3 id="异步组件加载成功" tabindex="-1"> 异步组件加载成功</h3>
<p>当异步组件加载成功，会执行 <code>resolve</code> 函数：</p>
<div><pre><code><span>const</span> resolve <span>=</span> <span>once</span><span>(</span><span>(</span><span><span>res</span><span>:</span> Object <span>|</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>=></span> <span>{</span>
  factory<span>.</span>resolved <span>=</span> <span>ensureCtor</span><span>(</span>res<span>,</span> baseCtor<span>)</span>
  <span>if</span> <span>(</span><span>!</span>sync<span>)</span> <span>{</span>
    <span>forceRender</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先把加载结果缓存到 <code>factory.resolved</code> 中，这个时候因为 <code>sync</code> 已经为 false，则执行 <code>forceRender()</code> 再次执行到 <code>resolveAsyncComponent</code>：</p>
<div><pre><code><span>if</span> <span>(</span><span>isDef</span><span>(</span>factory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
  <span>return</span> factory<span>.</span>resolved
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>那么这个时候直接返回 <code>factory.resolved</code>，渲染成功加载的组件。</p>
<h3 id="异步组件加载中" tabindex="-1"> 异步组件加载中</h3>
<p>如果异步组件加载中并未返回，这时候会走到这个逻辑：</p>
<div><pre><code><span>if</span> <span>(</span><span>isTrue</span><span>(</span>factory<span>.</span>loading<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>factory<span>.</span>loadingComp<span>)</span><span>)</span> <span>{</span>
  <span>return</span> factory<span>.</span>loadingComp
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>那么则会返回 <code>factory.loadingComp</code>，渲染 loading 组件。</p>
<h3 id="异步组件加载超时" tabindex="-1"> 异步组件加载超时</h3>
<p>如果超时，则走到了 <code>reject</code> 逻辑，之后逻辑和加载失败一样，渲染 error 组件。</p>
<h2 id="异步组件-patch" tabindex="-1"> 异步组件 patch</h2>
<p>回到 <code>createComponent</code> 的逻辑：</p>
<div><pre><code>Ctor <span>=</span> <span>resolveAsyncComponent</span><span>(</span>asyncFactory<span>,</span> baseCtor<span>,</span> context<span>)</span>
<span>if</span> <span>(</span>Ctor <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
  <span>return</span> <span>createAsyncPlaceholder</span><span>(</span>
    asyncFactory<span>,</span>
    data<span>,</span>
    context<span>,</span>
    children<span>,</span>
    tag
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果是第一次执行 <code>resolveAsyncComponent</code>，除非使用高级异步组件 <code>0 delay</code> 去创建了一个 loading 组件，否则返回是 <code>undefiend</code>，接着通过 <code>createAsyncPlaceholder</code> 创建一个注释节点作为占位符。它的定义在 <code>src/core/vdom/helpers/resolve-async-components.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createAsyncPlaceholder</span> <span>(</span>
  <span><span>factory</span><span>:</span> Function<span>,</span>
  <span>data</span><span>:</span> <span>?</span>VNodeData<span>,</span>
  <span>context</span><span>:</span> Component<span>,</span>
  <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  <span>tag</span><span>:</span> <span>?</span>string</span>
<span>)</span><span>:</span> VNode <span>{</span>
  <span>const</span> node <span>=</span> <span>createEmptyVNode</span><span>(</span><span>)</span>
  node<span>.</span>asyncFactory <span>=</span> factory
  node<span>.</span>asyncMeta <span>=</span> <span>{</span> data<span>,</span> context<span>,</span> children<span>,</span> tag <span>}</span>
  <span>return</span> node
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上就是就是创建了一个占位的注释 VNode，同时把 <code>asyncFactory</code> 和 <code>asyncMeta</code> 赋值给当前 <code>vnode</code>。</p>
<p>当执行 <code>forceRender</code> 的时候，会触发组件的重新渲染，那么会再一次执行 <code>resolveAsyncComponent</code>，这时候就会根据不同的情况，可能返回 loading、error 或成功加载的异步组件，返回值不为 <code>undefined</code>，因此就走正常的组件 <code>render</code>、<code>patch</code> 过程，与组件第一次渲染流程不一样，这个时候是存在新旧 <code>vnode</code> 的，下一章我会分析组件更新的 <code>patch</code> 过程。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过以上代码分析，我们对 Vue 的异步组件的实现有了深入的了解，知道了 3 种异步组件的实现方式，并且看到高级异步组件的实现是非常巧妙的，它实现了 loading、resolve、reject、timeout 4 种状态。异步组件实现的本质是 2 次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 <code>forceRender</code> 强制重新渲染，这样就能正确渲染出我们异步加载的组件了。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">组件注册</title>
    <id>https://0808200.xyz/vue2/components/component-register.html</id>
    <link href="https://0808200.xyz/vue2/components/component-register.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="组件注册" tabindex="-1"> 组件注册</h1>
<p>在 Vue.js 中，除了它内置的组件如 <code>keep-alive</code>、<code>component</code>、<code>transition</code>、<code>transition-group</code> 等，其它用户自定义组件在使用前必须注册。很多同学在开发过程中可能会遇到如下报错信息：</p>
<div><pre><code>'Unknown custom element: &lt;xxx> - did you register the component correctly?
 For recursive components, make sure to provide the "name" option.'
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>一般报这个错的原因都是我们使用了未注册的组件。Vue.js 提供了 2 种组件的注册方式，全局注册和局部注册。接下来我们从源码分析的角度来分析这两种注册方式。</p>
<h2 id="全局注册" tabindex="-1"> 全局注册</h2>
<p>要注册一个全局组件，可以使用 <code>Vue.component(tagName, options)</code>。例如：</p>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>'my-component'</span><span>,</span> <span>{</span>
  <span>// 选项</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>那么，<code>Vue.component</code> 函数是在什么时候定义的呢，它的定义过程发生在最开始初始化 Vue 的全局函数的时候，代码在 <code>src/core/global-api/assets.js</code> 中：</p>
<div><pre><code><span>import</span> <span>{</span> <span>ASSET_TYPES</span> <span>}</span> <span>from</span> <span>'shared/constants'</span>
<span>import</span> <span>{</span> isPlainObject<span>,</span> validateComponentName <span>}</span> <span>from</span> <span>'../util/index'</span>

<span>export</span> <span>function</span> <span>initAssetRegisters</span> <span>(</span><span><span>Vue</span><span>:</span> GlobalAPI</span><span>)</span> <span>{</span>
  <span>/**
   * Create asset registration methods.
   */</span>
  <span>ASSET_TYPES</span><span>.</span><span>forEach</span><span>(</span><span>type</span> <span>=></span> <span>{</span>
    Vue<span>[</span>type<span>]</span> <span>=</span> <span>function</span> <span>(</span>
      <span><span>id</span><span>:</span> string<span>,</span>
      <span>definition</span><span>:</span> Function <span>|</span> Object</span>
    <span>)</span><span>:</span> Function <span>|</span> Object <span>|</span> <span>void</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>definition<span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>options<span>[</span>type <span>+</span> <span>'s'</span><span>]</span><span>[</span>id<span>]</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>/* istanbul ignore if */</span>
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> type <span>===</span> <span>'component'</span><span>)</span> <span>{</span>
          <span>validateComponentName</span><span>(</span>id<span>)</span>
        <span>}</span>
        <span>if</span> <span>(</span>type <span>===</span> <span>'component'</span> <span>&amp;&amp;</span> <span>isPlainObject</span><span>(</span>definition<span>)</span><span>)</span> <span>{</span>
          definition<span>.</span>name <span>=</span> definition<span>.</span>name <span>||</span> id
          definition <span>=</span> <span>this</span><span>.</span>options<span>.</span>_base<span>.</span><span>extend</span><span>(</span>definition<span>)</span>
        <span>}</span>
        <span>if</span> <span>(</span>type <span>===</span> <span>'directive'</span> <span>&amp;&amp;</span> <span>typeof</span> definition <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
          definition <span>=</span> <span>{</span> <span>bind</span><span>:</span> definition<span>,</span> <span>update</span><span>:</span> definition <span>}</span>
        <span>}</span>
        <span>this</span><span>.</span>options<span>[</span>type <span>+</span> <span>'s'</span><span>]</span><span>[</span>id<span>]</span> <span>=</span> definition
        <span>return</span> definition
      <span>}</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数首先遍历 <code>ASSET_TYPES</code>，得到 <code>type</code> 后挂载到 Vue 上 。<code>ASSET_TYPES</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> <span>ASSET_TYPES</span> <span>=</span> <span>[</span>
  <span>'component'</span><span>,</span>
  <span>'directive'</span><span>,</span>
  <span>'filter'</span>
<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>所以实际上 Vue 是初始化了 3 个全局函数，并且如果 <code>type</code> 是 <code>component</code> 且 <code>definition</code> 是一个对象的话，通过 <code>this.opitons._base.extend</code>， 相当于 <code>Vue.extend</code> 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 <code>this.options[type + 's'][id] = definition</code> 把它挂载到 <code>Vue.options.components</code> 上。</p>
<p>由于我们每个组件的创建都是通过 <code>Vue.extend</code> 继承而来，我们之前分析过在继承的过程中有这么一段逻辑：</p>
<div><pre><code>Sub<span>.</span>options <span>=</span> <span>mergeOptions</span><span>(</span>
  Super<span>.</span>options<span>,</span>
  extendOptions
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>也就是说它会把 <code>Vue.options</code> 合并到 <code>Sub.options</code>，也就是组件的 <code>options</code> 上， 然后在组件的实例化阶段，会执行 <code>merge options</code> 逻辑，把 <code>Sub.options.components</code> 合并到 <code>vm.$options.components</code> 上。</p>
<p>然后在创建 <code>vnode</code> 的过程中，会执行 <code>_createElement</code> 方法，我们再来回顾一下这部分的逻辑，它的定义在 <code>src/core/vdom/create-element.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>_createElement</span> <span>(</span>
  <span><span>context</span><span>:</span> Component<span>,</span>
  tag<span>?</span><span>:</span> string <span>|</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object<span>,</span>
  data<span>?</span><span>:</span> VNodeData<span>,</span>
  children<span>?</span><span>:</span> any<span>,</span>
  normalizationType<span>?</span><span>:</span> number</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>// ...</span>
  <span>let</span> vnode<span>,</span> ns
  <span>if</span> <span>(</span><span>typeof</span> tag <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
    <span>let</span> Ctor
    ns <span>=</span> <span>(</span>context<span>.</span>$vnode <span>&amp;&amp;</span> context<span>.</span>$vnode<span>.</span>ns<span>)</span> <span>||</span> config<span>.</span><span>getTagNamespace</span><span>(</span>tag<span>)</span>
    <span>if</span> <span>(</span>config<span>.</span><span>isReservedTag</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
      <span>// platform built-in elements</span>
      vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
        config<span>.</span><span>parsePlatformTagName</span><span>(</span>tag<span>)</span><span>,</span> data<span>,</span> children<span>,</span>
        <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
      <span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>Ctor <span>=</span> <span>resolveAsset</span><span>(</span>context<span>.</span>$options<span>,</span> <span>'components'</span><span>,</span> tag<span>)</span><span>)</span><span>)</span> <span>{</span>
      <span>// component</span>
      vnode <span>=</span> <span>createComponent</span><span>(</span>Ctor<span>,</span> data<span>,</span> context<span>,</span> children<span>,</span> tag<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// unknown or unlisted namespaced elements</span>
      <span>// check at runtime because it may get assigned a namespace when its</span>
      <span>// parent normalizes children</span>
      vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
        tag<span>,</span> data<span>,</span> children<span>,</span>
        <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
      <span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// direct component options / constructor</span>
    vnode <span>=</span> <span>createComponent</span><span>(</span>tag<span>,</span> data<span>,</span> context<span>,</span> children<span>)</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里有一个判断逻辑 <code>isDef(Ctor = resolveAsset(context.$options, 'components', tag))</code>，先来看一下 <code>resolveAsset</code> 的定义，在 <code>src/core/utils/options.js</code> 中：</p>
<div><pre><code><span>/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */</span>
<span>export</span> <span>function</span> <span>resolveAsset</span> <span>(</span>
  <span><span>options</span><span>:</span> Object<span>,</span>
  <span>type</span><span>:</span> string<span>,</span>
  <span>id</span><span>:</span> string<span>,</span>
  warnMissing<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> any <span>{</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span><span>typeof</span> id <span>!==</span> <span>'string'</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> assets <span>=</span> options<span>[</span>type<span>]</span>
  <span>// check local registration variations first</span>
  <span>if</span> <span>(</span><span>hasOwn</span><span>(</span>assets<span>,</span> id<span>)</span><span>)</span> <span>return</span> assets<span>[</span>id<span>]</span>
  <span>const</span> camelizedId <span>=</span> <span>camelize</span><span>(</span>id<span>)</span>
  <span>if</span> <span>(</span><span>hasOwn</span><span>(</span>assets<span>,</span> camelizedId<span>)</span><span>)</span> <span>return</span> assets<span>[</span>camelizedId<span>]</span>
  <span>const</span> PascalCaseId <span>=</span> <span>capitalize</span><span>(</span>camelizedId<span>)</span>
  <span>if</span> <span>(</span><span>hasOwn</span><span>(</span>assets<span>,</span> PascalCaseId<span>)</span><span>)</span> <span>return</span> assets<span>[</span>PascalCaseId<span>]</span>
  <span>// fallback to prototype chain</span>
  <span>const</span> res <span>=</span> assets<span>[</span>id<span>]</span> <span>||</span> assets<span>[</span>camelizedId<span>]</span> <span>||</span> assets<span>[</span>PascalCaseId<span>]</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> warnMissing <span>&amp;&amp;</span> <span>!</span>res<span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span>'Failed to resolve '</span> <span>+</span> type<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span> <span>+</span> <span>': '</span> <span>+</span> id<span>,</span>
      options
    <span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段逻辑很简单，先通过 <code>const assets = options[type]</code> 拿到 <code>assets</code>，然后再尝试拿 <code>assets[id]</code>，这里有个顺序，先直接使用 <code>id</code> 拿，如果不存在，则把 <code>id</code> 变成驼峰的形式再拿，如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿，如果仍然拿不到则报错。这样说明了我们在使用 <code>Vue.component(id, definition)</code> 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。</p>
<p>那么回到我们的调用 <code>resolveAsset(context.$options, 'components', tag)</code>，即拿 <code>vm.$options.components[tag]</code>，这样我们就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p>
<h2 id="局部注册" tabindex="-1"> 局部注册</h2>
<p>Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 <code>components</code> 选项做组件的局部注册，例如：</p>
<div><pre><code><span>import</span> HelloWorld <span>from</span> <span>'./components/HelloWorld'</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>components</span><span>:</span> <span>{</span>
    HelloWorld
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实理解了全局注册的过程，局部注册是非常简单的。在组件的 Vue 的实例化阶段有一个合并 <code>option</code> 的逻辑，之前我们也分析过，所以就把 <code>components</code> 合并到 <code>vm.$options.components</code> 上，这样我们就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p>
<p>注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 <code>Vue.options</code> 下，所以在所有组件创建的过程中，都会从全局的 <code>Vue.options.components</code> 扩展到当前组件的 <code>vm.$options.components</code> 下，这就是全局注册的组件能被任意使用的原因。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一小节的分析，我们对组件的注册过程有了认识，并理解了全局注册和局部注册的差异。其实在平时的工作中，当我们使用到组件库的时候，往往更通用基础组件都是全局注册的，而编写的特例场景的业务组件都是局部注册的。了解了它们的原理，对我们在工作中到底使用全局注册组件还是局部注册组件是有这非常好的指导意义的。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">createComponent</title>
    <id>https://0808200.xyz/vue2/components/create-component.html</id>
    <link href="https://0808200.xyz/vue2/components/create-component.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="createcomponent" tabindex="-1"> createComponent</h1>
<p>上一章我们在分析 <code>createElement</code> 的实现的时候，它最终会调用 <code>_createElement</code> 方法，其中有一段逻辑是对参数 <code>tag</code> 的判断，如果是一个普通的 html 标签，像上一章的例子那样是一个普通的 div，则会实例化一个普通 VNode 节点，否则通过 <code>createComponent</code> 方法创建一个组件 VNode。</p>
<div><pre><code><span>if</span> <span>(</span><span>typeof</span> tag <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
  <span>let</span> Ctor
  ns <span>=</span> <span>(</span>context<span>.</span>$vnode <span>&amp;&amp;</span> context<span>.</span>$vnode<span>.</span>ns<span>)</span> <span>||</span> config<span>.</span><span>getTagNamespace</span><span>(</span>tag<span>)</span>
  <span>if</span> <span>(</span>config<span>.</span><span>isReservedTag</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
    <span>// platform built-in elements</span>
    vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
      config<span>.</span><span>parsePlatformTagName</span><span>(</span>tag<span>)</span><span>,</span> data<span>,</span> children<span>,</span>
      <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
    <span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>Ctor <span>=</span> <span>resolveAsset</span><span>(</span>context<span>.</span>$options<span>,</span> <span>'components'</span><span>,</span> tag<span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>// component</span>
    vnode <span>=</span> <span>createComponent</span><span>(</span>Ctor<span>,</span> data<span>,</span> context<span>,</span> children<span>,</span> tag<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// unknown or unlisted namespaced elements</span>
    <span>// check at runtime because it may get assigned a namespace when its</span>
    <span>// parent normalizes children</span>
    vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
      tag<span>,</span> data<span>,</span> children<span>,</span>
      <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
    <span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// direct component options / constructor</span>
  vnode <span>=</span> <span>createComponent</span><span>(</span>tag<span>,</span> data<span>,</span> context<span>,</span> children<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在我们这一章传入的是一个 App 对象，它本质上是一个 <code>Component</code> 类型，那么它会走到上述代码的 else 逻辑，直接通过 <code>createComponent</code> 方法来创建 <code>vnode</code>。所以接下来我们来看一下 <code>createComponent</code> 方法的实现，它定义在 <code>src/core/vdom/create-component.js</code> 文件中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponent</span> <span>(</span>
  <span><span>Ctor</span><span>:</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object <span>|</span> <span>void</span><span>,</span>
  <span>data</span><span>:</span> <span>?</span>VNodeData<span>,</span>
  <span>context</span><span>:</span> Component<span>,</span>
  <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  tag<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>|</span> <span>void</span> <span>{</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>Ctor<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> baseCtor <span>=</span> context<span>.</span>$options<span>.</span>_base

  <span>// plain options object: turn it into a constructor</span>
  <span>if</span> <span>(</span><span>isObject</span><span>(</span>Ctor<span>)</span><span>)</span> <span>{</span>
    Ctor <span>=</span> baseCtor<span>.</span><span>extend</span><span>(</span>Ctor<span>)</span>
  <span>}</span>

  <span>// if at this stage it's not a constructor or an async component factory,</span>
  <span>// reject.</span>
  <span>if</span> <span>(</span><span>typeof</span> Ctor <span>!==</span> <span>'function'</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span><span><span>`</span><span>Invalid Component definition: </span><span><span>${</span><span>String</span><span>(</span>Ctor<span>)</span><span>}</span></span><span>`</span></span><span>,</span> context<span>)</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>

  <span>// async component</span>
  <span>let</span> asyncFactory
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>Ctor<span>.</span>cid<span>)</span><span>)</span> <span>{</span>
    asyncFactory <span>=</span> Ctor
    Ctor <span>=</span> <span>resolveAsyncComponent</span><span>(</span>asyncFactory<span>,</span> baseCtor<span>,</span> context<span>)</span>
    <span>if</span> <span>(</span>Ctor <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
      <span>// return a placeholder node for async component, which is rendered</span>
      <span>// as a comment node but preserves all the raw information for the node.</span>
      <span>// the information will be used for async server-rendering and hydration.</span>
      <span>return</span> <span>createAsyncPlaceholder</span><span>(</span>
        asyncFactory<span>,</span>
        data<span>,</span>
        context<span>,</span>
        children<span>,</span>
        tag
      <span>)</span>
    <span>}</span>
  <span>}</span>

  data <span>=</span> data <span>||</span> <span>{</span><span>}</span>

  <span>// resolve constructor options in case global mixins are applied after</span>
  <span>// component constructor creation</span>
  <span>resolveConstructorOptions</span><span>(</span>Ctor<span>)</span>

  <span>// transform component v-model data into props &amp; events</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>.</span>model<span>)</span><span>)</span> <span>{</span>
    <span>transformModel</span><span>(</span>Ctor<span>.</span>options<span>,</span> data<span>)</span>
  <span>}</span>

  <span>// extract props</span>
  <span>const</span> propsData <span>=</span> <span>extractPropsFromVNodeData</span><span>(</span>data<span>,</span> Ctor<span>,</span> tag<span>)</span>

  <span>// functional component</span>
  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>Ctor<span>.</span>options<span>.</span>functional<span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span>createFunctionalComponent</span><span>(</span>Ctor<span>,</span> propsData<span>,</span> data<span>,</span> context<span>,</span> children<span>)</span>
  <span>}</span>

  <span>// extract listeners, since these needs to be treated as</span>
  <span>// child component listeners instead of DOM listeners</span>
  <span>const</span> listeners <span>=</span> data<span>.</span>on
  <span>// replace with listeners with .native modifier</span>
  <span>// so it gets processed during parent component patch.</span>
  data<span>.</span>on <span>=</span> data<span>.</span>nativeOn

  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>Ctor<span>.</span>options<span>.</span>abstract<span>)</span><span>)</span> <span>{</span>
    <span>// abstract components do not keep anything</span>
    <span>// other than props &amp; listeners &amp; slot</span>

    <span>// work around flow</span>
    <span>const</span> slot <span>=</span> data<span>.</span>slot
    data <span>=</span> <span>{</span><span>}</span>
    <span>if</span> <span>(</span>slot<span>)</span> <span>{</span>
      data<span>.</span>slot <span>=</span> slot
    <span>}</span>
  <span>}</span>

  <span>// install component management hooks onto the placeholder node</span>
  <span>installComponentHooks</span><span>(</span>data<span>)</span>

  <span>// return a placeholder vnode</span>
  <span>const</span> name <span>=</span> Ctor<span>.</span>options<span>.</span>name <span>||</span> tag
  <span>const</span> vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
    <span><span>`</span><span>vue-component-</span><span><span>${</span>Ctor<span>.</span>cid<span>}</span></span><span><span>${</span>name <span>?</span> <span><span>`</span><span>-</span><span><span>${</span>name<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span><span>,</span>
    data<span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context<span>,</span>
    <span>{</span> Ctor<span>,</span> propsData<span>,</span> listeners<span>,</span> tag<span>,</span> children <span>}</span><span>,</span>
    asyncFactory
  <span>)</span>

  <span>// Weex specific: invoke recycle-list optimized @render function for</span>
  <span>// extracting cell-slot template.</span>
  <span>// https://github.com/Hanks10100/weex-native-directive/tree/master/component</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>__WEEX__ <span>&amp;&amp;</span> <span>isRecyclableComponent</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span>renderRecyclableComponentTemplate</span><span>(</span>vnode<span>)</span>
  <span>}</span>

  <span>return</span> vnode
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，<code>createComponent</code> 的逻辑也会有一些复杂，但是分析源码比较推荐的是只分析核心流程，分支流程可以之后针对性的看，所以这里针对组件渲染这个 case 主要就 3 个关键步骤：</p>
<p>构造子类构造函数，安装组件钩子函数和实例化 <code>vnode</code>。</p>
<h2 id="构造子类构造函数" tabindex="-1"> 构造子类构造函数</h2>
<div><pre><code><span>const</span> baseCtor <span>=</span> context<span>.</span>$options<span>.</span>_base

<span>// plain options object: turn it into a constructor</span>
<span>if</span> <span>(</span><span>isObject</span><span>(</span>Ctor<span>)</span><span>)</span> <span>{</span>
  Ctor <span>=</span> baseCtor<span>.</span><span>extend</span><span>(</span>Ctor<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们在编写一个组件的时候，通常都是创建一个普通对象，还是以我们的 App.vue 为例，代码如下：</p>
<div><pre><code><span>import</span> HelloWorld <span>from</span> <span>'./components/HelloWorld'</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> <span>'app'</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    HelloWorld
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里 export 的是一个对象，所以 <code>createComponent</code> 里的代码逻辑会执行到 <code>baseCtor.extend(Ctor)</code>，在这里 <code>baseCtor</code> 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 <code>src/core/global-api/index.js</code> 中的 <code>initGlobalAPI</code> 函数有这么一段逻辑：</p>
<div><pre><code><span>// this is used to identify the "base" constructor to extend all plain-object</span>
<span>// components with in Weex's multi-instance scenarios.</span>
Vue<span>.</span>options<span>.</span>_base <span>=</span> Vue
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>细心的同学会发现，这里定义的是 <code>Vue.options</code>，而我们的 <code>createComponent</code> 取的是 <code>context.$options</code>，实际上在 <code>src/core/instance/init.js</code> 里 Vue 原型上的 <code>_init</code> 函数中有这么一段逻辑：</p>
<div><pre><code>vm<span>.</span>$options <span>=</span> <span>mergeOptions</span><span>(</span>
  <span>resolveConstructorOptions</span><span>(</span>vm<span>.</span>constructor<span>)</span><span>,</span>
  options <span>||</span> <span>{</span><span>}</span><span>,</span>
  vm
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这样就把 Vue 上的一些 <code>option</code> 扩展到了 vm.<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>o</span><span>pt</span><span>i</span><span>o</span><span>n</span><span>s</span><span>上，所以我们也就能通过</span><span>‘</span><span style="margin-right:0.03588em;">v</span><span>m</span><span>.</span></span></span></span>options._base<code> 拿到 Vue 这个构造函数了。</code>mergeOptions<code>的实现我们会在后续章节中具体分析，现在只需要理解它的功能是把 Vue 构造函数的</code>options<code>和用户传入的</code>options<code>做一层合并，到</code>vm.$options ` 上。</p>
<p>在了解了 <code>baseCtor</code> 指向了 Vue 之后，我们来看一下 <code>Vue.extend</code> 函数的定义，在 <code>src/core/global-api/extend.js</code> 中。</p>
<div><pre><code><span>/**
 * Class inheritance
 */</span>
Vue<span>.</span><span>extend</span> <span>=</span> <span>function</span> <span>(</span><span><span>extendOptions</span><span>:</span> Object</span><span>)</span><span>:</span> Function <span>{</span>
  extendOptions <span>=</span> extendOptions <span>||</span> <span>{</span><span>}</span>
  <span>const</span> Super <span>=</span> <span>this</span>
  <span>const</span> SuperId <span>=</span> Super<span>.</span>cid
  <span>const</span> cachedCtors <span>=</span> extendOptions<span>.</span>_Ctor <span>||</span> <span>(</span>extendOptions<span>.</span>_Ctor <span>=</span> <span>{</span><span>}</span><span>)</span>
  <span>if</span> <span>(</span>cachedCtors<span>[</span>SuperId<span>]</span><span>)</span> <span>{</span>
    <span>return</span> cachedCtors<span>[</span>SuperId<span>]</span>
  <span>}</span>

  <span>const</span> name <span>=</span> extendOptions<span>.</span>name <span>||</span> Super<span>.</span>options<span>.</span>name
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> name<span>)</span> <span>{</span>
    <span>validateComponentName</span><span>(</span>name<span>)</span>
  <span>}</span>

  <span>const</span> <span>Sub</span> <span>=</span> <span>function</span> <span>VueComponent</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span>
  <span>}</span>
  <span>Sub</span><span>.</span>prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>Super</span><span>.</span>prototype<span>)</span>
  <span>Sub</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Sub
  Sub<span>.</span>cid <span>=</span> cid<span>++</span>
  Sub<span>.</span>options <span>=</span> <span>mergeOptions</span><span>(</span>
    Super<span>.</span>options<span>,</span>
    extendOptions
  <span>)</span>
  Sub<span>[</span><span>'super'</span><span>]</span> <span>=</span> Super

  <span>// For props and computed properties, we define the proxy getters on</span>
  <span>// the Vue instances at extension time, on the extended prototype. This</span>
  <span>// avoids Object.defineProperty calls for each instance created.</span>
  <span>if</span> <span>(</span>Sub<span>.</span>options<span>.</span>props<span>)</span> <span>{</span>
    <span>initProps</span><span>(</span>Sub<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>Sub<span>.</span>options<span>.</span>computed<span>)</span> <span>{</span>
    <span>initComputed</span><span>(</span>Sub<span>)</span>
  <span>}</span>

  <span>// allow further extension/mixin/plugin usage</span>
  Sub<span>.</span>extend <span>=</span> Super<span>.</span>extend
  Sub<span>.</span>mixin <span>=</span> Super<span>.</span>mixin
  Sub<span>.</span>use <span>=</span> Super<span>.</span>use

  <span>// create asset registers, so extended classes</span>
  <span>// can have their private assets too.</span>
  <span>ASSET_TYPES</span><span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>type</span><span>)</span> <span>{</span>
    Sub<span>[</span>type<span>]</span> <span>=</span> Super<span>[</span>type<span>]</span>
  <span>}</span><span>)</span>
  <span>// enable recursive self-lookup</span>
  <span>if</span> <span>(</span>name<span>)</span> <span>{</span>
    Sub<span>.</span>options<span>.</span>components<span>[</span>name<span>]</span> <span>=</span> Sub
  <span>}</span>

  <span>// keep a reference to the super options at extension time.</span>
  <span>// later at instantiation we can check if Super's options have</span>
  <span>// been updated.</span>
  Sub<span>.</span>superOptions <span>=</span> Super<span>.</span>options
  Sub<span>.</span>extendOptions <span>=</span> extendOptions
  Sub<span>.</span>sealedOptions <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> Sub<span>.</span>options<span>)</span>

  <span>// cache constructor</span>
  cachedCtors<span>[</span>SuperId<span>]</span> <span>=</span> Sub
  <span>return</span> Sub
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Vue.extend</code> 的作用就是构造一个 <code>Vue</code> 的子类，它使用一种非常经典的原型继承的方式把一个纯对象转换一个继承于 <code>Vue</code> 的构造器 <code>Sub</code> 并返回，然后对 <code>Sub</code> 这个对象本身扩展了一些属性，如扩展 <code>options</code>、添加全局 API 等；并且对配置中的 <code>props</code> 和 <code>computed</code> 做了初始化工作；最后对于这个 <code>Sub</code> 构造函数做了缓存，避免多次执行 <code>Vue.extend</code> 的时候对同一个子组件重复构造。</p>
<p>这样当我们去实例化 <code>Sub</code> 的时候，就会执行 <code>this._init</code> 逻辑再次走到了 <code>Vue</code> 实例的初始化逻辑，实例化子组件的逻辑在之后的章节会介绍。</p>
<div><pre><code><span>const</span> <span>Sub</span> <span>=</span> <span>function</span> <span>VueComponent</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="安装组件钩子函数" tabindex="-1"> 安装组件钩子函数</h2>
<div><pre><code><span>// install component management hooks onto the placeholder node</span>
<span>installComponentHooks</span><span>(</span>data<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>我们之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">snabbdom</a>，它的一个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>init</span> <span>(</span>vnode<span>:</span> VNodeWithData<span>,</span> <span>hydrating</span><span>:</span> boolean<span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
    <span>if</span> <span>(</span>
      vnode<span>.</span>componentInstance <span>&amp;&amp;</span>
      <span>!</span>vnode<span>.</span>componentInstance<span>.</span>_isDestroyed <span>&amp;&amp;</span>
      vnode<span>.</span>data<span>.</span>keepAlive
    <span>)</span> <span>{</span>
      <span>// kept-alive components, treat as a patch</span>
      <span>const</span> <span>mountedNode</span><span>:</span> any <span>=</span> vnode <span>// work around flow</span>
      componentVNodeHooks<span>.</span><span>prepatch</span><span>(</span>mountedNode<span>,</span> mountedNode<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> <span>createComponentInstanceForVnode</span><span>(</span>
        vnode<span>,</span>
        activeInstance
      <span>)</span>
      child<span>.</span><span>$mount</span><span>(</span>hydrating <span>?</span> vnode<span>.</span>elm <span>:</span> <span>undefined</span><span>,</span> hydrating<span>)</span>
    <span>}</span>
  <span>}</span><span>,</span>

  <span>prepatch</span> <span>(</span><span><span>oldVnode</span><span>:</span> MountedComponentVNode<span>,</span> <span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> options <span>=</span> vnode<span>.</span>componentOptions
    <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> oldVnode<span>.</span>componentInstance
    <span>updateChildComponent</span><span>(</span>
      child<span>,</span>
      options<span>.</span>propsData<span>,</span> <span>// updated props</span>
      options<span>.</span>listeners<span>,</span> <span>// updated listeners</span>
      vnode<span>,</span> <span>// new parent vnode</span>
      options<span>.</span>children <span>// new children</span>
    <span>)</span>
  <span>}</span><span>,</span>

  <span>insert</span> <span>(</span><span><span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> context<span>,</span> componentInstance <span>}</span> <span>=</span> vnode
    <span>if</span> <span>(</span><span>!</span>componentInstance<span>.</span>_isMounted<span>)</span> <span>{</span>
      componentInstance<span>.</span>_isMounted <span>=</span> <span>true</span>
      <span>callHook</span><span>(</span>componentInstance<span>,</span> <span>'mounted'</span><span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>vnode<span>.</span>data<span>.</span>keepAlive<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>context<span>.</span>_isMounted<span>)</span> <span>{</span>
        <span>// vue-router#1212</span>
        <span>// During updates, a kept-alive component's child components may</span>
        <span>// change, so directly walking the tree here may call activated hooks</span>
        <span>// on incorrect children. Instead we push them into a queue which will</span>
        <span>// be processed after the whole patch process ended.</span>
        <span>queueActivatedComponent</span><span>(</span>componentInstance<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>activateChildComponent</span><span>(</span>componentInstance<span>,</span> <span>true</span> <span>/* direct */</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span>

  <span>destroy</span> <span>(</span><span><span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> componentInstance <span>}</span> <span>=</span> vnode
    <span>if</span> <span>(</span><span>!</span>componentInstance<span>.</span>_isDestroyed<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>vnode<span>.</span>data<span>.</span>keepAlive<span>)</span> <span>{</span>
        componentInstance<span>.</span><span>$destroy</span><span>(</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>deactivateChildComponent</span><span>(</span>componentInstance<span>,</span> <span>true</span> <span>/* direct */</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>const</span> hooksToMerge <span>=</span> Object<span>.</span><span>keys</span><span>(</span>componentVNodeHooks<span>)</span>

<span>function</span> <span>installComponentHooks</span> <span>(</span><span><span>data</span><span>:</span> VNodeData</span><span>)</span> <span>{</span>
  <span>const</span> hooks <span>=</span> data<span>.</span>hook <span>||</span> <span>(</span>data<span>.</span>hook <span>=</span> <span>{</span><span>}</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> hooksToMerge<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> hooksToMerge<span>[</span>i<span>]</span>
    <span>const</span> existing <span>=</span> hooks<span>[</span>key<span>]</span>
    <span>const</span> toMerge <span>=</span> componentVNodeHooks<span>[</span>key<span>]</span>
    <span>if</span> <span>(</span>existing <span>!==</span> toMerge <span>&amp;&amp;</span> <span>!</span><span>(</span>existing <span>&amp;&amp;</span> existing<span>.</span>_merged<span>)</span><span>)</span> <span>{</span>
      hooks<span>[</span>key<span>]</span> <span>=</span> existing <span>?</span> <span>mergeHook</span><span>(</span>toMerge<span>,</span> existing<span>)</span> <span>:</span> toMerge
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>mergeHook</span> <span>(</span><span><span>f1</span><span>:</span> any<span>,</span> <span>f2</span><span>:</span> any</span><span>)</span><span>:</span> Function <span>{</span>
  <span>const</span> <span>merged</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>{</span>
    <span>// flow complains about extra args which is why we use any</span>
    <span>f1</span><span>(</span>a<span>,</span> b<span>)</span>
    <span>f2</span><span>(</span>a<span>,</span> b<span>)</span>
  <span>}</span>
  merged<span>.</span>_merged <span>=</span> <span>true</span>
  <span>return</span> merged
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>整个 <code>installComponentHooks</code> 的过程就是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 VNode 执行 <code>patch</code> 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 <code>patch</code> 过程中会详细介绍。这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存在 <code>data.hook</code> 中，那么通过执行 <code>mergeHook</code> 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。</p>
<h2 id="实例化-vnode" tabindex="-1"> 实例化 VNode</h2>
<div><pre><code><span>const</span> name <span>=</span> Ctor<span>.</span>options<span>.</span>name <span>||</span> tag
<span>const</span> vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
  <span><span>`</span><span>vue-component-</span><span><span>${</span>Ctor<span>.</span>cid<span>}</span></span><span><span>${</span>name <span>?</span> <span><span>`</span><span>-</span><span><span>${</span>name<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span><span>,</span>
  data<span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context<span>,</span>
  <span>{</span> Ctor<span>,</span> propsData<span>,</span> listeners<span>,</span> tag<span>,</span> children <span>}</span><span>,</span>
  asyncFactory
<span>)</span>
<span>return</span> vnode
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最后一步非常简单，通过 <code>new VNode</code> 实例化一个 <code>vnode</code> 并返回。需要注意的是和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>children</code> 的，这点很关键，在之后的 <code>patch</code> 过程中我们会再提。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>这一节我们分析了 <code>createComponent</code> 的实现，了解到它在渲染一个组件的时候的 3 个关键逻辑：构造子类构造函数，安装组件钩子函数和实例化 <code>vnode</code>。<code>createComponent</code> 后返回的是组件 <code>vnode</code>，它也一样走到 <code>vm._update</code> 方法，进而执行了 <code>patch</code> 函数，我们在上一章对 <code>patch</code> 函数做了简单的分析，那么下一节我们会对它做进一步的分析。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">组件化</title>
    <id>https://0808200.xyz/vue2/components/</id>
    <link href="https://0808200.xyz/vue2/components/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="组件化" tabindex="-1"> 组件化</h1>
<p>Vue.js 另一个核心思想是组件化。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。</p>
<p>我们在用 Vue.js 开发实际项目的时候，就是像搭积木一样，编写一堆组件拼装生成页面。在 Vue.js 的官网中，也是花了大篇幅来介绍什么是组件，如何编写组件以及组件拥有的属性和特性。</p>
<p>那么在这一章节，我们将从源码的角度来分析 Vue 的组件内部是如何工作的，只有了解了内部的工作原理，才能让我们使用它的时候更加得心应手。</p>
<p>接下来我们会用 Vue-cli 初始化的代码为例，来分析一下 Vue 组件初始化的一个过程。</p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> App <span>from</span> <span>'./App.vue'</span>

<span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>// 这里的 h 是 createElement 方法</span>
  <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>App<span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段代码相信很多同学都很熟悉，它和我们上一章相同的点也是通过 <code>render</code> 函数去渲染的，不同的这次通过 <code>createElement</code> 传的参数是一个组件而不是一个原生的标签，那么接下来我们就开始分析这一过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">生命周期</title>
    <id>https://0808200.xyz/vue2/components/lifecycle.html</id>
    <link href="https://0808200.xyz/vue2/components/lifecycle.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="生命周期" tabindex="-1"> 生命周期</h1>
<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p>
<img :src="$withBase('/assets/lifecycle.png')"/>
<p>在我们实际项目开发过程中，会非常频繁地和 Vue 组件的生命周期打交道，接下来我们就从源码的角度来看一下这些生命周期的钩子函数是如何被执行的。</p>
<p>源码中最终执行生命周期的函数都是调用 <code>callHook</code> 方法，它的定义在 <code>src/core/instance/lifecycle</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>callHook</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>hook</span><span>:</span> string</span><span>)</span> <span>{</span>
  <span>// #7573 disable dep collection when invoking lifecycle hooks</span>
  <span>pushTarget</span><span>(</span><span>)</span>
  <span>const</span> handlers <span>=</span> vm<span>.</span>$options<span>[</span>hook<span>]</span>
  <span>if</span> <span>(</span>handlers<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> handlers<span>.</span>length<span>;</span> i <span>&lt;</span> j<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>try</span> <span>{</span>
        handlers<span>[</span>i<span>]</span><span>.</span><span>call</span><span>(</span>vm<span>)</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
        <span>handleError</span><span>(</span>e<span>,</span> vm<span>,</span> <span><span>`</span><span><span>${</span>hook<span>}</span></span><span> hook</span><span>`</span></span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>if</span> <span>(</span>vm<span>.</span>_hasHookEvent<span>)</span> <span>{</span>
    vm<span>.</span><span>$emit</span><span>(</span><span>'hook:'</span> <span>+</span> hook<span>)</span>
  <span>}</span>
  <span>popTarget</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>callHook</code> 函数的逻辑很简单，根据传入的字符串 <code>hook</code>，去拿到 <code>vm.$options[hook]</code> 对应的回调函数数组，然后遍历执行，执行的时候把 <code>vm</code> 作为函数执行的上下文。</p>
<p>在上一节中，我们详细地介绍了 Vue.js 合并 <code>options</code> 的过程，各个阶段的生命周期的函数也被合并到 <code>vm.$options</code> 里，并且是一个数组。因此 <code>callhook</code> 函数的功能就是调用某个生命周期钩子注册的所有回调函数。</p>
<p>了解了生命周期的执行方式后，接下来我们会具体介绍每一个生命周期函数它的调用时机。</p>
<h2 id="beforecreate-created" tabindex="-1"> beforeCreate &amp; created</h2>
<p><code>beforeCreate</code> 和 <code>created</code> 函数都是在实例化 <code>Vue</code> 的阶段，在 <code>_init</code> 方法中执行的，它的定义在 <code>src/core/instance/init.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_init</span> <span>=</span> <span>function</span> <span>(</span><span>options<span>?</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>initLifecycle</span><span>(</span>vm<span>)</span>
  <span>initEvents</span><span>(</span>vm<span>)</span>
  <span>initRender</span><span>(</span>vm<span>)</span>
  <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeCreate'</span><span>)</span>
  <span>initInjections</span><span>(</span>vm<span>)</span> <span>// resolve injections before data/props</span>
  <span>initState</span><span>(</span>vm<span>)</span>
  <span>initProvide</span><span>(</span>vm<span>)</span> <span>// resolve provide after data/props</span>
  <span>callHook</span><span>(</span>vm<span>,</span> <span>'created'</span><span>)</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 <code>beforeCreate</code> 和 <code>created</code> 的钩子调用是在 <code>initState</code> 的前后，<code>initState</code> 的作用是初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等属性，之后我们会详细分析。那么显然 <code>beforeCreate</code> 的钩子函数中就不能获取到 <code>props</code>、<code>data</code> 中定义的值，也不能调用 <code>methods</code> 中定义的函数。</p>
<p>在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 <code>props</code>、<code>data</code> 等数据的话，就需要使用 <code>created</code> 钩子函数。之后我们会介绍 vue-router 和 vuex 的时候会发现它们都混合了 <code>beforeCreate</code> 钩子函数。</p>
<h2 id="beforemount-mounted" tabindex="-1"> beforeMount &amp; mounted</h2>
<p>顾名思义，<code>beforeMount</code> 钩子函数发生在 <code>mount</code>，也就是 DOM 挂载之前，它的调用时机是在 <code>mountComponent</code> 函数中，定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mountComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>el</span><span>:</span> <span>?</span>Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  vm<span>.</span>$el <span>=</span> el
  <span>// ...</span>
  <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeMount'</span><span>)</span>

  <span>let</span> updateComponent
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
    <span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> name <span>=</span> vm<span>.</span>_name
      <span>const</span> id <span>=</span> vm<span>.</span>_uid
      <span>const</span> startTag <span>=</span> <span><span>`</span><span>vue-perf-start:</span><span><span>${</span>id<span>}</span></span><span>`</span></span>
      <span>const</span> endTag <span>=</span> <span><span>`</span><span>vue-perf-end:</span><span><span>${</span>id<span>}</span></span><span>`</span></span>

      <span>mark</span><span>(</span>startTag<span>)</span>
      <span>const</span> vnode <span>=</span> vm<span>.</span><span>_render</span><span>(</span><span>)</span>
      <span>mark</span><span>(</span>endTag<span>)</span>
      <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span>name<span>}</span></span><span> render</span><span>`</span></span><span>,</span> startTag<span>,</span> endTag<span>)</span>

      <span>mark</span><span>(</span>startTag<span>)</span>
      vm<span>.</span><span>_update</span><span>(</span>vnode<span>,</span> hydrating<span>)</span>
      <span>mark</span><span>(</span>endTag<span>)</span>
      <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span>name<span>}</span></span><span> patch</span><span>`</span></span><span>,</span> startTag<span>,</span> endTag<span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// we set this to vm._watcher inside the watcher's constructor</span>
  <span>// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>
  <span>// component's mounted hook), which relies on vm._watcher being already defined</span>
  <span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> updateComponent<span>,</span> noop<span>,</span> <span>{</span>
    <span>before</span> <span>(</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>vm<span>.</span>_isMounted<span>)</span> <span>{</span>
        <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeUpdate'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>true</span> <span>/* isRenderWatcher */</span><span>)</span>
  hydrating <span>=</span> <span>false</span>

  <span>// manually mounted instance, call mounted on self</span>
  <span>// mounted is called for render-created child components in its inserted hook</span>
  <span>if</span> <span>(</span>vm<span>.</span>$vnode <span>==</span> <span>null</span><span>)</span> <span>{</span>
    vm<span>.</span>_isMounted <span>=</span> <span>true</span>
    <span>callHook</span><span>(</span>vm<span>,</span> <span>'mounted'</span><span>)</span>
  <span>}</span>
  <span>return</span> vm
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在执行 <code>vm._render()</code> 函数渲染 VNode 之前，执行了 <code>beforeMount</code> 钩子函数，在执行完 <code>vm._update()</code> 把 VNode patch 到真实 DOM 后，执行 <code>mounted</code> 钩子。注意，这里对 <code>mounted</code> 钩子函数执行有一个判断逻辑，<code>vm.$vnode</code> 如果为 <code>null</code>，则表明这不是一次组件的初始化过程，而是我们通过外部 <code>new Vue</code> 初始化过程。那么对于组件，它的 <code>mounted</code> 时机在哪儿呢？</p>
<p>之前我们提到过，组件的 VNode patch 到 DOM 后，会执行 <code>invokeInsertHook</code> 函数，把 <code>insertedVnodeQueue</code> 里保存的钩子函数依次执行一遍，它的定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<div><pre><code><span>function</span> <span>invokeInsertHook</span> <span>(</span><span>vnode<span>,</span> queue<span>,</span> initial</span><span>)</span> <span>{</span>
  <span>// delay insert hooks for component root nodes, invoke them after the</span>
  <span>// element is really inserted</span>
  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>initial<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>vnode<span>.</span>parent<span>)</span><span>)</span> <span>{</span>
    vnode<span>.</span>parent<span>.</span>data<span>.</span>pendingInsert <span>=</span> queue
  <span>}</span> <span>else</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> queue<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
      queue<span>[</span>i<span>]</span><span>.</span>data<span>.</span>hook<span>.</span><span>insert</span><span>(</span>queue<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该函数会执行 <code>insert</code> 这个钩子函数，对于组件而言，<code>insert</code> 钩子函数的定义在 <code>src/core/vdom/create-component.js</code> 中的 <code>componentVNodeHooks</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>// ...</span>
  <span>insert</span> <span>(</span><span><span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> context<span>,</span> componentInstance <span>}</span> <span>=</span> vnode
    <span>if</span> <span>(</span><span>!</span>componentInstance<span>.</span>_isMounted<span>)</span> <span>{</span>
      componentInstance<span>.</span>_isMounted <span>=</span> <span>true</span>
      <span>callHook</span><span>(</span>componentInstance<span>,</span> <span>'mounted'</span><span>)</span>
    <span>}</span>
    <span>// ...</span>
  <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以看到，每个子组件都是在这个钩子函数中执行 <code>mounted</code> 钩子函数，并且我们之前分析过，<code>insertedVnodeQueue</code> 的添加顺序是先子后父，所以对于同步渲染的子组件而言，<code>mounted</code> 钩子函数的执行顺序也是先子后父。</p>
<h2 id="beforeupdate-updated" tabindex="-1"> beforeUpdate &amp; updated</h2>
<p>顾名思义，<code>beforeUpdate</code> 和 <code>updated</code> 的钩子函数执行时机都应该是在数据更新的时候，到目前为止，我们还没有分析 Vue 的数据双向绑定、更新相关，下一章我会详细介绍这个过程。</p>
<p><code>beforeUpdate</code> 的执行时机是在渲染 Watcher 的 <code>before</code> 函数中，我们刚才提到过：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mountComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>el</span><span>:</span> <span>?</span>Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  <span>// ...</span>

  <span>// we set this to vm._watcher inside the watcher's constructor</span>
  <span>// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>
  <span>// component's mounted hook), which relies on vm._watcher being already defined</span>
  <span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> updateComponent<span>,</span> noop<span>,</span> <span>{</span>
    <span>before</span> <span>(</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>vm<span>.</span>_isMounted<span>)</span> <span>{</span>
        <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeUpdate'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>true</span> <span>/* isRenderWatcher */</span><span>)</span>
  <span>// ...</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意这里有个判断，也就是在组件已经 <code>mounted</code> 之后，才会去调用这个钩子函数。</p>
<p><code>update</code> 的执行时机是在<code>flushSchedulerQueue</code> 函数调用的时候，它的定义在 <code>src/core/observer/scheduler.js</code> 中：</p>
<div><pre><code><span>function</span> <span>flushSchedulerQueue</span> <span>(</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>// 获取到 updatedQueue</span>
  <span>callUpdatedHooks</span><span>(</span>updatedQueue<span>)</span>
<span>}</span>

<span>function</span> <span>callUpdatedHooks</span> <span>(</span><span>queue</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> queue<span>.</span>length
  <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
    <span>const</span> watcher <span>=</span> queue<span>[</span>i<span>]</span>
    <span>const</span> vm <span>=</span> watcher<span>.</span>vm
    <span>if</span> <span>(</span>vm<span>.</span>_watcher <span>===</span> watcher <span>&amp;&amp;</span> vm<span>.</span>_isMounted<span>)</span> <span>{</span>
      <span>callHook</span><span>(</span>vm<span>,</span> <span>'updated'</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>flushSchedulerQueue</code> 函数我们之后会详细介绍，可以先大概了解一下，<code>updatedQueue</code> 是更新了的 <code>wathcer</code> 数组，那么在 <code>callUpdatedHooks</code> 函数中，它对这些数组做遍历，只有满足当前 <code>watcher</code> 为 <code>vm._watcher</code> 以及组件已经 <code>mounted</code> 这两个条件，才会执行 <code>updated</code> 钩子函数。</p>
<p>我们之前提过，在组件 mount 的过程中，会实例化一个渲染的 <code>Watcher</code> 去监听 <code>vm</code> 上的数据变化重新渲染，这段逻辑发生在 <code>mountComponent</code> 函数执行的时候：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mountComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>el</span><span>:</span> <span>?</span>Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  <span>// ...</span>
  <span>// 这里是简写</span>
  <span>let</span> <span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
  <span>}</span>
  <span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> updateComponent<span>,</span> noop<span>,</span> <span>{</span>
    <span>before</span> <span>(</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>vm<span>.</span>_isMounted<span>)</span> <span>{</span>
        <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeUpdate'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>true</span> <span>/* isRenderWatcher */</span><span>)</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么在实例化 <code>Watcher</code> 的过程中，在它的构造函数里会判断 <code>isRenderWatcher</code>，接着把当前 <code>watcher</code> 的实例赋值给 <code>vm._watcher</code>，定义在 <code>src/core/observer/watcher.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>Watcher</span> <span>{</span>
  <span>// ...</span>
  <span>constructor</span> <span>(</span>
    <span><span>vm</span><span>:</span> Component<span>,</span>
    <span>expOrFn</span><span>:</span> string <span>|</span> Function<span>,</span>
    <span>cb</span><span>:</span> Function<span>,</span>
    options<span>?</span><span>:</span> <span>?</span>Object<span>,</span>
    isRenderWatcher<span>?</span><span>:</span> boolean</span>
  <span>)</span> <span>{</span>
    <span>this</span><span>.</span>vm <span>=</span> vm
    <span>if</span> <span>(</span>isRenderWatcher<span>)</span> <span>{</span>
      vm<span>.</span>_watcher <span>=</span> <span>this</span>
    <span>}</span>
    vm<span>.</span>_watchers<span>.</span><span>push</span><span>(</span><span>this</span><span>)</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同时，还把当前 <code>wathcer</code> 实例 push 到 <code>vm._watchers</code> 中，<code>vm._watcher</code> 是专门用来监听 <code>vm</code> 上数据变化然后重新渲染的，所以它是一个渲染相关的 <code>watcher</code>，因此在 <code>callUpdatedHooks</code> 函数中，只有 <code>vm._watcher</code> 的回调执行完毕后，才会执行 <code>updated</code> 钩子函数。</p>
<h2 id="beforedestroy-destroyed" tabindex="-1"> beforeDestroy &amp; destroyed</h2>
<p>顾名思义，<code>beforeDestroy</code> 和 <code>destroyed</code> 钩子函数的执行时机在组件销毁的阶段，组件的销毁过程之后会详细介绍，最终会调用 <code>$destroy</code> 方法，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>$destroy</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
    <span>if</span> <span>(</span>vm<span>.</span>_isBeingDestroyed<span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
    <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeDestroy'</span><span>)</span>
    vm<span>.</span>_isBeingDestroyed <span>=</span> <span>true</span>
    <span>// remove self from parent</span>
    <span>const</span> parent <span>=</span> vm<span>.</span>$parent
    <span>if</span> <span>(</span>parent <span>&amp;&amp;</span> <span>!</span>parent<span>.</span>_isBeingDestroyed <span>&amp;&amp;</span> <span>!</span>vm<span>.</span>$options<span>.</span>abstract<span>)</span> <span>{</span>
      <span>remove</span><span>(</span>parent<span>.</span>$children<span>,</span> vm<span>)</span>
    <span>}</span>
    <span>// teardown watchers</span>
    <span>if</span> <span>(</span>vm<span>.</span>_watcher<span>)</span> <span>{</span>
      vm<span>.</span>_watcher<span>.</span><span>teardown</span><span>(</span><span>)</span>
    <span>}</span>
    <span>let</span> i <span>=</span> vm<span>.</span>_watchers<span>.</span>length
    <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
      vm<span>.</span>_watchers<span>[</span>i<span>]</span><span>.</span><span>teardown</span><span>(</span><span>)</span>
    <span>}</span>
    <span>// remove reference from data ob</span>
    <span>// frozen object may not have observer.</span>
    <span>if</span> <span>(</span>vm<span>.</span>_data<span>.</span>__ob__<span>)</span> <span>{</span>
      vm<span>.</span>_data<span>.</span>__ob__<span>.</span>vmCount<span>--</span>
    <span>}</span>
    <span>// call the last hook...</span>
    vm<span>.</span>_isDestroyed <span>=</span> <span>true</span>
    <span>// invoke destroy hooks on current rendered tree</span>
    vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>_vnode<span>,</span> <span>null</span><span>)</span>
    <span>// fire destroyed hook</span>
    <span>callHook</span><span>(</span>vm<span>,</span> <span>'destroyed'</span><span>)</span>
    <span>// turn off all instance listeners.</span>
    vm<span>.</span><span>$off</span><span>(</span><span>)</span>
    <span>// remove __vue__ reference</span>
    <span>if</span> <span>(</span>vm<span>.</span>$el<span>)</span> <span>{</span>
      vm<span>.</span>$el<span>.</span>__vue__ <span>=</span> <span>null</span>
    <span>}</span>
    <span>// release circular reference (#6759)</span>
    <span>if</span> <span>(</span>vm<span>.</span>$vnode<span>)</span> <span>{</span>
      vm<span>.</span>$vnode<span>.</span>parent <span>=</span> <span>null</span>
    <span>}</span>
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>beforeDestroy</code> 钩子函数的执行时机是在 <code>$destroy</code> 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 <code>parent</code> 的 <code>$children</code> 中删掉自身，删除 <code>watcher</code>，当前渲染的 VNode 执行销毁钩子函数等，执行完毕后再调用 <code>destroy</code> 钩子函数。</p>
<p>在 <code>$destroy</code> 的执行过程中，它又会执行 <code> vm.__patch__(vm._vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 <code>destroy</code> 钩子函数执行顺序是先子后父，和 <code>mounted</code> 过程一样。</p>
<h2 id="activated-deactivated" tabindex="-1"> activated &amp; deactivated</h2>
<p><code>activated</code> 和 <code>deactivated</code> 钩子函数是专门为 <code>keep-alive</code> 组件定制的钩子，我们会在介绍 <code>keep-alive</code> 组件的时候详细介绍，这里先留个悬念。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>这一节主要介绍了 Vue 生命周期中各个钩子函数的执行时机以及顺序，通过分析，我们知道了如在 <code>created</code> 钩子函数中可以访问到数据，在 <code>mounted</code> 钩子函数中可以访问到 DOM，在 <code>destroy</code> 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">合并配置</title>
    <id>https://0808200.xyz/vue2/components/merge-option.html</id>
    <link href="https://0808200.xyz/vue2/components/merge-option.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="合并配置" tabindex="-1"> 合并配置</h1>
<p>通过之前章节的源码分析我们知道，<code>new Vue</code> 的过程通常有 2 种场景，一种是外部我们的代码主动调用 <code>new Vue(options)</code> 的方式实例化一个 Vue 对象；另一种是我们上一节分析的组件过程中内部通过 <code>new Vue(options)</code> 实例化子组件。</p>
<p>无论哪种场景，都会执行实例的 <code>_init(options)</code> 方法，它首先会执行一个 <code> merge options</code> 的逻辑，相关的代码在 <code>src/core/instance/init.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_init</span> <span>=</span> <span>function</span> <span>(</span><span>options<span>?</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>// merge options</span>
  <span>if</span> <span>(</span>options <span>&amp;&amp;</span> options<span>.</span>_isComponent<span>)</span> <span>{</span>
    <span>// optimize internal component instantiation</span>
    <span>// since dynamic options merging is pretty slow, and none of the</span>
    <span>// internal component options needs special treatment.</span>
    <span>initInternalComponent</span><span>(</span>vm<span>,</span> options<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    vm<span>.</span>$options <span>=</span> <span>mergeOptions</span><span>(</span>
      <span>resolveConstructorOptions</span><span>(</span>vm<span>.</span>constructor<span>)</span><span>,</span>
      options <span>||</span> <span>{</span><span>}</span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到不同场景对于 <code>options</code> 的合并逻辑是不一样的，并且传入的 <code>options</code> 值也有非常大的不同，接下来我会分开介绍 2 种场景的 options 合并过程。</p>
<p>为了更直观，我们可以举个简单的示例：</p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>

<span>let</span> childComp <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>{{msg}}&lt;/div>'</span><span>,</span>
  <span>created</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'child created'</span><span>)</span>
  <span>}</span><span>,</span>
  <span>mounted</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'child mounted'</span><span>)</span>
  <span>}</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>msg</span><span>:</span> <span>'Hello Vue'</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
  <span>created</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'parent created'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>let</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>childComp<span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="外部调用场景" tabindex="-1"> 外部调用场景</h2>
<p>当执行 <code>new Vue</code> 的时候，在执行 <code>this._init(options)</code> 的时候，就会执行如下逻辑去合并 <code>options</code>：</p>
<div><pre><code>vm<span>.</span>$options <span>=</span> <span>mergeOptions</span><span>(</span>
  <span>resolveConstructorOptions</span><span>(</span>vm<span>.</span>constructor<span>)</span><span>,</span>
  options <span>||</span> <span>{</span><span>}</span><span>,</span>
  vm
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这里通过调用 <code>mergeOptions</code> 方法来合并，它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，<code>resolveConstructorOptions</code> 的实现先不考虑，在我们这个场景下，它还是简单返回 <code>vm.constructor.options</code>，相当于 <code>Vue.options</code>，那么这个值又是什么呢，其实在 <code>initGlobalAPI(Vue)</code> 的时候定义了这个值，代码在 <code>src/core/global-api/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initGlobalAPI</span> <span>(</span><span><span>Vue</span><span>:</span> GlobalAPI</span><span>)</span> <span>{</span>
  <span>// ...</span>
  Vue<span>.</span>options <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>ASSET_TYPES</span><span>.</span><span>forEach</span><span>(</span><span>type</span> <span>=></span> <span>{</span>
    Vue<span>.</span>options<span>[</span>type <span>+</span> <span>'s'</span><span>]</span> <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>}</span><span>)</span>

  <span>// this is used to identify the "base" constructor to extend all plain-object</span>
  <span>// components with in Weex's multi-instance scenarios.</span>
  Vue<span>.</span>options<span>.</span>_base <span>=</span> Vue

  <span>extend</span><span>(</span>Vue<span>.</span>options<span>.</span>components<span>,</span> builtInComponents<span>)</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先通过 <code>Vue.options = Object.create(null)</code> 创建一个空对象，然后遍历 <code>ASSET_TYPES</code>，<code>ASSET_TYPES</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> <span>ASSET_TYPES</span> <span>=</span> <span>[</span>
  <span>'component'</span><span>,</span>
  <span>'directive'</span><span>,</span>
  <span>'filter'</span>
<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>所以上面遍历 <code>ASSET_TYPES</code> 后的代码相当于：</p>
<div><pre><code>Vue<span>.</span>options<span>.</span>components <span>=</span> <span>{</span><span>}</span>
Vue<span>.</span>options<span>.</span>directives <span>=</span> <span>{</span><span>}</span>
Vue<span>.</span>options<span>.</span>filters <span>=</span> <span>{</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>接着执行了 <code>Vue.options._base = Vue</code>，它的作用在我们上节实例化子组件的时候介绍了。</p>
<p>最后通过 <code>extend(Vue.options.components, builtInComponents)</code> 把一些内置组件扩展到 <code>Vue.options.components</code> 上，Vue 的内置组件目前有 <code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 组件，这也就是为什么我们在其它组件中使用 <code>&lt;keep-alive&gt;</code> 组件不需要注册的原因，这块儿后续我们介绍 <code>&lt;keep-alive&gt;</code> 组件的时候会详细讲。</p>
<p>那么回到 <code>mergeOptions</code> 这个函数，它的定义在 <code>src/core/util/options.js</code> 中：</p>
<div><pre><code><span>/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */</span>
<span>export</span> <span>function</span> <span>mergeOptions</span> <span>(</span>
  <span><span>parent</span><span>:</span> Object<span>,</span>
  <span>child</span><span>:</span> Object<span>,</span>
  vm<span>?</span><span>:</span> Component</span>
<span>)</span><span>:</span> Object <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>checkComponents</span><span>(</span>child<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>typeof</span> child <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
    child <span>=</span> child<span>.</span>options
  <span>}</span>

  <span>normalizeProps</span><span>(</span>child<span>,</span> vm<span>)</span>
  <span>normalizeInject</span><span>(</span>child<span>,</span> vm<span>)</span>
  <span>normalizeDirectives</span><span>(</span>child<span>)</span>
  <span>const</span> extendsFrom <span>=</span> child<span>.</span>extends
  <span>if</span> <span>(</span>extendsFrom<span>)</span> <span>{</span>
    parent <span>=</span> <span>mergeOptions</span><span>(</span>parent<span>,</span> extendsFrom<span>,</span> vm<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>child<span>.</span>mixins<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> child<span>.</span>mixins<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      parent <span>=</span> <span>mergeOptions</span><span>(</span>parent<span>,</span> child<span>.</span>mixins<span>[</span>i<span>]</span><span>,</span> vm<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>const</span> options <span>=</span> <span>{</span><span>}</span>
  <span>let</span> key
  <span>for</span> <span>(</span>key <span>in</span> parent<span>)</span> <span>{</span>
    <span>mergeField</span><span>(</span>key<span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span>key <span>in</span> child<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>hasOwn</span><span>(</span>parent<span>,</span> key<span>)</span><span>)</span> <span>{</span>
      <span>mergeField</span><span>(</span>key<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>function</span> <span>mergeField</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
    <span>const</span> strat <span>=</span> strats<span>[</span>key<span>]</span> <span>||</span> defaultStrat
    options<span>[</span>key<span>]</span> <span>=</span> <span>strat</span><span>(</span>parent<span>[</span>key<span>]</span><span>,</span> child<span>[</span>key<span>]</span><span>,</span> vm<span>,</span> key<span>)</span>
  <span>}</span>
  <span>return</span> options
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>mergeOptions</code> 主要功能就是把 <code>parent</code> 和 <code>child</code> 这两个对象根据一些合并策略，合并成一个新对象并返回。比较核心的几步，先递归把 <code>extends</code> 和 <code>mixins</code> 合并到 <code>parent</code> 上，然后遍历 <code>parent</code>，调用 <code>mergeField</code>，然后再遍历 <code>child</code>，如果 <code>key</code> 不在 <code>parent</code> 的自身属性上，则调用 <code>mergeField</code>。</p>
<p>这里有意思的是 <code>mergeField</code> 函数，它对不同的 <code>key</code> 有着不同的合并策略。举例来说，对于生命周期函数，它的合并策略是这样的：</p>
<div><pre><code><span>function</span> <span>mergeHook</span> <span>(</span>
  <span><span>parentVal</span><span>:</span> <span>?</span>Array<span>&lt;</span>Function<span>></span><span>,</span>
  <span>childVal</span><span>:</span> <span>?</span>Function <span>|</span> <span>?</span>Array<span>&lt;</span>Function<span>></span></span>
<span>)</span><span>:</span> <span>?</span>Array<span>&lt;</span>Function<span>></span> <span>{</span>
  <span>return</span> childVal
    <span>?</span> parentVal
      <span>?</span> parentVal<span>.</span><span>concat</span><span>(</span>childVal<span>)</span>
      <span>:</span> Array<span>.</span><span>isArray</span><span>(</span>childVal<span>)</span>
        <span>?</span> childVal
        <span>:</span> <span>[</span>childVal<span>]</span>
    <span>:</span> parentVal
<span>}</span>

<span>LIFECYCLE_HOOKS</span><span>.</span><span>forEach</span><span>(</span><span>hook</span> <span>=></span> <span>{</span>
  strats<span>[</span>hook<span>]</span> <span>=</span> mergeHook
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这其中的 <code>LIFECYCLE_HOOKS</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> <span>LIFECYCLE_HOOKS</span> <span>=</span> <span>[</span>
  <span>'beforeCreate'</span><span>,</span>
  <span>'created'</span><span>,</span>
  <span>'beforeMount'</span><span>,</span>
  <span>'mounted'</span><span>,</span>
  <span>'beforeUpdate'</span><span>,</span>
  <span>'updated'</span><span>,</span>
  <span>'beforeDestroy'</span><span>,</span>
  <span>'destroyed'</span><span>,</span>
  <span>'activated'</span><span>,</span>
  <span>'deactivated'</span><span>,</span>
  <span>'errorCaptured'</span>
<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里定义了 Vue.js 所有的钩子函数名称，所以对于钩子函数，他们的合并策略都是 <code>mergeHook</code> 函数。这个函数的实现也非常有意思，用了一个多层 3 元运算符，逻辑就是如果不存在 <code>childVal</code> ，就返回 <code>parentVal</code>；否则再判断是否存在 <code>parentVal</code>，如果存在就把 <code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；否则返回 <code>childVal</code> 的数组。所以回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code> 和 <code>child</code> 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。</p>
<p>关于其它属性的合并策略的定义都可以在 <code>src/core/util/options.js</code> 文件中看到，这里不一一介绍了，感兴趣的同学可以自己看。</p>
<p>通过执行 <code>mergeField</code> 函数，把合并后的结果保存到 <code>options</code> 对象中，最终返回它。</p>
<p>因此，在我们当前这个 case 下，执行完如下合并后：</p>
<div><pre><code>vm<span>.</span>$options <span>=</span> <span>mergeOptions</span><span>(</span>
  <span>resolveConstructorOptions</span><span>(</span>vm<span>.</span>constructor<span>)</span><span>,</span>
  options <span>||</span> <span>{</span><span>}</span><span>,</span>
  vm
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><code>vm.$options</code> 的值差不多是如下这样：</p>
<div><pre><code>vm<span>.</span>$options <span>=</span> <span>{</span>
  <span>components</span><span>:</span> <span>{</span> <span>}</span><span>,</span>
  <span>created</span><span>:</span> <span>[</span>
    <span>function</span> <span>created</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'parent created'</span><span>)</span>
    <span>}</span>
  <span>]</span><span>,</span>
  <span>directives</span><span>:</span> <span>{</span> <span>}</span><span>,</span>
  <span>filters</span><span>:</span> <span>{</span> <span>}</span><span>,</span>
  <span>_base</span><span>:</span> <span>function</span> <span>Vue</span><span>(</span><span>options</span><span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span><span>,</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>render</span><span>:</span> <span>function</span> <span>(</span><span>h</span><span>)</span> <span>{</span>
    <span>//...</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="组件场景" tabindex="-1"> 组件场景</h2>
<p>由于组件的构造函数是通过 <code>Vue.extend</code> 继承自 <code>Vue</code> 的，先回顾一下这个过程，代码定义在 <code>src/core/global-api/extend.js</code> 中。</p>
<div><pre><code><span>/**
 * Class inheritance
 */</span>
Vue<span>.</span><span>extend</span> <span>=</span> <span>function</span> <span>(</span><span><span>extendOptions</span><span>:</span> Object</span><span>)</span><span>:</span> Function <span>{</span>
  <span>// ...</span>
  Sub<span>.</span>options <span>=</span> <span>mergeOptions</span><span>(</span>
    Super<span>.</span>options<span>,</span>
    extendOptions
  <span>)</span>

  <span>// ...</span>
  <span>// keep a reference to the super options at extension time.</span>
  <span>// later at instantiation we can check if Super's options have</span>
  <span>// been updated.</span>
  Sub<span>.</span>superOptions <span>=</span> Super<span>.</span>options
  Sub<span>.</span>extendOptions <span>=</span> extendOptions
  Sub<span>.</span>sealedOptions <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> Sub<span>.</span>options<span>)</span>

  <span>// ...</span>
  <span>return</span> Sub
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们只保留关键逻辑，这里的 <code>extendOptions</code> 对应的就是前面定义的组件对象，它会和 <code>Vue.options</code> 合并到 <code>Sub.opitons</code> 中。</p>
<p>接下来我们再回忆一下子组件的初始化过程，代码定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponentInstanceForVnode</span> <span>(</span>
  <span>vnode</span><span>:</span> any<span>,</span> <span>// we know it's MountedComponentVNode but flow doesn't</span>
  <span>parent</span><span>:</span> any<span>,</span> <span>// activeInstance in lifecycle state</span>
<span>)</span><span>:</span> Component <span>{</span>
  <span>const</span> <span>options</span><span>:</span> InternalComponentOptions <span>=</span> <span>{</span>
    <span>_isComponent</span><span>:</span> <span>true</span><span>,</span>
    <span>_parentVnode</span><span>:</span> vnode<span>,</span>
    parent
  <span>}</span>
  <span>// ...</span>
  <span>return</span> <span>new</span> <span>vnode<span>.</span>componentOptions<span>.</span>Ctor</span><span>(</span>options<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的 <code>vnode.componentOptions.Ctor</code> 就是指向 <code>Vue.extend</code> 的返回值 <code>Sub</code>， 所以 执行 <code>new vnode.componentOptions.Ctor(options)</code> 接着执行 <code>this._init(options)</code>，因为 <code>options._isComponent</code> 为 true，那么合并 <code>options</code> 的过程走到了 <code> initInternalComponent(vm, options)</code> 逻辑。先来看一下它的代码实现，在 <code>src/core/instance/init.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initInternalComponent</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>options</span><span>:</span> InternalComponentOptions</span><span>)</span> <span>{</span>
  <span>const</span> opts <span>=</span> vm<span>.</span>$options <span>=</span> Object<span>.</span><span>create</span><span>(</span>vm<span>.</span>constructor<span>.</span>options<span>)</span>
  <span>// doing this because it's faster than dynamic enumeration.</span>
  <span>const</span> parentVnode <span>=</span> options<span>.</span>_parentVnode
  opts<span>.</span>parent <span>=</span> options<span>.</span>parent
  opts<span>.</span>_parentVnode <span>=</span> parentVnode

  <span>const</span> vnodeComponentOptions <span>=</span> parentVnode<span>.</span>componentOptions
  opts<span>.</span>propsData <span>=</span> vnodeComponentOptions<span>.</span>propsData
  opts<span>.</span>_parentListeners <span>=</span> vnodeComponentOptions<span>.</span>listeners
  opts<span>.</span>_renderChildren <span>=</span> vnodeComponentOptions<span>.</span>children
  opts<span>.</span>_componentTag <span>=</span> vnodeComponentOptions<span>.</span>tag

  <span>if</span> <span>(</span>options<span>.</span>render<span>)</span> <span>{</span>
    opts<span>.</span>render <span>=</span> options<span>.</span>render
    opts<span>.</span>staticRenderFns <span>=</span> options<span>.</span>staticRenderFns
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>initInternalComponent</code> 方法首先执行 <code>const opts = vm.$options = Object.create(vm.constructor.options)</code>，这里的 <code>vm.constructor</code> 就是子组件的构造函数 <code>Sub</code>，相当于 <code>vm.$options = Object.create(Sub.options)</code>。</p>
<p>接着又把实例化子组件传入的子组件父 VNode 实例 <code>parentVnode</code>、子组件的父 Vue 实例 <code>parent</code> 保存到 <code>vm.$options</code> 中，另外还保留了 <code>parentVnode</code> 配置中的如 <code>propsData</code> 等其它的属性。</p>
<p>这么看来，<code>initInternalComponent</code> 只是做了简单一层对象赋值，并不涉及到递归、合并策略等复杂逻辑。</p>
<p>因此，在我们当前这个 case 下，执行完如下合并后：</p>
<div><pre><code><span>initInternalComponent</span><span>(</span>vm<span>,</span> options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>vm.$options</code> 的值差不多是如下这样：</p>
<div><pre><code>vm<span>.</span>$options <span>=</span> <span>{</span>
  <span>parent</span><span>:</span> Vue <span>/*父Vue实例*/</span><span>,</span>
  <span>propsData</span><span>:</span> <span>undefined</span><span>,</span>
  <span>_componentTag</span><span>:</span> <span>undefined</span><span>,</span>
  <span>_parentVnode</span><span>:</span> VNode <span>/*父VNode实例*/</span><span>,</span>
  <span>_renderChildren</span><span>:</span><span>undefined</span><span>,</span>
  <span>__proto__</span><span>:</span> <span>{</span>
    <span>components</span><span>:</span> <span>{</span> <span>}</span><span>,</span>
    <span>directives</span><span>:</span> <span>{</span> <span>}</span><span>,</span>
    <span>filters</span><span>:</span> <span>{</span> <span>}</span><span>,</span>
    <span>_base</span><span>:</span> <span>function</span> <span>Vue</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>//...</span>
    <span>}</span><span>,</span>
    <span>_Ctor</span><span>:</span> <span>{</span><span>}</span><span>,</span>
    <span>created</span><span>:</span> <span>[</span>
      <span>function</span> <span>created</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'parent created'</span><span>)</span>
      <span>}</span><span>,</span> <span>function</span> <span>created</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'child created'</span><span>)</span>
      <span>}</span>
    <span>]</span><span>,</span>
    <span>mounted</span><span>:</span> <span>[</span>
      <span>function</span> <span>mounted</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'child mounted'</span><span>)</span>
      <span>}</span>
    <span>]</span><span>,</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>{</span>
         <span>msg</span><span>:</span> <span>'Hello Vue'</span>
       <span>}</span>
    <span>}</span><span>,</span>
    <span>template</span><span>:</span> <span>'&lt;div>{{msg}}&lt;/div>'</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，Vue 初始化阶段对于 <code>options</code> 的合并过程就介绍完了，我们需要知道对于 <code>options</code> 的合并有 2 种方式，子组件初始化过程通过 <code>initInternalComponent</code> 方式要比外部初始化 Vue 通过 <code>mergeOptions</code> 的过程要快，合并完的结果保留在 <code>vm.$options</code> 中。</p>
<p>纵观一些库、框架的设计几乎都是类似的，自身定义了一些默认配置，同时又可以在初始化阶段传入一些定义配置，然后去 merge 默认配置，来达到定制化不同需求的目的。只不过在 Vue 的场景下，会对 merge 的过程做一些精细化控制，虽然我们在开发自己的 JSSDK 的时候并没有 Vue 这么复杂，但这个设计思想是值得我们借鉴的。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">patch</title>
    <id>https://0808200.xyz/vue2/components/patch.html</id>
    <link href="https://0808200.xyz/vue2/components/patch.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="patch" tabindex="-1"> patch</h1>
<p>通过前一章的分析我们知道，当我们通过 <code>createComponent</code> 创建了组件 VNode，接下来会走到 <code>vm._update</code>，执行 <code>vm.__patch__</code> 去把 VNode 转换成真正的 DOM 节点。这个过程我们在前一章已经分析过了，但是针对一个普通的 VNode 节点，接下来我们来看看组件的 VNode 会有哪些不一样的地方。</p>
<p>patch 的过程会调用 <code>createElm</code> 创建元素节点，回顾一下 <code>createElm</code> 的实现，它的定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<div><pre><code><span>function</span> <span>createElm</span> <span>(</span>
  <span>vnode<span>,</span>
  insertedVnodeQueue<span>,</span>
  parentElm<span>,</span>
  refElm<span>,</span>
  nested<span>,</span>
  ownerArray<span>,</span>
  index</span>
<span>)</span> <span>{</span>
  <span>// ...</span>
  <span>if</span> <span>(</span><span>createComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="createcomponent" tabindex="-1"> createComponent</h2>
<p>我们删掉多余的代码，只保留关键的逻辑，这里会判断 <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值，如果为 <code>true</code> 则直接结束，那么接下来看一下 <code>createComponent</code> 方法的实现：</p>
<div><pre><code><span>function</span> <span>createComponent</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
    <span>const</span> isReactivated <span>=</span> <span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span> <span>&amp;&amp;</span> i<span>.</span>keepAlive
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>init<span>)</span><span>)</span> <span>{</span>
      <span>i</span><span>(</span>vnode<span>,</span> <span>false</span> <span>/* hydrating */</span><span>)</span>
    <span>}</span>
    <span>// after calling the init hook, if the vnode is a child component</span>
    <span>// it should've created a child instance and mounted it. the child</span>
    <span>// component also has set the placeholder vnode's elm.</span>
    <span>// in that case we can just return the element and be done.</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span><span>)</span> <span>{</span>
      <span>initComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
      <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
      <span>if</span> <span>(</span><span>isTrue</span><span>(</span>isReactivated<span>)</span><span>)</span> <span>{</span>
        <span>reactivateComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span>
      <span>}</span>
      <span>return</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createComponent</code> 函数中，首先对 <code>vnode.data</code> 做了一些判断：</p>
<div><pre><code><span>let</span> i <span>=</span> vnode<span>.</span>data
<span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>init<span>)</span><span>)</span> <span>{</span>
    <span>i</span><span>(</span>vnode<span>,</span> <span>false</span> <span>/* hydrating */</span><span>)</span>
    <span>// ...</span>
  <span>}</span>
  <span>// ..</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果 <code>vnode</code> 是一个组件 VNode，那么条件会满足，并且得到 <code>i</code> 就是 <code>init</code> 钩子函数，回顾上节我们在创建组件 VNode 的时候合并钩子函数中就包含 <code>init</code> 钩子函数，定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>init</span> <span>(</span>vnode<span>:</span> VNodeWithData<span>,</span> <span>hydrating</span><span>:</span> boolean<span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
  <span>if</span> <span>(</span>
    vnode<span>.</span>componentInstance <span>&amp;&amp;</span>
    <span>!</span>vnode<span>.</span>componentInstance<span>.</span>_isDestroyed <span>&amp;&amp;</span>
    vnode<span>.</span>data<span>.</span>keepAlive
  <span>)</span> <span>{</span>
    <span>// kept-alive components, treat as a patch</span>
    <span>const</span> <span>mountedNode</span><span>:</span> any <span>=</span> vnode <span>// work around flow</span>
    componentVNodeHooks<span>.</span><span>prepatch</span><span>(</span>mountedNode<span>,</span> mountedNode<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> <span>createComponentInstanceForVnode</span><span>(</span>
      vnode<span>,</span>
      activeInstance
    <span>)</span>
    child<span>.</span><span>$mount</span><span>(</span>hydrating <span>?</span> vnode<span>.</span>elm <span>:</span> <span>undefined</span><span>,</span> hydrating<span>)</span>
  <span>}</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>init</code> 钩子函数执行也很简单，我们先不考虑 <code>keepAlive</code> 的情况，它是通过 <code>createComponentInstanceForVnode</code> 创建一个 Vue 的实例，然后调用 <code>$mount</code> 方法挂载子组件，
先来看一下 <code>createComponentInstanceForVnode</code> 的实现：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponentInstanceForVnode</span> <span>(</span>
  <span>vnode</span><span>:</span> any<span>,</span> <span>// we know it's MountedComponentVNode but flow doesn't</span>
  <span>parent</span><span>:</span> any<span>,</span> <span>// activeInstance in lifecycle state</span>
<span>)</span><span>:</span> Component <span>{</span>
  <span>const</span> <span>options</span><span>:</span> InternalComponentOptions <span>=</span> <span>{</span>
    <span>_isComponent</span><span>:</span> <span>true</span><span>,</span>
    <span>_parentVnode</span><span>:</span> vnode<span>,</span>
    parent
  <span>}</span>
  <span>// check inline-template render functions</span>
  <span>const</span> inlineTemplate <span>=</span> vnode<span>.</span>data<span>.</span>inlineTemplate
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>inlineTemplate<span>)</span><span>)</span> <span>{</span>
    options<span>.</span>render <span>=</span> inlineTemplate<span>.</span>render
    options<span>.</span>staticRenderFns <span>=</span> inlineTemplate<span>.</span>staticRenderFns
  <span>}</span>
  <span>return</span> <span>new</span> <span>vnode<span>.</span>componentOptions<span>.</span>Ctor</span><span>(</span>options<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createComponentInstanceForVnode</code> 函数构造的一个内部组件的参数，然后执行 <code>new vnode.componentOptions.Ctor(options)</code>。这里的 <code>vnode.componentOptions.Ctor</code> 对应的就是子组件的构造函数，我们上一节分析了它实际上是继承于 Vue 的一个构造器 <code>Sub</code>，相当于 <code>new Sub(options)</code> 这里有几个关键参数要注意几个点，<code>_isComponent</code> 为 <code>true</code> 表示它是一个组件，<code>parent</code> 表示当前激活的组件实例（注意，这里比较有意思的是如何拿到组件实例，后面会介绍。</p>
<p>所以子组件的实例化实际上就是在这个时机执行的，并且它会执行实例的 <code>_init</code> 方法，这个过程有一些和之前不同的地方需要挑出来说，代码在 <code>src/core/instance/init.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_init</span> <span>=</span> <span>function</span> <span>(</span><span>options<span>?</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>// merge options</span>
  <span>if</span> <span>(</span>options <span>&amp;&amp;</span> options<span>.</span>_isComponent<span>)</span> <span>{</span>
    <span>// optimize internal component instantiation</span>
    <span>// since dynamic options merging is pretty slow, and none of the</span>
    <span>// internal component options needs special treatment.</span>
    <span>initInternalComponent</span><span>(</span>vm<span>,</span> options<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    vm<span>.</span>$options <span>=</span> <span>mergeOptions</span><span>(</span>
      <span>resolveConstructorOptions</span><span>(</span>vm<span>.</span>constructor<span>)</span><span>,</span>
      options <span>||</span> <span>{</span><span>}</span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  <span>// ...</span>
  <span>if</span> <span>(</span>vm<span>.</span>$options<span>.</span>el<span>)</span> <span>{</span>
    vm<span>.</span><span>$mount</span><span>(</span>vm<span>.</span>$options<span>.</span>el<span>)</span>
  <span>}</span> 
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里首先是合并 <code>options</code> 的过程有变化，<code>_isComponent</code> 为 true，所以走到了 <code>initInternalComponent</code> 过程，这个函数的实现也简单看一下：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initInternalComponent</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>options</span><span>:</span> InternalComponentOptions</span><span>)</span> <span>{</span>
  <span>const</span> opts <span>=</span> vm<span>.</span>$options <span>=</span> Object<span>.</span><span>create</span><span>(</span>vm<span>.</span>constructor<span>.</span>options<span>)</span>
  <span>// doing this because it's faster than dynamic enumeration.</span>
  <span>const</span> parentVnode <span>=</span> options<span>.</span>_parentVnode
  opts<span>.</span>parent <span>=</span> options<span>.</span>parent
  opts<span>.</span>_parentVnode <span>=</span> parentVnode

  <span>const</span> vnodeComponentOptions <span>=</span> parentVnode<span>.</span>componentOptions
  opts<span>.</span>propsData <span>=</span> vnodeComponentOptions<span>.</span>propsData
  opts<span>.</span>_parentListeners <span>=</span> vnodeComponentOptions<span>.</span>listeners
  opts<span>.</span>_renderChildren <span>=</span> vnodeComponentOptions<span>.</span>children
  opts<span>.</span>_componentTag <span>=</span> vnodeComponentOptions<span>.</span>tag

  <span>if</span> <span>(</span>options<span>.</span>render<span>)</span> <span>{</span>
    opts<span>.</span>render <span>=</span> options<span>.</span>render
    opts<span>.</span>staticRenderFns <span>=</span> options<span>.</span>staticRenderFns
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个过程我们重点记住以下几个点即可：<code>opts.parent = options.parent</code>、<code>opts._parentVnode = parentVnode</code>，它们是把之前我们通过 <code>createComponentInstanceForVnode</code> 函数传入的几个参数合并到内部的选项 <code>$options</code> 里了。</p>
<p>再来看一下 <code>_init</code> 函数最后执行的代码：</p>
<div><pre><code><span>if</span> <span>(</span>vm<span>.</span>$options<span>.</span>el<span>)</span> <span>{</span>
   vm<span>.</span><span>$mount</span><span>(</span>vm<span>.</span>$options<span>.</span>el<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>由于组件初始化的时候是不传 el 的，因此组件是自己接管了 <code>$mount</code> 的过程，这个过程的主要流程在上一章介绍过了，回到组件 <code>init</code> 的过程，<code>componentVNodeHooks</code> 的 <code>init</code> 钩子函数，在完成实例化的 <code>_init</code> 后，接着会执行 <code>child.$mount(hydrating ? vnode.elm : undefined, hydrating)</code> 。这里 <code>hydrating</code> 为 true 一般是服务端渲染的情况，我们只考虑客户端渲染，所以这里 <code>$mount</code> 相当于执行 <code>child.$mount(undefined, false)</code>，它最终会调用 <code>mountComponent</code> 方法，进而执行 <code>vm._render()</code> 方法：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_render</span> <span>=</span> <span>function</span> <span>(</span><span>)</span><span>:</span> VNode <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>const</span> <span>{</span> render<span>,</span> _parentVnode <span>}</span> <span>=</span> vm<span>.</span>$options

  
  <span>// set parent vnode. this allows render functions to have access</span>
  <span>// to the data on the placeholder node.</span>
  vm<span>.</span>$vnode <span>=</span> _parentVnode
  <span>// render self</span>
  <span>let</span> vnode
  <span>try</span> <span>{</span>
    vnode <span>=</span> <span>render</span><span>.</span><span>call</span><span>(</span>vm<span>.</span>_renderProxy<span>,</span> vm<span>.</span>$createElement<span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
  <span>// set parent</span>
  vnode<span>.</span>parent <span>=</span> _parentVnode
  <span>return</span> vnode
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们只保留关键部分的代码，这里的 <code>_parentVnode</code> 就是当前组件的父 VNode，而 <code>render</code> 函数生成的 <code>vnode</code> 当前组件的渲染 <code>vnode</code>，<code>vnode</code> 的 <code>parent</code> 指向了 <code>_parentVnode</code>，也就是 <code>vm.$vnode</code>，它们是一种父子的关系。</p>
<p>我们知道在执行完 <code>vm._render</code> 生成 VNode 后，接下来就要执行 <code>vm._update</code> 去渲染 VNode 了。来看一下组件渲染的过程中有哪些需要注意的，<code>vm._update</code> 的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>let</span> <span>activeInstance</span><span>:</span> any <span>=</span> <span>null</span>
<span>Vue</span><span>.</span>prototype<span>.</span><span>_update</span> <span>=</span> <span>function</span> <span>(</span><span><span>vnode</span><span>:</span> VNode<span>,</span> hydrating<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>const</span> prevEl <span>=</span> vm<span>.</span>$el
  <span>const</span> prevVnode <span>=</span> vm<span>.</span>_vnode
  <span>const</span> prevActiveInstance <span>=</span> activeInstance
  activeInstance <span>=</span> vm
  vm<span>.</span>_vnode <span>=</span> vnode
  <span>// Vue.prototype.__patch__ is injected in entry points</span>
  <span>// based on the rendering backend used.</span>
  <span>if</span> <span>(</span><span>!</span>prevVnode<span>)</span> <span>{</span>
    <span>// initial render</span>
    vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>$el<span>,</span> vnode<span>,</span> hydrating<span>,</span> <span>false</span> <span>/* removeOnly */</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// updates</span>
    vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>prevVnode<span>,</span> vnode<span>)</span>
  <span>}</span>
  activeInstance <span>=</span> prevActiveInstance
  <span>// update __vue__ reference</span>
  <span>if</span> <span>(</span>prevEl<span>)</span> <span>{</span>
    prevEl<span>.</span>__vue__ <span>=</span> <span>null</span>
  <span>}</span>
  <span>if</span> <span>(</span>vm<span>.</span>$el<span>)</span> <span>{</span>
    vm<span>.</span>$el<span>.</span>__vue__ <span>=</span> vm
  <span>}</span>
  <span>// if parent is an HOC, update its $el as well</span>
  <span>if</span> <span>(</span>vm<span>.</span>$vnode <span>&amp;&amp;</span> vm<span>.</span>$parent <span>&amp;&amp;</span> vm<span>.</span>$vnode <span>===</span> vm<span>.</span>$parent<span>.</span>_vnode<span>)</span> <span>{</span>
    vm<span>.</span>$parent<span>.</span>$el <span>=</span> vm<span>.</span>$el
  <span>}</span>
  <span>// updated hook is called by the scheduler to ensure that children are</span>
  <span>// updated in a parent's updated hook.</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>_update</code> 过程中有几个关键的代码，首先 <code>vm._vnode = vnode</code> 的逻辑，这个 <code>vnode</code> 是通过 <code>vm._render()</code> 返回的组件渲染 VNode，<code>vm._vnode</code> 和 <code>vm.$vnode</code> 的关系就是一种父子关系，用代码表达就是 <code>vm._vnode.parent === vm.$vnode</code>。还有一段比较有意思的代码：</p>
<div><pre><code><span>export</span> <span>let</span> <span>activeInstance</span><span>:</span> any <span>=</span> <span>null</span>
<span>Vue</span><span>.</span>prototype<span>.</span><span>_update</span> <span>=</span> <span>function</span> <span>(</span><span><span>vnode</span><span>:</span> VNode<span>,</span> hydrating<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
    <span>// ...</span>
    <span>const</span> prevActiveInstance <span>=</span> activeInstance
    activeInstance <span>=</span> vm
    <span>if</span> <span>(</span><span>!</span>prevVnode<span>)</span> <span>{</span>
      <span>// initial render</span>
      vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>$el<span>,</span> vnode<span>,</span> hydrating<span>,</span> <span>false</span> <span>/* removeOnly */</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// updates</span>
      vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>prevVnode<span>,</span> vnode<span>)</span>
    <span>}</span>
    activeInstance <span>=</span> prevActiveInstance
    <span>// ...</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个 <code>activeInstance</code> 作用就是保持当前上下文的 Vue 实例，它是在 <code>lifecycle</code> 模块的全局变量，定义是 <code>export let activeInstance: any = null</code>，并且在之前我们调用 <code>createComponentInstanceForVnode</code> 方法的时候从 <code>lifecycle</code> 模块获取，并且作为参数传入的。因为实际上 JavaScript 是一个单线程，Vue 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 Vue 实例是什么，并把它作为子组件的父 Vue 实例。之前我们提到过对子组件的实例化过程先会调用 <code>initInternalComponent(vm, options)</code> 合并 <code>options</code>，把 <code>parent</code> 存储在 <code>vm.$options</code> 中，在 <code>$mount</code> 之前会调用 <code>initLifecycle(vm)</code> 方法：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initLifecycle</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  <span>const</span> options <span>=</span> vm<span>.</span>$options

  <span>// locate first non-abstract parent</span>
  <span>let</span> parent <span>=</span> options<span>.</span>parent
  <span>if</span> <span>(</span>parent <span>&amp;&amp;</span> <span>!</span>options<span>.</span>abstract<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>parent<span>.</span>$options<span>.</span>abstract <span>&amp;&amp;</span> parent<span>.</span>$parent<span>)</span> <span>{</span>
      parent <span>=</span> parent<span>.</span>$parent
    <span>}</span>
    parent<span>.</span>$children<span>.</span><span>push</span><span>(</span>vm<span>)</span>
  <span>}</span>

  vm<span>.</span>$parent <span>=</span> parent
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 <code>vm.$parent</code> 就是用来保留当前 <code>vm</code> 的父实例，并且通过 <code>parent.$children.push(vm)</code> 来把当前的 <code>vm</code> 存储到父实例的 <code>$children</code> 中。</p>
<p>在 <code>vm._update</code> 的过程中，把当前的 <code>vm</code> 赋值给 <code>activeInstance</code>，同时通过 <code>const prevActiveInstance = activeInstance</code> 用 <code>prevActiveInstance</code> 保留上一次的 <code>activeInstance</code>。实际上，<code>prevActiveInstance</code> 和当前的 <code>vm</code> 是一个父子关系，当一个 <code>vm</code> 实例完成它的所有子树的 patch 或者 update 过程后，<code>activeInstance</code> 会回到它的父实例，这样就完美地保证了 <code>createComponentInstanceForVnode</code> 整个深度遍历过程中，我们在实例化子组件的时候能传入当前子组件的父 Vue 实例，并在 <code>_init</code> 的过程中，通过 <code>vm.$parent</code> 把这个父子关系保留。</p>
<p>那么回到 <code>_update</code>，最后就是调用 <code>__patch__</code> 渲染 VNode 了。</p>
<div><pre><code>vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>$el<span>,</span> vnode<span>,</span> hydrating<span>,</span> <span>false</span> <span>/* removeOnly */</span><span>)</span>
 
<span>function</span> <span>patch</span> <span>(</span><span>oldVnode<span>,</span> vnode<span>,</span> hydrating<span>,</span> removeOnly</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>let</span> isInitialPatch <span>=</span> <span>false</span>
  <span>const</span> insertedVnodeQueue <span>=</span> <span>[</span><span>]</span>

  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldVnode<span>)</span><span>)</span> <span>{</span>
    <span>// empty mount (likely as component), create new root element</span>
    isInitialPatch <span>=</span> <span>true</span>
    <span>createElm</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里又回到了本节开始的过程，之前分析过负责渲染成 DOM 的函数是 <code>createElm</code>，注意这里我们只传了 2 个参数，所以对应的 <code>parentElm</code> 是 <code>undefined</code>。我们再来看看它的定义：</p>
<div><pre><code><span>function</span> <span>createElm</span> <span>(</span>
  <span>vnode<span>,</span>
  insertedVnodeQueue<span>,</span>
  parentElm<span>,</span>
  refElm<span>,</span>
  nested<span>,</span>
  ownerArray<span>,</span>
  index</span>
<span>)</span> <span>{</span>
  <span>// ...</span>
  <span>if</span> <span>(</span><span>createComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> data <span>=</span> vnode<span>.</span>data
  <span>const</span> children <span>=</span> vnode<span>.</span>children
  <span>const</span> tag <span>=</span> vnode<span>.</span>tag
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
    <span>// ...</span>

    vnode<span>.</span>elm <span>=</span> vnode<span>.</span>ns
      <span>?</span> nodeOps<span>.</span><span>createElementNS</span><span>(</span>vnode<span>.</span>ns<span>,</span> tag<span>)</span>
      <span>:</span> nodeOps<span>.</span><span>createElement</span><span>(</span>tag<span>,</span> vnode<span>)</span>
    <span>setScope</span><span>(</span>vnode<span>)</span>

    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>__WEEX__<span>)</span> <span>{</span>
      <span>// ...</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>createChildren</span><span>(</span>vnode<span>,</span> children<span>,</span> insertedVnodeQueue<span>)</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
        <span>invokeCreateHooks</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
      <span>}</span>
      <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
    <span>}</span>
    
    <span>// ...</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isTrue</span><span>(</span>vnode<span>.</span>isComment<span>)</span><span>)</span> <span>{</span>
    vnode<span>.</span>elm <span>=</span> nodeOps<span>.</span><span>createComment</span><span>(</span>vnode<span>.</span>text<span>)</span>
    <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    vnode<span>.</span>elm <span>=</span> nodeOps<span>.</span><span>createTextNode</span><span>(</span>vnode<span>.</span>text<span>)</span>
    <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，这里我们传入的 <code>vnode</code> 是组件渲染的 <code>vnode</code>，也就是我们之前说的 <code>vm._vnode</code>，如果组件的根节点是个普通元素，那么 <code>vm._vnode</code> 也是普通的 <code>vnode</code>，这里 <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值是 false。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 <code>createElm</code>，在遍历的过程中，如果遇到子 VNode 是一个组件的 VNode，则重复本节开始的过程，这样通过一个递归的方式就可以完整地构建了整个组件树。</p>
<p>由于我们这个时候传入的 <code>parentElm</code> 是空，所以对组件的插入，在 <code>createComponent</code> 有这么一段逻辑：</p>
<div><pre><code><span>function</span> <span>createComponent</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
    <span>// ....</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>init<span>)</span><span>)</span> <span>{</span>
      <span>i</span><span>(</span>vnode<span>,</span> <span>false</span> <span>/* hydrating */</span><span>)</span>
    <span>}</span>
    <span>// ...</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span><span>)</span> <span>{</span>
      <span>initComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
      <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
      <span>if</span> <span>(</span><span>isTrue</span><span>(</span>isReactivated<span>)</span><span>)</span> <span>{</span>
        <span>reactivateComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span>
      <span>}</span>
      <span>return</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在完成组件的整个 <code>patch</code> 过程后，最后执行 <code>insert(parentElm, vnode.elm, refElm)</code> 完成组件的 DOM 插入，如果组件 <code>patch</code> 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么到此，一个组件的 VNode 是如何创建、初始化、渲染的过程也就介绍完毕了。在对组件化的实现有一个大概了解后，接下来我们来介绍一下这其中的一些细节。我们知道编写一个组件实际上是编写一个 JavaScript 对象，对象的描述就是各种配置，之前我们提到在 <code>_init</code> 的最初阶段执行的就是 <code>merge options</code> 的逻辑，那么下一节我们从源码角度来分析合并配置的过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">createElement</title>
    <id>https://0808200.xyz/vue2/data-driven/create-element.html</id>
    <link href="https://0808200.xyz/vue2/data-driven/create-element.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="createelement" tabindex="-1"> createElement</h1>
<p>Vue.js 利用 createElement 方法创建 VNode，它定义在 <code>src/core/vdom/create-element.js</code> 中：</p>
<div><pre><code><span>// wrapper function for providing a more flexible interface</span>
<span>// without getting yelled at by flow</span>
<span>export</span> <span>function</span> <span>createElement</span> <span>(</span>
  <span><span>context</span><span>:</span> Component<span>,</span>
  <span>tag</span><span>:</span> any<span>,</span>
  <span>data</span><span>:</span> any<span>,</span>
  <span>children</span><span>:</span> any<span>,</span>
  <span>normalizationType</span><span>:</span> any<span>,</span>
  <span>alwaysNormalize</span><span>:</span> boolean</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>data<span>)</span> <span>||</span> <span>isPrimitive</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
    normalizationType <span>=</span> children
    children <span>=</span> data
    data <span>=</span> <span>undefined</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>alwaysNormalize<span>)</span><span>)</span> <span>{</span>
    normalizationType <span>=</span> <span>ALWAYS_NORMALIZE</span>
  <span>}</span>
  <span>return</span> <span>_createElement</span><span>(</span>context<span>,</span> tag<span>,</span> data<span>,</span> children<span>,</span> normalizationType<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数 <code>_createElement</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>_createElement</span> <span>(</span>
  <span><span>context</span><span>:</span> Component<span>,</span>
  tag<span>?</span><span>:</span> string <span>|</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object<span>,</span>
  data<span>?</span><span>:</span> VNodeData<span>,</span>
  children<span>?</span><span>:</span> any<span>,</span>
  normalizationType<span>?</span><span>:</span> number</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span><span>(</span>data<span>:</span> any<span>)</span><span>.</span>__ob__<span>)</span><span>)</span> <span>{</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
      <span><span>`</span><span>Avoid using observed data object as vnode data: </span><span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>data<span>)</span><span>}</span></span><span>\n</span><span>`</span></span> <span>+</span>
      <span>'Always create fresh vnode data objects in each render!'</span><span>,</span>
      context
    <span>)</span>
    <span>return</span> <span>createEmptyVNode</span><span>(</span><span>)</span>
  <span>}</span>
  <span>// object syntax in v-bind</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>data<span>.</span>is<span>)</span><span>)</span> <span>{</span>
    tag <span>=</span> data<span>.</span>is
  <span>}</span>
  <span>if</span> <span>(</span><span>!</span>tag<span>)</span> <span>{</span>
    <span>// in case of component :is set to falsy value</span>
    <span>return</span> <span>createEmptyVNode</span><span>(</span><span>)</span>
  <span>}</span>
  <span>// warn against non-primitive key</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    <span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>data<span>.</span>key<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isPrimitive</span><span>(</span>data<span>.</span>key<span>)</span>
  <span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>__WEEX__ <span>||</span> <span>!</span><span>(</span><span>'@binding'</span> <span>in</span> data<span>.</span>key<span>)</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'Avoid using non-primitive value as key, '</span> <span>+</span>
        <span>'use string/number value instead.'</span><span>,</span>
        context
      <span>)</span>
    <span>}</span>
  <span>}</span>
  <span>// support single function children as default scoped slot</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>children<span>)</span> <span>&amp;&amp;</span>
    <span>typeof</span> children<span>[</span><span>0</span><span>]</span> <span>===</span> <span>'function'</span>
  <span>)</span> <span>{</span>
    data <span>=</span> data <span>||</span> <span>{</span><span>}</span>
    data<span>.</span>scopedSlots <span>=</span> <span>{</span> <span>default</span><span>:</span> children<span>[</span><span>0</span><span>]</span> <span>}</span>
    children<span>.</span>length <span>=</span> <span>0</span>
  <span>}</span>
  <span>if</span> <span>(</span>normalizationType <span>===</span> <span>ALWAYS_NORMALIZE</span><span>)</span> <span>{</span>
    children <span>=</span> <span>normalizeChildren</span><span>(</span>children<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>normalizationType <span>===</span> <span>SIMPLE_NORMALIZE</span><span>)</span> <span>{</span>
    children <span>=</span> <span>simpleNormalizeChildren</span><span>(</span>children<span>)</span>
  <span>}</span>
  <span>let</span> vnode<span>,</span> ns
  <span>if</span> <span>(</span><span>typeof</span> tag <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
    <span>let</span> Ctor
    ns <span>=</span> <span>(</span>context<span>.</span>$vnode <span>&amp;&amp;</span> context<span>.</span>$vnode<span>.</span>ns<span>)</span> <span>||</span> config<span>.</span><span>getTagNamespace</span><span>(</span>tag<span>)</span>
    <span>if</span> <span>(</span>config<span>.</span><span>isReservedTag</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
      <span>// platform built-in elements</span>
      vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
        config<span>.</span><span>parsePlatformTagName</span><span>(</span>tag<span>)</span><span>,</span> data<span>,</span> children<span>,</span>
        <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
      <span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>Ctor <span>=</span> <span>resolveAsset</span><span>(</span>context<span>.</span>$options<span>,</span> <span>'components'</span><span>,</span> tag<span>)</span><span>)</span><span>)</span> <span>{</span>
      <span>// component</span>
      vnode <span>=</span> <span>createComponent</span><span>(</span>Ctor<span>,</span> data<span>,</span> context<span>,</span> children<span>,</span> tag<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// unknown or unlisted namespaced elements</span>
      <span>// check at runtime because it may get assigned a namespace when its</span>
      <span>// parent normalizes children</span>
      vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
        tag<span>,</span> data<span>,</span> children<span>,</span>
        <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
      <span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// direct component options / constructor</span>
    vnode <span>=</span> <span>createComponent</span><span>(</span>tag<span>,</span> data<span>,</span> context<span>,</span> children<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
    <span>return</span> vnode
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>ns<span>)</span><span>)</span> <span>applyNS</span><span>(</span>vnode<span>,</span> ns<span>)</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>registerDeepBindings</span><span>(</span>data<span>)</span>
    <span>return</span> vnode
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span>createEmptyVNode</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>_createElement</code> 方法有 5 个参数，<code>context</code> 表示 VNode 的上下文环境，它是 <code>Component</code> 类型；<code>tag</code> 表示标签，它可以是一个字符串，也可以是一个 <code>Component</code>；<code>data</code> 表示 VNode 的数据，它是一个 <code>VNodeData</code> 类型，可以在 <code>flow/vnode.js</code> 中找到它的定义，这里先不展开说；<code>children</code> 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准的 VNode 数组；<code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 <code>render</code> 函数是编译生成的还是用户手写的。</p>
<p><code>createElement</code> 函数的流程略微有点多，我们接下来主要分析 2 个重点的流程 —— <code>children</code> 的规范化以及 VNode 的创建。</p>
<h2 id="children-的规范化" tabindex="-1"> children 的规范化</h2>
<p>由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。<code>_createElement</code> 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。</p>
<p>这里根据 <code>normalizationType</code> 的不同，调用了 <code>normalizeChildren(children)</code> 和 <code>simpleNormalizeChildren(children)</code> 方法，它们的定义都在 <code>src/core/vdom/helpers/normalzie-children.js</code> 中：</p>
<div><pre><code><span>// The template compiler attempts to minimize the need for normalization by</span>
<span>// statically analyzing the template at compile time.</span>
<span>//</span>
<span>// For plain HTML markup, normalization can be completely skipped because the</span>
<span>// generated render function is guaranteed to return Array&lt;VNode>. There are</span>
<span>// two cases where extra normalization is needed:</span>

<span>// 1. When the children contains components - because a functional component</span>
<span>// may return an Array instead of a single root. In this case, just a simple</span>
<span>// normalization is needed - if any child is an Array, we flatten the whole</span>
<span>// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep</span>
<span>// because functional components already normalize their own children.</span>
<span>export</span> <span>function</span> <span>simpleNormalizeChildren</span> <span>(</span><span><span>children</span><span>:</span> any</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>children<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
      <span>return</span> <span>Array</span><span>.</span>prototype<span>.</span><span>concat</span><span>.</span><span>apply</span><span>(</span><span>[</span><span>]</span><span>,</span> children<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> children
<span>}</span>

<span>// 2. When the children contains constructs that always generated nested Arrays,</span>
<span>// e.g. &lt;template>, &lt;slot>, v-for, or when the children is provided by user</span>
<span>// with hand-written render functions / JSX. In such cases a full normalization</span>
<span>// is needed to cater to all possible types of children values.</span>
<span>export</span> <span>function</span> <span>normalizeChildren</span> <span>(</span><span><span>children</span><span>:</span> any</span><span>)</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>return</span> <span>isPrimitive</span><span>(</span>children<span>)</span>
    <span>?</span> <span>[</span><span>createTextVNode</span><span>(</span>children<span>)</span><span>]</span>
    <span>:</span> Array<span>.</span><span>isArray</span><span>(</span>children<span>)</span>
      <span>?</span> <span>normalizeArrayChildren</span><span>(</span>children<span>)</span>
      <span>:</span> <span>undefined</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>simpleNormalizeChildren</code> 方法调用场景是 <code>render</code> 函数是编译生成的。理论上编译生成的 <code>children</code> 都已经是 VNode 类型的，但这里有一个例外，就是 <code>functional component</code> 函数式组件返回的是一个数组而不是一个根节点，所以会通过 <code>Array.prototype.concat</code> 方法把整个 <code>children</code> 数组打平，让它的深度只有一层。</p>
<p><code>normalizeChildren</code> 方法的调用场景有 2 种，一个场景是 <code>render</code> 函数是用户手写的，当 <code>children</code> 只有一个节点的时候，Vue.js 从接口层面允许用户把 <code>children</code> 写成基础类型用来创建单个简单的文本节点，这种情况会调用 <code>createTextVNode</code> 创建一个文本节点的 VNode；另一个场景是当编译 <code>slot</code>、<code>v-for</code> 的时候会产生嵌套数组的情况，会调用 <code>normalizeArrayChildren</code> 方法，接下来看一下它的实现：</p>
<div><pre><code><span>function</span> <span>normalizeArrayChildren</span> <span>(</span><span><span>children</span><span>:</span> any<span>,</span> nestedIndex<span>?</span><span>:</span> string</span><span>)</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>let</span> i<span>,</span> c<span>,</span> lastIndex<span>,</span> last
  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    c <span>=</span> children<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>c<span>)</span> <span>||</span> <span>typeof</span> c <span>===</span> <span>'boolean'</span><span>)</span> <span>continue</span>
    lastIndex <span>=</span> res<span>.</span>length <span>-</span> <span>1</span>
    last <span>=</span> res<span>[</span>lastIndex<span>]</span>
    <span>//  nested</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>c<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>c<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
        c <span>=</span> <span>normalizeArrayChildren</span><span>(</span>c<span>,</span> <span><span>`</span><span><span>${</span>nestedIndex <span>||</span> <span>''</span><span>}</span></span><span>_</span><span><span>${</span>i<span>}</span></span><span>`</span></span><span>)</span>
        <span>// merge adjacent text nodes</span>
        <span>if</span> <span>(</span><span>isTextNode</span><span>(</span>c<span>[</span><span>0</span><span>]</span><span>)</span> <span>&amp;&amp;</span> <span>isTextNode</span><span>(</span>last<span>)</span><span>)</span> <span>{</span>
          res<span>[</span>lastIndex<span>]</span> <span>=</span> <span>createTextVNode</span><span>(</span>last<span>.</span>text <span>+</span> <span>(</span>c<span>[</span><span>0</span><span>]</span><span>:</span> any<span>)</span><span>.</span>text<span>)</span>
          c<span>.</span><span>shift</span><span>(</span><span>)</span>
        <span>}</span>
        res<span>.</span><span>push</span><span>.</span><span>apply</span><span>(</span>res<span>,</span> c<span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isPrimitive</span><span>(</span>c<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isTextNode</span><span>(</span>last<span>)</span><span>)</span> <span>{</span>
        <span>// merge adjacent text nodes</span>
        <span>// this is necessary for SSR hydration because text nodes are</span>
        <span>// essentially merged when rendered to HTML strings</span>
        res<span>[</span>lastIndex<span>]</span> <span>=</span> <span>createTextVNode</span><span>(</span>last<span>.</span>text <span>+</span> c<span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>c <span>!==</span> <span>''</span><span>)</span> <span>{</span>
        <span>// convert primitive to vnode</span>
        res<span>.</span><span>push</span><span>(</span><span>createTextVNode</span><span>(</span>c<span>)</span><span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span><span>isTextNode</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> <span>isTextNode</span><span>(</span>last<span>)</span><span>)</span> <span>{</span>
        <span>// merge adjacent text nodes</span>
        res<span>[</span>lastIndex<span>]</span> <span>=</span> <span>createTextVNode</span><span>(</span>last<span>.</span>text <span>+</span> c<span>.</span>text<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>// default key for nested array children (likely generated by v-for)</span>
        <span>if</span> <span>(</span><span>isTrue</span><span>(</span>children<span>.</span>_isVList<span>)</span> <span>&amp;&amp;</span>
          <span>isDef</span><span>(</span>c<span>.</span>tag<span>)</span> <span>&amp;&amp;</span>
          <span>isUndef</span><span>(</span>c<span>.</span>key<span>)</span> <span>&amp;&amp;</span>
          <span>isDef</span><span>(</span>nestedIndex<span>)</span><span>)</span> <span>{</span>
          c<span>.</span>key <span>=</span> <span><span>`</span><span>__vlist</span><span><span>${</span>nestedIndex<span>}</span></span><span>_</span><span><span>${</span>i<span>}</span></span><span>__</span><span>`</span></span>
        <span>}</span>
        res<span>.</span><span>push</span><span>(</span>c<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>normalizeArrayChildren</code> 接收 2 个参数，<code>children</code> 表示要规范的子节点，<code>nestedIndex</code> 表示嵌套的索引，因为单个 <code>child</code> 可能是一个数组类型。 <code>normalizeArrayChildren</code> 主要的逻辑就是遍历 <code>children</code>，获得单个节点 <code>c</code>，然后对 <code>c</code> 的类型判断，如果是一个数组类型，则递归调用 <code>normalizeArrayChildren</code>; 如果是基础类型，则通过 <code>createTextVNode</code> 方法转换成 VNode 类型；否则就已经是 VNode 类型了，如果 <code>children</code> 是一个列表并且列表还存在嵌套的情况，则根据 <code>nestedIndex</code> 去更新它的 key。这里需要注意一点，在遍历的过程中，对这 3 种情况都做了如下处理：如果存在两个连续的 <code>text</code> 节点，会把它们合并成一个 <code>text</code> 节点。</p>
<p>经过对 <code>children</code> 的规范化，<code>children</code> 变成了一个类型为 VNode 的 Array。</p>
<h2 id="vnode-的创建" tabindex="-1"> VNode 的创建</h2>
<p>回到 <code>createElement</code> 函数，规范化 <code>children</code> 后，接下来会去创建一个 VNode 的实例：</p>
<div><pre><code><span>let</span> vnode<span>,</span> ns
<span>if</span> <span>(</span><span>typeof</span> tag <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
  <span>let</span> Ctor
  ns <span>=</span> <span>(</span>context<span>.</span>$vnode <span>&amp;&amp;</span> context<span>.</span>$vnode<span>.</span>ns<span>)</span> <span>||</span> config<span>.</span><span>getTagNamespace</span><span>(</span>tag<span>)</span>
  <span>if</span> <span>(</span>config<span>.</span><span>isReservedTag</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
    <span>// platform built-in elements</span>
    vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
      config<span>.</span><span>parsePlatformTagName</span><span>(</span>tag<span>)</span><span>,</span> data<span>,</span> children<span>,</span>
      <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
    <span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>Ctor <span>=</span> <span>resolveAsset</span><span>(</span>context<span>.</span>$options<span>,</span> <span>'components'</span><span>,</span> tag<span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>// component</span>
    vnode <span>=</span> <span>createComponent</span><span>(</span>Ctor<span>,</span> data<span>,</span> context<span>,</span> children<span>,</span> tag<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// unknown or unlisted namespaced elements</span>
    <span>// check at runtime because it may get assigned a namespace when its</span>
    <span>// parent normalizes children</span>
    vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
      tag<span>,</span> data<span>,</span> children<span>,</span>
      <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context
    <span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// direct component options / constructor</span>
  vnode <span>=</span> <span>createComponent</span><span>(</span>tag<span>,</span> data<span>,</span> context<span>,</span> children<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里先对 <code>tag</code> 做判断，如果是 <code>string</code> 类型，则接着判断如果是内置的一些节点，则直接创建一个普通 VNode，如果是为已注册的组件名，则通过 <code>createComponent</code> 创建一个组件类型的 VNode，否则创建一个未知的标签的 VNode。 如果 <code>tag</code> 是一个 <code>Component</code> 类型，则直接调用 <code>createComponent</code> 创建一个组件类型的 VNode 节点。对于 <code>createComponent</code> 创建组件类型的 VNode 的过程，我们之后会去介绍，本质上它还是返回了一个 VNode。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，我们大致了解了 <code>createElement</code> 创建 VNode 的过程，每个 VNode 有 <code>children</code>，<code>children</code> 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。</p>
<p>回到 <code>mountComponent</code> 函数的过程，我们已经知道 <code>vm._render</code> 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 <code>vm._update</code> 完成的，接下来分析一下这个过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">数据驱动</title>
    <id>https://0808200.xyz/vue2/data-driven/</id>
    <link href="https://0808200.xyz/vue2/data-driven/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据驱动" tabindex="-1"> 数据驱动</h1>
<p>Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。</p>
<p>在 Vue.js 中我们可以采用简洁的模板语法来声明式的将数据渲染为 DOM：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  {{ message }}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>'Hello Vue!'</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最终它会在页面上渲染出 <code>Hello Vue</code>。接下来，我们会从源码角度来分析 Vue 是如何实现的，分析过程会以主线代码为主，重要的分支逻辑会放在之后单独分析。数据驱动还有一部分是数据更新驱动视图变化，这一块内容我们也会在之后的章节分析，这一章我们的目标是弄清楚模板和数据如何渲染成最终的 DOM。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue 实例挂载的实现</title>
    <id>https://0808200.xyz/vue2/data-driven/mounted.html</id>
    <link href="https://0808200.xyz/vue2/data-driven/mounted.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vue-实例挂载的实现" tabindex="-1"> Vue 实例挂载的实现</h1>
<p>Vue 中我们是通过 <code>$mount</code> 实例方法去挂载 <code>vm</code> 的，<code>$mount</code> 方法在多个文件中都有定义，如 <code>src/platform/web/entry-runtime-with-compiler.js</code>、<code>src/platform/web/runtime/index.js</code>、<code>src/platform/weex/runtime/index.js</code>。因为 <code>$mount</code> 这个方法的实现是和平台、构建方式都相关的。接下来我们重点分析带 <code>compiler</code> 版本的 <code>$mount</code> 实现，因为抛开 webpack 的 vue-loader，我们在纯前端浏览器环境分析 Vue 的工作原理，有助于我们对原理理解的深入。</p>
<p><code>compiler</code> 版本的 <code>$mount</code> 实现非常有意思，先来看一下 <code>src/platform/web/entry-runtime-with-compiler.js</code> 文件中定义：</p>
<div><pre><code><span>const</span> mount <span>=</span> <span>Vue</span><span>.</span>prototype<span>.</span>$mount
<span>Vue</span><span>.</span>prototype<span>.</span><span>$mount</span> <span>=</span> <span>function</span> <span>(</span>
  <span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  el <span>=</span> el <span>&amp;&amp;</span> <span>query</span><span>(</span>el<span>)</span>

  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>el <span>===</span> document<span>.</span>body <span>||</span> el <span>===</span> document<span>.</span>documentElement<span>)</span> <span>{</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
      <span><span>`</span><span>Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.</span><span>`</span></span>
    <span>)</span>
    <span>return</span> <span>this</span>
  <span>}</span>

  <span>const</span> options <span>=</span> <span>this</span><span>.</span>$options
  <span>// resolve template/el and convert to render function</span>
  <span>if</span> <span>(</span><span>!</span>options<span>.</span>render<span>)</span> <span>{</span>
    <span>let</span> template <span>=</span> options<span>.</span>template
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> template <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>template<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'#'</span><span>)</span> <span>{</span>
          template <span>=</span> <span>idToTemplate</span><span>(</span>template<span>)</span>
          <span>/* istanbul ignore if */</span>
          <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>template<span>)</span> <span>{</span>
            <span>warn</span><span>(</span>
              <span><span>`</span><span>Template element not found or is empty: </span><span><span>${</span>options<span>.</span>template<span>}</span></span><span>`</span></span><span>,</span>
              <span>this</span>
            <span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>template<span>.</span>nodeType<span>)</span> <span>{</span>
        template <span>=</span> template<span>.</span>innerHTML
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
          <span>warn</span><span>(</span><span>'invalid template option:'</span> <span>+</span> template<span>,</span> <span>this</span><span>)</span>
        <span>}</span>
        <span>return</span> <span>this</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>)</span> <span>{</span>
      template <span>=</span> <span>getOuterHTML</span><span>(</span>el<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
        <span>mark</span><span>(</span><span>'compile'</span><span>)</span>
      <span>}</span>

      <span>const</span> <span>{</span> render<span>,</span> staticRenderFns <span>}</span> <span>=</span> <span>compileToFunctions</span><span>(</span>template<span>,</span> <span>{</span>
        shouldDecodeNewlines<span>,</span>
        shouldDecodeNewlinesForHref<span>,</span>
        <span>delimiters</span><span>:</span> options<span>.</span>delimiters<span>,</span>
        <span>comments</span><span>:</span> options<span>.</span>comments
      <span>}</span><span>,</span> <span>this</span><span>)</span>
      options<span>.</span>render <span>=</span> render
      options<span>.</span>staticRenderFns <span>=</span> staticRenderFns

      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
        <span>mark</span><span>(</span><span>'compile end'</span><span>)</span>
        <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span><span>this</span><span>.</span>_name<span>}</span></span><span> compile</span><span>`</span></span><span>,</span> <span>'compile'</span><span>,</span> <span>'compile end'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>mount</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> el<span>,</span> hydrating<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段代码首先缓存了原型上的 <code>$mount</code> 方法，再重新定义该方法，我们先来分析这段代码。首先，它对 <code>el</code> 做了限制，Vue 不能挂载在 <code>body</code>、<code>html</code> 这样的根节点上。接下来的是很关键的逻辑 —— 如果没有定义 <code>render</code> 方法，则会把 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code> 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 <code>render</code> 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 <code>el</code> 或者 <code>template</code> 属性，最终都会转换成 <code>render</code> 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 <code>compileToFunctions</code> 方法实现的，编译过程我们之后会介绍。最后，调用原先原型上的 <code>$mount</code> 方法挂载。</p>
<p>原先原型上的 <code>$mount</code> 方法在 <code>src/platform/web/runtime/index.js</code> 中定义，之所以这么设计完全是为了复用，因为它是可以被 <code>runtime only</code> 版本的 Vue 直接使用的。</p>
<div><pre><code><span>// public mount method</span>
<span>Vue</span><span>.</span>prototype<span>.</span><span>$mount</span> <span>=</span> <span>function</span> <span>(</span>
  <span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  el <span>=</span> el <span>&amp;&amp;</span> inBrowser <span>?</span> <span>query</span><span>(</span>el<span>)</span> <span>:</span> <span>undefined</span>
  <span>return</span> <span>mountComponent</span><span>(</span><span>this</span><span>,</span> el<span>,</span> hydrating<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>$mount</code> 方法支持传入 2 个参数，第一个是 <code>el</code>，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 <code>query</code> 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。</p>
<p><code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mountComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>el</span><span>:</span> <span>?</span>Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  vm<span>.</span>$el <span>=</span> el
  <span>if</span> <span>(</span><span>!</span>vm<span>.</span>$options<span>.</span>render<span>)</span> <span>{</span>
    vm<span>.</span>$options<span>.</span>render <span>=</span> createEmptyVNode
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span><span>(</span>vm<span>.</span>$options<span>.</span>template <span>&amp;&amp;</span> vm<span>.</span>$options<span>.</span>template<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>!==</span> <span>'#'</span><span>)</span> <span>||</span>
        vm<span>.</span>$options<span>.</span>el <span>||</span> el<span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'You are using the runtime-only build of Vue where the template '</span> <span>+</span>
          <span>'compiler is not available. Either pre-compile the templates into '</span> <span>+</span>
          <span>'render functions, or use the compiler-included build.'</span><span>,</span>
          vm
        <span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'Failed to mount component: template or render function not defined.'</span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeMount'</span><span>)</span>

  <span>let</span> updateComponent
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
    <span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> name <span>=</span> vm<span>.</span>_name
      <span>const</span> id <span>=</span> vm<span>.</span>_uid
      <span>const</span> startTag <span>=</span> <span><span>`</span><span>vue-perf-start:</span><span><span>${</span>id<span>}</span></span><span>`</span></span>
      <span>const</span> endTag <span>=</span> <span><span>`</span><span>vue-perf-end:</span><span><span>${</span>id<span>}</span></span><span>`</span></span>

      <span>mark</span><span>(</span>startTag<span>)</span>
      <span>const</span> vnode <span>=</span> vm<span>.</span><span>_render</span><span>(</span><span>)</span>
      <span>mark</span><span>(</span>endTag<span>)</span>
      <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span>name<span>}</span></span><span> render</span><span>`</span></span><span>,</span> startTag<span>,</span> endTag<span>)</span>

      <span>mark</span><span>(</span>startTag<span>)</span>
      vm<span>.</span><span>_update</span><span>(</span>vnode<span>,</span> hydrating<span>)</span>
      <span>mark</span><span>(</span>endTag<span>)</span>
      <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span>name<span>}</span></span><span> patch</span><span>`</span></span><span>,</span> startTag<span>,</span> endTag<span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// we set this to vm._watcher inside the watcher's constructor</span>
  <span>// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>
  <span>// component's mounted hook), which relies on vm._watcher being already defined</span>
  <span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> updateComponent<span>,</span> noop<span>,</span> <span>{</span>
    <span>before</span> <span>(</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>vm<span>.</span>_isMounted<span>)</span> <span>{</span>
        <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeUpdate'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>true</span> <span>/* isRenderWatcher */</span><span>)</span>
  hydrating <span>=</span> <span>false</span>

  <span>// manually mounted instance, call mounted on self</span>
  <span>// mounted is called for render-created child components in its inserted hook</span>
  <span>if</span> <span>(</span>vm<span>.</span>$vnode <span>==</span> <span>null</span><span>)</span> <span>{</span>
    vm<span>.</span>_isMounted <span>=</span> <span>true</span>
    <span>callHook</span><span>(</span>vm<span>,</span> <span>'mounted'</span><span>)</span>
  <span>}</span>
  <span>return</span> vm
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>从上面的代码可以看到，<code>mountComponent</code> 核心就是先实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法，在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 DOM。</p>
<p><code>Watcher</code> 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数，这块儿我们会在之后的章节中介绍。</p>
<p>函数最后判断为根节点的时候设置 <code>vm._isMounted</code> 为 <code>true</code>， 表示这个实例已经挂载了，同时执行 <code>mounted</code> 钩子函数。 这里注意 <code>vm.$vnode</code> 表示 Vue 实例的父虚拟 Node，所以它为 <code>Null</code> 则表示当前是根 Vue 的实例。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p><code>mountComponent</code> 方法的逻辑也是非常清晰的，它会完成整个渲染工作，接下来我们要重点分析其中的细节，也就是最核心的 2 个方法：<code>vm._render</code> 和 <code>vm._update</code>。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">new Vue 发生了什么</title>
    <id>https://0808200.xyz/vue2/data-driven/new-vue.html</id>
    <link href="https://0808200.xyz/vue2/data-driven/new-vue.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="new-vue-发生了什么" tabindex="-1"> new Vue 发生了什么</h1>
<p>从入口代码开始分析，我们先来分析 <code>new Vue</code> 背后发生了哪些事情。我们都知道，<code>new</code> 关键字在 Javascript 语言中代表实例化是一个对象，而 <code>Vue</code> 实际上是一个类，类在 Javascript 中是用 Function 来实现的，来看一下源码，在<code>src/core/instance/index.js</code> 中。</p>
<div><pre><code><span>function</span> <span>Vue</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    <span>!</span><span>(</span><span>this</span> <span>instanceof</span> <span>Vue</span><span>)</span>
  <span>)</span> <span>{</span>
    <span>warn</span><span>(</span><span>'Vue is a constructor and should be called with the `new` keyword'</span><span>)</span>
  <span>}</span>
  <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 <code>Vue</code> 只能通过 new 关键字初始化，然后会调用 <code>this._init</code> 方法， 该方法在 <code>src/core/instance/init.js</code> 中定义。</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_init</span> <span>=</span> <span>function</span> <span>(</span><span>options<span>?</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>// a uid</span>
  vm<span>.</span>_uid <span>=</span> uid<span>++</span>

  <span>let</span> startTag<span>,</span> endTag
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
    startTag <span>=</span> <span><span>`</span><span>vue-perf-start:</span><span><span>${</span>vm<span>.</span>_uid<span>}</span></span><span>`</span></span>
    endTag <span>=</span> <span><span>`</span><span>vue-perf-end:</span><span><span>${</span>vm<span>.</span>_uid<span>}</span></span><span>`</span></span>
    <span>mark</span><span>(</span>startTag<span>)</span>
  <span>}</span>

  <span>// a flag to avoid this being observed</span>
  vm<span>.</span>_isVue <span>=</span> <span>true</span>
  <span>// merge options</span>
  <span>if</span> <span>(</span>options <span>&amp;&amp;</span> options<span>.</span>_isComponent<span>)</span> <span>{</span>
    <span>// optimize internal component instantiation</span>
    <span>// since dynamic options merging is pretty slow, and none of the</span>
    <span>// internal component options needs special treatment.</span>
    <span>initInternalComponent</span><span>(</span>vm<span>,</span> options<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    vm<span>.</span>$options <span>=</span> <span>mergeOptions</span><span>(</span>
      <span>resolveConstructorOptions</span><span>(</span>vm<span>.</span>constructor<span>)</span><span>,</span>
      options <span>||</span> <span>{</span><span>}</span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  <span>/* istanbul ignore else */</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>initProxy</span><span>(</span>vm<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    vm<span>.</span>_renderProxy <span>=</span> vm
  <span>}</span>
  <span>// expose real self</span>
  vm<span>.</span>_self <span>=</span> vm
  <span>initLifecycle</span><span>(</span>vm<span>)</span>
  <span>initEvents</span><span>(</span>vm<span>)</span>
  <span>initRender</span><span>(</span>vm<span>)</span>
  <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeCreate'</span><span>)</span>
  <span>initInjections</span><span>(</span>vm<span>)</span> <span>// resolve injections before data/props</span>
  <span>initState</span><span>(</span>vm<span>)</span>
  <span>initProvide</span><span>(</span>vm<span>)</span> <span>// resolve provide after data/props</span>
  <span>callHook</span><span>(</span>vm<span>,</span> <span>'created'</span><span>)</span>

  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
    vm<span>.</span>_name <span>=</span> <span>formatComponentName</span><span>(</span>vm<span>,</span> <span>false</span><span>)</span>
    <span>mark</span><span>(</span>endTag<span>)</span>
    <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span>vm<span>.</span>_name<span>}</span></span><span> init</span><span>`</span></span><span>,</span> startTag<span>,</span> endTag<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span>vm<span>.</span>$options<span>.</span>el<span>)</span> <span>{</span>
    vm<span>.</span><span>$mount</span><span>(</span>vm<span>.</span>$options<span>.</span>el<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>Vue 的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，这样的编程思想是非常值得借鉴和学习的。</p>
<p>由于我们这一章的目标是弄清楚模板和数据如何渲染成最终的 DOM，所以各种初始化逻辑我们先不看。在初始化的最后，检测到如果有 <code>el</code> 属性，则调用 <code>vm.$mount</code> 方法挂载 <code>vm</code>，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">render</title>
    <id>https://0808200.xyz/vue2/data-driven/render.html</id>
    <link href="https://0808200.xyz/vue2/data-driven/render.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="render" tabindex="-1"> render</h1>
<p>Vue 的 <code>_render</code> 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 <code>src/core/instance/render.js</code> 文件中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_render</span> <span>=</span> <span>function</span> <span>(</span><span>)</span><span>:</span> VNode <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>const</span> <span>{</span> render<span>,</span> _parentVnode <span>}</span> <span>=</span> vm<span>.</span>$options

  <span>// reset _rendered flag on slots for duplicate slot check</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> vm<span>.</span>$slots<span>)</span> <span>{</span>
      <span>// $flow-disable-line</span>
      vm<span>.</span>$slots<span>[</span>key<span>]</span><span>.</span>_rendered <span>=</span> <span>false</span>
    <span>}</span>
  <span>}</span>

  <span>if</span> <span>(</span>_parentVnode<span>)</span> <span>{</span>
    vm<span>.</span>$scopedSlots <span>=</span> _parentVnode<span>.</span>data<span>.</span>scopedSlots <span>||</span> emptyObject
  <span>}</span>

  <span>// set parent vnode. this allows render functions to have access</span>
  <span>// to the data on the placeholder node.</span>
  vm<span>.</span>$vnode <span>=</span> _parentVnode
  <span>// render self</span>
  <span>let</span> vnode
  <span>try</span> <span>{</span>
    vnode <span>=</span> <span>render</span><span>.</span><span>call</span><span>(</span>vm<span>.</span>_renderProxy<span>,</span> vm<span>.</span>$createElement<span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    <span>handleError</span><span>(</span>e<span>,</span> vm<span>,</span> <span><span>`</span><span>render</span><span>`</span></span><span>)</span>
    <span>// return error render result,</span>
    <span>// or previous vnode to prevent render error causing blank component</span>
    <span>/* istanbul ignore else */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>vm<span>.</span>$options<span>.</span>renderError<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
          vnode <span>=</span> vm<span>.</span>$options<span>.</span><span>renderError</span><span>.</span><span>call</span><span>(</span>vm<span>.</span>_renderProxy<span>,</span> vm<span>.</span>$createElement<span>,</span> e<span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
          <span>handleError</span><span>(</span>e<span>,</span> vm<span>,</span> <span><span>`</span><span>renderError</span><span>`</span></span><span>)</span>
          vnode <span>=</span> vm<span>.</span>_vnode
        <span>}</span>
      <span>}</span> <span>else</span> <span>{</span>
        vnode <span>=</span> vm<span>.</span>_vnode
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      vnode <span>=</span> vm<span>.</span>_vnode
    <span>}</span>
  <span>}</span>
  <span>// return empty vnode in case the render function errored out</span>
  <span>if</span> <span>(</span><span>!</span><span>(</span>vnode <span>instanceof</span> <span>VNode</span><span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> Array<span>.</span><span>isArray</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'Multiple root nodes returned from render function. Render function '</span> <span>+</span>
        <span>'should return a single root node.'</span><span>,</span>
        vm
      <span>)</span>
    <span>}</span>
    vnode <span>=</span> <span>createEmptyVNode</span><span>(</span><span>)</span>
  <span>}</span>
  <span>// set parent</span>
  vnode<span>.</span>parent <span>=</span> _parentVnode
  <span>return</span> vnode
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段代码最关键的是 <code>render</code> 方法的调用，我们在平时的开发工作中手写 <code>render</code> 方法的场景比较少，而写的比较多的是 <code>template</code> 模板，在之前的 <code>mounted</code> 方法的实现中，会把 <code>template</code> 编译成 <code>render</code> 方法，但这个编译过程是非常复杂的，我们不打算在这里展开讲，之后会专门花一个章节来分析 Vue 的编译过程。</p>
<p>在 Vue 的官方文档中介绍了 <code>render</code> 函数的第一个参数是 <code>createElement</code>，那么结合之前的例子：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  {{ message }}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>相当于我们编写如下 <code>render</code> 函数：</p>
<div><pre><code><span>render</span><span>:</span> <span>function</span> <span>(</span><span>createElement</span><span>)</span> <span>{</span>
  <span>return</span> <span>createElement</span><span>(</span><span>'div'</span><span>,</span> <span>{</span>
     <span>attrs</span><span>:</span> <span>{</span>
        <span>id</span><span>:</span> <span>'app'</span>
      <span>}</span><span>,</span>
  <span>}</span><span>,</span> <span>this</span><span>.</span>message<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再回到 <code>_render</code> 函数中的 <code>render</code> 方法的调用：</p>
<div><pre><code>vnode <span>=</span> <span>render</span><span>.</span><span>call</span><span>(</span>vm<span>.</span>_renderProxy<span>,</span> vm<span>.</span>$createElement<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>可以看到，<code>render</code> 函数中的 <code>createElement</code> 方法就是 <code>vm.$createElement</code> 方法：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initRender</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>// bind the createElement fn to this instance</span>
  <span>// so that we get proper render context inside it.</span>
  <span>// args order: tag, data, children, normalizationType, alwaysNormalize</span>
  <span>// internal version is used by render functions compiled from templates</span>
  vm<span>.</span><span>_c</span> <span>=</span> <span>(</span><span>a<span>,</span> b<span>,</span> c<span>,</span> d</span><span>)</span> <span>=></span> <span>createElement</span><span>(</span>vm<span>,</span> a<span>,</span> b<span>,</span> c<span>,</span> d<span>,</span> <span>false</span><span>)</span>
  <span>// normalization is always applied for the public version, used in</span>
  <span>// user-written render functions.</span>
  vm<span>.</span><span>$createElement</span> <span>=</span> <span>(</span><span>a<span>,</span> b<span>,</span> c<span>,</span> d</span><span>)</span> <span>=></span> <span>createElement</span><span>(</span>vm<span>,</span> a<span>,</span> b<span>,</span> c<span>,</span> d<span>,</span> <span>true</span><span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上，<code>vm.$createElement</code> 方法定义是在执行 <code>initRender</code> 方法的时候，可以看到除了 <code>vm.$createElement</code> 方法，还有一个 <code>vm._c</code> 方法，它是被模板编译成的 <code>render</code> 函数使用，而 <code>vm.$createElement</code> 是用户手写 <code>render</code> 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 <code>createElement</code> 方法。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p><code>vm._render</code> 最终是通过执行 <code>createElement</code> 方法并返回的是 <code>vnode</code>，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 <code>createElement</code> 的实现前，我们先了解一下 Virtual DOM 的概念。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">update</title>
    <id>https://0808200.xyz/vue2/data-driven/update.html</id>
    <link href="https://0808200.xyz/vue2/data-driven/update.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="update" tabindex="-1"> update</h1>
<p>Vue 的 <code>_update</code> 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。<code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_update</span> <span>=</span> <span>function</span> <span>(</span><span><span>vnode</span><span>:</span> VNode<span>,</span> hydrating<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>const</span> prevEl <span>=</span> vm<span>.</span>$el
  <span>const</span> prevVnode <span>=</span> vm<span>.</span>_vnode
  <span>const</span> prevActiveInstance <span>=</span> activeInstance
  activeInstance <span>=</span> vm
  vm<span>.</span>_vnode <span>=</span> vnode
  <span>// Vue.prototype.__patch__ is injected in entry points</span>
  <span>// based on the rendering backend used.</span>
  <span>if</span> <span>(</span><span>!</span>prevVnode<span>)</span> <span>{</span>
    <span>// initial render</span>
    vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>$el<span>,</span> vnode<span>,</span> hydrating<span>,</span> <span>false</span> <span>/* removeOnly */</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// updates</span>
    vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>prevVnode<span>,</span> vnode<span>)</span>
  <span>}</span>
  activeInstance <span>=</span> prevActiveInstance
  <span>// update __vue__ reference</span>
  <span>if</span> <span>(</span>prevEl<span>)</span> <span>{</span>
    prevEl<span>.</span>__vue__ <span>=</span> <span>null</span>
  <span>}</span>
  <span>if</span> <span>(</span>vm<span>.</span>$el<span>)</span> <span>{</span>
    vm<span>.</span>$el<span>.</span>__vue__ <span>=</span> vm
  <span>}</span>
  <span>// if parent is an HOC, update its $el as well</span>
  <span>if</span> <span>(</span>vm<span>.</span>$vnode <span>&amp;&amp;</span> vm<span>.</span>$parent <span>&amp;&amp;</span> vm<span>.</span>$vnode <span>===</span> vm<span>.</span>$parent<span>.</span>_vnode<span>)</span> <span>{</span>
    vm<span>.</span>$parent<span>.</span>$el <span>=</span> vm<span>.</span>$el
  <span>}</span>
  <span>// updated hook is called by the scheduler to ensure that children are</span>
  <span>// updated in a parent's updated hook.</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>_update</code> 的核心就是调用 <code>vm.__patch__</code> 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，因此在 web 平台中它的定义在 <code>src/platforms/web/runtime/index.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span>__patch__ <span>=</span> inBrowser <span>?</span> patch <span>:</span> noop
</code></pre><div aria-hidden="true"><div></div></div></div><p>可以看到，甚至在 web 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 <code>patch</code> 方法，它的定义在 <code>src/platforms/web/runtime/patch.js</code>中：</p>
<div><pre><code><span>import</span> <span>*</span> <span>as</span> nodeOps <span>from</span> <span>'web/runtime/node-ops'</span>
<span>import</span> <span>{</span> createPatchFunction <span>}</span> <span>from</span> <span>'core/vdom/patch'</span>
<span>import</span> baseModules <span>from</span> <span>'core/vdom/modules/index'</span>
<span>import</span> platformModules <span>from</span> <span>'web/runtime/modules/index'</span>

<span>// the directive module should be applied last, after all</span>
<span>// built-in modules have been applied.</span>
<span>const</span> modules <span>=</span> platformModules<span>.</span><span>concat</span><span>(</span>baseModules<span>)</span>

<span>export</span> <span>const</span> <span>patch</span><span>:</span> Function <span>=</span> <span>createPatchFunction</span><span>(</span><span>{</span> nodeOps<span>,</span> modules <span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该方法的定义是调用 <code>createPatchFunction</code> 方法的返回值，这里传入了一个对象，包含 <code>nodeOps</code> 参数和 <code>modules</code> 参数。其中，<code>nodeOps</code> 封装了一系列 DOM 操作的方法，<code>modules</code> 定义了一些模块的钩子函数的实现，我们这里先不详细介绍，来看一下 <code>createPatchFunction</code> 的实现，它定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<div><pre><code><span>const</span> hooks <span>=</span> <span>[</span><span>'create'</span><span>,</span> <span>'activate'</span><span>,</span> <span>'update'</span><span>,</span> <span>'remove'</span><span>,</span> <span>'destroy'</span><span>]</span>

<span>export</span> <span>function</span> <span>createPatchFunction</span> <span>(</span><span>backend</span><span>)</span> <span>{</span>
  <span>let</span> i<span>,</span> j
  <span>const</span> cbs <span>=</span> <span>{</span><span>}</span>

  <span>const</span> <span>{</span> modules<span>,</span> nodeOps <span>}</span> <span>=</span> backend

  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> hooks<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
    cbs<span>[</span>hooks<span>[</span>i<span>]</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
    <span>for</span> <span>(</span>j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> modules<span>.</span>length<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>modules<span>[</span>j<span>]</span><span>[</span>hooks<span>[</span>i<span>]</span><span>]</span><span>)</span><span>)</span> <span>{</span>
        cbs<span>[</span>hooks<span>[</span>i<span>]</span><span>]</span><span>.</span><span>push</span><span>(</span>modules<span>[</span>j<span>]</span><span>[</span>hooks<span>[</span>i<span>]</span><span>]</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>// ...</span>

  <span>return</span> <span>function</span> <span>patch</span> <span>(</span><span>oldVnode<span>,</span> vnode<span>,</span> hydrating<span>,</span> removeOnly</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>)</span><span>)</span> <span>invokeDestroyHook</span><span>(</span>oldVnode<span>)</span>
      <span>return</span>
    <span>}</span>

    <span>let</span> isInitialPatch <span>=</span> <span>false</span>
    <span>const</span> insertedVnodeQueue <span>=</span> <span>[</span><span>]</span>

    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldVnode<span>)</span><span>)</span> <span>{</span>
      <span>// empty mount (likely as component), create new root element</span>
      isInitialPatch <span>=</span> <span>true</span>
      <span>createElm</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> isRealElement <span>=</span> <span>isDef</span><span>(</span>oldVnode<span>.</span>nodeType<span>)</span>
      <span>if</span> <span>(</span><span>!</span>isRealElement <span>&amp;&amp;</span> <span>sameVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>)</span> <span>{</span>
        <span>// patch existing root node</span>
        <span>patchVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>,</span> removeOnly<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>isRealElement<span>)</span> <span>{</span>
          <span>// mounting to a real element</span>
          <span>// check if this is server-rendered content and if we can perform</span>
          <span>// a successful hydration.</span>
          <span>if</span> <span>(</span>oldVnode<span>.</span>nodeType <span>===</span> <span>1</span> <span>&amp;&amp;</span> oldVnode<span>.</span><span>hasAttribute</span><span>(</span><span>SSR_ATTR</span><span>)</span><span>)</span> <span>{</span>
            oldVnode<span>.</span><span>removeAttribute</span><span>(</span><span>SSR_ATTR</span><span>)</span>
            hydrating <span>=</span> <span>true</span>
          <span>}</span>
          <span>if</span> <span>(</span><span>isTrue</span><span>(</span>hydrating<span>)</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>hydrate</span><span>(</span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>)</span><span>)</span> <span>{</span>
              <span>invokeInsertHook</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> <span>true</span><span>)</span>
              <span>return</span> oldVnode
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
              <span>warn</span><span>(</span>
                <span>'The client-side rendered virtual DOM tree is not matching '</span> <span>+</span>
                <span>'server-rendered content. This is likely caused by incorrect '</span> <span>+</span>
                <span>'HTML markup, for example nesting block-level elements inside '</span> <span>+</span>
                <span>'&lt;p>, or missing &lt;tbody>. Bailing hydration and performing '</span> <span>+</span>
                <span>'full client-side render.'</span>
              <span>)</span>
            <span>}</span>
          <span>}</span>
          <span>// either not server-rendered, or hydration failed.</span>
          <span>// create an empty node and replace it</span>
          oldVnode <span>=</span> <span>emptyNodeAt</span><span>(</span>oldVnode<span>)</span>
        <span>}</span>

        <span>// replacing existing element</span>
        <span>const</span> oldElm <span>=</span> oldVnode<span>.</span>elm
        <span>const</span> parentElm <span>=</span> nodeOps<span>.</span><span>parentNode</span><span>(</span>oldElm<span>)</span>

        <span>// create new node</span>
        <span>createElm</span><span>(</span>
          vnode<span>,</span>
          insertedVnodeQueue<span>,</span>
          <span>// extremely rare edge case: do not insert if old element is in a</span>
          <span>// leaving transition. Only happens when combining transition +</span>
          <span>// keep-alive + HOCs. (#4590)</span>
          oldElm<span>.</span>_leaveCb <span>?</span> <span>null</span> <span>:</span> parentElm<span>,</span>
          nodeOps<span>.</span><span>nextSibling</span><span>(</span>oldElm<span>)</span>
        <span>)</span>

        <span>// update parent placeholder node element, recursively</span>
        <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>parent<span>)</span><span>)</span> <span>{</span>
          <span>let</span> ancestor <span>=</span> vnode<span>.</span>parent
          <span>const</span> patchable <span>=</span> <span>isPatchable</span><span>(</span>vnode<span>)</span>
          <span>while</span> <span>(</span>ancestor<span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>destroy<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
              cbs<span>.</span>destroy<span>[</span>i<span>]</span><span>(</span>ancestor<span>)</span>
            <span>}</span>
            ancestor<span>.</span>elm <span>=</span> vnode<span>.</span>elm
            <span>if</span> <span>(</span>patchable<span>)</span> <span>{</span>
              <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>create<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
                cbs<span>.</span>create<span>[</span>i<span>]</span><span>(</span>emptyNode<span>,</span> ancestor<span>)</span>
              <span>}</span>
              <span>// #6513</span>
              <span>// invoke insert hooks that may have been merged by create hooks.</span>
              <span>// e.g. for directives that uses the "inserted" hook.</span>
              <span>const</span> insert <span>=</span> ancestor<span>.</span>data<span>.</span>hook<span>.</span>insert
              <span>if</span> <span>(</span>insert<span>.</span>merged<span>)</span> <span>{</span>
                <span>// start at index 1 to avoid re-invoking component mounted hook</span>
                <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> insert<span>.</span>fns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                  insert<span>.</span>fns<span>[</span>i<span>]</span><span>(</span><span>)</span>
                <span>}</span>
              <span>}</span>
            <span>}</span> <span>else</span> <span>{</span>
              <span>registerRef</span><span>(</span>ancestor<span>)</span>
            <span>}</span>
            ancestor <span>=</span> ancestor<span>.</span>parent
          <span>}</span>
        <span>}</span>

        <span>// destroy old node</span>
        <span>if</span> <span>(</span><span>isDef</span><span>(</span>parentElm<span>)</span><span>)</span> <span>{</span>
          <span>removeVnodes</span><span>(</span>parentElm<span>,</span> <span>[</span>oldVnode<span>]</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
          <span>invokeDestroyHook</span><span>(</span>oldVnode<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>invokeInsertHook</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> isInitialPatch<span>)</span>
    <span>return</span> vnode<span>.</span>elm
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createPatchFunction</code> 内部定义了一系列的辅助方法，最终返回了一个 <code>patch</code> 方法，这个方法就赋值给了 <code>vm._update</code> 函数里调用的 <code>vm.__patch__</code>。</p>
<p>在介绍 <code>patch</code> 的方法实现之前，我们可以思考一下为何 Vue.js 源码绕了这么一大圈，把相关代码分散到各个目录。因为前面介绍过，<code>patch</code> 是平台相关的，在 Web 和 Weex 环境，它们把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 <code>nodeOps</code> 和 <code>modules</code>，它们的代码需要托管在 <code>src/platforms</code> 这个大目录下。</p>
<p>而不同平台的 <code>patch</code> 的主要逻辑部分是相同的，所以这部分公共的部分托管在 <code>core</code> 这个大目录下。差异化部分只需要通过参数来区别，这里用到了一个函数柯里化的技巧，通过 <code>createPatchFunction</code> 把差异化参数提前固化，这样不用每次调用 <code>patch</code> 的时候都传递 <code>nodeOps</code> 和 <code>modules</code> 了，这种编程技巧也非常值得学习。</p>
<p>在这里，<code>nodeOps</code> 表示对 “平台 DOM” 的一些操作方法，<code>modules</code> 表示平台的一些模块，它们会在整个 <code>patch</code> 过程的不同阶段执行相应的钩子函数。这些代码的具体实现会在之后的章节介绍。</p>
<p>回到 <code>patch</code> 方法本身，它接收 4个参数，<code>oldVnode</code> 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；<code>vnode</code> 表示执行 <code>_render</code> 后返回的 VNode 的节点；<code>hydrating</code> 表示是否是服务端渲染；<code>removeOnly</code> 是给 <code>transition-group</code> 用的，之后会介绍。</p>
<p><code>patch</code> 的逻辑看上去相对复杂，因为它有着非常多的分支逻辑，为了方便理解，我们并不会在这里介绍所有的逻辑，仅会针对我们之前的例子分析它的执行逻辑。之后我们对其它场景做源码分析的时候会再次回顾 <code>patch</code> 方法。</p>
<p>先来回顾我们的例子：</p>
<div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>render</span><span>:</span> <span>function</span> <span>(</span><span>createElement</span><span>)</span> <span>{</span>
    <span>return</span> <span>createElement</span><span>(</span><span>'div'</span><span>,</span> <span>{</span>
      <span>attrs</span><span>:</span> <span>{</span>
        <span>id</span><span>:</span> <span>'app'</span>
      <span>}</span><span>,</span>
    <span>}</span><span>,</span> <span>this</span><span>.</span>message<span>)</span>
  <span>}</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>'Hello Vue!'</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后我们在 <code>vm._update</code> 的方法里是这么调用 <code>patch</code> 方法的：</p>
<div><pre><code><span>// initial render</span>
vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>$el<span>,</span> vnode<span>,</span> hydrating<span>,</span> <span>false</span> <span>/* removeOnly */</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>结合我们的例子，我们的场景是首次渲染，所以在执行 <code>patch</code> 函数的时候，传入的 <code>vm.$el</code> 对应的是例子中 id 为 <code>app</code> 的 DOM 对象，这个也就是我们在 index.html 模板中写的 <code>&lt;div id=&quot;app&quot;&gt;</code>， <code>vm.$el</code> 的赋值是在之前 <code>mountComponent</code> 函数做的，<code>vnode</code> 对应的是调用 <code>render</code> 函数的返回值，<code>hydrating</code> 在非服务端渲染情况下为 false，<code>removeOnly</code> 为 false。</p>
<p>确定了这些入参后，我们回到 <code>patch</code> 函数的执行过程，看几个关键步骤。</p>
<div><pre><code><span>const</span> isRealElement <span>=</span> <span>isDef</span><span>(</span>oldVnode<span>.</span>nodeType<span>)</span>
<span>if</span> <span>(</span><span>!</span>isRealElement <span>&amp;&amp;</span> <span>sameVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>)</span> <span>{</span>
  <span>// patch existing root node</span>
  <span>patchVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>,</span> removeOnly<span>)</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>if</span> <span>(</span>isRealElement<span>)</span> <span>{</span>
    <span>// mounting to a real element</span>
    <span>// check if this is server-rendered content and if we can perform</span>
    <span>// a successful hydration.</span>
    <span>if</span> <span>(</span>oldVnode<span>.</span>nodeType <span>===</span> <span>1</span> <span>&amp;&amp;</span> oldVnode<span>.</span><span>hasAttribute</span><span>(</span><span>SSR_ATTR</span><span>)</span><span>)</span> <span>{</span>
      oldVnode<span>.</span><span>removeAttribute</span><span>(</span><span>SSR_ATTR</span><span>)</span>
      hydrating <span>=</span> <span>true</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>isTrue</span><span>(</span>hydrating<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>hydrate</span><span>(</span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>)</span><span>)</span> <span>{</span>
        <span>invokeInsertHook</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> <span>true</span><span>)</span>
        <span>return</span> oldVnode
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'The client-side rendered virtual DOM tree is not matching '</span> <span>+</span>
          <span>'server-rendered content. This is likely caused by incorrect '</span> <span>+</span>
          <span>'HTML markup, for example nesting block-level elements inside '</span> <span>+</span>
          <span>'&lt;p>, or missing &lt;tbody>. Bailing hydration and performing '</span> <span>+</span>
          <span>'full client-side render.'</span>
        <span>)</span>
      <span>}</span>
    <span>}</span>      
    <span>// either not server-rendered, or hydration failed.</span>
    <span>// create an empty node and replace it</span>
    oldVnode <span>=</span> <span>emptyNodeAt</span><span>(</span>oldVnode<span>)</span>
  <span>}</span>

  <span>// replacing existing element</span>
  <span>const</span> oldElm <span>=</span> oldVnode<span>.</span>elm
  <span>const</span> parentElm <span>=</span> nodeOps<span>.</span><span>parentNode</span><span>(</span>oldElm<span>)</span>

  <span>// create new node</span>
  <span>createElm</span><span>(</span>
    vnode<span>,</span>
    insertedVnodeQueue<span>,</span>
    <span>// extremely rare edge case: do not insert if old element is in a</span>
    <span>// leaving transition. Only happens when combining transition +</span>
    <span>// keep-alive + HOCs. (#4590)</span>
    oldElm<span>.</span>_leaveCb <span>?</span> <span>null</span> <span>:</span> parentElm<span>,</span>
    nodeOps<span>.</span><span>nextSibling</span><span>(</span>oldElm<span>)</span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>由于我们传入的 <code>oldVnode</code> 实际上是一个 DOM container，所以 <code>isRealElement</code> 为 true，接下来又通过 <code>emptyNodeAt</code> 方法把 <code>oldVnode</code> 转换成 <code>VNode</code> 对象，然后再调用 <code>createElm</code> 方法，这个方法在这里非常重要，来看一下它的实现：</p>
<div><pre><code><span>function</span> <span>createElm</span> <span>(</span>
  <span>vnode<span>,</span>
  insertedVnodeQueue<span>,</span>
  parentElm<span>,</span>
  refElm<span>,</span>
  nested<span>,</span>
  ownerArray<span>,</span>
  index</span>
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>elm<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>ownerArray<span>)</span><span>)</span> <span>{</span>
    <span>// This vnode was used in a previous render!</span>
    <span>// now it's used as a new node, overwriting its elm would cause</span>
    <span>// potential patch errors down the road when it's used as an insertion</span>
    <span>// reference node. Instead, we clone the node on-demand before creating</span>
    <span>// associated DOM element for it.</span>
    vnode <span>=</span> ownerArray<span>[</span>index<span>]</span> <span>=</span> <span>cloneVNode</span><span>(</span>vnode<span>)</span>
  <span>}</span>

  vnode<span>.</span>isRootInsert <span>=</span> <span>!</span>nested <span>// for transition enter check</span>
  <span>if</span> <span>(</span><span>createComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> data <span>=</span> vnode<span>.</span>data
  <span>const</span> children <span>=</span> vnode<span>.</span>children
  <span>const</span> tag <span>=</span> vnode<span>.</span>tag
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>data <span>&amp;&amp;</span> data<span>.</span>pre<span>)</span> <span>{</span>
        creatingElmInVPre<span>++</span>
      <span>}</span>
      <span>if</span> <span>(</span><span>isUnknownElement</span><span>(</span>vnode<span>,</span> creatingElmInVPre<span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'Unknown custom element: &lt;'</span> <span>+</span> tag <span>+</span> <span>'> - did you '</span> <span>+</span>
          <span>'register the component correctly? For recursive components, '</span> <span>+</span>
          <span>'make sure to provide the "name" option.'</span><span>,</span>
          vnode<span>.</span>context
        <span>)</span>
      <span>}</span>
    <span>}</span>

    vnode<span>.</span>elm <span>=</span> vnode<span>.</span>ns
      <span>?</span> nodeOps<span>.</span><span>createElementNS</span><span>(</span>vnode<span>.</span>ns<span>,</span> tag<span>)</span>
      <span>:</span> nodeOps<span>.</span><span>createElement</span><span>(</span>tag<span>,</span> vnode<span>)</span>
    <span>setScope</span><span>(</span>vnode<span>)</span>

    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>__WEEX__<span>)</span> <span>{</span>
      <span>// ...</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>createChildren</span><span>(</span>vnode<span>,</span> children<span>,</span> insertedVnodeQueue<span>)</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
        <span>invokeCreateHooks</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
      <span>}</span>
      <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
    <span>}</span>

    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> data <span>&amp;&amp;</span> data<span>.</span>pre<span>)</span> <span>{</span>
      creatingElmInVPre<span>--</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isTrue</span><span>(</span>vnode<span>.</span>isComment<span>)</span><span>)</span> <span>{</span>
    vnode<span>.</span>elm <span>=</span> nodeOps<span>.</span><span>createComment</span><span>(</span>vnode<span>.</span>text<span>)</span>
    <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    vnode<span>.</span>elm <span>=</span> nodeOps<span>.</span><span>createTextNode</span><span>(</span>vnode<span>.</span>text<span>)</span>
    <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createElm</code> 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。 我们来看一下它的一些关键逻辑，<code>createComponent</code> 方法目的是尝试创建子组件，这个逻辑在之后组件的章节会详细介绍，在当前这个 case 下它的返回值为 false；接下来判断 <code>vnode</code> 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素。</p>
<div><pre><code>vnode<span>.</span>elm <span>=</span> vnode<span>.</span>ns
  <span>?</span> nodeOps<span>.</span><span>createElementNS</span><span>(</span>vnode<span>.</span>ns<span>,</span> tag<span>)</span>
  <span>:</span> nodeOps<span>.</span><span>createElement</span><span>(</span>tag<span>,</span> vnode<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>接下来调用 <code>createChildren</code> 方法去创建子元素：</p>
<div><pre><code><span>createChildren</span><span>(</span>vnode<span>,</span> children<span>,</span> insertedVnodeQueue<span>)</span>

<span>function</span> <span>createChildren</span> <span>(</span><span>vnode<span>,</span> children<span>,</span> insertedVnodeQueue</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>children<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>checkDuplicateKeys</span><span>(</span>children<span>)</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
      <span>createElm</span><span>(</span>children<span>[</span>i<span>]</span><span>,</span> insertedVnodeQueue<span>,</span> vnode<span>.</span>elm<span>,</span> <span>null</span><span>,</span> <span>true</span><span>,</span> children<span>,</span> i<span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isPrimitive</span><span>(</span>vnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>
    nodeOps<span>.</span><span>appendChild</span><span>(</span>vnode<span>.</span>elm<span>,</span> nodeOps<span>.</span><span>createTextNode</span><span>(</span><span>String</span><span>(</span>vnode<span>.</span>text<span>)</span><span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createChildren</code> 的逻辑很简单，实际上是遍历子虚拟节点，递归调用 <code>createElm</code>，这是一种常用的深度优先的遍历算法，这里要注意的一点是在遍历过程中会把 <code>vnode.elm</code> 作为父容器的 DOM 节点占位符传入。</p>
<p>接着再调用 <code>invokeCreateHooks</code> 方法执行所有的 create 的钩子并把 <code>vnode</code> push 到 <code>insertedVnodeQueue</code> 中。</p>
<div><pre><code> <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
  <span>invokeCreateHooks</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
<span>}</span>

<span>function</span> <span>invokeCreateHooks</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>create<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
    cbs<span>.</span>create<span>[</span>i<span>]</span><span>(</span>emptyNode<span>,</span> vnode<span>)</span>
  <span>}</span>
  i <span>=</span> vnode<span>.</span>data<span>.</span>hook <span>// Reuse variable</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>.</span>create<span>)</span><span>)</span> i<span>.</span><span>create</span><span>(</span>emptyNode<span>,</span> vnode<span>)</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>.</span>insert<span>)</span><span>)</span> insertedVnodeQueue<span>.</span><span>push</span><span>(</span>vnode<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最后调用 <code>insert</code> 方法把 <code>DOM</code> 插入到父节点中，因为是递归调用，子元素会优先调用 <code>insert</code>，所以整个 <code>vnode</code> 树节点的插入顺序是先子后父。来看一下 <code>insert</code> 方法，它的定义在 <code>src/core/vdom/patch.js</code> 上。</p>
<div><pre><code><span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>

<span>function</span> <span>insert</span> <span>(</span><span>parent<span>,</span> elm<span>,</span> ref</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>parent<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>ref<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>ref<span>.</span>parentNode <span>===</span> parent<span>)</span> <span>{</span>
        nodeOps<span>.</span><span>insertBefore</span><span>(</span>parent<span>,</span> elm<span>,</span> ref<span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      nodeOps<span>.</span><span>appendChild</span><span>(</span>parent<span>,</span> elm<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>insert</code> 逻辑很简单，调用一些 <code>nodeOps</code> 把子节点插入到父节点中，这些辅助方法定义在 <code>src/platforms/web/runtime/node-ops.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>insertBefore</span> <span>(</span><span><span>parentNode</span><span>:</span> Node<span>,</span> <span>newNode</span><span>:</span> Node<span>,</span> <span>referenceNode</span><span>:</span> Node</span><span>)</span> <span>{</span>
  parentNode<span>.</span><span>insertBefore</span><span>(</span>newNode<span>,</span> referenceNode<span>)</span>
<span>}</span>

<span>export</span> <span>function</span> <span>appendChild</span> <span>(</span><span><span>node</span><span>:</span> Node<span>,</span> <span>child</span><span>:</span> Node</span><span>)</span> <span>{</span>
  node<span>.</span><span>appendChild</span><span>(</span>child<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实就是调用原生 DOM 的 API 进行 DOM 操作，看到这里，很多同学恍然大悟，原来 Vue 是这样动态创建的 DOM。</p>
<p>在 <code>createElm</code> 过程中，如果 <code>vnode</code> 节点不包含 <code>tag</code>，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 <code>vnode</code>，它的 <code>text</code> 值取的就是之前的 <code>this.message</code> 的值 <code>Hello Vue!</code>。</p>
<p>再回到 <code>patch</code> 方法，首次渲染我们调用了 <code>createElm</code> 方法，这里传入的 <code>parentElm</code> 是 <code>oldVnode.elm</code> 的父元素，在我们的例子是 id 为 <code>#app</code> div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。</p>
<p>最后，我们根据之前递归 <code>createElm</code> 生成的 <code>vnode</code> 插入顺序队列，执行相关的 <code>insert</code> 钩子函数，这部分内容我们之后会详细介绍。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。</p>
<img :src="$withBase('/assets/new-vue.png')"/>
<p>我们这里只是分析了最简单和最基础的场景，在实际项目中，我们是把页面拆成很多组件的，Vue 另一个核心思想就是组件化。那么下一章我们就来分析 Vue 的组件化过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Virtual DOM</title>
    <id>https://0808200.xyz/vue2/data-driven/virtual-dom.html</id>
    <link href="https://0808200.xyz/vue2/data-driven/virtual-dom.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="virtual-dom" tabindex="-1"> Virtual DOM</h1>
<p>Virtual DOM 这个概念相信大部分人都不会陌生，它产生的前提是浏览器中的 DOM 是很“昂贵&quot;的，为了更直观的感受，我们可以简单的把一个简单的 div 元素的属性都打印出来，如图所示：</p>
<img :src="$withBase('/assets/dom.png')">
<p>可以看到，真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。</p>
<p>而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 <code>VNode</code> 这么一个 Class 去描述，它是定义在 <code>src/core/vdom/vnode.js</code> 中的。</p>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>VNode</span> <span>{</span>
  <span>tag</span><span>:</span> string <span>|</span> <span>void</span><span>;</span>
  <span>data</span><span>:</span> VNodeData <span>|</span> <span>void</span><span>;</span>
  <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>;</span>
  <span>text</span><span>:</span> string <span>|</span> <span>void</span><span>;</span>
  <span>elm</span><span>:</span> Node <span>|</span> <span>void</span><span>;</span>
  <span>ns</span><span>:</span> string <span>|</span> <span>void</span><span>;</span>
  <span>context</span><span>:</span> Component <span>|</span> <span>void</span><span>;</span> <span>// rendered in this component's scope</span>
  <span>key</span><span>:</span> string <span>|</span> number <span>|</span> <span>void</span><span>;</span>
  <span>componentOptions</span><span>:</span> VNodeComponentOptions <span>|</span> <span>void</span><span>;</span>
  <span>componentInstance</span><span>:</span> Component <span>|</span> <span>void</span><span>;</span> <span>// component instance</span>
  <span>parent</span><span>:</span> VNode <span>|</span> <span>void</span><span>;</span> <span>// component placeholder node</span>

  <span>// strictly internal</span>
  <span>raw</span><span>:</span> boolean<span>;</span> <span>// contains raw HTML? (server only)</span>
  <span>isStatic</span><span>:</span> boolean<span>;</span> <span>// hoisted static node</span>
  <span>isRootInsert</span><span>:</span> boolean<span>;</span> <span>// necessary for enter transition check</span>
  <span>isComment</span><span>:</span> boolean<span>;</span> <span>// empty comment placeholder?</span>
  <span>isCloned</span><span>:</span> boolean<span>;</span> <span>// is a cloned node?</span>
  <span>isOnce</span><span>:</span> boolean<span>;</span> <span>// is a v-once node?</span>
  <span>asyncFactory</span><span>:</span> Function <span>|</span> <span>void</span><span>;</span> <span>// async component factory function</span>
  <span>asyncMeta</span><span>:</span> Object <span>|</span> <span>void</span><span>;</span>
  <span>isAsyncPlaceholder</span><span>:</span> boolean<span>;</span>
  <span>ssrContext</span><span>:</span> Object <span>|</span> <span>void</span><span>;</span>
  <span>fnContext</span><span>:</span> Component <span>|</span> <span>void</span><span>;</span> <span>// real context vm for functional nodes</span>
  <span>fnOptions</span><span>:</span> <span>?</span>ComponentOptions<span>;</span> <span>// for SSR caching</span>
  <span>fnScopeId</span><span>:</span> <span>?</span>string<span>;</span> <span>// functional scope id support</span>

  <span>constructor</span> <span>(</span>
    <span>tag<span>?</span><span>:</span> string<span>,</span>
    data<span>?</span><span>:</span> VNodeData<span>,</span>
    children<span>?</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
    text<span>?</span><span>:</span> string<span>,</span>
    elm<span>?</span><span>:</span> Node<span>,</span>
    context<span>?</span><span>:</span> Component<span>,</span>
    componentOptions<span>?</span><span>:</span> VNodeComponentOptions<span>,</span>
    asyncFactory<span>?</span><span>:</span> Function</span>
  <span>)</span> <span>{</span>
    <span>this</span><span>.</span>tag <span>=</span> tag
    <span>this</span><span>.</span>data <span>=</span> data
    <span>this</span><span>.</span>children <span>=</span> children
    <span>this</span><span>.</span>text <span>=</span> text
    <span>this</span><span>.</span>elm <span>=</span> elm
    <span>this</span><span>.</span>ns <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>context <span>=</span> context
    <span>this</span><span>.</span>fnContext <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>fnOptions <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>fnScopeId <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>key <span>=</span> data <span>&amp;&amp;</span> data<span>.</span>key
    <span>this</span><span>.</span>componentOptions <span>=</span> componentOptions
    <span>this</span><span>.</span>componentInstance <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>parent <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>raw <span>=</span> <span>false</span>
    <span>this</span><span>.</span>isStatic <span>=</span> <span>false</span>
    <span>this</span><span>.</span>isRootInsert <span>=</span> <span>true</span>
    <span>this</span><span>.</span>isComment <span>=</span> <span>false</span>
    <span>this</span><span>.</span>isCloned <span>=</span> <span>false</span>
    <span>this</span><span>.</span>isOnce <span>=</span> <span>false</span>
    <span>this</span><span>.</span>asyncFactory <span>=</span> asyncFactory
    <span>this</span><span>.</span>asyncMeta <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>isAsyncPlaceholder <span>=</span> <span>false</span>
  <span>}</span>

  <span>// DEPRECATED: alias for componentInstance for backwards compat.</span>
  <span>/* istanbul ignore next */</span>
  <span>get</span> <span>child</span> <span>(</span><span>)</span><span>:</span> Component <span>|</span> <span>void</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>componentInstance
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为它这里包含了很多 Vue.js 的特性。这里千万不要被这些茫茫多的属性吓到，实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西。我建议大家如果想深入了解 Vue.js 的 Virtual DOM 前不妨先阅读这个库的源码，因为它更加简单和纯粹。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。</p>
<p>Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 <code>createElement</code> 方法创建的，我们接下来分析这部分的实现。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">event</title>
    <id>https://0808200.xyz/vue2/extend/event.html</id>
    <link href="https://0808200.xyz/vue2/extend/event.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="event" tabindex="-1"> event</h1>
<p>我们平时开发工作中，处理组件间的通讯，原生的交互，都离不开事件。对于一个组件元素，我们不仅仅可以绑定原生的 DOM 事件，还可以绑定自定义事件，非常灵活和方便。那么接下来我们从源码角度来看看它的实现原理。</p>
<p>为了更加直观，我们通过一个例子来分析它的实现：</p>
<div><pre><code><span>let</span> Child <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;button @click="clickHandler($event)">'</span> <span>+</span>
  <span>'click me'</span> <span>+</span>
  <span>'&lt;/button>'</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>clickHandler</span><span>(</span><span>e</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Button clicked!'</span><span>,</span> e<span>)</span>
      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'select'</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;child @select="selectHandler" @click.native.prevent="clickHandler">&lt;/child>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>clickHandler</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Child clicked!'</span><span>)</span>
    <span>}</span><span>,</span>
    <span>selectHandler</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Child select!'</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    Child
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="编译" tabindex="-1"> 编译</h2>
<p>先从编译阶段开始看起，在 <code>parse</code> 阶段，会执行 <code>processAttrs</code> 方法，它的定义在 <code>src/compiler/parser/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> onRE <span>=</span> <span><span>/</span><span>^@|^v-on:</span><span>/</span></span>
<span>export</span> <span>const</span> dirRE <span>=</span> <span><span>/</span><span>^v-|^@|^:</span><span>/</span></span>
<span>export</span> <span>const</span> bindRE <span>=</span> <span><span>/</span><span>^:|^v-bind:</span><span>/</span></span>
<span>function</span> <span>processAttrs</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
  <span>const</span> list <span>=</span> el<span>.</span>attrsList
  <span>let</span> i<span>,</span> l<span>,</span> name<span>,</span> rawName<span>,</span> value<span>,</span> modifiers<span>,</span> isProp
  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>,</span> l <span>=</span> list<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    name <span>=</span> rawName <span>=</span> list<span>[</span>i<span>]</span><span>.</span>name
    value <span>=</span> list<span>[</span>i<span>]</span><span>.</span>value
    <span>if</span> <span>(</span>dirRE<span>.</span><span>test</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>   
      el<span>.</span>hasBindings <span>=</span> <span>true</span>
      modifiers <span>=</span> <span>parseModifiers</span><span>(</span>name<span>)</span>
      <span>if</span> <span>(</span>modifiers<span>)</span> <span>{</span>
        name <span>=</span> name<span>.</span><span>replace</span><span>(</span>modifierRE<span>,</span> <span>''</span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>bindRE<span>.</span><span>test</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>
        <span>// ..</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>onRE<span>.</span><span>test</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>
        name <span>=</span> name<span>.</span><span>replace</span><span>(</span>onRE<span>,</span> <span>''</span><span>)</span>
        <span>addHandler</span><span>(</span>el<span>,</span> name<span>,</span> value<span>,</span> modifiers<span>,</span> <span>false</span><span>,</span> warn<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>// ...</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// ...</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>parseModifiers</span> <span>(</span><span><span>name</span><span>:</span> string</span><span>)</span><span>:</span> Object <span>|</span> <span>void</span> <span>{</span>
  <span>const</span> match <span>=</span> name<span>.</span><span>match</span><span>(</span>modifierRE<span>)</span>
  <span>if</span> <span>(</span>match<span>)</span> <span>{</span>
    <span>const</span> ret <span>=</span> <span>{</span><span>}</span>
    match<span>.</span><span>forEach</span><span>(</span><span>m</span> <span>=></span> <span>{</span> ret<span>[</span>m<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span><span>]</span> <span>=</span> <span>true</span> <span>}</span><span>)</span>
    <span>return</span> ret
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在对标签属性的处理过程中，判断如果是指令，首先通过 <code>parseModifiers</code> 解析出修饰符，然后判断如果事件的指令，则执行 <code>addHandler(el, name, value, modifiers, false, warn)</code> 方法，它的定义在 <code>src/compiler/helpers.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>addHandler</span> <span>(</span>
  <span><span>el</span><span>:</span> ASTElement<span>,</span>
  <span>name</span><span>:</span> string<span>,</span>
  <span>value</span><span>:</span> string<span>,</span>
  <span>modifiers</span><span>:</span> <span>?</span>ASTModifiers<span>,</span>
  important<span>?</span><span>:</span> boolean<span>,</span>
  warn<span>?</span><span>:</span> Function</span>
<span>)</span> <span>{</span>
  modifiers <span>=</span> modifiers <span>||</span> emptyObject
  <span>// warn prevent and passive modifier</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> warn <span>&amp;&amp;</span>
    modifiers<span>.</span>prevent <span>&amp;&amp;</span> modifiers<span>.</span>passive
  <span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span>'passive and prevent can\'t be used together. '</span> <span>+</span>
      <span>'Passive handler can\'t prevent default event.'</span>
    <span>)</span>
  <span>}</span>

  <span>// check capture modifier</span>
  <span>if</span> <span>(</span>modifiers<span>.</span>capture<span>)</span> <span>{</span>
    <span>delete</span> modifiers<span>.</span>capture
    name <span>=</span> <span>'!'</span> <span>+</span> name <span>// mark the event as captured</span>
  <span>}</span>
  <span>if</span> <span>(</span>modifiers<span>.</span>once<span>)</span> <span>{</span>
    <span>delete</span> modifiers<span>.</span>once
    name <span>=</span> <span>'~'</span> <span>+</span> name <span>// mark the event as once</span>
  <span>}</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>modifiers<span>.</span>passive<span>)</span> <span>{</span>
    <span>delete</span> modifiers<span>.</span>passive
    name <span>=</span> <span>'&amp;'</span> <span>+</span> name <span>// mark the event as passive</span>
  <span>}</span>

  <span>// normalize click.right and click.middle since they don't actually fire</span>
  <span>// this is technically browser-specific, but at least for now browsers are</span>
  <span>// the only target envs that have right/middle clicks.</span>
  <span>if</span> <span>(</span>name <span>===</span> <span>'click'</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>modifiers<span>.</span>right<span>)</span> <span>{</span>
      name <span>=</span> <span>'contextmenu'</span>
      <span>delete</span> modifiers<span>.</span>right
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>modifiers<span>.</span>middle<span>)</span> <span>{</span>
      name <span>=</span> <span>'mouseup'</span>
    <span>}</span>
  <span>}</span>

  <span>let</span> events
  <span>if</span> <span>(</span>modifiers<span>.</span>native<span>)</span> <span>{</span>
    <span>delete</span> modifiers<span>.</span>native
    events <span>=</span> el<span>.</span>nativeEvents <span>||</span> <span>(</span>el<span>.</span>nativeEvents <span>=</span> <span>{</span><span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    events <span>=</span> el<span>.</span>events <span>||</span> <span>(</span>el<span>.</span>events <span>=</span> <span>{</span><span>}</span><span>)</span>
  <span>}</span>

  <span>const</span> <span>newHandler</span><span>:</span> any <span>=</span> <span>{</span>
    <span>value</span><span>:</span> value<span>.</span><span>trim</span><span>(</span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>modifiers <span>!==</span> emptyObject<span>)</span> <span>{</span>
    newHandler<span>.</span>modifiers <span>=</span> modifiers
  <span>}</span>

  <span>const</span> handlers <span>=</span> events<span>[</span>name<span>]</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>handlers<span>)</span><span>)</span> <span>{</span>
    important <span>?</span> handlers<span>.</span><span>unshift</span><span>(</span>newHandler<span>)</span> <span>:</span> handlers<span>.</span><span>push</span><span>(</span>newHandler<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>handlers<span>)</span> <span>{</span>
    events<span>[</span>name<span>]</span> <span>=</span> important <span>?</span> <span>[</span>newHandler<span>,</span> handlers<span>]</span> <span>:</span> <span>[</span>handlers<span>,</span> newHandler<span>]</span>
  <span>}</span> <span>else</span> <span>{</span>
    events<span>[</span>name<span>]</span> <span>=</span> newHandler
  <span>}</span>

  el<span>.</span>plain <span>=</span> <span>false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>addHandler</code> 函数看起来长，实际上就做了 3 件事情，首先根据 <code>modifier</code> 修饰符对事件名 <code>name</code> 做处理，接着根据 <code>modifier.native</code> 判断是一个纯原生事件还是普通事件，分别对应 <code>el.nativeEvents</code> 和 <code>el.events</code>，最后按照 <code>name</code> 对事件做归类，并把回调函数的字符串保留到对应的事件中。</p>
<p>在我们的例子中，父组件的 <code>child</code> 节点生成的 <code>el.events</code> 和 <code>el.nativeEvents</code> 如下：</p>
<div><pre><code>el<span>.</span>events <span>=</span> <span>{</span>
  <span>select</span><span>:</span> <span>{</span>
    <span>value</span><span>:</span> <span>'selectHandler'</span>
  <span>}</span>
<span>}</span>

el<span>.</span>nativeEvents <span>=</span> <span>{</span>
  <span>click</span><span>:</span> <span>{</span>
    <span>value</span><span>:</span> <span>'clickHandler'</span><span>,</span>
    <span>modifiers</span><span>:</span> <span>{</span>
      <span>prevent</span><span>:</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>子组件的 <code>button</code> 节点生成的 <code>el.events</code> 如下：</p>
<div><pre><code>el<span>.</span>events <span>=</span> <span>{</span>
  <span>click</span><span>:</span> <span>{</span>
    <span>value</span><span>:</span> <span>'clickHandler($event)'</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>然后在 <code>codegen</code> 的阶段，会在 <code>genData</code> 函数中根据 AST 元素节点上的 <code>events</code> 和 <code>nativeEvents</code> 生成 <code>data</code> 数据，它的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genData</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
  <span>let</span> data <span>=</span> <span>'{'</span>
  <span>// ...</span>
  <span>if</span> <span>(</span>el<span>.</span>events<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span><span>${</span><span>genHandlers</span><span>(</span>el<span>.</span>events<span>,</span> <span>false</span><span>,</span> state<span>.</span>warn<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>el<span>.</span>nativeEvents<span>)</span> <span>{</span>
    data <span>+=</span> <span><span>`</span><span><span>${</span><span>genHandlers</span><span>(</span>el<span>.</span>nativeEvents<span>,</span> <span>true</span><span>,</span> state<span>.</span>warn<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>// ...</span>
  <span>return</span> data
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于这两个属性，会调用 <code>genHandlers</code> 函数，定义在 <code>src/compiler/codegen/events.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genHandlers</span> <span>(</span>
  <span><span>events</span><span>:</span> ASTElementHandlers<span>,</span>
  <span>isNative</span><span>:</span> boolean<span>,</span>
  <span>warn</span><span>:</span> Function</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>let</span> res <span>=</span> isNative <span>?</span> <span>'nativeOn:{'</span> <span>:</span> <span>'on:{'</span>
  <span>for</span> <span>(</span><span>const</span> name <span>in</span> events<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span>"</span><span><span>${</span>name<span>}</span></span><span>":</span><span><span>${</span><span>genHandler</span><span>(</span>name<span>,</span> events<span>[</span>name<span>]</span><span>)</span><span>}</span></span><span>,</span><span>`</span></span>
  <span>}</span>
  <span>return</span> res<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span> <span>+</span> <span>'}'</span>
<span>}</span>

<span>const</span> fnExpRE <span>=</span> <span><span>/</span><span>^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(</span><span>/</span></span>
<span>const</span> simplePathRE <span>=</span> <span><span>/</span><span>^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$</span><span>/</span></span>
<span>function</span> <span>genHandler</span> <span>(</span>
  <span><span>name</span><span>:</span> string<span>,</span>
  <span>handler</span><span>:</span> ASTElementHandler <span>|</span> Array<span>&lt;</span>ASTElementHandler<span>></span></span>
<span>)</span><span>:</span> string <span>{</span>
  <span>if</span> <span>(</span><span>!</span>handler<span>)</span> <span>{</span>
    <span>return</span> <span>'function(){}'</span>
  <span>}</span>

  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>handler<span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>[</span><span><span>${</span>handler<span>.</span><span>map</span><span>(</span><span>handler</span> <span>=></span> <span>genHandler</span><span>(</span>name<span>,</span> handler<span>)</span><span>)</span><span>.</span><span>join</span><span>(</span><span>','</span><span>)</span><span>}</span></span><span>]</span><span>`</span></span>
  <span>}</span>

  <span>const</span> isMethodPath <span>=</span> simplePathRE<span>.</span><span>test</span><span>(</span>handler<span>.</span>value<span>)</span>
  <span>const</span> isFunctionExpression <span>=</span> fnExpRE<span>.</span><span>test</span><span>(</span>handler<span>.</span>value<span>)</span>

  <span>if</span> <span>(</span><span>!</span>handler<span>.</span>modifiers<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>isMethodPath <span>||</span> isFunctionExpression<span>)</span> <span>{</span>
      <span>return</span> handler<span>.</span>value
    <span>}</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>__WEEX__ <span>&amp;&amp;</span> handler<span>.</span>params<span>)</span> <span>{</span>
      <span>return</span> <span>genWeexHandler</span><span>(</span>handler<span>.</span>params<span>,</span> handler<span>.</span>value<span>)</span>
    <span>}</span>
    <span>return</span> <span><span>`</span><span>function($event){</span><span><span>${</span>handler<span>.</span>value<span>}</span></span><span>}</span><span>`</span></span> <span>// inline statement</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>let</span> code <span>=</span> <span>''</span>
    <span>let</span> genModifierCode <span>=</span> <span>''</span>
    <span>const</span> keys <span>=</span> <span>[</span><span>]</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> handler<span>.</span>modifiers<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>modifierCode<span>[</span>key<span>]</span><span>)</span> <span>{</span>
        genModifierCode <span>+=</span> modifierCode<span>[</span>key<span>]</span>
        <span>// left/right</span>
        <span>if</span> <span>(</span>keyCodes<span>[</span>key<span>]</span><span>)</span> <span>{</span>
          keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>===</span> <span>'exact'</span><span>)</span> <span>{</span>
        <span>const</span> <span>modifiers</span><span>:</span> ASTModifiers <span>=</span> <span>(</span>handler<span>.</span>modifiers<span>:</span> any<span>)</span>
        genModifierCode <span>+=</span> <span>genGuard</span><span>(</span>
          <span>[</span><span>'ctrl'</span><span>,</span> <span>'shift'</span><span>,</span> <span>'alt'</span><span>,</span> <span>'meta'</span><span>]</span>
            <span>.</span><span>filter</span><span>(</span><span>keyModifier</span> <span>=></span> <span>!</span>modifiers<span>[</span>keyModifier<span>]</span><span>)</span>
            <span>.</span><span>map</span><span>(</span><span>keyModifier</span> <span>=></span> <span><span>`</span><span>$event.</span><span><span>${</span>keyModifier<span>}</span></span><span>Key</span><span>`</span></span><span>)</span>
            <span>.</span><span>join</span><span>(</span><span>'||'</span><span>)</span>
        <span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>keys<span>.</span>length<span>)</span> <span>{</span>
      code <span>+=</span> <span>genKeyFilter</span><span>(</span>keys<span>)</span>
    <span>}</span>
    <span>// Make sure modifiers like prevent and stop get executed after key filtering</span>
    <span>if</span> <span>(</span>genModifierCode<span>)</span> <span>{</span>
      code <span>+=</span> genModifierCode
    <span>}</span>
    <span>const</span> handlerCode <span>=</span> isMethodPath
      <span>?</span> <span><span>`</span><span>return </span><span><span>${</span>handler<span>.</span>value<span>}</span></span><span>($event)</span><span>`</span></span>
      <span>:</span> isFunctionExpression
        <span>?</span> <span><span>`</span><span>return (</span><span><span>${</span>handler<span>.</span>value<span>}</span></span><span>)($event)</span><span>`</span></span>
        <span>:</span> handler<span>.</span>value
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>__WEEX__ <span>&amp;&amp;</span> handler<span>.</span>params<span>)</span> <span>{</span>
      <span>return</span> <span>genWeexHandler</span><span>(</span>handler<span>.</span>params<span>,</span> code <span>+</span> handlerCode<span>)</span>
    <span>}</span>
    <span>return</span> <span><span>`</span><span>function($event){</span><span><span>${</span>code<span>}</span></span><span><span>${</span>handlerCode<span>}</span></span><span>}</span><span>`</span></span>
  <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genHandlers</code> 方法遍历事件对象 <code>events</code>，对同一个事件名称的事件调用 <code>genHandler(name, events[name])</code> 方法，它的内容看起来多，但实际上逻辑很简单，首先先判断如果 <code>handler</code> 是一个数组，就遍历它然后递归调用 <code>genHandler</code> 方法并拼接结果，然后判断 <code>hanlder.value</code> 是一个函数的调用路径还是一个函数表达式， 接着对 <code>modifiers</code> 做判断，对于没有 <code>modifiers</code> 的情况，就根据 <code>handler.value</code> 不同情况处理，要么直接返回，要么返回一个函数包裹的表达式；对于有 <code>modifiers</code> 的情况，则对各种不同的 <code>modifer</code> 情况做不同处理，添加相应的代码串。</p>
<p>那么对于我们的例子而言，父组件生成的 <code>data</code> 串为：</p>
<div><pre><code><span>{</span>
  <span>on</span><span>:</span> <span>{</span><span>"select"</span><span>:</span> selectHandler<span>}</span><span>,</span>
  <span>nativeOn</span><span>:</span> <span>{</span><span>"click"</span><span>:</span> <span>function</span><span>(</span><span>$event</span><span>)</span> <span>{</span>
      $event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
      <span>return</span> <span>clickHandler</span><span>(</span>$event<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>子组件生成的 <code>data</code> 串为：</p>
<div><pre><code><span>{</span>
  <span>on</span><span>:</span> <span>{</span><span>"click"</span><span>:</span> <span>function</span><span>(</span><span>$event</span><span>)</span> <span>{</span>
      <span>clickHandler</span><span>(</span>$event<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么到这里，编译部分完了，接下来我们来看一下运行时部分是如何实现的。其实 Vue 的事件有 2 种，一种是原生 DOM 事件，一种是用户自定义事件，我们分别来看。</p>
<h2 id="dom-事件" tabindex="-1"> DOM 事件</h2>
<p>还记得我们之前在 <code>patch</code> 的时候执行各种 <code>module</code> 的钩子函数吗，当时这部分是略过的，我们之前只分析了 DOM 是如何渲染的，而 DOM 元素相关的属性、样式、事件等都是通过这些 <code>module</code> 的钩子函数完成设置的。</p>
<p>所有和 web 相关的 <code>module</code> 都定义在 <code>src/platforms/web/runtime/modules</code> 目录下，我们这次只关注目录下的 <code>events.js</code> 即可。</p>
<p>在 <code>patch</code> 过程中的创建阶段和更新阶段都会执行 <code>updateDOMListeners</code>：</p>
<div><pre><code><span>let</span> <span>target</span><span>:</span> any
<span>function</span> <span>updateDOMListeners</span> <span>(</span><span><span>oldVnode</span><span>:</span> VNodeWithData<span>,</span> <span>vnode</span><span>:</span> VNodeWithData</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldVnode<span>.</span>data<span>.</span>on<span>)</span> <span>&amp;&amp;</span> <span>isUndef</span><span>(</span>vnode<span>.</span>data<span>.</span>on<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> on <span>=</span> vnode<span>.</span>data<span>.</span>on <span>||</span> <span>{</span><span>}</span>
  <span>const</span> oldOn <span>=</span> oldVnode<span>.</span>data<span>.</span>on <span>||</span> <span>{</span><span>}</span>
  target <span>=</span> vnode<span>.</span>elm
  <span>normalizeEvents</span><span>(</span>on<span>)</span>
  <span>updateListeners</span><span>(</span>on<span>,</span> oldOn<span>,</span> add<span>,</span> remove<span>,</span> vnode<span>.</span>context<span>)</span>
  target <span>=</span> <span>undefined</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先获取 <code>vnode.data.on</code>，这就是我们之前的生成的 <code>data</code> 中对应的事件对象，<code>target</code> 是当前 <code>vnode</code> 对于的 DOM 对象，<code>normalizeEvents</code> 主要是对 <code>v-model</code> 相关的处理，我们之后分析 <code>v-model</code> 的时候会介绍，接着调用 <code>updateListeners(on, oldOn, add, remove, vnode.context)</code> 方法，它的定义在 <code>src/core/vdom/helpers/update-listeners.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>updateListeners</span> <span>(</span>
  <span><span>on</span><span>:</span> Object<span>,</span>
  <span>oldOn</span><span>:</span> Object<span>,</span>
  <span>add</span><span>:</span> Function<span>,</span>
  <span>remove</span><span>:</span> Function<span>,</span>
  <span>vm</span><span>:</span> Component</span>
<span>)</span> <span>{</span>
  <span>let</span> name<span>,</span> def<span>,</span> cur<span>,</span> old<span>,</span> event
  <span>for</span> <span>(</span>name <span>in</span> on<span>)</span> <span>{</span>
    def <span>=</span> cur <span>=</span> on<span>[</span>name<span>]</span>
    old <span>=</span> oldOn<span>[</span>name<span>]</span>
    event <span>=</span> <span>normalizeEvent</span><span>(</span>name<span>)</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>__WEEX__ <span>&amp;&amp;</span> <span>isPlainObject</span><span>(</span>def<span>)</span><span>)</span> <span>{</span>
      cur <span>=</span> def<span>.</span>handler
      event<span>.</span>params <span>=</span> def<span>.</span>params
    <span>}</span>
    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>cur<span>)</span><span>)</span> <span>{</span>
      process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
        <span><span>`</span><span>Invalid handler for event "</span><span><span>${</span>event<span>.</span>name<span>}</span></span><span>": got </span><span>`</span></span> <span>+</span> <span>String</span><span>(</span>cur<span>)</span><span>,</span>
        vm
      <span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isUndef</span><span>(</span>old<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isUndef</span><span>(</span>cur<span>.</span>fns<span>)</span><span>)</span> <span>{</span>
        cur <span>=</span> on<span>[</span>name<span>]</span> <span>=</span> <span>createFnInvoker</span><span>(</span>cur<span>)</span>
      <span>}</span>
      <span>add</span><span>(</span>event<span>.</span>name<span>,</span> cur<span>,</span> event<span>.</span>once<span>,</span> event<span>.</span>capture<span>,</span> event<span>.</span>passive<span>,</span> event<span>.</span>params<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>cur <span>!==</span> old<span>)</span> <span>{</span>
      old<span>.</span>fns <span>=</span> cur
      on<span>[</span>name<span>]</span> <span>=</span> old
    <span>}</span>
  <span>}</span>
  <span>for</span> <span>(</span>name <span>in</span> oldOn<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>on<span>[</span>name<span>]</span><span>)</span><span>)</span> <span>{</span>
      event <span>=</span> <span>normalizeEvent</span><span>(</span>name<span>)</span>
      <span>remove</span><span>(</span>event<span>.</span>name<span>,</span> oldOn<span>[</span>name<span>]</span><span>,</span> event<span>.</span>capture<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>updateListeners</code> 的逻辑很简单，遍历 <code>on</code> 去添加事件监听，遍历 <code>oldOn</code> 去移除事件监听，关于监听和移除事件的方法都是外部传入的，因为它既处理原生 DOM 事件的添加删除，也处理自定义事件的添加删除。</p>
<p>对于 <code>on</code> 的遍历，首先获得每一个事件名，然后做 <code>normalizeEvent</code> 的处理：</p>
<div><pre><code><span>const</span> normalizeEvent <span>=</span> <span>cached</span><span>(</span><span>(</span>name<span>:</span> string<span>)</span><span>:</span> <span>{</span>
  <span>name</span><span>:</span> string<span>,</span>
  <span>once</span><span>:</span> boolean<span>,</span>
  <span>capture</span><span>:</span> boolean<span>,</span>
  <span>passive</span><span>:</span> boolean<span>,</span>
  handler<span>?</span><span>:</span> Function<span>,</span>
  params<span>?</span><span>:</span> Array<span>&lt;</span>any<span>></span>
<span>}</span> <span>=></span> <span>{</span>
  <span>const</span> passive <span>=</span> name<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'&amp;'</span>
  name <span>=</span> passive <span>?</span> name<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span> <span>:</span> name
  <span>const</span> once <span>=</span> name<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'~'</span> <span>// Prefixed last, checked first</span>
  name <span>=</span> once <span>?</span> name<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span> <span>:</span> name
  <span>const</span> capture <span>=</span> name<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'!'</span>
  name <span>=</span> capture <span>?</span> name<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span> <span>:</span> name
  <span>return</span> <span>{</span>
    name<span>,</span>
    once<span>,</span>
    capture<span>,</span>
    passive
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>根据我们的的事件名的一些特殊标识（之前在 <code>addHandler</code> 的时候添加上的）区分出这个事件是否有 <code>once</code>、<code>capture</code>、<code>passive</code> 等修饰符。</p>
<p>处理完事件名后，又对事件回调函数做处理，对于第一次，满足 <code>isUndef(old)</code> 并且 <code>isUndef(cur.fns)</code>，会执行 <code>cur = on[name] = createFnInvoker(cur)</code> 方法去创建一个回调函数，然后在执行 <code>add(event.name, cur, event.once, event.capture, event.passive, event.params)</code> 完成一次事件绑定。我们先看一下 <code>createFnInvoker</code> 的实现：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createFnInvoker</span> <span>(</span><span><span>fns</span><span>:</span> Function <span>|</span> Array<span>&lt;</span>Function<span>></span></span><span>)</span><span>:</span> Function <span>{</span>
  <span>function</span> <span>invoker</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> fns <span>=</span> invoker<span>.</span>fns
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>fns<span>)</span><span>)</span> <span>{</span>
      <span>const</span> cloned <span>=</span> fns<span>.</span><span>slice</span><span>(</span><span>)</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cloned<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        cloned<span>[</span>i<span>]</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> arguments<span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> <span>fns</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> arguments<span>)</span>
    <span>}</span>
  <span>}</span>
  invoker<span>.</span>fns <span>=</span> fns
  <span>return</span> invoker
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里定义了 <code>invoker</code> 方法并返回，由于一个事件可能会对应多个回调函数，所以这里做了数组的判断，多个回调函数就依次调用。注意最后的赋值逻辑， <code>invoker.fns = fns</code>，每一次执行 <code>invoker</code> 函数都是从 <code>invoker.fns</code> 里取执行的回调函数，回到 <code>updateListeners</code>，当我们第二次执行该函数的时候，判断如果 <code>cur !== old</code>，那么只需要更改 <code>old.fns = cur</code> 把之前绑定的 <code>involer.fns</code>  赋值为新的回调函数即可，并且 通过 <code>on[name] = old</code> 保留引用关系，这样就保证了事件回调只添加一次，之后仅仅去修改它的回调函数的引用。</p>
<p><code>updateListeners</code> 函数的最后遍历 <code>oldOn</code> 拿到事件名称，判断如果满足 <code>isUndef(on[name])</code>，则执行 <code>remove(event.name, oldOn[name], event.capture)</code> 去移除事件回调。</p>
<p>了解了 <code>updateListeners</code> 的实现后，我们来看一下在原生 DOM 事件中真正添加回调和移除回调函数的实现，它们的定义都在 <code>src/platforms/web/runtime/modules/event.js</code> 中：</p>
<div><pre><code><span>function</span> <span>add</span> <span>(</span>
  <span><span>event</span><span>:</span> string<span>,</span>
  <span>handler</span><span>:</span> Function<span>,</span>
  <span>once</span><span>:</span> boolean<span>,</span>
  <span>capture</span><span>:</span> boolean<span>,</span>
  <span>passive</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  handler <span>=</span> <span>withMacroTask</span><span>(</span>handler<span>)</span>
  <span>if</span> <span>(</span>once<span>)</span> handler <span>=</span> <span>createOnceHandler</span><span>(</span>handler<span>,</span> event<span>,</span> capture<span>)</span>
  target<span>.</span><span>addEventListener</span><span>(</span>
    event<span>,</span>
    handler<span>,</span>
    supportsPassive
      <span>?</span> <span>{</span> capture<span>,</span> passive <span>}</span>
      <span>:</span> capture
  <span>)</span>
<span>}</span>

<span>function</span> <span>remove</span> <span>(</span>
  <span><span>event</span><span>:</span> string<span>,</span>
  <span>handler</span><span>:</span> Function<span>,</span>
  <span>capture</span><span>:</span> boolean<span>,</span>
  _target<span>?</span><span>:</span> HTMLElement</span>
<span>)</span> <span>{</span>
  <span>(</span>_target <span>||</span> target<span>)</span><span>.</span><span>removeEventListener</span><span>(</span>
    event<span>,</span>
    handler<span>.</span>_withTask <span>||</span> handler<span>,</span>
    capture
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>add</code> 和 <code>remove</code> 的逻辑很简单，就是实际上调用原生 <code>addEventListener</code> 和 <code>removeEventListener</code>，并根据参数传递一些配置，注意这里的 <code>hanlder</code> 会用 <code>withMacroTask(hanlder)</code> 包裹一下，它的定义在 <code>src/core/util/next-tick.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>withMacroTask</span> <span>(</span><span><span>fn</span><span>:</span> Function</span><span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> fn<span>.</span>_withTask <span>||</span> <span>(</span>fn<span>.</span><span>_withTask</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    useMacroTask <span>=</span> <span>true</span>
    <span>const</span> res <span>=</span> <span>fn</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> arguments<span>)</span>
    useMacroTask <span>=</span> <span>false</span>
    <span>return</span> res
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上就是强制在 DOM 事件的回调函数执行期间如果修改了数据，那么这些数据更改推入的队列会被当做 <code>macroTask</code> 在 <code>nextTick</code> 后执行。</p>
<h2 id="自定义事件" tabindex="-1"> 自定义事件</h2>
<p>除了原生 DOM 事件，Vue 还支持了自定义事件，并且自定义事件只能作用在组件上，如果在组件上使用原生事件，需要加 <code>.native</code> 修饰符，普通元素上使用 <code>.native</code> 修饰符无效，接下来我们就来分析它的实现。</p>
<p>在 <code>render</code> 阶段，如果是一个组件节点，则通过 <code>createComponent</code> 创建一个组件 <code>vnode</code>，我们再来回顾这个方法，定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponent</span> <span>(</span>
  <span><span>Ctor</span><span>:</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object <span>|</span> <span>void</span><span>,</span>
  <span>data</span><span>:</span> <span>?</span>VNodeData<span>,</span>
  <span>context</span><span>:</span> Component<span>,</span>
  <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  tag<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>|</span> <span>void</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> listeners <span>=</span> data<span>.</span>on
  
  data<span>.</span>on <span>=</span> data<span>.</span>nativeOn
  
  <span>// ...</span>
  <span>const</span> name <span>=</span> Ctor<span>.</span>options<span>.</span>name <span>||</span> tag
  <span>const</span> vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
    <span><span>`</span><span>vue-component-</span><span><span>${</span>Ctor<span>.</span>cid<span>}</span></span><span><span>${</span>name <span>?</span> <span><span>`</span><span>-</span><span><span>${</span>name<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span><span>,</span>
    data<span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context<span>,</span>
    <span>{</span> Ctor<span>,</span> propsData<span>,</span> listeners<span>,</span> tag<span>,</span> children <span>}</span><span>,</span>
    asyncFactory
  <span>)</span>

  <span>return</span> vnode
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们只关注事件相关的逻辑，可以看到，它把 <code>data.on</code> 赋值给了 <code>listeners</code>，把 <code>data.nativeOn</code> 赋值给了 <code>data.on</code>，这样所有的原生 DOM 事件处理跟我们刚才介绍的一样，它是在当前组件环境中处理的。而对于自定义事件，我们把 <code>listeners</code> 作为 <code>vnode</code> 的 <code>componentOptions</code> 传入，它是在子组件初始化阶段中处理的，所以它的处理环境是子组件。</p>
<p>然后在子组件的初始化的时候，会执行 <code>initInternalComponent</code> 方法，它的定义在 <code>src/core/instance/init.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initInternalComponent</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>options</span><span>:</span> InternalComponentOptions</span><span>)</span> <span>{</span>
  <span>const</span> opts <span>=</span> vm<span>.</span>$options <span>=</span> Object<span>.</span><span>create</span><span>(</span>vm<span>.</span>constructor<span>.</span>options<span>)</span>
  <span>// ....</span>
  <span>const</span> vnodeComponentOptions <span>=</span> parentVnode<span>.</span>componentOptions
 
  opts<span>.</span>_parentListeners <span>=</span> vnodeComponentOptions<span>.</span>listeners
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里拿到了父组件传入的 <code>listeners</code>，然后在执行 <code>initEvents</code> 的过程中，会处理这个 <code>listeners</code>，定义在 <code>src/core/instance/events.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initEvents</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  vm<span>.</span>_events <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  vm<span>.</span>_hasHookEvent <span>=</span> <span>false</span>
  <span>// init parent attached events</span>
  <span>const</span> listeners <span>=</span> vm<span>.</span>$options<span>.</span>_parentListeners
  <span>if</span> <span>(</span>listeners<span>)</span> <span>{</span>
    <span>updateComponentListeners</span><span>(</span>vm<span>,</span> listeners<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>拿到 <code>listeners</code> 后，执行 <code>updateComponentListeners(vm, listeners)</code> 方法：</p>
<div><pre><code><span>let</span> <span>target</span><span>:</span> any
<span>export</span> <span>function</span> <span>updateComponentListeners</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>listeners</span><span>:</span> Object<span>,</span>
  <span>oldListeners</span><span>:</span> <span>?</span>Object</span>
<span>)</span> <span>{</span>
  target <span>=</span> vm
  <span>updateListeners</span><span>(</span>listeners<span>,</span> oldListeners <span>||</span> <span>{</span><span>}</span><span>,</span> add<span>,</span> remove<span>,</span> vm<span>)</span>
  target <span>=</span> <span>undefined</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>updateListeners</code> 我们之前介绍过，所以对于自定义事件和原生 DOM 事件处理的差异就在事件添加和删除的实现上，来看一下自定义事件 <code>add</code> 和 <code>remove</code> 的实现：</p>
<div><pre><code><span>function</span> <span>add</span> <span>(</span><span>event<span>,</span> fn<span>,</span> once</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>once<span>)</span> <span>{</span>
    target<span>.</span><span>$once</span><span>(</span>event<span>,</span> fn<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    target<span>.</span><span>$on</span><span>(</span>event<span>,</span> fn<span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>remove</span> <span>(</span><span>event<span>,</span> fn</span><span>)</span> <span>{</span>
  target<span>.</span><span>$off</span><span>(</span>event<span>,</span> fn<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上是利用 Vue 定义的事件中心，简单分析一下它的实现：</p>
<div><pre><code><span>export</span> <span>function</span> <span>eventsMixin</span> <span>(</span><span><span>Vue</span><span>:</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>{</span>
  <span>const</span> hookRE <span>=</span> <span><span>/</span><span>^hook:</span><span>/</span></span>
  <span>Vue</span><span>.</span>prototype<span>.</span><span>$on</span> <span>=</span> <span>function</span> <span>(</span><span><span>event</span><span>:</span> string <span>|</span> Array<span>&lt;</span>string<span>></span><span>,</span> <span>fn</span><span>:</span> Function</span><span>)</span><span>:</span> Component <span>{</span>
    <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> event<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>$on</span><span>(</span>event<span>[</span>i<span>]</span><span>,</span> fn<span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>(</span>vm<span>.</span>_events<span>[</span>event<span>]</span> <span>||</span> <span>(</span>vm<span>.</span>_events<span>[</span>event<span>]</span> <span>=</span> <span>[</span><span>]</span><span>)</span><span>)</span><span>.</span><span>push</span><span>(</span>fn<span>)</span>
      <span>// optimize hook:event cost by using a boolean flag marked at registration</span>
      <span>// instead of a hash lookup</span>
      <span>if</span> <span>(</span>hookRE<span>.</span><span>test</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>
        vm<span>.</span>_hasHookEvent <span>=</span> <span>true</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> vm
  <span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$once</span> <span>=</span> <span>function</span> <span>(</span><span><span>event</span><span>:</span> string<span>,</span> <span>fn</span><span>:</span> Function</span><span>)</span><span>:</span> Component <span>{</span>
    <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
    <span>function</span> <span>on</span> <span>(</span><span>)</span> <span>{</span>
      vm<span>.</span><span>$off</span><span>(</span>event<span>,</span> on<span>)</span>
      <span>fn</span><span>.</span><span>apply</span><span>(</span>vm<span>,</span> arguments<span>)</span>
    <span>}</span>
    on<span>.</span>fn <span>=</span> fn
    vm<span>.</span><span>$on</span><span>(</span>event<span>,</span> on<span>)</span>
    <span>return</span> vm
  <span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$off</span> <span>=</span> <span>function</span> <span>(</span><span>event<span>?</span><span>:</span> string <span>|</span> Array<span>&lt;</span>string<span>></span><span>,</span> fn<span>?</span><span>:</span> Function</span><span>)</span><span>:</span> Component <span>{</span>
    <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
    <span>// all</span>
    <span>if</span> <span>(</span><span>!</span>arguments<span>.</span>length<span>)</span> <span>{</span>
      vm<span>.</span>_events <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
      <span>return</span> vm
    <span>}</span>
    <span>// array of events</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>event<span>)</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> event<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>$off</span><span>(</span>event<span>[</span>i<span>]</span><span>,</span> fn<span>)</span>
      <span>}</span>
      <span>return</span> vm
    <span>}</span>
    <span>// specific event</span>
    <span>const</span> cbs <span>=</span> vm<span>.</span>_events<span>[</span>event<span>]</span>
    <span>if</span> <span>(</span><span>!</span>cbs<span>)</span> <span>{</span>
      <span>return</span> vm
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>fn<span>)</span> <span>{</span>
      vm<span>.</span>_events<span>[</span>event<span>]</span> <span>=</span> <span>null</span>
      <span>return</span> vm
    <span>}</span>
    <span>if</span> <span>(</span>fn<span>)</span> <span>{</span>
      <span>// specific handler</span>
      <span>let</span> cb
      <span>let</span> i <span>=</span> cbs<span>.</span>length
      <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
        cb <span>=</span> cbs<span>[</span>i<span>]</span>
        <span>if</span> <span>(</span>cb <span>===</span> fn <span>||</span> cb<span>.</span>fn <span>===</span> fn<span>)</span> <span>{</span>
          cbs<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span>
          <span>break</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> vm
  <span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$emit</span> <span>=</span> <span>function</span> <span>(</span><span><span>event</span><span>:</span> string</span><span>)</span><span>:</span> Component <span>{</span>
    <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>const</span> lowerCaseEvent <span>=</span> event<span>.</span><span>toLowerCase</span><span>(</span><span>)</span>
      <span>if</span> <span>(</span>lowerCaseEvent <span>!==</span> event <span>&amp;&amp;</span> vm<span>.</span>_events<span>[</span>lowerCaseEvent<span>]</span><span>)</span> <span>{</span>
        <span>tip</span><span>(</span>
          <span><span>`</span><span>Event "</span><span><span>${</span>lowerCaseEvent<span>}</span></span><span>" is emitted in component </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span><span>${</span><span>formatComponentName</span><span>(</span>vm<span>)</span><span>}</span></span><span> but the handler is registered for "</span><span><span>${</span>event<span>}</span></span><span>". </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>Note that HTML attributes are case-insensitive and you cannot use </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>v-on to listen to camelCase events when using in-DOM templates. </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>You should probably use "</span><span><span>${</span><span>hyphenate</span><span>(</span>event<span>)</span><span>}</span></span><span>" instead of "</span><span><span>${</span>event<span>}</span></span><span>".</span><span>`</span></span>
        <span>)</span>
      <span>}</span>
    <span>}</span>
    <span>let</span> cbs <span>=</span> vm<span>.</span>_events<span>[</span>event<span>]</span>
    <span>if</span> <span>(</span>cbs<span>)</span> <span>{</span>
      cbs <span>=</span> cbs<span>.</span>length <span>></span> <span>1</span> <span>?</span> <span>toArray</span><span>(</span>cbs<span>)</span> <span>:</span> cbs
      <span>const</span> args <span>=</span> <span>toArray</span><span>(</span>arguments<span>,</span> <span>1</span><span>)</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> cbs<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
          cbs<span>[</span>i<span>]</span><span>.</span><span>apply</span><span>(</span>vm<span>,</span> args<span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
          <span>handleError</span><span>(</span>e<span>,</span> vm<span>,</span> <span><span>`</span><span>event handler for "</span><span><span>${</span>event<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> vm
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>非常经典的事件中心的实现，把所有的事件用 <code>vm._events</code> 存储起来，当执行 <code>vm.$on(event,fn)</code> 的时候，按事件的名称 <code>event</code> 把回调函数 <code>fn</code> 存储起来 <code>vm._events[event].push(fn)</code>。当执行 <code>vm.$emit(event)</code> 的时候，根据事件名 <code>event</code> 找到所有的回调函数 <code>let cbs = vm._events[event]</code>，然后遍历执行所有的回调函数。当执行 <code>vm.$off(event,fn)</code> 的时候会移除指定事件名 <code>event</code> 和指定的 <code>fn</code> 当执行 <code>vm.$once(event,fn)</code> 的时候，内部就是执行 <code>vm.$on</code>，并且当回调函数执行一次后再通过 <code>vm.$off</code> 移除事件的回调，这样就确保了回调函数只执行一次。</p>
<p>所以对于用户自定义的事件添加和删除就是利用了这几个事件中心的 API。需要注意的事一点，<code>vm.$emit</code> 是给当前的 <code>vm</code> 上派发的实例，之所以我们常用它做父子组件通讯，是因为它的回调函数的定义是在父组件中，对于我们这个例子而言，当子组件的 <code>button</code> 被点击了，它通过 <code>this.$emit('select')</code> 派发事件，那么子组件的实例就监听到了这个 <code>select</code> 事件，并执行它的回调函数——定义在父组件中的 <code>selectHandler</code> 方法，这样就相当于完成了一次父子组件的通讯。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此我们对 Vue 的事件实现有了进一步的了解，Vue 支持 2 种事件类型，原生 DOM 事件和自定义事件，它们主要的区别在于添加和删除事件的方式不一样，并且自定义事件的派发是往当前实例上派发，但是可以利用在父组件环境定义回调函数来实现父子组件的通讯。另外要注意一点，只有组件节点才可以添加自定义事件，并且添加原生 DOM 事件需要使用 <code>native</code> 修饰符；而普通元素使用 <code>.native</code> 修饰符是没有作用的，也只能添加原生 DOM 事件。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">扩展</title>
    <id>https://0808200.xyz/vue2/extend/</id>
    <link href="https://0808200.xyz/vue2/extend/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="扩展" tabindex="-1"> 扩展</h1>
<p>前面几章我们分析了 Vue 的核心以及编译过程，除此之外，Vue 还提供了很多好用的 feature 如 <code>event</code>、<code>v-model</code>、<code>slot</code>、<code>keep-alive</code>、<code>transition</code> 等等。对他们的理解有助于我们在平时开发中更好地应用这些 feature，即使出现 bug 我们也可以很从容地应对。</p>
<p>这一章是一个可扩展的章节，除了已分析的这些 feature 外，未来我们可能会扩展更多的内容。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">keep-alive</title>
    <id>https://0808200.xyz/vue2/extend/keep-alive.html</id>
    <link href="https://0808200.xyz/vue2/extend/keep-alive.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="keep-alive" tabindex="-1"> keep-alive</h1>
<p>在我们的平时开发工作中，经常为了组件的缓存优化而使用 <code>&lt;keep-alive&gt;</code> 组件，乐此不疲，但很少有人关注它的实现原理，下面就让我们来一探究竟。</p>
<h2 id="内置组件" tabindex="-1"> 内置组件</h2>
<p><code>&lt;keep-alive&gt;</code> 是 Vue 源码中实现的一个组件，也就是说 Vue 源码不仅实现了一套组件化的机制，也实现了一些内置组件，它的定义在 <code>src/core/components/keep-alive.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> <span>'keep-alive'</span><span>,</span>
  <span>abstract</span><span>:</span> <span>true</span><span>,</span>

  <span>props</span><span>:</span> <span>{</span>
    <span>include</span><span>:</span> patternTypes<span>,</span>
    <span>exclude</span><span>:</span> patternTypes<span>,</span>
    <span>max</span><span>:</span> <span>[</span>String<span>,</span> Number<span>]</span>
  <span>}</span><span>,</span>

  <span>created</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>cache <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>this</span><span>.</span>keys <span>=</span> <span>[</span><span>]</span>
  <span>}</span><span>,</span>

  <span>destroyed</span> <span>(</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> <span>this</span><span>.</span>cache<span>)</span> <span>{</span>
      <span>pruneCacheEntry</span><span>(</span><span>this</span><span>.</span>cache<span>,</span> key<span>,</span> <span>this</span><span>.</span>keys<span>)</span>
    <span>}</span>
  <span>}</span><span>,</span>

  <span>mounted</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>$watch</span><span>(</span><span>'include'</span><span>,</span> <span>val</span> <span>=></span> <span>{</span>
      <span>pruneCache</span><span>(</span><span>this</span><span>,</span> <span>name</span> <span>=></span> <span>matches</span><span>(</span>val<span>,</span> name<span>)</span><span>)</span>
    <span>}</span><span>)</span>
    <span>this</span><span>.</span><span>$watch</span><span>(</span><span>'exclude'</span><span>,</span> <span>val</span> <span>=></span> <span>{</span>
      <span>pruneCache</span><span>(</span><span>this</span><span>,</span> <span>name</span> <span>=></span> <span>!</span><span>matches</span><span>(</span>val<span>,</span> name<span>)</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span><span>,</span>

  <span>render</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> slot <span>=</span> <span>this</span><span>.</span>$slots<span>.</span>default
    <span>const</span> <span>vnode</span><span>:</span> VNode <span>=</span> <span>getFirstComponentChild</span><span>(</span>slot<span>)</span>
    <span>const</span> <span>componentOptions</span><span>:</span> <span>?</span>VNodeComponentOptions <span>=</span> vnode <span>&amp;&amp;</span> vnode<span>.</span>componentOptions
    <span>if</span> <span>(</span>componentOptions<span>)</span> <span>{</span>
      <span>// check pattern</span>
      <span>const</span> <span>name</span><span>:</span> <span>?</span>string <span>=</span> <span>getComponentName</span><span>(</span>componentOptions<span>)</span>
      <span>const</span> <span>{</span> include<span>,</span> exclude <span>}</span> <span>=</span> <span>this</span>
      <span>if</span> <span>(</span>
        <span>// not included</span>
        <span>(</span>include <span>&amp;&amp;</span> <span>(</span><span>!</span>name <span>||</span> <span>!</span><span>matches</span><span>(</span>include<span>,</span> name<span>)</span><span>)</span><span>)</span> <span>||</span>
        <span>// excluded</span>
        <span>(</span>exclude <span>&amp;&amp;</span> name <span>&amp;&amp;</span> <span>matches</span><span>(</span>exclude<span>,</span> name<span>)</span><span>)</span>
      <span>)</span> <span>{</span>
        <span>return</span> vnode
      <span>}</span>

      <span>const</span> <span>{</span> cache<span>,</span> keys <span>}</span> <span>=</span> <span>this</span>
      <span>const</span> <span>key</span><span>:</span> <span>?</span>string <span>=</span> vnode<span>.</span>key <span>==</span> <span>null</span>
        <span>// same constructor may get registered as different local components</span>
        <span>// so cid alone is not enough (#3269)</span>
        <span>?</span> componentOptions<span>.</span>Ctor<span>.</span>cid <span>+</span> <span>(</span>componentOptions<span>.</span>tag <span>?</span> <span><span>`</span><span>::</span><span><span>${</span>componentOptions<span>.</span>tag<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>)</span>
        <span>:</span> vnode<span>.</span>key
      <span>if</span> <span>(</span>cache<span>[</span>key<span>]</span><span>)</span> <span>{</span>
        vnode<span>.</span>componentInstance <span>=</span> cache<span>[</span>key<span>]</span><span>.</span>componentInstance
        <span>// make current key freshest</span>
        <span>remove</span><span>(</span>keys<span>,</span> key<span>)</span>
        keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        cache<span>[</span>key<span>]</span> <span>=</span> vnode
        keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
        <span>// prune oldest entry</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>max <span>&amp;&amp;</span> keys<span>.</span>length <span>></span> <span>parseInt</span><span>(</span><span>this</span><span>.</span>max<span>)</span><span>)</span> <span>{</span>
          <span>pruneCacheEntry</span><span>(</span>cache<span>,</span> keys<span>[</span><span>0</span><span>]</span><span>,</span> keys<span>,</span> <span>this</span><span>.</span>_vnode<span>)</span>
        <span>}</span>
      <span>}</span>

      vnode<span>.</span>data<span>.</span>keepAlive <span>=</span> <span>true</span>
    <span>}</span>
    <span>return</span> vnode <span>||</span> <span>(</span>slot <span>&amp;&amp;</span> slot<span>[</span><span>0</span><span>]</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 <code>&lt;keep-alive&gt;</code> 组件的实现也是一个对象，注意它有一个属性 <code>abstract</code> 为 true，是一个抽象组件，Vue 的文档没有提这个概念，实际上它在组件实例建立父子关系的时候会被忽略，发生在 <code>initLifecycle</code> 的过程中：</p>
<div><pre><code><span>// locate first non-abstract parent</span>
<span>let</span> parent <span>=</span> options<span>.</span>parent
<span>if</span> <span>(</span>parent <span>&amp;&amp;</span> <span>!</span>options<span>.</span>abstract<span>)</span> <span>{</span>
  <span>while</span> <span>(</span>parent<span>.</span>$options<span>.</span>abstract <span>&amp;&amp;</span> parent<span>.</span>$parent<span>)</span> <span>{</span>
    parent <span>=</span> parent<span>.</span>$parent
  <span>}</span>
  parent<span>.</span>$children<span>.</span><span>push</span><span>(</span>vm<span>)</span>
<span>}</span>
vm<span>.</span>$parent <span>=</span> parent
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>&lt;keep-alive&gt;</code> 在 <code>created</code> 钩子里定义了 <code>this.cache</code> 和 <code>this.keys</code>，本质上它就是去缓存已经创建过的 <code>vnode</code>。它的 <code>props</code> 定义了 <code>include</code>，<code>exclude</code>，它们可以字符串或者表达式，<code>include</code> 表示只有匹配的组件会被缓存，而 <code>exclude</code> 表示任何匹配的组件都不会被缓存，<code>props</code> 还定义了 <code>max</code>，它表示缓存的大小，因为我们是缓存的 <code>vnode</code> 对象，它也会持有 DOM，当我们缓存很多的时候，会比较占用内存，所以该配置允许我们指定缓存大小。</p>
<p><code>&lt;keep-alive&gt;</code> 直接实现了 <code>render</code> 函数，而不是我们常规模板的方式，执行 <code>&lt;keep-alive&gt;</code> 组件渲染的时候，就会执行到这个 <code>render</code> 函数，接下来我们分析一下它的实现。</p>
<p>首先获取第一个子元素的 <code>vnode</code>：</p>
<div><pre><code><span>const</span> slot <span>=</span> <span>this</span><span>.</span>$slots<span>.</span>default
<span>const</span> <span>vnode</span><span>:</span> VNode <span>=</span> <span>getFirstComponentChild</span><span>(</span>slot<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>由于我们也是在 <code>&lt;keep-alive&gt;</code> 标签内部写 DOM，所以可以先获取到它的默认插槽，然后再获取到它的第一个子节点。<code>&lt;keep-alive&gt;</code> 只处理第一个子元素，所以一般和它搭配使用的有 <code>component</code> 动态组件或者是 <code>router-view</code>，这点要牢记。</p>
<p>然后又判断了当前组件的名称和 <code>include</code>、<code>exclude</code> 的关系：</p>
<div><pre><code><span>// check pattern</span>
<span>const</span> <span>name</span><span>:</span> <span>?</span>string <span>=</span> <span>getComponentName</span><span>(</span>componentOptions<span>)</span>
<span>const</span> <span>{</span> include<span>,</span> exclude <span>}</span> <span>=</span> <span>this</span>
<span>if</span> <span>(</span>
  <span>// not included</span>
  <span>(</span>include <span>&amp;&amp;</span> <span>(</span><span>!</span>name <span>||</span> <span>!</span><span>matches</span><span>(</span>include<span>,</span> name<span>)</span><span>)</span><span>)</span> <span>||</span>
  <span>// excluded</span>
  <span>(</span>exclude <span>&amp;&amp;</span> name <span>&amp;&amp;</span> <span>matches</span><span>(</span>exclude<span>,</span> name<span>)</span><span>)</span>
<span>)</span> <span>{</span>
  <span>return</span> vnode
<span>}</span>

<span>function</span> <span>matches</span> <span>(</span><span><span>pattern</span><span>:</span> string <span>|</span> RegExp <span>|</span> Array<span>&lt;</span>string<span>></span><span>,</span> <span>name</span><span>:</span> string</span><span>)</span><span>:</span> boolean <span>{</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>pattern<span>)</span><span>)</span> <span>{</span>
    <span>return</span> pattern<span>.</span><span>indexOf</span><span>(</span>name<span>)</span> <span>></span> <span>-</span><span>1</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> pattern <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
    <span>return</span> pattern<span>.</span><span>split</span><span>(</span><span>','</span><span>)</span><span>.</span><span>indexOf</span><span>(</span>name<span>)</span> <span>></span> <span>-</span><span>1</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isRegExp</span><span>(</span>pattern<span>)</span><span>)</span> <span>{</span>
    <span>return</span> pattern<span>.</span><span>test</span><span>(</span>name<span>)</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>matches</code> 的逻辑很简单，就是做匹配，分别处理了数组、字符串、正则表达式的情况，也就是说我们平时传的 <code>include</code> 和 <code>exclude</code> 可以是这三种类型的任意一种。并且我们的组件名如果满足了配置 <code>include</code> 且不匹配或者是配置了 <code>exclude</code> 且匹配，那么就直接返回这个组件的 <code>vnode</code>，否则的话走下一步缓存：</p>
<div><pre><code><span>const</span> <span>{</span> cache<span>,</span> keys <span>}</span> <span>=</span> <span>this</span>
<span>const</span> <span>key</span><span>:</span> <span>?</span>string <span>=</span> vnode<span>.</span>key <span>==</span> <span>null</span>
  <span>// same constructor may get registered as different local components</span>
  <span>// so cid alone is not enough (#3269)</span>
  <span>?</span> componentOptions<span>.</span>Ctor<span>.</span>cid <span>+</span> <span>(</span>componentOptions<span>.</span>tag <span>?</span> <span><span>`</span><span>::</span><span><span>${</span>componentOptions<span>.</span>tag<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>)</span>
  <span>:</span> vnode<span>.</span>key
<span>if</span> <span>(</span>cache<span>[</span>key<span>]</span><span>)</span> <span>{</span>
  vnode<span>.</span>componentInstance <span>=</span> cache<span>[</span>key<span>]</span><span>.</span>componentInstance
  <span>// make current key freshest</span>
  <span>remove</span><span>(</span>keys<span>,</span> key<span>)</span>
  keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
<span>}</span> <span>else</span> <span>{</span>
  cache<span>[</span>key<span>]</span> <span>=</span> vnode
  keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
  <span>// prune oldest entry</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>max <span>&amp;&amp;</span> keys<span>.</span>length <span>></span> <span>parseInt</span><span>(</span><span>this</span><span>.</span>max<span>)</span><span>)</span> <span>{</span>
    <span>pruneCacheEntry</span><span>(</span>cache<span>,</span> keys<span>[</span><span>0</span><span>]</span><span>,</span> keys<span>,</span> <span>this</span><span>.</span>_vnode<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这部分逻辑很简单，如果命中缓存，则直接从缓存中拿 <code>vnode</code> 的组件实例，并且重新调整了 key 的顺序放在了最后一个；否则把 <code>vnode</code> 设置进缓存，最后还有一个逻辑，如果配置了 <code>max</code> 并且缓存的长度超过了 <code>this.max</code>，还要从缓存中删除第一个：</p>
<div><pre><code><span>function</span> <span>pruneCacheEntry</span> <span>(</span>
  <span><span>cache</span><span>:</span> VNodeCache<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>keys</span><span>:</span> Array<span>&lt;</span>string<span>></span><span>,</span>
  current<span>?</span><span>:</span> VNode</span>
<span>)</span> <span>{</span>
  <span>const</span> cached <span>=</span> cache<span>[</span>key<span>]</span>
  <span>if</span> <span>(</span>cached <span>&amp;&amp;</span> <span>(</span><span>!</span>current <span>||</span> cached<span>.</span>tag <span>!==</span> current<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
    cached<span>.</span>componentInstance<span>.</span><span>$destroy</span><span>(</span><span>)</span>
  <span>}</span>
  cache<span>[</span>key<span>]</span> <span>=</span> <span>null</span> 
  <span>remove</span><span>(</span>keys<span>,</span> key<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>除了从缓存中删除外，还要判断如果要删除的缓存并的组件 <code>tag</code> 不是当前渲染组件 <code>tag</code>，也执行删除缓存的组件实例的 <code>$destroy</code> 方法。</p>
<p>最后设置 <code>vnode.data.keepAlive = true</code> ，这个作用稍后我们介绍。</p>
<p>注意，<code>&lt;keep-alive&gt;</code> 组件也是为观测 <code>include</code> 和 <code>exclude</code> 的变化，对缓存做处理：</p>
<div><pre><code><span>watch</span><span>:</span> <span>{</span>
  <span>include</span> <span>(</span><span><span>val</span><span>:</span> string <span>|</span> RegExp <span>|</span> Array<span>&lt;</span>string<span>></span></span><span>)</span> <span>{</span>
    <span>pruneCache</span><span>(</span><span>this</span><span>,</span> <span>name</span> <span>=></span> <span>matches</span><span>(</span>val<span>,</span> name<span>)</span><span>)</span>
  <span>}</span><span>,</span>
  <span>exclude</span> <span>(</span><span><span>val</span><span>:</span> string <span>|</span> RegExp <span>|</span> Array<span>&lt;</span>string<span>></span></span><span>)</span> <span>{</span>
    <span>pruneCache</span><span>(</span><span>this</span><span>,</span> <span>name</span> <span>=></span> <span>!</span><span>matches</span><span>(</span>val<span>,</span> name<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>pruneCache</span> <span>(</span><span><span>keepAliveInstance</span><span>:</span> any<span>,</span> <span>filter</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> cache<span>,</span> keys<span>,</span> _vnode <span>}</span> <span>=</span> keepAliveInstance
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> cache<span>)</span> <span>{</span>
    <span>const</span> <span>cachedNode</span><span>:</span> <span>?</span>VNode <span>=</span> cache<span>[</span>key<span>]</span>
    <span>if</span> <span>(</span>cachedNode<span>)</span> <span>{</span>
      <span>const</span> <span>name</span><span>:</span> <span>?</span>string <span>=</span> <span>getComponentName</span><span>(</span>cachedNode<span>.</span>componentOptions<span>)</span>
      <span>if</span> <span>(</span>name <span>&amp;&amp;</span> <span>!</span><span>filter</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>
        <span>pruneCacheEntry</span><span>(</span>cache<span>,</span> key<span>,</span> keys<span>,</span> _vnode<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>逻辑很简单，观测他们的变化执行 <code>pruneCache</code> 函数，其实就是对 <code>cache</code> 做遍历，发现缓存的节点名称和新的规则没有匹配上的时候，就把这个缓存节点从缓存中摘除。</p>
<h2 id="组件渲染" tabindex="-1"> 组件渲染</h2>
<p>到此为止，我们只了解了 <code>&lt;keep-alive&gt;</code> 的组件实现，但并不知道它包裹的子组件渲染和普通组件有什么不一样的地方。我们关注 2 个方面，首次渲染和缓存渲染。</p>
<p>同样为了更好地理解，我们也结合一个示例来分析：</p>
<div><pre><code><span>let</span> <span>A</span> <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;p>A Comp&lt;/p>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>name</span><span>:</span> <span>'A'</span>
<span>}</span>

<span>let</span> <span>B</span> <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;p>B Comp&lt;/p>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>name</span><span>:</span> <span>'B'</span>
<span>}</span>

<span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;keep-alive>'</span> <span>+</span>
  <span>'&lt;component :is="currentComp">'</span> <span>+</span>
  <span>'&lt;/component>'</span> <span>+</span>
  <span>'&lt;/keep-alive>'</span> <span>+</span>
  <span>'&lt;button @click="change">switch&lt;/button>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>currentComp</span><span>:</span> <span>'A'</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>change</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>currentComp <span>=</span> <span>this</span><span>.</span>currentComp <span>===</span> <span>'A'</span> <span>?</span> <span>'B'</span> <span>:</span> <span>'A'</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    <span>A</span><span>,</span>
    <span>B</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="首次渲染" tabindex="-1"> 首次渲染</h3>
<p>我们知道 Vue 的渲染最后都会到 <code>patch</code> 过程，而组件的 <code>patch</code> 过程会执行 <code>createComponent</code> 方法，它的定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<div><pre><code><span>function</span> <span>createComponent</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
    <span>const</span> isReactivated <span>=</span> <span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span> <span>&amp;&amp;</span> i<span>.</span>keepAlive
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>init<span>)</span><span>)</span> <span>{</span>
      <span>i</span><span>(</span>vnode<span>,</span> <span>false</span> <span>/* hydrating */</span><span>)</span>
    <span>}</span>
    <span>// after calling the init hook, if the vnode is a child component</span>
    <span>// it should've created a child instance and mounted it. the child</span>
    <span>// component also has set the placeholder vnode's elm.</span>
    <span>// in that case we can just return the element and be done.</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span><span>)</span> <span>{</span>
      <span>initComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
      <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
      <span>if</span> <span>(</span><span>isTrue</span><span>(</span>isReactivated<span>)</span><span>)</span> <span>{</span>
        <span>reactivateComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span>
      <span>}</span>
      <span>return</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createComponent</code> 定义了 <code>isReactivated</code> 的变量，它是根据 <code>vnode.componentInstance</code> 以及 <code>vnode.data.keepAlive</code> 的判断，第一次渲染的时候，<code>vnode.componentInstance</code> 为 <code>undefined</code>，<code>vnode.data.keepAlive</code> 为 true，因为它的父组件 <code>&lt;keep-alive&gt;</code> 的 <code>render</code> 函数会先执行，那么该 <code>vnode</code> 缓存到内存中，并且设置 <code>vnode.data.keepAlive</code> 为 true，因此 <code>isReactivated</code> 为 <code>false</code>，那么走正常的 <code>init</code> 的钩子函数执行组件的 <code>mount</code>。当 <code>vnode</code> 已经执行完 <code>patch</code> 后，执行 <code>initComponent</code> 函数：</p>
<div><pre><code><span>function</span> <span>initComponent</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>data<span>.</span>pendingInsert<span>)</span><span>)</span> <span>{</span>
    insertedVnodeQueue<span>.</span><span>push</span><span>.</span><span>apply</span><span>(</span>insertedVnodeQueue<span>,</span> vnode<span>.</span>data<span>.</span>pendingInsert<span>)</span>
    vnode<span>.</span>data<span>.</span>pendingInsert <span>=</span> <span>null</span>
  <span>}</span>
  vnode<span>.</span>elm <span>=</span> vnode<span>.</span>componentInstance<span>.</span>$el
  <span>if</span> <span>(</span><span>isPatchable</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
    <span>invokeCreateHooks</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
    <span>setScope</span><span>(</span>vnode<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// empty component root.</span>
    <span>// skip all element-related modules except for ref (#3455)</span>
    <span>registerRef</span><span>(</span>vnode<span>)</span>
    <span>// make sure to invoke the insert hook</span>
    insertedVnodeQueue<span>.</span><span>push</span><span>(</span>vnode<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里会有 <code>vnode.elm</code> 缓存了 <code>vnode</code> 创建生成的 DOM 节点。所以对于首次渲染而言，除了在 <code>&lt;keep-alive&gt;</code> 中建立缓存，和普通组件渲染没什么区别。</p>
<p>所以对我们的例子，初始化渲染 <code>A</code> 组件以及第一次点击 <code>switch</code> 渲染 <code>B</code> 组件，都是首次渲染。</p>
<h3 id="缓存渲染" tabindex="-1"> 缓存渲染</h3>
<p>当我们从 <code>B</code> 组件再次点击 <code>switch</code> 切换到 <code>A</code> 组件，就会命中缓存渲染。</p>
<p>我们之前分析过，当数据发送变化，在 <code>patch</code> 的过程中会执行 <code>patchVnode</code> 的逻辑，它会对比新旧 <code>vnode</code> 节点，甚至对比它们的子节点去做更新逻辑，但是对于组件 <code>vnode</code> 而言，是没有 <code>children</code> 的，那么对于 <code>&lt;keep-alive&gt;</code> 组件而言，如何更新它包裹的内容呢？</p>
<p>原来 <code>patchVnode</code> 在做各种 diff 之前，会先执行 <code>prepatch</code> 的钩子函数，它的定义在 <code>src/core/vdom/create-component</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>prepatch</span> <span>(</span><span><span>oldVnode</span><span>:</span> MountedComponentVNode<span>,</span> <span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> options <span>=</span> vnode<span>.</span>componentOptions
    <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> oldVnode<span>.</span>componentInstance
    <span>updateChildComponent</span><span>(</span>
      child<span>,</span>
      options<span>.</span>propsData<span>,</span> <span>// updated props</span>
      options<span>.</span>listeners<span>,</span> <span>// updated listeners</span>
      vnode<span>,</span> <span>// new parent vnode</span>
      options<span>.</span>children <span>// new children</span>
    <span>)</span>
  <span>}</span><span>,</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>prepatch</code> 核心逻辑就是执行 <code>updateChildComponent</code> 方法，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>updateChildComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>propsData</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>listeners</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>parentVnode</span><span>:</span> MountedComponentVNode<span>,</span>
  <span>renderChildren</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span></span>
<span>)</span> <span>{</span>
  <span>const</span> hasChildren <span>=</span> <span>!</span><span>!</span><span>(</span>
    renderChildren <span>||</span>          
    vm<span>.</span>$options<span>.</span>_renderChildren <span>||</span>
    parentVnode<span>.</span>data<span>.</span>scopedSlots <span>||</span> 
    vm<span>.</span>$scopedSlots <span>!==</span> emptyObject 
  <span>)</span>

  <span>// ...</span>
  <span>if</span> <span>(</span>hasChildren<span>)</span> <span>{</span>
    vm<span>.</span>$slots <span>=</span> <span>resolveSlots</span><span>(</span>renderChildren<span>,</span> parentVnode<span>.</span>context<span>)</span>
    vm<span>.</span><span>$forceUpdate</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>updateChildComponent</code> 方法主要是去更新组件实例的一些属性，这里我们重点关注一下 <code>slot</code> 部分，由于 <code>&lt;keep-alive&gt;</code> 组件本质上支持了 <code>slot</code>，所以它执行 <code>prepatch</code> 的时候，需要对自己的 <code>children</code>，也就是这些 <code>slots</code> 做重新解析，并触发 <code>&lt;keep-alive&gt;</code> 组件实例 <code>$forceUpdate</code> 逻辑，也就是重新执行 <code>&lt;keep-alive&gt;</code> 的 <code>render</code> 方法，这个时候如果它包裹的第一个组件 <code>vnode</code> 命中缓存，则直接返回缓存中的 <code>vnode.componentInstance</code>，在我们的例子中就是缓存的 <code>A</code> 组件，接着又会执行 <code>patch</code> 过程，再次执行到 <code>createComponent</code> 方法，我们再回顾一下：</p>
<div><pre><code><span>function</span> <span>createComponent</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
    <span>const</span> isReactivated <span>=</span> <span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span> <span>&amp;&amp;</span> i<span>.</span>keepAlive
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>init<span>)</span><span>)</span> <span>{</span>
      <span>i</span><span>(</span>vnode<span>,</span> <span>false</span> <span>/* hydrating */</span><span>)</span>
    <span>}</span>
    <span>// after calling the init hook, if the vnode is a child component</span>
    <span>// it should've created a child instance and mounted it. the child</span>
    <span>// component also has set the placeholder vnode's elm.</span>
    <span>// in that case we can just return the element and be done.</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>componentInstance<span>)</span><span>)</span> <span>{</span>
      <span>initComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
      <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
      <span>if</span> <span>(</span><span>isTrue</span><span>(</span>isReactivated<span>)</span><span>)</span> <span>{</span>
        <span>reactivateComponent</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm<span>)</span>
      <span>}</span>
      <span>return</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个时候 <code>isReactivated</code> 为 true，并且在执行 <code>init</code> 钩子函数的时候不会再执行组件的 <code>mount</code> 过程了，相关逻辑在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>init</span> <span>(</span>vnode<span>:</span> VNodeWithData<span>,</span> <span>hydrating</span><span>:</span> boolean<span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
    <span>if</span> <span>(</span>
      vnode<span>.</span>componentInstance <span>&amp;&amp;</span>
      <span>!</span>vnode<span>.</span>componentInstance<span>.</span>_isDestroyed <span>&amp;&amp;</span>
      vnode<span>.</span>data<span>.</span>keepAlive
    <span>)</span> <span>{</span>
      <span>// kept-alive components, treat as a patch</span>
      <span>const</span> <span>mountedNode</span><span>:</span> any <span>=</span> vnode <span>// work around flow</span>
      componentVNodeHooks<span>.</span><span>prepatch</span><span>(</span>mountedNode<span>,</span> mountedNode<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> <span>createComponentInstanceForVnode</span><span>(</span>
        vnode<span>,</span>
        activeInstance
      <span>)</span>
      child<span>.</span><span>$mount</span><span>(</span>hydrating <span>?</span> vnode<span>.</span>elm <span>:</span> <span>undefined</span><span>,</span> hydrating<span>)</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这也就是被 <code>&lt;keep-alive&gt;</code> 包裹的组件在有缓存的时候就不会在执行组件的 <code>created</code>、<code>mounted</code> 等钩子函数的原因了。回到 <code>createComponent</code> 方法，在 <code>isReactivated</code> 为 true 的情况下会执行 <code>reactivateComponent</code> 方法：</p>
<div><pre><code><span>function</span> <span>reactivateComponent</span> <span>(</span><span>vnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> refElm</span><span>)</span> <span>{</span>
  <span>let</span> i
  <span>// hack for #4339: a reactivated component with inner transition</span>
  <span>// does not trigger because the inner node's created hooks are not called</span>
  <span>// again. It's not ideal to involve module-specific logic in here but</span>
  <span>// there doesn't seem to be a better way to do it.</span>
  <span>let</span> innerNode <span>=</span> vnode
  <span>while</span> <span>(</span>innerNode<span>.</span>componentInstance<span>)</span> <span>{</span>
    innerNode <span>=</span> innerNode<span>.</span>componentInstance<span>.</span>_vnode
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> innerNode<span>.</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>transition<span>)</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>activate<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
        cbs<span>.</span>activate<span>[</span>i<span>]</span><span>(</span>emptyNode<span>,</span> innerNode<span>)</span>
      <span>}</span>
      insertedVnodeQueue<span>.</span><span>push</span><span>(</span>innerNode<span>)</span>
      <span>break</span>
    <span>}</span>
  <span>}</span>
  <span>// unlike a newly created component,</span>
  <span>// a reactivated keep-alive component doesn't insert itself</span>
  <span>insert</span><span>(</span>parentElm<span>,</span> vnode<span>.</span>elm<span>,</span> refElm<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>前面部分的逻辑是解决对 <code>reactived</code> 组件 <code>transition</code> 动画不触发的问题，可以先不关注，最后通过执行 <code>insert(parentElm, vnode.elm, refElm)</code> 就把缓存的 DOM 对象直接插入到目标元素中，这样就完成了在数据更新的情况下的渲染过程。</p>
<h2 id="生命周期" tabindex="-1"> 生命周期</h2>
<p>之前我们提到，组件一旦被 <code>&lt;keep-alive&gt;</code> 缓存，那么再次渲染的时候就不会执行 <code>created</code>、<code>mounted</code> 等钩子函数，但是我们很多业务场景都是希望在我们被缓存的组件再次被渲染的时候做一些事情，好在 Vue 提供了 <code>activated</code> 钩子函数，它的执行时机是 <code>&lt;keep-alive&gt;</code> 包裹的组件渲染的时候，接下来我们从源码角度来分析一下它的实现原理。</p>
<p>在渲染的最后一步，会执行 <code>invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</code> 函数执行 <code>vnode</code> 的 <code>insert</code> 钩子函数，它的定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>insert</span> <span>(</span><span><span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> context<span>,</span> componentInstance <span>}</span> <span>=</span> vnode
    <span>if</span> <span>(</span><span>!</span>componentInstance<span>.</span>_isMounted<span>)</span> <span>{</span>
      componentInstance<span>.</span>_isMounted <span>=</span> <span>true</span>
      <span>callHook</span><span>(</span>componentInstance<span>,</span> <span>'mounted'</span><span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>vnode<span>.</span>data<span>.</span>keepAlive<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>context<span>.</span>_isMounted<span>)</span> <span>{</span>
        <span>// vue-router#1212</span>
        <span>// During updates, a kept-alive component's child components may</span>
        <span>// change, so directly walking the tree here may call activated hooks</span>
        <span>// on incorrect children. Instead we push them into a queue which will</span>
        <span>// be processed after the whole patch process ended.</span>
        <span>queueActivatedComponent</span><span>(</span>componentInstance<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>activateChildComponent</span><span>(</span>componentInstance<span>,</span> <span>true</span> <span>/* direct */</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里判断如果是被 <code>&lt;keep-alive&gt;</code> 包裹的组件已经 <code>mounted</code>，那么则执行 <code>queueActivatedComponent(componentInstance)</code> ，否则执行 <code>activateChildComponent(componentInstance, true)</code>。我们先分析非 <code>mounted</code> 的情况，<code>activateChildComponent</code> 的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>activateChildComponent</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> direct<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>direct<span>)</span> <span>{</span>
    vm<span>.</span>_directInactive <span>=</span> <span>false</span>
    <span>if</span> <span>(</span><span>isInInactiveTree</span><span>(</span>vm<span>)</span><span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>vm<span>.</span>_directInactive<span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>if</span> <span>(</span>vm<span>.</span>_inactive <span>||</span> vm<span>.</span>_inactive <span>===</span> <span>null</span><span>)</span> <span>{</span>
    vm<span>.</span>_inactive <span>=</span> <span>false</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> vm<span>.</span>$children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>activateChildComponent</span><span>(</span>vm<span>.</span>$children<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
    <span>callHook</span><span>(</span>vm<span>,</span> <span>'activated'</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到这里就是执行组件的 <code>acitvated</code> 钩子函数，并且递归去执行它的所有子组件的 <code>activated</code> 钩子函数。</p>
<p>那么再看 <code>queueActivatedComponent</code> 的逻辑，它定义在 <code>src/core/observer/scheduler.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>queueActivatedComponent</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  vm<span>.</span>_inactive <span>=</span> <span>false</span>
  activatedChildren<span>.</span><span>push</span><span>(</span>vm<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这个逻辑很简单，把当前 <code>vm</code> 实例添加到 <code>activatedChildren</code> 数组中，等所有的渲染完毕，在 <code>nextTick</code>后会执行 <code>flushSchedulerQueue</code>，这个时候就会执行：</p>
<div><pre><code><span>function</span> <span>flushSchedulerQueue</span> <span>(</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> activatedQueue <span>=</span> activatedChildren<span>.</span><span>slice</span><span>(</span><span>)</span>
  <span>callActivatedHooks</span><span>(</span>activatedQueue<span>)</span>
  <span>// ...</span>
<span>}</span> 

<span>function</span> <span>callActivatedHooks</span> <span>(</span><span>queue</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> queue<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    queue<span>[</span>i<span>]</span><span>.</span>_inactive <span>=</span> <span>true</span>
    <span>activateChildComponent</span><span>(</span>queue<span>[</span>i<span>]</span><span>,</span> <span>true</span><span>)</span>  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是遍历所有的 <code>activatedChildren</code>，执行 <code>activateChildComponent</code> 方法，通过队列调的方式就是把整个 <code>activated</code> 时机延后了。</p>
<p>有 <code>activated</code> 钩子函数，也就有对应的 <code>deactivated</code> 钩子函数，它是发生在 <code>vnode</code> 的 <code>destory</code> 钩子函数，定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>destroy</span> <span>(</span><span><span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> componentInstance <span>}</span> <span>=</span> vnode
    <span>if</span> <span>(</span><span>!</span>componentInstance<span>.</span>_isDestroyed<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>vnode<span>.</span>data<span>.</span>keepAlive<span>)</span> <span>{</span>
        componentInstance<span>.</span><span>$destroy</span><span>(</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>deactivateChildComponent</span><span>(</span>componentInstance<span>,</span> <span>true</span> <span>/* direct */</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于 <code>&lt;keep-alive&gt;</code> 包裹的组件而言，它会执行 <code>deactivateChildComponent(componentInstance, true)</code> 方法，定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>deactivateChildComponent</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> direct<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>direct<span>)</span> <span>{</span>
    vm<span>.</span>_directInactive <span>=</span> <span>true</span>
    <span>if</span> <span>(</span><span>isInInactiveTree</span><span>(</span>vm<span>)</span><span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>!</span>vm<span>.</span>_inactive<span>)</span> <span>{</span>
    vm<span>.</span>_inactive <span>=</span> <span>true</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> vm<span>.</span>$children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>deactivateChildComponent</span><span>(</span>vm<span>.</span>$children<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
    <span>callHook</span><span>(</span>vm<span>,</span> <span>'deactivated'</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>和 <code>activateChildComponent</code> 方法类似，就是执行组件的 <code>deacitvated</code> 钩子函数，并且递归去执行它的所有子组件的 <code>deactivated</code> 钩子函数。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，<code>&lt;keep-alive&gt;</code> 的实现原理就介绍完了，通过分析我们知道了 <code>&lt;keep-alive&gt;</code> 组件是一个抽象组件，它的实现通过自定义 <code>render</code> 函数并且利用了插槽，并且知道了 <code>&lt;keep-alive&gt;</code> 缓存 <code>vnode</code>，了解组件包裹的子元素——也就是插槽是如何做更新的。且在 <code>patch</code> 过程中对于已缓存的组件不会执行 <code>mounted</code>，所以不会有一般的组件的生命周期函数但是又提供了 <code>activated</code> 和 <code>deactivated</code> 钩子函数。另外我们还知道了 <code>&lt;keep-alive&gt;</code> 的 <code>props</code> 除了 <code>include</code> 和 <code>exclude</code> 还有文档中没有提到的 <code>max</code>，它能控制我们缓存的个数。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">slot</title>
    <id>https://0808200.xyz/vue2/extend/slot.html</id>
    <link href="https://0808200.xyz/vue2/extend/slot.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="slot" tabindex="-1"> slot</h1>
<p>Vue 的组件提供了一个非常有用的特性 —— <code>slot</code> 插槽，它让组件的实现变的更加灵活。我们平时在开发组件库的时候，为了让组件更加灵活可定制，经常用插槽的方式让用户可以自定义内容。插槽分为普通插槽和作用域插槽，它们可以解决不同的场景，但它是怎么实现的呢，下面我们就从源码的角度来分析插槽的实现原理。</p>
<h2 id="普通插槽" tabindex="-1"> 普通插槽</h2>
<p>为了更加直观，我们还是通过一个例子来分析插槽的实现：</p>
<div><pre><code><span>let</span> AppLayout <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;header>&lt;slot name="header">&lt;/slot>&lt;/header>'</span> <span>+</span>
  <span>'&lt;main>&lt;slot>默认内容&lt;/slot>&lt;/main>'</span> <span>+</span>
  <span>'&lt;footer>&lt;slot name="footer">&lt;/slot>&lt;/footer>'</span> <span>+</span>
  <span>'&lt;/div>'</span>
<span>}</span>

<span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;app-layout>'</span> <span>+</span>
  <span>'&lt;h1 slot="header">{{title}}&lt;/h1>'</span> <span>+</span>
  <span>'&lt;p>{{msg}}&lt;/p>'</span> <span>+</span>
  <span>'&lt;p slot="footer">{{desc}}&lt;/p>'</span> <span>+</span>
  <span>'&lt;/app-layout>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>title</span><span>:</span> <span>'我是标题'</span><span>,</span>
      <span>msg</span><span>:</span> <span>'我是内容'</span><span>,</span>
      <span>desc</span><span>:</span> <span>'其它信息'</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    AppLayout
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们定义了 <code>AppLayout</code> 子组件，它内部定义了 3 个插槽，2 个为具名插槽，一个 <code>name</code> 为 <code>header</code>，一个 <code>name</code> 为 <code>footer</code>，还有一个没有定义 <code>name</code> 的是默认插槽。 <code>&lt;slot&gt;</code> 和 <code>&lt;/slot&gt;</code> 之前填写的内容为默认内容。我们的父组件注册和引用了 <code>AppLayout</code> 的组件，并在组件内部定义了一些元素，用来替换插槽，那么它最终生成的 DOM 如下：</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>header</span><span>></span></span><span><span><span>&lt;</span>h1</span><span>></span></span>我是标题<span><span><span>&lt;/</span>h1</span><span>></span></span><span><span><span>&lt;/</span>header</span><span>></span></span>
    <span><span><span>&lt;</span>main</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>我是内容<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>main</span><span>></span></span>
    <span><span><span>&lt;</span>footer</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>其它信息<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>footer</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="编译" tabindex="-1"> 编译</h2>
<p>还是先从编译说起，我们知道编译是发生在调用 <code>vm.$mount</code> 的时候，所以编译的顺序是先编译父组件，再编译子组件。</p>
<p>首先编译父组件，在 <code>parse</code> 阶段，会执行 <code>processSlot</code> 处理 <code>slot</code>，它的定义在 <code>src/compiler/parser/index.js</code> 中：</p>
<div><pre><code><span>function</span> <span>processSlot</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'slot'</span><span>)</span> <span>{</span>
    el<span>.</span>slotName <span>=</span> <span>getBindingAttr</span><span>(</span>el<span>,</span> <span>'name'</span><span>)</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> el<span>.</span>key<span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>\`key\` does not work on &lt;slot> because slots are abstract outlets </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>and can possibly expand into multiple elements. </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>Use the key on a wrapping element instead.</span><span>`</span></span>
      <span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>let</span> slotScope
    <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'template'</span><span>)</span> <span>{</span>
      slotScope <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'scope'</span><span>)</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> slotScope<span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>the "scope" attribute for scoped slots have been deprecated and </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>replaced by "slot-scope" since 2.5. The new "slot-scope" attribute </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>can also be used on plain elements in addition to &lt;template> to </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>denote scoped slots.</span><span>`</span></span><span>,</span>
          <span>true</span>
        <span>)</span>
      <span>}</span>
      el<span>.</span>slotScope <span>=</span> slotScope <span>||</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'slot-scope'</span><span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>(</span>slotScope <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'slot-scope'</span><span>)</span><span>)</span><span>)</span> <span>{</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> el<span>.</span>attrsMap<span>[</span><span>'v-for'</span><span>]</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>Ambiguous combined usage of slot-scope and v-for on &lt;</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>> </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>(v-for takes higher priority). Use a wrapper &lt;template> for the </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>scoped slot to make it clearer.</span><span>`</span></span><span>,</span>
          <span>true</span>
        <span>)</span>
      <span>}</span>
      el<span>.</span>slotScope <span>=</span> slotScope
    <span>}</span>
    <span>const</span> slotTarget <span>=</span> <span>getBindingAttr</span><span>(</span>el<span>,</span> <span>'slot'</span><span>)</span>
    <span>if</span> <span>(</span>slotTarget<span>)</span> <span>{</span>
      el<span>.</span>slotTarget <span>=</span> slotTarget <span>===</span> <span>'""'</span> <span>?</span> <span>'"default"'</span> <span>:</span> slotTarget
      <span>// preserve slot as an attribute for native shadow DOM compat</span>
      <span>// only for non-scoped slots.</span>
      <span>if</span> <span>(</span>el<span>.</span>tag <span>!==</span> <span>'template'</span> <span>&amp;&amp;</span> <span>!</span>el<span>.</span>slotScope<span>)</span> <span>{</span>
        <span>addAttr</span><span>(</span>el<span>,</span> <span>'slot'</span><span>,</span> slotTarget<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当解析到标签上有 <code>slot</code> 属性的时候，会给对应的 AST
元素节点添加 <code>slotTarget</code> 属性，然后在 <code>codegen</code> 阶段，在 <code>genData</code> 中会处理 <code>slotTarget</code>，相关代码在 <code>src/compiler/codegen/index.js</code> 中：</p>
<div><pre><code><span>if</span> <span>(</span>el<span>.</span>slotTarget <span>&amp;&amp;</span> <span>!</span>el<span>.</span>slotScope<span>)</span> <span>{</span>
  data <span>+=</span> <span><span>`</span><span>slot:</span><span><span>${</span>el<span>.</span>slotTarget<span>}</span></span><span>,</span><span>`</span></span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>会给 <code>data</code> 添加一个 <code>slot</code> 属性，并指向 <code>slotTarget</code>，之后会用到。在我们的例子中，父组件最终生成的代码如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span><span>{</span>
  <span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span>
    <span>[</span><span>_c</span><span>(</span><span>'app-layout'</span><span>,</span>
      <span>[</span><span>_c</span><span>(</span><span>'h1'</span><span>,</span><span>{</span><span>attrs</span><span>:</span><span>{</span><span>"slot"</span><span>:</span><span>"header"</span><span>}</span><span>,</span><span>slot</span><span>:</span><span>"header"</span><span>}</span><span>,</span>
         <span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>title<span>)</span><span>)</span><span>]</span><span>)</span><span>,</span>
       <span>_c</span><span>(</span><span>'p'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>msg<span>)</span><span>)</span><span>]</span><span>)</span><span>,</span>
       <span>_c</span><span>(</span><span>'p'</span><span>,</span><span>{</span><span>attrs</span><span>:</span><span>{</span><span>"slot"</span><span>:</span><span>"footer"</span><span>}</span><span>,</span><span>slot</span><span>:</span><span>"footer"</span><span>}</span><span>,</span>
         <span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>desc<span>)</span><span>)</span><span>]</span>
         <span>)</span>
       <span>]</span><span>)</span>
     <span>]</span><span>,</span>
   <span>1</span><span>)</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>接下来编译子组件，同样在 <code>parser</code> 阶段会执行 <code>processSlot</code> 处理函数，它的定义在 <code>src/compiler/parser/index.js</code> 中：</p>
<div><pre><code><span>function</span> <span>processSlot</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'slot'</span><span>)</span> <span>{</span>
    el<span>.</span>slotName <span>=</span> <span>getBindingAttr</span><span>(</span>el<span>,</span> <span>'name'</span><span>)</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当遇到 <code>slot</code> 标签的时候会给对应的 AST 元素节点添加 <code>slotName</code> 属性，然后在 <code>codegen</code> 阶段，会判断如果当前 AST 元素节点是 <code>slot</code> 标签，则执行 <code>genSlot</code> 函数，它的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<div><pre><code><span>function</span> <span>genSlot</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
  <span>const</span> slotName <span>=</span> el<span>.</span>slotName <span>||</span> <span>'"default"'</span>
  <span>const</span> children <span>=</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>let</span> res <span>=</span> <span><span>`</span><span>_t(</span><span><span>${</span>slotName<span>}</span></span><span><span>${</span>children <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>children<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span>
  <span>const</span> attrs <span>=</span> el<span>.</span>attrs <span>&amp;&amp;</span> <span><span>`</span><span>{</span><span><span>${</span>el<span>.</span>attrs<span>.</span><span>map</span><span>(</span><span>a</span> <span>=></span> <span><span>`</span><span><span>${</span><span>camelize</span><span>(</span>a<span>.</span>name<span>)</span><span>}</span></span><span>:</span><span><span>${</span>a<span>.</span>value<span>}</span></span><span>`</span></span><span>)</span><span>.</span><span>join</span><span>(</span><span>','</span><span>)</span><span>}</span></span><span>}</span><span>`</span></span>
  <span>const</span> bind <span>=</span> el<span>.</span>attrsMap<span>[</span><span>'v-bind'</span><span>]</span>
  <span>if</span> <span>(</span><span>(</span>attrs <span>||</span> bind<span>)</span> <span>&amp;&amp;</span> <span>!</span>children<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span>,null</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>attrs<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span>,</span><span><span>${</span>attrs<span>}</span></span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>bind<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span><span>${</span>attrs <span>?</span> <span>''</span> <span>:</span> <span>',null'</span><span>}</span></span><span>,</span><span><span>${</span>bind<span>}</span></span><span>`</span></span>
  <span>}</span>
  <span>return</span> res <span>+</span> <span>')'</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们先不考虑 <code>slot</code> 标签上有 <code>attrs</code> 以及 <code>v-bind</code> 的情况，那么它生成的代码实际上就只有：</p>
<div><pre><code><span>const</span> slotName <span>=</span> el<span>.</span>slotName <span>||</span> <span>'"default"'</span>
<span>const</span> children <span>=</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span>
<span>let</span> res <span>=</span> <span><span>`</span><span>_t(</span><span><span>${</span>slotName<span>}</span></span><span><span>${</span>children <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>children<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这里的 <code>slotName</code> 从 AST 元素节点对应的属性上取，默认是 <code>default</code>，而 <code>children</code> 对应的就是 <code>slot</code> 开始和闭合标签包裹的内容。来看一下我们例子的子组件最终生成的代码，如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span> <span>{</span>
  <span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span><span>{</span>
    <span>staticClass</span><span>:</span><span>"container"</span>
    <span>}</span><span>,</span><span>[</span>
      <span>_c</span><span>(</span><span>'header'</span><span>,</span><span>[</span><span>_t</span><span>(</span><span>"header"</span><span>)</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span>
      <span>_c</span><span>(</span><span>'main'</span><span>,</span><span>[</span><span>_t</span><span>(</span><span>"default"</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>"默认内容"</span><span>)</span><span>]</span><span>)</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span>
      <span>_c</span><span>(</span><span>'footer'</span><span>,</span><span>[</span><span>_t</span><span>(</span><span>"footer"</span><span>)</span><span>]</span><span>,</span><span>2</span><span>)</span>
      <span>]</span>
   <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在编译章节我们了解到，<code>_t</code> 函数对应的就是 <code>renderSlot</code> 方法，它的定义在 <code>src/core/instance/render-heplpers/render-slot.js</code> 中：</p>
<div><pre><code><span>/**
 * Runtime helper for rendering &lt;slot>
 */</span>
<span>export</span> <span>function</span> <span>renderSlot</span> <span>(</span>
  <span><span>name</span><span>:</span> string<span>,</span>
  <span>fallback</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  <span>props</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>bindObject</span><span>:</span> <span>?</span>Object</span>
<span>)</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>const</span> scopedSlotFn <span>=</span> <span>this</span><span>.</span>$scopedSlots<span>[</span>name<span>]</span>
  <span>let</span> nodes
  <span>if</span> <span>(</span>scopedSlotFn<span>)</span> <span>{</span> <span>// scoped slot</span>
    props <span>=</span> props <span>||</span> <span>{</span><span>}</span>
    <span>if</span> <span>(</span>bindObject<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span><span>isObject</span><span>(</span>bindObject<span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'slot v-bind without argument expects an Object'</span><span>,</span>
          <span>this</span>
        <span>)</span>
      <span>}</span>
      props <span>=</span> <span>extend</span><span>(</span><span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> bindObject<span>)</span><span>,</span> props<span>)</span>
    <span>}</span>
    nodes <span>=</span> <span>scopedSlotFn</span><span>(</span>props<span>)</span> <span>||</span> fallback
  <span>}</span> <span>else</span> <span>{</span>
    <span>const</span> slotNodes <span>=</span> <span>this</span><span>.</span>$slots<span>[</span>name<span>]</span>
    <span>// warn duplicate slot usage</span>
    <span>if</span> <span>(</span>slotNodes<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> slotNodes<span>.</span>_rendered<span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>Duplicate presence of slot "</span><span><span>${</span>name<span>}</span></span><span>" found in the same render tree </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>- this will likely cause render errors.</span><span>`</span></span><span>,</span>
          <span>this</span>
        <span>)</span>
      <span>}</span>
      slotNodes<span>.</span>_rendered <span>=</span> <span>true</span>
    <span>}</span>
    nodes <span>=</span> slotNodes <span>||</span> fallback
  <span>}</span>

  <span>const</span> target <span>=</span> props <span>&amp;&amp;</span> props<span>.</span>slot
  <span>if</span> <span>(</span>target<span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>$createElement</span><span>(</span><span>'template'</span><span>,</span> <span>{</span> <span>slot</span><span>:</span> target <span>}</span><span>,</span> nodes<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> nodes
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>render-slot</code> 的参数 <code>name</code> 代表插槽名称 <code>slotName</code>，<code>fallback</code> 代表插槽的默认内容生成的 <code>vnode</code> 数组。先忽略 <code>scoped-slot</code>，只看默认插槽逻辑。如果 <code>this.$slot[name]</code> 有值，就返回它对应的 <code>vnode</code> 数组，否则返回 <code>fallback</code>。那么这个 <code>this.$slot</code> 是哪里来的呢？我们知道子组件的 <code>init</code> 时机是在父组件执行 <code>patch</code> 过程的时候，那这个时候父组件已经编译完成了。并且子组件在 <code>init</code> 过程中会执行 <code>initRender</code> 函数，<code>initRender</code> 的时候获取到 <code>  vm.$slot</code>，相关代码在 <code>src/core/instance/render.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initRender</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> parentVnode <span>=</span> vm<span>.</span>$vnode <span>=</span> options<span>.</span>_parentVnode <span>// the placeholder node in parent tree</span>
  <span>const</span> renderContext <span>=</span> parentVnode <span>&amp;&amp;</span> parentVnode<span>.</span>context
  vm<span>.</span>$slots <span>=</span> <span>resolveSlots</span><span>(</span>options<span>.</span>_renderChildren<span>,</span> renderContext<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>vm.$slots</code> 是通过执行 <code>resolveSlots(options._renderChildren, renderContext)</code> 返回的，它的定义在 <code>src/core/instance/render-helpers/resolve-slots.js</code> 中：</p>
<div><pre><code><span>/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */</span>
<span>export</span> <span>function</span> <span>resolveSlots</span> <span>(</span>
  <span><span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  <span>context</span><span>:</span> <span>?</span>Component</span>
<span>)</span><span>:</span> <span>{</span> <span>[</span>key<span>:</span> string<span>]</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>}</span> <span>{</span>
  <span>const</span> slots <span>=</span> <span>{</span><span>}</span>
  <span>if</span> <span>(</span><span>!</span>children<span>)</span> <span>{</span>
    <span>return</span> slots
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> children<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> child <span>=</span> children<span>[</span>i<span>]</span>
    <span>const</span> data <span>=</span> child<span>.</span>data
    <span>// remove slot attribute if the node is resolved as a Vue slot node</span>
    <span>if</span> <span>(</span>data <span>&amp;&amp;</span> data<span>.</span>attrs <span>&amp;&amp;</span> data<span>.</span>attrs<span>.</span>slot<span>)</span> <span>{</span>
      <span>delete</span> data<span>.</span>attrs<span>.</span>slot
    <span>}</span>
    <span>// named slots should only be respected if the vnode was rendered in the</span>
    <span>// same context.</span>
    <span>if</span> <span>(</span><span>(</span>child<span>.</span>context <span>===</span> context <span>||</span> child<span>.</span>fnContext <span>===</span> context<span>)</span> <span>&amp;&amp;</span>
      data <span>&amp;&amp;</span> data<span>.</span>slot <span>!=</span> <span>null</span>
    <span>)</span> <span>{</span>
      <span>const</span> name <span>=</span> data<span>.</span>slot
      <span>const</span> slot <span>=</span> <span>(</span>slots<span>[</span>name<span>]</span> <span>||</span> <span>(</span>slots<span>[</span>name<span>]</span> <span>=</span> <span>[</span><span>]</span><span>)</span><span>)</span>
      <span>if</span> <span>(</span>child<span>.</span>tag <span>===</span> <span>'template'</span><span>)</span> <span>{</span>
        slot<span>.</span><span>push</span><span>.</span><span>apply</span><span>(</span>slot<span>,</span> child<span>.</span>children <span>||</span> <span>[</span><span>]</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        slot<span>.</span><span>push</span><span>(</span>child<span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>(</span>slots<span>.</span>default <span>||</span> <span>(</span>slots<span>.</span>default <span>=</span> <span>[</span><span>]</span><span>)</span><span>)</span><span>.</span><span>push</span><span>(</span>child<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>// ignore slots that contains only whitespace</span>
  <span>for</span> <span>(</span><span>const</span> name <span>in</span> slots<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>slots<span>[</span>name<span>]</span><span>.</span><span>every</span><span>(</span>isWhitespace<span>)</span><span>)</span> <span>{</span>
      <span>delete</span> slots<span>[</span>name<span>]</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> slots
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>resolveSlots</code> 方法接收 2 个参数，第一个参数 <code>chilren</code> 对应的是父 <code>vnode</code> 的 <code>children</code>，在我们的例子中就是 <code>&lt;app-layout&gt;</code> 和 <code>&lt;/app-layout&gt;</code> 包裹的内容。第二个参数 <code>context</code> 是父 <code>vnode</code> 的上下文，也就是父组件的 <code>vm</code> 实例。</p>
<p><code>resolveSlots</code> 函数的逻辑就是遍历 <code>chilren</code>，拿到每一个 <code>child</code> 的 <code>data</code>，然后通过 <code>data.slot</code> 获取到插槽名称，这个 <code>slot</code> 就是我们之前编译父组件在 <code>codegen</code> 阶段设置的 <code>data.slot</code>。接着以插槽名称为 <code>key</code> 把 <code>child</code> 添加到 <code>slots</code> 中，如果 <code>data.slot</code> 不存在，则是默认插槽的内容，则把对应的 <code>child</code> 添加到 <code>slots.defaults</code> 中。这样就获取到整个 <code>slots</code>，它是一个对象，<code>key</code> 是插槽名称，<code>value</code> 是一个 <code>vnode</code> 类型的数组，因为它可以有多个同名插槽。</p>
<p>这样我们就拿到了 <code>vm.$slots</code> 了，回到 <code>renderSlot</code> 函数，<code>const slotNodes = this.$slots[name]</code>，我们也就能根据插槽名称获取到对应的 <code>vnode</code> 数组了，这个数组里的 <code>vnode</code> 都是在父组件创建的，这样就实现了在父组件替换子组件插槽的内容了。</p>
<p>对应的 <code>slot</code> 渲染成 <code>vnodes</code>，作为当前组件渲染 <code>vnode</code> 的 <code>children</code>，之后的渲染过程之前分析过，不再赘述。</p>
<p>我们知道在普通插槽中，父组件应用到子组件插槽里的数据都是绑定到父组件的，因为它渲染成 <code>vnode</code> 的时机的上下文是父组件的实例。但是在一些实际开发中，我们想通过子组件的一些数据来决定父组件实现插槽的逻辑，Vue 提供了另一种插槽——作用域插槽，接下来我们就来分析一下它的实现原理。</p>
<h2 id="作用域插槽" tabindex="-1"> 作用域插槽</h2>
<p>为了更加直观，我们也是通过一个例子来分析作用域插槽的实现：</p>
<div><pre><code><span>let</span> Child <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;slot text="Hello " :msg="msg">&lt;/slot>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>msg</span><span>:</span> <span>'Vue'</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;child>'</span> <span>+</span>
  <span>'&lt;template slot-scope="props">'</span> <span>+</span>
  <span>'&lt;p>Hello from parent&lt;/p>'</span> <span>+</span>
  <span>'&lt;p>{{ props.text + props.msg}}&lt;/p>'</span> <span>+</span>
  <span>'&lt;/template>'</span> <span>+</span>
  <span>'&lt;/child>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    Child
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最终生成的 DOM 结构如下：</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>child<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Hello from parent<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Hello Vue<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以看到子组件的 <code>slot</code> 标签多了 <code>text</code> 属性，以及 <code>:msg</code> 属性。父组件实现插槽的部分多了一个 <code>template</code> 标签，以及 <code>scope-slot</code> 属性，其实在 Vue 2.5+ 版本，<code>scoped-slot</code> 可以作用在普通元素上。这些就是作用域插槽和普通插槽在写法上的差别。</p>
<p>在编译阶段，仍然是先编译父组件，同样是通过 <code>processSlot</code> 函数去处理 <code>scoped-slot</code>，它的定义在在 <code>src/compiler/parser/index.js</code> 中：</p>
<div><pre><code><span>function</span> <span>processSlot</span> <span>(</span><span>el</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>let</span> slotScope
  <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'template'</span><span>)</span> <span>{</span>
    slotScope <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'scope'</span><span>)</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> slotScope<span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>the "scope" attribute for scoped slots have been deprecated and </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>replaced by "slot-scope" since 2.5. The new "slot-scope" attribute </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>can also be used on plain elements in addition to &lt;template> to </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>denote scoped slots.</span><span>`</span></span><span>,</span>
        <span>true</span>
      <span>)</span>
    <span>}</span>
    el<span>.</span>slotScope <span>=</span> slotScope <span>||</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'slot-scope'</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>(</span>slotScope <span>=</span> <span>getAndRemoveAttr</span><span>(</span>el<span>,</span> <span>'slot-scope'</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> el<span>.</span>attrsMap<span>[</span><span>'v-for'</span><span>]</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>Ambiguous combined usage of slot-scope and v-for on &lt;</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>> </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>(v-for takes higher priority). Use a wrapper &lt;template> for the </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>scoped slot to make it clearer.</span><span>`</span></span><span>,</span>
        <span>true</span>
      <span>)</span>
    <span>}</span>
    el<span>.</span>slotScope <span>=</span> slotScope
  <span>}</span>
  <span>// ...</span>
<span>}</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这块逻辑很简单，读取 <code>scoped-slot</code> 属性并赋值给当前 AST 元素节点的 <code>slotScope</code> 属性，接下来在构造 AST 树的时候，会执行以下逻辑：</p>
<div><pre><code><span>if</span> <span>(</span>element<span>.</span>elseif <span>||</span> element<span>.</span>else<span>)</span> <span>{</span>
  <span>processIfConditions</span><span>(</span>element<span>,</span> currentParent<span>)</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span>element<span>.</span>slotScope<span>)</span> <span>{</span> 
  currentParent<span>.</span>plain <span>=</span> <span>false</span>
  <span>const</span> name <span>=</span> element<span>.</span>slotTarget <span>||</span> <span>'"default"'</span>
  <span>;</span><span>(</span>currentParent<span>.</span>scopedSlots <span>||</span> <span>(</span>currentParent<span>.</span>scopedSlots <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>[</span>name<span>]</span> <span>=</span> element
<span>}</span> <span>else</span> <span>{</span>
  currentParent<span>.</span>children<span>.</span><span>push</span><span>(</span>element<span>)</span>
  element<span>.</span>parent <span>=</span> currentParent
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到对于拥有 <code>scopedSlot</code> 属性的 AST 元素节点而言，是不会作为 <code>children</code> 添加到当前 AST 树中，而是存到父 AST 元素节点的 <code>scopedSlots</code> 属性上，它是一个对象，以插槽名称 <code>name</code> 为 <code>key</code>。</p>
<p>然后在 <code>genData</code> 的过程，会对 <code>scopedSlots</code> 做处理：</p>
<div><pre><code><span>if</span> <span>(</span>el<span>.</span>scopedSlots<span>)</span> <span>{</span>
  data <span>+=</span> <span><span>`</span><span><span>${</span><span>genScopedSlots</span><span>(</span>el<span>.</span>scopedSlots<span>,</span> state<span>)</span><span>}</span></span><span>,</span><span>`</span></span>
<span>}</span>

<span>function</span> <span>genScopedSlots</span> <span>(</span>
  <span><span>slots</span><span>:</span> <span>{</span> <span>[</span>key<span>:</span> string<span>]</span><span>:</span> ASTElement <span>}</span><span>,</span>
  <span>state</span><span>:</span> CodegenState</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>return</span> <span><span>`</span><span>scopedSlots:_u([</span><span><span>${</span>
    Object<span>.</span><span>keys</span><span>(</span>slots<span>)</span><span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
      <span>return</span> <span>genScopedSlot</span><span>(</span>key<span>,</span> slots<span>[</span>key<span>]</span><span>,</span> state<span>)</span>
    <span>}</span><span>)</span><span>.</span><span>join</span><span>(</span><span>','</span><span>)</span>
  <span>}</span></span><span>])</span><span>`</span></span>
<span>}</span>

<span>function</span> <span>genScopedSlot</span> <span>(</span>
  <span><span>key</span><span>:</span> string<span>,</span>
  <span>el</span><span>:</span> ASTElement<span>,</span>
  <span>state</span><span>:</span> CodegenState</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>if</span> <span>(</span>el<span>.</span>for <span>&amp;&amp;</span> <span>!</span>el<span>.</span>forProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genForScopedSlot</span><span>(</span>key<span>,</span> el<span>,</span> state<span>)</span>
  <span>}</span>
  <span>const</span> fn <span>=</span> <span><span>`</span><span>function(</span><span><span>${</span><span>String</span><span>(</span>el<span>.</span>slotScope<span>)</span><span>}</span></span><span>){</span><span>`</span></span> <span>+</span>
    <span><span>`</span><span>return </span><span><span>${</span>el<span>.</span>tag <span>===</span> <span>'template'</span>
      <span>?</span> el<span>.</span>if
        <span>?</span> <span><span>`</span><span><span>${</span>el<span>.</span>if<span>}</span></span><span>?</span><span><span>${</span><span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span> <span>||</span> <span>'undefined'</span><span>}</span></span><span>:undefined</span><span>`</span></span>
        <span>:</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span> <span>||</span> <span>'undefined'</span>
      <span>:</span> <span>genElement</span><span>(</span>el<span>,</span> state<span>)</span>
    <span>}</span></span><span>}</span><span>`</span></span>
  <span>return</span> <span><span>`</span><span>{key:</span><span><span>${</span>key<span>}</span></span><span>,fn:</span><span><span>${</span>fn<span>}</span></span><span>}</span><span>`</span></span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genScopedSlots</code> 就是对 <code>scopedSlots</code> 对象遍历，执行 <code>genScopedSlot</code>，并把结果用逗号拼接，而 <code>genScopedSlot</code> 是先生成一段函数代码，并且函数的参数就是我们的 <code>slotScope</code>，也就是写在标签属性上的 <code>scoped-slot</code> 对应的值，然后再返回一个对象，<code>key</code> 为插槽名称，<code>fn</code> 为生成的函数代码。</p>
<p>对于我们这个例子而言，父组件最终生成的代码如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span><span>{</span>
  <span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span>
    <span>[</span><span>_c</span><span>(</span><span>'child'</span><span>,</span>
      <span>{</span><span>scopedSlots</span><span>:</span><span>_u</span><span>(</span><span>[</span>
        <span>{</span>
          <span>key</span><span>:</span> <span>"default"</span><span>,</span>
          <span>fn</span><span>:</span> <span>function</span><span>(</span><span>props</span><span>)</span> <span>{</span>
            <span>return</span> <span>[</span>
              <span>_c</span><span>(</span><span>'p'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>"Hello from parent"</span><span>)</span><span>]</span><span>)</span><span>,</span>
              <span>_c</span><span>(</span><span>'p'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>props<span>.</span>text <span>+</span> props<span>.</span>msg<span>)</span><span>)</span><span>]</span><span>)</span>
            <span>]</span>
          <span>}</span>
        <span>}</span><span>]</span><span>)</span>
      <span>}</span>
    <span>)</span><span>]</span><span>,</span>
  <span>1</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到它和普通插槽父组件编译结果的一个很明显的区别就是没有 <code>children</code> 了，<code>data</code> 部分多了一个对象，并且执行了 <code>_u</code> 方法，在编译章节我们了解到，<code>_u</code> 函数对的就是 <code>resolveScopedSlots</code> 方法，它的定义在 <code>src/core/instance/render-heplpers/resolve-slots.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>resolveScopedSlots</span> <span>(</span>
  <span>fns</span><span>:</span> ScopedSlotsData<span>,</span> <span>// see flow/vnode</span>
  res<span>?</span><span>:</span> Object
<span>)</span><span>:</span> <span>{</span> <span>[</span>key<span>:</span> string<span>]</span><span>:</span> Function <span>}</span> <span>{</span>
  res <span>=</span> res <span>||</span> <span>{</span><span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> fns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>fns<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
      <span>resolveScopedSlots</span><span>(</span>fns<span>[</span>i<span>]</span><span>,</span> res<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      res<span>[</span>fns<span>[</span>i<span>]</span><span>.</span>key<span>]</span> <span>=</span> fns<span>[</span>i<span>]</span><span>.</span>fn
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中，<code>fns</code> 是一个数组，每一个数组元素都有一个 <code>key</code> 和一个 <code>fn</code>，<code>key</code> 对应的是插槽的名称，<code>fn</code> 对应一个函数。整个逻辑就是遍历这个 <code>fns</code> 数组，生成一个对象，对象的 <code>key</code> 就是插槽名称，<code>value</code> 就是函数。这个函数的执行时机稍后我们会介绍。</p>
<p>接着我们再来看一下子组件的编译，和普通插槽的过程基本相同，唯一一点区别是在 <code>genSlot</code> 的时候：</p>
<div><pre><code><span>function</span> <span>genSlot</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
  <span>const</span> slotName <span>=</span> el<span>.</span>slotName <span>||</span> <span>'"default"'</span>
  <span>const</span> children <span>=</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>let</span> res <span>=</span> <span><span>`</span><span>_t(</span><span><span>${</span>slotName<span>}</span></span><span><span>${</span>children <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>children<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span>
  <span>const</span> attrs <span>=</span> el<span>.</span>attrs <span>&amp;&amp;</span> <span><span>`</span><span>{</span><span><span>${</span>el<span>.</span>attrs<span>.</span><span>map</span><span>(</span><span>a</span> <span>=></span> <span><span>`</span><span><span>${</span><span>camelize</span><span>(</span>a<span>.</span>name<span>)</span><span>}</span></span><span>:</span><span><span>${</span>a<span>.</span>value<span>}</span></span><span>`</span></span><span>)</span><span>.</span><span>join</span><span>(</span><span>','</span><span>)</span><span>}</span></span><span>}</span><span>`</span></span>
  <span>const</span> bind <span>=</span> el<span>.</span>attrsMap<span>[</span><span>'v-bind'</span><span>]</span>
  <span>if</span> <span>(</span><span>(</span>attrs <span>||</span> bind<span>)</span> <span>&amp;&amp;</span> <span>!</span>children<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span>,null</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>attrs<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span>,</span><span><span>${</span>attrs<span>}</span></span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>bind<span>)</span> <span>{</span>
    res <span>+=</span> <span><span>`</span><span><span>${</span>attrs <span>?</span> <span>''</span> <span>:</span> <span>',null'</span><span>}</span></span><span>,</span><span><span>${</span>bind<span>}</span></span><span>`</span></span>
  <span>}</span>
  <span>return</span> res <span>+</span> <span>')'</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它会对 <code>attrs</code> 和 <code>v-bind</code> 做处理，对应到我们的例子，最终生成的代码如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span><span>{</span>
  <span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span>
    <span>{</span><span>staticClass</span><span>:</span><span>"child"</span><span>}</span><span>,</span>
    <span>[</span><span>_t</span><span>(</span><span>"default"</span><span>,</span><span>null</span><span>,</span>
      <span>{</span><span>text</span><span>:</span><span>"Hello "</span><span>,</span><span>msg</span><span>:</span>msg<span>}</span>
    <span>)</span><span>]</span><span>,</span>
  <span>2</span><span>)</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>_t</code> 方法我们之前介绍过，对应的是 <code>renderSlot</code> 方法：</p>
<div><pre><code><span>export</span> <span>function</span> <span>renderSlot</span> <span>(</span>
  <span><span>name</span><span>:</span> string<span>,</span>
  <span>fallback</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  <span>props</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>bindObject</span><span>:</span> <span>?</span>Object</span>
<span>)</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span> <span>{</span>
  <span>const</span> scopedSlotFn <span>=</span> <span>this</span><span>.</span>$scopedSlots<span>[</span>name<span>]</span>
  <span>let</span> nodes
  <span>if</span> <span>(</span>scopedSlotFn<span>)</span> <span>{</span>
    props <span>=</span> props <span>||</span> <span>{</span><span>}</span>
    <span>if</span> <span>(</span>bindObject<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span><span>isObject</span><span>(</span>bindObject<span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'slot v-bind without argument expects an Object'</span><span>,</span>
          <span>this</span>
        <span>)</span>
      <span>}</span>
      props <span>=</span> <span>extend</span><span>(</span><span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> bindObject<span>)</span><span>,</span> props<span>)</span>
    <span>}</span>
    nodes <span>=</span> <span>scopedSlotFn</span><span>(</span>props<span>)</span> <span>||</span> fallback
  <span>}</span> <span>else</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>

  <span>const</span> target <span>=</span> props <span>&amp;&amp;</span> props<span>.</span>slot
  <span>if</span> <span>(</span>target<span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>$createElement</span><span>(</span><span>'template'</span><span>,</span> <span>{</span> <span>slot</span><span>:</span> target <span>}</span><span>,</span> nodes<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> nodes
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们只关注作用域插槽的逻辑，那么这个 <code>this.$scopedSlots</code> 又是在什么地方定义的呢，原来在子组件的渲染函数执行前，在 <code>vm_render</code> 方法内，有这么一段逻辑，定义在 <code>src/core/instance/render.js</code> 中：</p>
<div><pre><code> <span>if</span> <span>(</span>_parentVnode<span>)</span> <span>{</span>
  vm<span>.</span>$scopedSlots <span>=</span> _parentVnode<span>.</span>data<span>.</span>scopedSlots <span>||</span> emptyObject
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这个 <code>_parentVNode.data.scopedSlots</code> 对应的就是我们在父组件通过执行 <code>resolveScopedSlots</code> 返回的对象。所以回到 <code>genSlot</code> 函数，我们就可以通过插槽的名称拿到对应的 <code>scopedSlotFn</code>，然后把相关的数据扩展到 <code>props</code> 上，作为函数的参数传入，原来之前我们提到的函数这个时候执行，然后返回生成的 <code>vnodes</code>，为后续渲染节点用。</p>
<p>后续流程之前已介绍过，不再赘述，那么至此，作用域插槽的实现也就分析完毕。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一章的分析，我们了解了普通插槽和作用域插槽的实现。它们有一个很大的差别是数据作用域，普通插槽是在父组件编译和渲染阶段生成 <code>vnodes</code>，所以数据的作用域是父组件实例，子组件渲染的时候直接拿到这些渲染好的 <code>vnodes</code>。而对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 <code>vnodes</code>，而是在父节点 <code>vnode</code> 的 <code>data</code> 中保留一个 <code>scopedSlots</code> 对象，存储着不同名称的插槽以及它们对应的渲染函数，只有在编译和渲染子组件阶段才会执行这个渲染函数生成 <code>vnodes</code>，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。</p>
<p>简单地说，两种插槽的目的都是让子组件 <code>slot</code> 占位符生成的内容由父组件来决定，但数据的作用域会根据它们 <code>vnodes</code> 渲染时机不同而不同。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">transition-group</title>
    <id>https://0808200.xyz/vue2/extend/tansition-group.html</id>
    <link href="https://0808200.xyz/vue2/extend/tansition-group.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="transition-group" tabindex="-1"> transition-group</h1>
<p>前一节我们介绍了 <code>&lt;transiiton&gt;</code> 组件的实现原理，它只能针对单一元素实现过渡效果。我们做前端开发经常会遇到列表的需求，我们对列表元素进行添加和删除，有时候也希望有过渡效果，Vue.js 提供了 <code>&lt;transition-group&gt;</code> 组件，很好地帮助我们实现了列表的过渡效果。那么接下来我们就来分析一下它的实现原理。</p>
<p>为了更直观，我们也是通过一个示例来说明：</p>
<div><pre><code><span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div id="list-complete-demo">'</span> <span>+</span>
  <span>'&lt;button v-on:click="add">Add&lt;/button>'</span> <span>+</span>
  <span>'&lt;button v-on:click="remove">Remove&lt;/button>'</span> <span>+</span>
  <span>'&lt;transition-group name="list-complete" tag="p">'</span> <span>+</span>
  <span>'&lt;span v-for="item in items" v-bind:key="item">'</span> <span>+</span>
  <span>'{{ item }}'</span> <span>+</span>
  <span>'&lt;/span>'</span> <span>+</span>
  <span>'&lt;/transition-group>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>items</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>,</span>
    <span>nextNum</span><span>:</span> <span>10</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>randomIndex</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>this</span><span>.</span>items<span>.</span>length<span>)</span>
    <span>}</span><span>,</span>
    <span>add</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>items<span>.</span><span>splice</span><span>(</span><span>this</span><span>.</span><span>randomIndex</span><span>(</span><span>)</span><span>,</span> <span>0</span><span>,</span> <span>this</span><span>.</span>nextNum<span>++</span><span>)</span>
    <span>}</span><span>,</span>
    <span>remove</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>items<span>.</span><span>splice</span><span>(</span><span>this</span><span>.</span><span>randomIndex</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code> <span>.list-complete-item</span> <span>{</span>
  <span>display</span><span>:</span> inline-block<span>;</span>
  <span>margin-right</span><span>:</span> 10px<span>;</span>
<span>}</span>
<span>.list-complete-move</span> <span>{</span>
  <span>transition</span><span>:</span> all 1s<span>;</span>
<span>}</span>
<span>.list-complete-enter, .list-complete-leave-to</span> <span>{</span>
  <span>opacity</span><span>:</span> 0<span>;</span>
  <span>transform</span><span>:</span> <span>translateY</span><span>(</span>30px<span>)</span><span>;</span>
<span>}</span>
<span>.list-complete-enter-active</span> <span>{</span>
  <span>transition</span><span>:</span> all 1s<span>;</span>
<span>}</span>
<span>.list-complete-leave-active</span> <span>{</span>
  <span>transition</span><span>:</span> all 1s<span>;</span>
  <span>position</span><span>:</span> absolute<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个示例初始会展现 1-9 十个数字，当我们点击 <code>Add</code> 按钮时，会生成 <code>nextNum</code> 并随机在当前数列表中插入；当我们点击 <code>Remove</code> 按钮时，会随机删除掉一个数。我们会发现在数添加删除的过程中在列表中会有过渡动画，这就是 <code>&lt;transition-group&gt;</code> 组件配合我们定义的 CSS 产生的效果。</p>
<p>我们首先还是来分析 <code>&lt;transtion-group&gt;</code> 组件的实现，它的定义在 <code>src/platforms/web/runtime/components/transitions.js</code> 中：</p>
<div><pre><code><span>const</span> props <span>=</span> <span>extend</span><span>(</span><span>{</span>
  <span>tag</span><span>:</span> String<span>,</span>
  <span>moveClass</span><span>:</span> String
<span>}</span><span>,</span> transitionProps<span>)</span>

<span>delete</span> props<span>.</span>mode

<span>export</span> <span>default</span> <span>{</span>
  props<span>,</span>

  <span>beforeMount</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> update <span>=</span> <span>this</span><span>.</span>_update
    <span>this</span><span>.</span><span>_update</span> <span>=</span> <span>(</span><span>vnode<span>,</span> hydrating</span><span>)</span> <span>=></span> <span>{</span>
      <span>// force removing pass</span>
      <span>this</span><span>.</span><span>__patch__</span><span>(</span>
        <span>this</span><span>.</span>_vnode<span>,</span>
        <span>this</span><span>.</span>kept<span>,</span>
        <span>false</span><span>,</span> <span>// hydrating</span>
        <span>true</span> <span>// removeOnly (!important, avoids unnecessary moves)</span>
      <span>)</span>
      <span>this</span><span>.</span>_vnode <span>=</span> <span>this</span><span>.</span>kept
      <span>update</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> vnode<span>,</span> hydrating<span>)</span>
    <span>}</span>
  <span>}</span><span>,</span>

  <span>render</span> <span>(</span><span><span>h</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>const</span> <span>tag</span><span>:</span> string <span>=</span> <span>this</span><span>.</span>tag <span>||</span> <span>this</span><span>.</span>$vnode<span>.</span>data<span>.</span>tag <span>||</span> <span>'span'</span>
    <span>const</span> <span>map</span><span>:</span> Object <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>const</span> <span>prevChildren</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>prevChildren <span>=</span> <span>this</span><span>.</span>children
    <span>const</span> <span>rawChildren</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>$slots<span>.</span>default <span>||</span> <span>[</span><span>]</span>
    <span>const</span> <span>children</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>children <span>=</span> <span>[</span><span>]</span>
    <span>const</span> <span>transitionData</span><span>:</span> Object <span>=</span> <span>extractTransitionData</span><span>(</span><span>this</span><span>)</span>

    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rawChildren<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>const</span> <span>c</span><span>:</span> VNode <span>=</span> rawChildren<span>[</span>i<span>]</span>
      <span>if</span> <span>(</span>c<span>.</span>tag<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>c<span>.</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>String</span><span>(</span>c<span>.</span>key<span>)</span><span>.</span><span>indexOf</span><span>(</span><span>'__vlist'</span><span>)</span> <span>!==</span> <span>0</span><span>)</span> <span>{</span>
          children<span>.</span><span>push</span><span>(</span>c<span>)</span>
          map<span>[</span>c<span>.</span>key<span>]</span> <span>=</span> c
          <span>;</span><span>(</span>c<span>.</span>data <span>||</span> <span>(</span>c<span>.</span>data <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>.</span>transition <span>=</span> transitionData
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
          <span>const</span> <span>opts</span><span>:</span> <span>?</span>VNodeComponentOptions <span>=</span> c<span>.</span>componentOptions
          <span>const</span> <span>name</span><span>:</span> string <span>=</span> opts <span>?</span> <span>(</span>opts<span>.</span>Ctor<span>.</span>options<span>.</span>name <span>||</span> opts<span>.</span>tag <span>||</span> <span>''</span><span>)</span> <span>:</span> c<span>.</span>tag
          <span>warn</span><span>(</span><span><span>`</span><span>&lt;transition-group> children must be keyed: &lt;</span><span><span>${</span>name<span>}</span></span><span>></span><span>`</span></span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span>prevChildren<span>)</span> <span>{</span>
      <span>const</span> <span>kept</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>[</span><span>]</span>
      <span>const</span> <span>removed</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>[</span><span>]</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> prevChildren<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>const</span> <span>c</span><span>:</span> VNode <span>=</span> prevChildren<span>[</span>i<span>]</span>
        c<span>.</span>data<span>.</span>transition <span>=</span> transitionData
        c<span>.</span>data<span>.</span>pos <span>=</span> c<span>.</span>elm<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span>
        <span>if</span> <span>(</span>map<span>[</span>c<span>.</span>key<span>]</span><span>)</span> <span>{</span>
          kept<span>.</span><span>push</span><span>(</span>c<span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          removed<span>.</span><span>push</span><span>(</span>c<span>)</span>
        <span>}</span>
      <span>}</span>
      <span>this</span><span>.</span>kept <span>=</span> <span>h</span><span>(</span>tag<span>,</span> <span>null</span><span>,</span> kept<span>)</span>
      <span>this</span><span>.</span>removed <span>=</span> removed
    <span>}</span>

    <span>return</span> <span>h</span><span>(</span>tag<span>,</span> <span>null</span><span>,</span> children<span>)</span>
  <span>}</span><span>,</span>

  <span>updated</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>children</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>prevChildren
    <span>const</span> <span>moveClass</span><span>:</span> string <span>=</span> <span>this</span><span>.</span>moveClass <span>||</span> <span>(</span><span>(</span><span>this</span><span>.</span>name <span>||</span> <span>'v'</span><span>)</span> <span>+</span> <span>'-move'</span><span>)</span>
    <span>if</span> <span>(</span><span>!</span>children<span>.</span>length <span>||</span> <span>!</span><span>this</span><span>.</span><span>hasMove</span><span>(</span>children<span>[</span><span>0</span><span>]</span><span>.</span>elm<span>,</span> moveClass<span>)</span><span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>

    <span>// we divide the work into three loops to avoid mixing DOM reads and writes</span>
    <span>// in each iteration - which helps prevent layout thrashing.</span>
    children<span>.</span><span>forEach</span><span>(</span>callPendingCbs<span>)</span>
    children<span>.</span><span>forEach</span><span>(</span>recordPosition<span>)</span>
    children<span>.</span><span>forEach</span><span>(</span>applyTranslation<span>)</span>

    <span>// force reflow to put everything in position</span>
    <span>// assign to this to avoid being removed in tree-shaking</span>
    <span>// $flow-disable-line</span>
    <span>this</span><span>.</span>_reflow <span>=</span> document<span>.</span>body<span>.</span>offsetHeight

    children<span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>c<span>.</span>data<span>.</span>moved<span>)</span> <span>{</span>
        <span>var</span> <span>el</span><span>:</span> any <span>=</span> c<span>.</span>elm
        <span>var</span> <span>s</span><span>:</span> any <span>=</span> el<span>.</span>style
        <span>addTransitionClass</span><span>(</span>el<span>,</span> moveClass<span>)</span>
        s<span>.</span>transform <span>=</span> s<span>.</span>WebkitTransform <span>=</span> s<span>.</span>transitionDuration <span>=</span> <span>''</span>
        el<span>.</span><span>addEventListener</span><span>(</span>transitionEndEvent<span>,</span> el<span>.</span><span>_moveCb</span> <span>=</span> <span>function</span> <span>cb</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
          <span>if</span> <span>(</span><span>!</span>e <span>||</span> <span><span>/</span><span>transform$</span><span>/</span></span><span>.</span><span>test</span><span>(</span>e<span>.</span>propertyName<span>)</span><span>)</span> <span>{</span>
            el<span>.</span><span>removeEventListener</span><span>(</span>transitionEndEvent<span>,</span> cb<span>)</span>
            el<span>.</span>_moveCb <span>=</span> <span>null</span>
            <span>removeTransitionClass</span><span>(</span>el<span>,</span> moveClass<span>)</span>
          <span>}</span>
        <span>}</span><span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span><span>,</span>

  <span>methods</span><span>:</span> <span>{</span>
    <span>hasMove</span> <span>(</span>el<span>:</span> any<span>,</span> <span>moveClass</span><span>:</span> string<span>)</span><span>:</span> boolean <span>{</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span><span>!</span>hasTransition<span>)</span> <span>{</span>
        <span>return</span> <span>false</span>
      <span>}</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>_hasMove<span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>_hasMove
      <span>}</span>
      <span>// Detect whether an element with the move class applied has</span>
      <span>// CSS transitions. Since the element may be inside an entering</span>
      <span>// transition at this very moment, we make a clone of it and remove</span>
      <span>// all other transition classes applied to ensure only the move class</span>
      <span>// is applied.</span>
      <span>const</span> <span>clone</span><span>:</span> HTMLElement <span>=</span> el<span>.</span><span>cloneNode</span><span>(</span><span>)</span>
      <span>if</span> <span>(</span>el<span>.</span>_transitionClasses<span>)</span> <span>{</span>
        el<span>.</span>_transitionClasses<span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>cls</span><span>:</span> string</span><span>)</span> <span>=></span> <span>{</span> <span>removeClass</span><span>(</span>clone<span>,</span> cls<span>)</span> <span>}</span><span>)</span>
      <span>}</span>
      <span>addClass</span><span>(</span>clone<span>,</span> moveClass<span>)</span>
      clone<span>.</span>style<span>.</span>display <span>=</span> <span>'none'</span>
      <span>this</span><span>.</span>$el<span>.</span><span>appendChild</span><span>(</span>clone<span>)</span>
      <span>const</span> <span>info</span><span>:</span> Object <span>=</span> <span>getTransitionInfo</span><span>(</span>clone<span>)</span>
      <span>this</span><span>.</span>$el<span>.</span><span>removeChild</span><span>(</span>clone<span>)</span>
      <span>return</span> <span>(</span><span>this</span><span>.</span>_hasMove <span>=</span> info<span>.</span>hasTransform<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="render-函数" tabindex="-1"> render 函数</h2>
<p><code>&lt;transition-group&gt;</code> 组件也是由 <code>render</code> 函数渲染生成 <code>vnode</code>，接下来我们先分析 <code>render</code> 的实现。</p>
<ul>
<li>定义一些变量</li>
</ul>
<div><pre><code><span>const</span> <span>tag</span><span>:</span> string <span>=</span> <span>this</span><span>.</span>tag <span>||</span> <span>this</span><span>.</span>$vnode<span>.</span>data<span>.</span>tag <span>||</span> <span>'span'</span>
<span>const</span> <span>map</span><span>:</span> Object <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
<span>const</span> <span>prevChildren</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>prevChildren <span>=</span> <span>this</span><span>.</span>children
<span>const</span> <span>rawChildren</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>$slots<span>.</span>default <span>||</span> <span>[</span><span>]</span>
<span>const</span> <span>children</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>children <span>=</span> <span>[</span><span>]</span>
<span>const</span> <span>transitionData</span><span>:</span> Object <span>=</span> <span>extractTransitionData</span><span>(</span><span>this</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>不同于 <code>&lt;transition&gt;</code> 组件，<code>&lt;transition-group&gt;</code> 组件非抽象组件，它会渲染成一个真实元素，默认 <code>tag</code> 是 <code>span</code>。 <code>prevChildren</code> 用来存储上一次的子节点；<code>children</code> 用来存储当前的子节点；<code>rawChildren</code> 表示 <code>&lt;transtition-group&gt;</code> 包裹的原始子节点；<code>transtionData</code> 是从 <code>&lt;transtition-group&gt;</code> 组件上提取出来的一些渲染数据，这点和 <code>&lt;transition&gt;</code> 组件的实现是一样的。</p>
<ul>
<li>遍历 <code>rawChidren</code>，初始化 <code>children</code></li>
</ul>
<div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rawChildren<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>const</span> <span>c</span><span>:</span> VNode <span>=</span> rawChildren<span>[</span>i<span>]</span>
  <span>if</span> <span>(</span>c<span>.</span>tag<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c<span>.</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>String</span><span>(</span>c<span>.</span>key<span>)</span><span>.</span><span>indexOf</span><span>(</span><span>'__vlist'</span><span>)</span> <span>!==</span> <span>0</span><span>)</span> <span>{</span>
      children<span>.</span><span>push</span><span>(</span>c<span>)</span>
      map<span>[</span>c<span>.</span>key<span>]</span> <span>=</span> c
      <span>;</span><span>(</span>c<span>.</span>data <span>||</span> <span>(</span>c<span>.</span>data <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>.</span>transition <span>=</span> transitionData
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>const</span> <span>opts</span><span>:</span> <span>?</span>VNodeComponentOptions <span>=</span> c<span>.</span>componentOptions
      <span>const</span> <span>name</span><span>:</span> string <span>=</span> opts <span>?</span> <span>(</span>opts<span>.</span>Ctor<span>.</span>options<span>.</span>name <span>||</span> opts<span>.</span>tag <span>||</span> <span>''</span><span>)</span> <span>:</span> c<span>.</span>tag
      <span>warn</span><span>(</span><span><span>`</span><span>&lt;transition-group> children must be keyed: &lt;</span><span><span>${</span>name<span>}</span></span><span>></span><span>`</span></span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实就是对 <code>rawChildren</code> 遍历，拿到每个 <code>vnode</code>，然后会判断每个 <code>vnode</code> 是否设置了 <code>key</code>，这个是 <code>&lt;transition-group&gt;</code> 对列表元素的要求。然后把 <code>vnode</code> 添加到 <code>children</code> 中，然后把刚刚提取的过渡数据 <code>transitionData</code> 添加的 <code>vnode.data.transition</code> 中，这点很关键，只有这样才能实现列表中单个元素的过渡动画。</p>
<ul>
<li>处理 prevChildren</li>
</ul>
<div><pre><code><span>if</span> <span>(</span>prevChildren<span>)</span> <span>{</span>
  <span>const</span> <span>kept</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>[</span><span>]</span>
  <span>const</span> <span>removed</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> prevChildren<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> <span>c</span><span>:</span> VNode <span>=</span> prevChildren<span>[</span>i<span>]</span>
    c<span>.</span>data<span>.</span>transition <span>=</span> transitionData
    c<span>.</span>data<span>.</span>pos <span>=</span> c<span>.</span>elm<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span>map<span>[</span>c<span>.</span>key<span>]</span><span>)</span> <span>{</span>
      kept<span>.</span><span>push</span><span>(</span>c<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      removed<span>.</span><span>push</span><span>(</span>c<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>this</span><span>.</span>kept <span>=</span> <span>h</span><span>(</span>tag<span>,</span> <span>null</span><span>,</span> kept<span>)</span>
  <span>this</span><span>.</span>removed <span>=</span> removed
<span>}</span>

<span>return</span> <span>h</span><span>(</span>tag<span>,</span> <span>null</span><span>,</span> children<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当有 <code>prevChildren</code> 的时候，我们会对它做遍历，获取到每个 <code>vnode</code>，然后把 <code>transitionData</code> 赋值到 <code>vnode.data.transition</code>，这个是为了当它在 <code>enter</code> 和 <code>leave</code> 的钩子函数中有过渡动画，我们在上节介绍 <code>transition</code> 的实现中说过。接着又调用了原生 DOM 的 <code>getBoundingClientRect</code> 方法获取到原生 DOM 的位置信息，记录到 <code>vnode.data.pos</code> 中，然后判断一下 <code>vnode.key</code> 是否在 <code>map</code> 中，如果在则放入 <code>kept</code> 中，否则表示该节点已被删除，放入 <code>removed</code> 中，然后通过执行 <code>h(tag, null, kept)</code> 渲染后放入 <code>this.kept</code> 中，把 <code>removed</code> 用 <code>this.removed</code> 保存。最后整个 <code>render</code> 函数通过 <code>h(tag, null, children)</code> 生成渲染 <code>vnode</code>。</p>
<p>如果 <code>transition-group</code> 只实现了这个 <code>render</code> 函数，那么每次插入和删除的元素的缓动动画是可以实现的，在我们的例子中，当新增一个元素，它的插入的过渡动画是有的，但是剩余元素平移的过渡效果是出不来的，所以接下来我们来分析 <code>&lt;transition-group&gt;</code> 组件是如何实现剩余元素平移的过渡效果的。</p>
<h2 id="move-过渡实现" tabindex="-1"> move 过渡实现</h2>
<p>其实我们在实现元素的插入和删除，无非就是操作数据，控制它们的添加和删除。比如我们新增数据的时候，会添加一条数据，除了重新执行 <code>render</code> 函数渲染新的节点外，还要触发 <code>updated</code> 钩子函数，接着我们就来分析 <code>updated</code> 钩子函数的实现。</p>
<ul>
<li>判断子元素是否定义 <code>move</code> 相关样式</li>
</ul>
<div><pre><code><span>const</span> <span>children</span><span>:</span> Array<span>&lt;</span>VNode<span>></span> <span>=</span> <span>this</span><span>.</span>prevChildren
<span>const</span> <span>moveClass</span><span>:</span> string <span>=</span> <span>this</span><span>.</span>moveClass <span>||</span> <span>(</span><span>(</span><span>this</span><span>.</span>name <span>||</span> <span>'v'</span><span>)</span> <span>+</span> <span>'-move'</span><span>)</span>
<span>if</span> <span>(</span><span>!</span>children<span>.</span>length <span>||</span> <span>!</span><span>this</span><span>.</span><span>hasMove</span><span>(</span>children<span>[</span><span>0</span><span>]</span><span>.</span>elm<span>,</span> moveClass<span>)</span><span>)</span> <span>{</span>
  <span>return</span>
<span>}</span>

<span>hasMove</span> <span>(</span>el<span>:</span> any<span>,</span> <span>moveClass</span><span>:</span> string<span>)</span><span>:</span> boolean <span>{</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span><span>!</span>hasTransition<span>)</span> <span>{</span>
    <span>return</span> <span>false</span>
  <span>}</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>_hasMove<span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>_hasMove
  <span>}</span>
  <span>// Detect whether an element with the move class applied has</span>
  <span>// CSS transitions. Since the element may be inside an entering</span>
  <span>// transition at this very moment, we make a clone of it and remove</span>
  <span>// all other transition classes applied to ensure only the move class</span>
  <span>// is applied.</span>
  <span>const</span> <span>clone</span><span>:</span> HTMLElement <span>=</span> el<span>.</span><span>cloneNode</span><span>(</span><span>)</span>
  <span>if</span> <span>(</span>el<span>.</span>_transitionClasses<span>)</span> <span>{</span>
    el<span>.</span>_transitionClasses<span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>cls</span><span>:</span> string</span><span>)</span> <span>=></span> <span>{</span> <span>removeClass</span><span>(</span>clone<span>,</span> cls<span>)</span> <span>}</span><span>)</span>
  <span>}</span>
  <span>addClass</span><span>(</span>clone<span>,</span> moveClass<span>)</span>
  clone<span>.</span>style<span>.</span>display <span>=</span> <span>'none'</span>
  <span>this</span><span>.</span>$el<span>.</span><span>appendChild</span><span>(</span>clone<span>)</span>
  <span>const</span> <span>info</span><span>:</span> Object <span>=</span> <span>getTransitionInfo</span><span>(</span>clone<span>)</span>
  <span>this</span><span>.</span>$el<span>.</span><span>removeChild</span><span>(</span>clone<span>)</span>
  <span>return</span> <span>(</span><span>this</span><span>.</span>_hasMove <span>=</span> info<span>.</span>hasTransform<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>核心就是 <code>hasMove</code> 的判断，首先克隆一个 DOM 节点，然后为了避免影响，移除它的所有其他的过渡 <code>Class</code>；接着添加了 <code>moveClass</code> 样式，设置 <code>display</code> 为 <code>none</code>，添加到组件根节点上；接下来通过 <code>getTransitionInfo</code> 获取它的一些缓动相关的信息，这个函数在上一节我们也介绍过，然后从组件根节点上删除这个克隆节点，并通过判断 <code>info.hasTransform</code> 来判断 <code>hasMove</code>，在我们的例子中，该值为 <code>true</code>。</p>
<ul>
<li>子节点预处理</li>
</ul>
<div><pre><code>children<span>.</span><span>forEach</span><span>(</span>callPendingCbs<span>)</span>
children<span>.</span><span>forEach</span><span>(</span>recordPosition<span>)</span>
children<span>.</span><span>forEach</span><span>(</span>applyTranslation<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>对 <code>children</code> 做了 3 轮循环，分别做了如下一些处理：</p>
<div><pre><code><span>function</span> <span>callPendingCbs</span> <span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>c<span>.</span>elm<span>.</span>_moveCb<span>)</span> <span>{</span>
    c<span>.</span>elm<span>.</span><span>_moveCb</span><span>(</span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>c<span>.</span>elm<span>.</span>_enterCb<span>)</span> <span>{</span>
    c<span>.</span>elm<span>.</span><span>_enterCb</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>recordPosition</span> <span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>{</span>
  c<span>.</span>data<span>.</span>newPos <span>=</span> c<span>.</span>elm<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span>
<span>}</span>

<span>function</span> <span>applyTranslation</span> <span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>{</span>
  <span>const</span> oldPos <span>=</span> c<span>.</span>data<span>.</span>pos
  <span>const</span> newPos <span>=</span> c<span>.</span>data<span>.</span>newPos
  <span>const</span> dx <span>=</span> oldPos<span>.</span>left <span>-</span> newPos<span>.</span>left
  <span>const</span> dy <span>=</span> oldPos<span>.</span>top <span>-</span> newPos<span>.</span>top
  <span>if</span> <span>(</span>dx <span>||</span> dy<span>)</span> <span>{</span>
    c<span>.</span>data<span>.</span>moved <span>=</span> <span>true</span>
    <span>const</span> s <span>=</span> c<span>.</span>elm<span>.</span>style
    s<span>.</span>transform <span>=</span> s<span>.</span>WebkitTransform <span>=</span> <span><span>`</span><span>translate(</span><span><span>${</span>dx<span>}</span></span><span>px,</span><span><span>${</span>dy<span>}</span></span><span>px)</span><span>`</span></span>
    s<span>.</span>transitionDuration <span>=</span> <span>'0s'</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>callPendingCbs</code> 方法是在前一个过渡动画没执行完又再次执行到该方法的时候，会提前执行 <code>_moveCb</code> 和 <code>_enterCb</code>。</p>
<p><code>recordPosition</code> 的作用是记录节点的新位置。</p>
<p><code>applyTranslation</code> 的作用是先计算节点新位置和旧位置的差值，如果差值不为 0，则说明这些节点是需要移动的，所以记录 <code>vnode.data.moved</code> 为 true，并且通过设置 <code>transform</code> 把需要移动的节点的位置又偏移到之前的旧位置，目的是为了做 <code>move</code> 缓动做准备。</p>
<ul>
<li>遍历子元素实现 move 过渡</li>
</ul>
<div><pre><code><span>this</span><span>.</span>_reflow <span>=</span> document<span>.</span>body<span>.</span>offsetHeight

children<span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>c<span>.</span>data<span>.</span>moved<span>)</span> <span>{</span>
    <span>var</span> <span>el</span><span>:</span> any <span>=</span> c<span>.</span>elm
    <span>var</span> <span>s</span><span>:</span> any <span>=</span> el<span>.</span>style
    <span>addTransitionClass</span><span>(</span>el<span>,</span> moveClass<span>)</span>
    s<span>.</span>transform <span>=</span> s<span>.</span>WebkitTransform <span>=</span> s<span>.</span>transitionDuration <span>=</span> <span>''</span>
    el<span>.</span><span>addEventListener</span><span>(</span>transitionEndEvent<span>,</span> el<span>.</span><span>_moveCb</span> <span>=</span> <span>function</span> <span>cb</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>e <span>||</span> <span><span>/</span><span>transform$</span><span>/</span></span><span>.</span><span>test</span><span>(</span>e<span>.</span>propertyName<span>)</span><span>)</span> <span>{</span>
        el<span>.</span><span>removeEventListener</span><span>(</span>transitionEndEvent<span>,</span> cb<span>)</span>
        el<span>.</span>_moveCb <span>=</span> <span>null</span>
        <span>removeTransitionClass</span><span>(</span>el<span>,</span> moveClass<span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先通过 <code>document.body.offsetHeight</code> 强制触发浏览器重绘，接着再次对 <code>children</code> 遍历，先给子节点添加 <code>moveClass</code>，在我们的例子中，<code>moveClass</code> 定义了 <code>transition: all 1s;</code> 缓动；接着把子节点的 <code>style.transform</code> 设置为空，由于我们前面把这些节点偏移到之前的旧位置，所以它就会从旧位置按照 <code>1s</code> 的缓动时间过渡偏移到它的当前目标位置，这样就实现了 move 的过渡动画。并且接下来会监听 <code>transitionEndEvent</code> 过渡结束的事件，做一些清理的操作。</p>
<p>另外，由于虚拟 DOM 的子元素更新算法是不稳定的，它不能保证被移除元素的相对位置，所以我们强制 <code>&lt;transition-group&gt;</code> 组件更新子节点通过 2 个步骤：第一步我们移除需要移除的 <code>vnode</code>，同时触发它们的 <code>leaving</code> 过渡；第二步我们需要把插入和移动的节点达到它们的最终态，同时还要保证移除的节点保留在应该的位置，而这个是通过 <code>beforeMount</code> 钩子函数来实现的：</p>
<div><pre><code><span>beforeMount</span> <span>(</span><span>)</span> <span>{</span>
  <span>const</span> update <span>=</span> <span>this</span><span>.</span>_update
  <span>this</span><span>.</span><span>_update</span> <span>=</span> <span>(</span><span>vnode<span>,</span> hydrating</span><span>)</span> <span>=></span> <span>{</span>
    <span>// force removing pass</span>
    <span>this</span><span>.</span><span>__patch__</span><span>(</span>
      <span>this</span><span>.</span>_vnode<span>,</span>
      <span>this</span><span>.</span>kept<span>,</span>
      <span>false</span><span>,</span> <span>// hydrating</span>
      <span>true</span> <span>// removeOnly (!important, avoids unnecessary moves)</span>
    <span>)</span>
    <span>this</span><span>.</span>_vnode <span>=</span> <span>this</span><span>.</span>kept
    <span>update</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> vnode<span>,</span> hydrating<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通过把 <code>__patch__</code> 方法的第四个参数 <code>removeOnly</code> 设置为 true，这样在 <code>updateChildren</code> 阶段，是不会移动 <code>vnode</code> 节点的。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么到此，<code>&lt;transtion-group&gt;</code> 组件的实现原理就介绍完毕了，它和 <code>&lt;transition&gt;</code> 组件相比，实现了列表的过渡，以及它会渲染成真实的元素。当我们去修改列表的数据的时候，如果是添加或者删除数据，则会触发相应元素本身的过渡动画，这点和 <code>&lt;transition&gt;</code> 组件实现效果一样，除此之外 <code>&lt;transtion-group&gt;</code> 还实现了 move 的过渡效果，让我们的列表过渡动画更加丰富。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">transition</title>
    <id>https://0808200.xyz/vue2/extend/tansition.html</id>
    <link href="https://0808200.xyz/vue2/extend/tansition.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="transition" tabindex="-1"> transition</h1>
<p>在我们平时的前端项目开发中，经常会遇到如下需求，一个 DOM 节点的插入和删除或者是显示和隐藏，我们不想让它特别生硬，通常会考虑加一些过渡效果。</p>
<p>Vue.js 除了实现了强大的数据驱动，组件化的能力，也给我们提供了一整套过渡的解决方案。它内置了 <code>&lt;transition&gt;</code> 组件，我们可以利用它配合一些 CSS3 样式很方便地实现过渡动画，也可以利用它配合 JavaScript 的钩子函数实现过渡动画，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡：</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>那么举一个最简单的实例，如下：</p>
<div><pre><code><span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div id="demo">'</span> <span>+</span>
  <span>'&lt;button v-on:click="show = !show">'</span> <span>+</span>
  <span>'Toggle'</span> <span>+</span>
  <span>'&lt;/button>'</span> <span>+</span>
  <span>'&lt;transition :appear="true" name="fade">'</span> <span>+</span>
  <span>'&lt;p v-if="show">hello&lt;/p>'</span> <span>+</span>
  <span>'&lt;/transition>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>show</span><span>:</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>.fade-enter-active, .fade-leave-active</span> <span>{</span>
  <span>transition</span><span>:</span> opacity .5s<span>;</span>
<span>}</span>
<span>.fade-enter, .fade-leave-to</span> <span>{</span>
  <span>opacity</span><span>:</span> 0<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当我们点击按钮切换显示状态的时候，被 <code>&lt;transition&gt;</code> 包裹的内容会有过渡动画。那么接下来我们从源码的角度来分析它的实现原理。</p>
<h2 id="内置组件" tabindex="-1"> 内置组件</h2>
<p><code>&lt;transition&gt;</code> 组件和 <code>&lt;keep-alive&gt;</code> 组件一样，都是 Vue 的内置组件，而 <code>&lt;transition&gt;</code> 的定义在 <code>src/platforms/web/runtime/component/transtion.js</code> 中，之所以在这里定义，是因为 <code>&lt;transition&gt;</code> 组件是 web 平台独有的，先来看一下它的实现：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> <span>'transition'</span><span>,</span>
  <span>props</span><span>:</span> transitionProps<span>,</span>
  <span>abstract</span><span>:</span> <span>true</span><span>,</span>

  <span>render</span> <span>(</span><span><span>h</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>let</span> <span>children</span><span>:</span> any <span>=</span> <span>this</span><span>.</span>$slots<span>.</span>default
    <span>if</span> <span>(</span><span>!</span>children<span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>

    <span>// filter out text nodes (possible whitespaces)</span>
    children <span>=</span> children<span>.</span><span>filter</span><span>(</span><span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>=></span> c<span>.</span>tag <span>||</span> <span>isAsyncPlaceholder</span><span>(</span>c<span>)</span><span>)</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span><span>!</span>children<span>.</span>length<span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>

    <span>// warn multiple elements</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> children<span>.</span>length <span>></span> <span>1</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'&lt;transition> can only be used on a single element. Use '</span> <span>+</span>
        <span>'&lt;transition-group> for lists.'</span><span>,</span>
        <span>this</span><span>.</span>$parent
      <span>)</span>
    <span>}</span>

    <span>const</span> <span>mode</span><span>:</span> string <span>=</span> <span>this</span><span>.</span>mode

    <span>// warn invalid mode</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
      mode <span>&amp;&amp;</span> mode <span>!==</span> <span>'in-out'</span> <span>&amp;&amp;</span> mode <span>!==</span> <span>'out-in'</span>
    <span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'invalid &lt;transition> mode: '</span> <span>+</span> mode<span>,</span>
        <span>this</span><span>.</span>$parent
      <span>)</span>
    <span>}</span>

    <span>const</span> <span>rawChild</span><span>:</span> VNode <span>=</span> children<span>[</span><span>0</span><span>]</span>

    <span>// if this is a component root node and the component's</span>
    <span>// parent container node also has transition, skip.</span>
    <span>if</span> <span>(</span><span>hasParentTransition</span><span>(</span><span>this</span><span>.</span>$vnode<span>)</span><span>)</span> <span>{</span>
      <span>return</span> rawChild
    <span>}</span>

    <span>// apply transition data to child</span>
    <span>// use getRealChild() to ignore abstract components e.g. keep-alive</span>
    <span>const</span> <span>child</span><span>:</span> <span>?</span>VNode <span>=</span> <span>getRealChild</span><span>(</span>rawChild<span>)</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span><span>!</span>child<span>)</span> <span>{</span>
      <span>return</span> rawChild
    <span>}</span>

    <span>if</span> <span>(</span><span>this</span><span>.</span>_leaving<span>)</span> <span>{</span>
      <span>return</span> <span>placeholder</span><span>(</span>h<span>,</span> rawChild<span>)</span>
    <span>}</span>

    <span>// ensure a key that is unique to the vnode type and to this transition</span>
    <span>// component instance. This key will be used to remove pending leaving nodes</span>
    <span>// during entering.</span>
    <span>const</span> <span>id</span><span>:</span> string <span>=</span> <span><span>`</span><span>__transition-</span><span><span>${</span><span>this</span><span>.</span>_uid<span>}</span></span><span>-</span><span>`</span></span>
    child<span>.</span>key <span>=</span> child<span>.</span>key <span>==</span> <span>null</span>
      <span>?</span> child<span>.</span>isComment
        <span>?</span> id <span>+</span> <span>'comment'</span>
        <span>:</span> id <span>+</span> child<span>.</span>tag
      <span>:</span> <span>isPrimitive</span><span>(</span>child<span>.</span>key<span>)</span>
        <span>?</span> <span>(</span><span>String</span><span>(</span>child<span>.</span>key<span>)</span><span>.</span><span>indexOf</span><span>(</span>id<span>)</span> <span>===</span> <span>0</span> <span>?</span> child<span>.</span>key <span>:</span> id <span>+</span> child<span>.</span>key<span>)</span>
        <span>:</span> child<span>.</span>key

    <span>const</span> <span>data</span><span>:</span> Object <span>=</span> <span>(</span>child<span>.</span>data <span>||</span> <span>(</span>child<span>.</span>data <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>.</span>transition <span>=</span> <span>extractTransitionData</span><span>(</span><span>this</span><span>)</span>
    <span>const</span> <span>oldRawChild</span><span>:</span> VNode <span>=</span> <span>this</span><span>.</span>_vnode
    <span>const</span> <span>oldChild</span><span>:</span> VNode <span>=</span> <span>getRealChild</span><span>(</span>oldRawChild<span>)</span>

    <span>// mark v-show</span>
    <span>// so that the transition module can hand over the control to the directive</span>
    <span>if</span> <span>(</span>child<span>.</span>data<span>.</span>directives <span>&amp;&amp;</span> child<span>.</span>data<span>.</span>directives<span>.</span><span>some</span><span>(</span><span>d</span> <span>=></span> d<span>.</span>name <span>===</span> <span>'show'</span><span>)</span><span>)</span> <span>{</span>
      child<span>.</span>data<span>.</span>show <span>=</span> <span>true</span>
    <span>}</span>

    <span>if</span> <span>(</span>
      oldChild <span>&amp;&amp;</span>
      oldChild<span>.</span>data <span>&amp;&amp;</span>
      <span>!</span><span>isSameChild</span><span>(</span>child<span>,</span> oldChild<span>)</span> <span>&amp;&amp;</span>
      <span>!</span><span>isAsyncPlaceholder</span><span>(</span>oldChild<span>)</span> <span>&amp;&amp;</span>
      <span>// #6687 component root is a comment node</span>
      <span>!</span><span>(</span>oldChild<span>.</span>componentInstance <span>&amp;&amp;</span> oldChild<span>.</span>componentInstance<span>.</span>_vnode<span>.</span>isComment<span>)</span>
    <span>)</span> <span>{</span>
      <span>// replace old child transition data with fresh one</span>
      <span>// important for dynamic transitions!</span>
      <span>const</span> <span>oldData</span><span>:</span> Object <span>=</span> oldChild<span>.</span>data<span>.</span>transition <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> data<span>)</span>
      <span>// handle transition mode</span>
      <span>if</span> <span>(</span>mode <span>===</span> <span>'out-in'</span><span>)</span> <span>{</span>
        <span>// return placeholder node and queue update when leave finishes</span>
        <span>this</span><span>.</span>_leaving <span>=</span> <span>true</span>
        <span>mergeVNodeHook</span><span>(</span>oldData<span>,</span> <span>'afterLeave'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>this</span><span>.</span>_leaving <span>=</span> <span>false</span>
          <span>this</span><span>.</span><span>$forceUpdate</span><span>(</span><span>)</span>
        <span>}</span><span>)</span>
        <span>return</span> <span>placeholder</span><span>(</span>h<span>,</span> rawChild<span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>mode <span>===</span> <span>'in-out'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isAsyncPlaceholder</span><span>(</span>child<span>)</span><span>)</span> <span>{</span>
          <span>return</span> oldRawChild
        <span>}</span>
        <span>let</span> delayedLeave
        <span>const</span> <span>performLeave</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span> <span>delayedLeave</span><span>(</span><span>)</span> <span>}</span>
        <span>mergeVNodeHook</span><span>(</span>data<span>,</span> <span>'afterEnter'</span><span>,</span> performLeave<span>)</span>
        <span>mergeVNodeHook</span><span>(</span>data<span>,</span> <span>'enterCancelled'</span><span>,</span> performLeave<span>)</span>
        <span>mergeVNodeHook</span><span>(</span>oldData<span>,</span> <span>'delayLeave'</span><span>,</span> <span>leave</span> <span>=></span> <span>{</span> delayedLeave <span>=</span> leave <span>}</span><span>)</span>
      <span>}</span>
    <span>}</span>

    <span>return</span> rawChild
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>&lt;transition&gt;</code> 组件和 <code>&lt;keep-alive&gt;</code> 组件有几点实现类似，同样是抽象组件，同样直接实现 <code>render</code> 函数，同样利用了默认插槽。<code>&lt;transition&gt;</code> 组件非常灵活，支持的 <code>props</code> 非常多：</p>
<div><pre><code><span>export</span> <span>const</span> transitionProps <span>=</span> <span>{</span>
  <span>name</span><span>:</span> String<span>,</span>
  <span>appear</span><span>:</span> Boolean<span>,</span>
  <span>css</span><span>:</span> Boolean<span>,</span>
  <span>mode</span><span>:</span> String<span>,</span>
  <span>type</span><span>:</span> String<span>,</span>
  <span>enterClass</span><span>:</span> String<span>,</span>
  <span>leaveClass</span><span>:</span> String<span>,</span>
  <span>enterToClass</span><span>:</span> String<span>,</span>
  <span>leaveToClass</span><span>:</span> String<span>,</span>
  <span>enterActiveClass</span><span>:</span> String<span>,</span>
  <span>leaveActiveClass</span><span>:</span> String<span>,</span>
  <span>appearClass</span><span>:</span> String<span>,</span>
  <span>appearActiveClass</span><span>:</span> String<span>,</span>
  <span>appearToClass</span><span>:</span> String<span>,</span>
  <span>duration</span><span>:</span> <span>[</span>Number<span>,</span> String<span>,</span> Object<span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这些配置我们稍后会分析它们的作用，<code>&lt;transition&gt;</code> 组件另一个重要的就是 <code>render</code> 函数的实现，<code>render</code> 函数主要作用就是渲染生成 <code>vnode</code>，下面来看一下这部分的逻辑。</p>
<ul>
<li>处理 <code>children</code></li>
</ul>
<div><pre><code><span>let</span> <span>children</span><span>:</span> any <span>=</span> <span>this</span><span>.</span>$slots<span>.</span>default
<span>if</span> <span>(</span><span>!</span>children<span>)</span> <span>{</span>
  <span>return</span>
<span>}</span>

<span>// filter out text nodes (possible whitespaces)</span>
children <span>=</span> children<span>.</span><span>filter</span><span>(</span><span>(</span><span><span>c</span><span>:</span> VNode</span><span>)</span> <span>=></span> c<span>.</span>tag <span>||</span> <span>isAsyncPlaceholder</span><span>(</span>c<span>)</span><span>)</span>
<span>/* istanbul ignore if */</span>
<span>if</span> <span>(</span><span>!</span>children<span>.</span>length<span>)</span> <span>{</span>
  <span>return</span>
<span>}</span>

<span>// warn multiple elements</span>
<span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> children<span>.</span>length <span>></span> <span>1</span><span>)</span> <span>{</span>
  <span>warn</span><span>(</span>
    <span>'&lt;transition> can only be used on a single element. Use '</span> <span>+</span>
    <span>'&lt;transition-group> for lists.'</span><span>,</span>
    <span>this</span><span>.</span>$parent
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>先从默认插槽中获取 <code>&lt;transition&gt;</code> 包裹的子节点，并且判断了子节点的长度，如果长度为 0，则直接返回，否则判断长度如果大于 1，也会在开发环境报警告，因为 <code>&lt;transition&gt;</code> 组件是只能包裹一个子节点的。</p>
<ul>
<li>处理 <code>model</code></li>
</ul>
<div><pre><code><span>const</span> <span>mode</span><span>:</span> string <span>=</span> <span>this</span><span>.</span>mode

<span>// warn invalid mode</span>
<span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
  mode <span>&amp;&amp;</span> mode <span>!==</span> <span>'in-out'</span> <span>&amp;&amp;</span> mode <span>!==</span> <span>'out-in'</span>
<span>)</span> <span>{</span>
  <span>warn</span><span>(</span>
    <span>'invalid &lt;transition> mode: '</span> <span>+</span> mode<span>,</span>
    <span>this</span><span>.</span>$parent
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>过渡组件的对 <code>mode</code> 的支持只有 2 种，<code>in-out</code> 或者是 <code>out-in</code>。</p>
<ul>
<li>获取 <code>rawChild</code> &amp; <code>child</code></li>
</ul>
<div><pre><code><span>const</span> <span>rawChild</span><span>:</span> VNode <span>=</span> children<span>[</span><span>0</span><span>]</span>

<span>// if this is a component root node and the component's</span>
<span>// parent container node also has transition, skip.</span>
<span>if</span> <span>(</span><span>hasParentTransition</span><span>(</span><span>this</span><span>.</span>$vnode<span>)</span><span>)</span> <span>{</span>
  <span>return</span> rawChild
<span>}</span>

<span>// apply transition data to child</span>
<span>// use getRealChild() to ignore abstract components e.g. keep-alive</span>
<span>const</span> <span>child</span><span>:</span> <span>?</span>VNode <span>=</span> <span>getRealChild</span><span>(</span>rawChild<span>)</span>
<span>/* istanbul ignore if */</span>
<span>if</span> <span>(</span><span>!</span>child<span>)</span> <span>{</span>
  <span>return</span> rawChild
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>rawChild</code> 就是第一个子节点 <code>vnode</code>，接着判断当前 <code>&lt;transition&gt;</code> 如果是组件根节点并且外面包裹该组件的容器也是 <code>&lt;transition&gt;</code> 的时候要跳过。来看一下 <code>hasParentTransition</code> 的实现：</p>
<div><pre><code><span>function</span> <span>hasParentTransition</span> <span>(</span><span><span>vnode</span><span>:</span> VNode</span><span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
  <span>while</span> <span>(</span><span>(</span>vnode <span>=</span> vnode<span>.</span>parent<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>vnode<span>.</span>data<span>.</span>transition<span>)</span> <span>{</span>
      <span>return</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>因为传入的是 <code>this.$vnode</code>，也就是 <code>&lt;transition&gt;</code> 组件的 占位 <code>vnode</code>，只有当它同时作为根 <code>vnode</code>，也就是 <code>vm._vnode</code> 的时候，它的 <code>parent</code> 才不会为空，并且判断 <code>parent</code> 也是 <code>&lt;transition&gt;</code> 组件，才返回 true，<code>vnode.data.transition</code> 我们稍后会介绍。</p>
<p><code>getRealChild</code> 的目的是获取组件的非抽象子节点，因为 <code>&lt;transition&gt;</code> 很可能会包裹一个 <code>keep-alive</code>，它的实现如下：</p>
<div><pre><code><span>// in case the child is also an abstract component, e.g. &lt;keep-alive></span>
<span>// we want to recursively retrieve the real component to be rendered</span>
<span>function</span> <span>getRealChild</span> <span>(</span><span><span>vnode</span><span>:</span> <span>?</span>VNode</span><span>)</span><span>:</span> <span>?</span>VNode <span>{</span>
  <span>const</span> <span>compOptions</span><span>:</span> <span>?</span>VNodeComponentOptions <span>=</span> vnode <span>&amp;&amp;</span> vnode<span>.</span>componentOptions
  <span>if</span> <span>(</span>compOptions <span>&amp;&amp;</span> compOptions<span>.</span>Ctor<span>.</span>options<span>.</span>abstract<span>)</span> <span>{</span>
    <span>return</span> <span>getRealChild</span><span>(</span><span>getFirstComponentChild</span><span>(</span>compOptions<span>.</span>children<span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> vnode
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>会递归找到第一个非抽象组件的 <code>vnode</code> 并返回，在我们这个 case 下，<code>rawChild === child</code>。</p>
<ul>
<li>处理 <code>id</code> &amp; <code>data</code></li>
</ul>
<div><pre><code><span>// ensure a key that is unique to the vnode type and to this transition</span>
<span>// component instance. This key will be used to remove pending leaving nodes</span>
<span>// during entering.</span>
<span>const</span> <span>id</span><span>:</span> string <span>=</span> <span><span>`</span><span>__transition-</span><span><span>${</span><span>this</span><span>.</span>_uid<span>}</span></span><span>-</span><span>`</span></span>
child<span>.</span>key <span>=</span> child<span>.</span>key <span>==</span> <span>null</span>
  <span>?</span> child<span>.</span>isComment
    <span>?</span> id <span>+</span> <span>'comment'</span>
    <span>:</span> id <span>+</span> child<span>.</span>tag
  <span>:</span> <span>isPrimitive</span><span>(</span>child<span>.</span>key<span>)</span>
    <span>?</span> <span>(</span><span>String</span><span>(</span>child<span>.</span>key<span>)</span><span>.</span><span>indexOf</span><span>(</span>id<span>)</span> <span>===</span> <span>0</span> <span>?</span> child<span>.</span>key <span>:</span> id <span>+</span> child<span>.</span>key<span>)</span>
    <span>:</span> child<span>.</span>key

<span>const</span> <span>data</span><span>:</span> Object <span>=</span> <span>(</span>child<span>.</span>data <span>||</span> <span>(</span>child<span>.</span>data <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>.</span>transition <span>=</span> <span>extractTransitionData</span><span>(</span><span>this</span><span>)</span>
<span>const</span> <span>oldRawChild</span><span>:</span> VNode <span>=</span> <span>this</span><span>.</span>_vnode
<span>const</span> <span>oldChild</span><span>:</span> VNode <span>=</span> <span>getRealChild</span><span>(</span>oldRawChild<span>)</span>

<span>// mark v-show</span>
<span>// so that the transition module can hand over the control to the directive</span>
<span>if</span> <span>(</span>child<span>.</span>data<span>.</span>directives <span>&amp;&amp;</span> child<span>.</span>data<span>.</span>directives<span>.</span><span>some</span><span>(</span><span>d</span> <span>=></span> d<span>.</span>name <span>===</span> <span>'show'</span><span>)</span><span>)</span> <span>{</span>
  child<span>.</span>data<span>.</span>show <span>=</span> <span>true</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>先根据 <code>key</code> 等一系列条件获取 <code>id</code>，接着从当前通过 <code>extractTransitionData</code> 组件实例上提取出过渡所需要的数据：</p>
<div><pre><code><span>export</span> <span>function</span> <span>extractTransitionData</span> <span>(</span><span><span>comp</span><span>:</span> Component</span><span>)</span><span>:</span> Object <span>{</span>
  <span>const</span> data <span>=</span> <span>{</span><span>}</span>
  <span>const</span> <span>options</span><span>:</span> ComponentOptions <span>=</span> comp<span>.</span>$options
  <span>// props</span>
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> options<span>.</span>propsData<span>)</span> <span>{</span>
    data<span>[</span>key<span>]</span> <span>=</span> comp<span>[</span>key<span>]</span>
  <span>}</span>
  <span>// events.</span>
  <span>// extract listeners and pass them directly to the transition methods</span>
  <span>const</span> <span>listeners</span><span>:</span> <span>?</span>Object <span>=</span> options<span>.</span>_parentListeners
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> listeners<span>)</span> <span>{</span>
    data<span>[</span><span>camelize</span><span>(</span>key<span>)</span><span>]</span> <span>=</span> listeners<span>[</span>key<span>]</span>
  <span>}</span>
  <span>return</span> data
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先是遍历 <code>props</code> 赋值到 <code>data</code> 中，接着是遍历所有父组件的事件也把事件回调赋值到 <code>data</code> 中。</p>
<p>这样 <code>child.data.transition</code> 中就包含了过渡所需的一些数据，这些稍后都会用到，对于 <code>child</code> 如果使用了 <code>v-show</code> 指令，也会把 <code>child.data.show</code> 设置为 true，在我们的例子中，得到的 <code>child.data</code> 如下：</p>
<div><pre><code><span>{</span>
  <span>transition</span><span>:</span> <span>{</span>
    <span>appear</span><span>:</span> <span>true</span><span>,</span>
    <span>name</span><span>:</span> <span>'fade'</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>至于 <code>oldRawChild</code> 和 <code>oldChild</code> 是与后面的判断逻辑相关，这些我们这里先不介绍。</p>
<h2 id="transition-module" tabindex="-1"> transition module</h2>
<p>刚刚我们介绍完 <code>&lt;transition&gt;</code> 组件的实现，它的 <code>render</code> 阶段只获取了一些数据，并且返回了渲染的 <code>vnode</code>，并没有任何和动画相关，而动画相关的逻辑全部在 <code>src/platforms/web/modules/transition.js</code> 中：</p>
<div><pre><code><span>function</span> <span>_enter</span> <span>(</span><span><span>_</span><span>:</span> any<span>,</span> <span>vnode</span><span>:</span> VNodeWithData</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>vnode<span>.</span>data<span>.</span>show <span>!==</span> <span>true</span><span>)</span> <span>{</span>
    <span>enter</span><span>(</span>vnode<span>)</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> inBrowser <span>?</span> <span>{</span>
  <span>create</span><span>:</span> _enter<span>,</span>
  <span>activate</span><span>:</span> _enter<span>,</span>
  <span>remove</span> <span>(</span><span><span>vnode</span><span>:</span> VNode<span>,</span> <span>rm</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>/* istanbul ignore else */</span>
    <span>if</span> <span>(</span>vnode<span>.</span>data<span>.</span>show <span>!==</span> <span>true</span><span>)</span> <span>{</span>
      <span>leave</span><span>(</span>vnode<span>,</span> rm<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>rm</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span> <span>:</span> <span>{</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在之前介绍事件实现的章节中我们提到过在 <code>vnode patch</code> 的过程中，会执行很多钩子函数，那么对于过渡的实现，它只接收了 <code>create</code> 和 <code>activate</code> 2 个钩子函数，我们知道 <code>create</code> 钩子函数只有当节点的创建过程才会执行，而 <code>remove</code> 会在节点销毁的时候执行，这也就印证了 <code>&lt;transition&gt;</code> 必须要满足 <code>v-if</code> 、动态组件、组件根节点条件之一了，对于 <code>v-show</code> 在它的指令的钩子函数中也会执行相关逻辑，这块儿先不介绍。</p>
<p>过渡动画提供了 2 个时机，一个是 <code>create</code> 和 <code>activate</code> 的时候提供了 entering 进入动画，一个是 <code>remove</code> 的时候提供了 leaving 离开动画，那么接下来我们就来分别去分析这两个过程。</p>
<h2 id="entering" tabindex="-1"> entering</h2>
<p>整个 entering 过程的实现是 <code>enter</code> 函数：</p>
<div><pre><code><span>export</span> <span>function</span> <span>enter</span> <span>(</span><span><span>vnode</span><span>:</span> VNodeWithData<span>,</span> <span>toggleDisplay</span><span>:</span> <span>?</span><span>(</span><span>)</span> <span>=></span> <span>void</span></span><span>)</span> <span>{</span>
  <span>const</span> <span>el</span><span>:</span> any <span>=</span> vnode<span>.</span>elm

  <span>// call leave callback now</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>el<span>.</span>_leaveCb<span>)</span><span>)</span> <span>{</span>
    el<span>.</span>_leaveCb<span>.</span>cancelled <span>=</span> <span>true</span>
    el<span>.</span><span>_leaveCb</span><span>(</span><span>)</span>
  <span>}</span>

  <span>const</span> data <span>=</span> <span>resolveTransition</span><span>(</span>vnode<span>.</span>data<span>.</span>transition<span>)</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>el<span>.</span>_enterCb<span>)</span> <span>||</span> el<span>.</span>nodeType <span>!==</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> <span>{</span>
    css<span>,</span>
    type<span>,</span>
    enterClass<span>,</span>
    enterToClass<span>,</span>
    enterActiveClass<span>,</span>
    appearClass<span>,</span>
    appearToClass<span>,</span>
    appearActiveClass<span>,</span>
    beforeEnter<span>,</span>
    enter<span>,</span>
    afterEnter<span>,</span>
    enterCancelled<span>,</span>
    beforeAppear<span>,</span>
    appear<span>,</span>
    afterAppear<span>,</span>
    appearCancelled<span>,</span>
    duration
  <span>}</span> <span>=</span> data

  <span>// activeInstance will always be the &lt;transition> component managing this</span>
  <span>// transition. One edge case to check is when the &lt;transition> is placed</span>
  <span>// as the root node of a child component. In that case we need to check</span>
  <span>// &lt;transition>'s parent for appear check.</span>
  <span>let</span> context <span>=</span> activeInstance
  <span>let</span> transitionNode <span>=</span> activeInstance<span>.</span>$vnode
  <span>while</span> <span>(</span>transitionNode <span>&amp;&amp;</span> transitionNode<span>.</span>parent<span>)</span> <span>{</span>
    transitionNode <span>=</span> transitionNode<span>.</span>parent
    context <span>=</span> transitionNode<span>.</span>context
  <span>}</span>

  <span>const</span> isAppear <span>=</span> <span>!</span>context<span>.</span>_isMounted <span>||</span> <span>!</span>vnode<span>.</span>isRootInsert

  <span>if</span> <span>(</span>isAppear <span>&amp;&amp;</span> <span>!</span>appear <span>&amp;&amp;</span> appear <span>!==</span> <span>''</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> startClass <span>=</span> isAppear <span>&amp;&amp;</span> appearClass
    <span>?</span> appearClass
    <span>:</span> enterClass
  <span>const</span> activeClass <span>=</span> isAppear <span>&amp;&amp;</span> appearActiveClass
    <span>?</span> appearActiveClass
    <span>:</span> enterActiveClass
  <span>const</span> toClass <span>=</span> isAppear <span>&amp;&amp;</span> appearToClass
    <span>?</span> appearToClass
    <span>:</span> enterToClass

  <span>const</span> beforeEnterHook <span>=</span> isAppear
    <span>?</span> <span>(</span>beforeAppear <span>||</span> beforeEnter<span>)</span>
    <span>:</span> beforeEnter
  <span>const</span> enterHook <span>=</span> isAppear
    <span>?</span> <span>(</span><span>typeof</span> appear <span>===</span> <span>'function'</span> <span>?</span> appear <span>:</span> enter<span>)</span>
    <span>:</span> enter
  <span>const</span> afterEnterHook <span>=</span> isAppear
    <span>?</span> <span>(</span>afterAppear <span>||</span> afterEnter<span>)</span>
    <span>:</span> afterEnter
  <span>const</span> enterCancelledHook <span>=</span> isAppear
    <span>?</span> <span>(</span>appearCancelled <span>||</span> enterCancelled<span>)</span>
    <span>:</span> enterCancelled

  <span>const</span> <span>explicitEnterDuration</span><span>:</span> any <span>=</span> <span>toNumber</span><span>(</span>
    <span>isObject</span><span>(</span>duration<span>)</span>
      <span>?</span> duration<span>.</span>enter
      <span>:</span> duration
  <span>)</span>

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> explicitEnterDuration <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>checkDuration</span><span>(</span>explicitEnterDuration<span>,</span> <span>'enter'</span><span>,</span> vnode<span>)</span>
  <span>}</span>

  <span>const</span> expectsCSS <span>=</span> css <span>!==</span> <span>false</span> <span>&amp;&amp;</span> <span>!</span>isIE9
  <span>const</span> userWantsControl <span>=</span> <span>getHookArgumentsLength</span><span>(</span>enterHook<span>)</span>

  <span>const</span> cb <span>=</span> el<span>.</span>_enterCb <span>=</span> <span>once</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> toClass<span>)</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> activeClass<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
        <span>removeTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
      <span>}</span>
      enterCancelledHook <span>&amp;&amp;</span> <span>enterCancelledHook</span><span>(</span>el<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      afterEnterHook <span>&amp;&amp;</span> <span>afterEnterHook</span><span>(</span>el<span>)</span>
    <span>}</span>
    el<span>.</span>_enterCb <span>=</span> <span>null</span>
  <span>}</span><span>)</span>

  <span>if</span> <span>(</span><span>!</span>vnode<span>.</span>data<span>.</span>show<span>)</span> <span>{</span>
    <span>// remove pending leave element on enter by injecting an insert hook</span>
    <span>mergeVNodeHook</span><span>(</span>vnode<span>,</span> <span>'insert'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> parent <span>=</span> el<span>.</span>parentNode
      <span>const</span> pendingNode <span>=</span> parent <span>&amp;&amp;</span> parent<span>.</span>_pending <span>&amp;&amp;</span> parent<span>.</span>_pending<span>[</span>vnode<span>.</span>key<span>]</span>
      <span>if</span> <span>(</span>pendingNode <span>&amp;&amp;</span>
        pendingNode<span>.</span>tag <span>===</span> vnode<span>.</span>tag <span>&amp;&amp;</span>
        pendingNode<span>.</span>elm<span>.</span>_leaveCb
      <span>)</span> <span>{</span>
        pendingNode<span>.</span>elm<span>.</span><span>_leaveCb</span><span>(</span><span>)</span>
      <span>}</span>
      enterHook <span>&amp;&amp;</span> <span>enterHook</span><span>(</span>el<span>,</span> cb<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>// start enter transition</span>
  beforeEnterHook <span>&amp;&amp;</span> <span>beforeEnterHook</span><span>(</span>el<span>)</span>
  <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
    <span>addTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
    <span>addTransitionClass</span><span>(</span>el<span>,</span> activeClass<span>)</span>
    <span>nextFrame</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
      <span>if</span> <span>(</span><span>!</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
        <span>addTransitionClass</span><span>(</span>el<span>,</span> toClass<span>)</span>
        <span>if</span> <span>(</span><span>!</span>userWantsControl<span>)</span> <span>{</span>
          <span>if</span> <span>(</span><span>isValidDuration</span><span>(</span>explicitEnterDuration<span>)</span><span>)</span> <span>{</span>
            <span>setTimeout</span><span>(</span>cb<span>,</span> explicitEnterDuration<span>)</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>whenTransitionEnds</span><span>(</span>el<span>,</span> type<span>,</span> cb<span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span>vnode<span>.</span>data<span>.</span>show<span>)</span> <span>{</span>
    toggleDisplay <span>&amp;&amp;</span> <span>toggleDisplay</span><span>(</span><span>)</span>
    enterHook <span>&amp;&amp;</span> <span>enterHook</span><span>(</span>el<span>,</span> cb<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>!</span>expectsCSS <span>&amp;&amp;</span> <span>!</span>userWantsControl<span>)</span> <span>{</span>
    <span>cb</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>enter</code> 的代码很长，我们先分析其中的核心逻辑。</p>
<ul>
<li>解析过渡数据</li>
</ul>
<div><pre><code><span>const</span> data <span>=</span> <span>resolveTransition</span><span>(</span>vnode<span>.</span>data<span>.</span>transition<span>)</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
<span>}</span>

<span>const</span> <span>{</span>
  css<span>,</span>
  type<span>,</span>
  enterClass<span>,</span>
  enterToClass<span>,</span>
  enterActiveClass<span>,</span>
  appearClass<span>,</span>
  appearToClass<span>,</span>
  appearActiveClass<span>,</span>
  beforeEnter<span>,</span>
  enter<span>,</span>
  afterEnter<span>,</span>
  enterCancelled<span>,</span>
  beforeAppear<span>,</span>
  appear<span>,</span>
  afterAppear<span>,</span>
  appearCancelled<span>,</span>
  duration
<span>}</span> <span>=</span> data
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>从 <code>vnode.data.transition</code> 中解析出过渡相关的一些数据，<code>resolveTransition</code> 的定义在 <code>src/platforms/web/transition-util.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>resolveTransition</span> <span>(</span><span>def<span>?</span><span>:</span> string <span>|</span> Object</span><span>)</span><span>:</span> <span>?</span>Object <span>{</span>
  <span>if</span> <span>(</span><span>!</span>def<span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>/* istanbul ignore else */</span>
  <span>if</span> <span>(</span><span>typeof</span> def <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
    <span>const</span> res <span>=</span> <span>{</span><span>}</span>
    <span>if</span> <span>(</span>def<span>.</span>css <span>!==</span> <span>false</span><span>)</span> <span>{</span>
      <span>extend</span><span>(</span>res<span>,</span> <span>autoCssTransition</span><span>(</span>def<span>.</span>name <span>||</span> <span>'v'</span><span>)</span><span>)</span>
    <span>}</span>
    <span>extend</span><span>(</span>res<span>,</span> def<span>)</span>
    <span>return</span> res
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> def <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
    <span>return</span> <span>autoCssTransition</span><span>(</span>def<span>)</span>
  <span>}</span>
<span>}</span>

<span>const</span> <span>autoCssTransition</span><span>:</span> <span>(</span><span><span>name</span><span>:</span> string</span><span>)</span> <span>=></span> Object <span>=</span> <span>cached</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
  <span>return</span> <span>{</span>
    <span>enterClass</span><span>:</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span>-enter</span><span>`</span></span><span>,</span>
    <span>enterToClass</span><span>:</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span>-enter-to</span><span>`</span></span><span>,</span>
    <span>enterActiveClass</span><span>:</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span>-enter-active</span><span>`</span></span><span>,</span>
    <span>leaveClass</span><span>:</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span>-leave</span><span>`</span></span><span>,</span>
    <span>leaveToClass</span><span>:</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span>-leave-to</span><span>`</span></span><span>,</span>
    <span>leaveActiveClass</span><span>:</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span>-leave-active</span><span>`</span></span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>resolveTransition</code> 会通过 <code>autoCssTransition</code> 处理 <code>name</code> 属性，生成一个用来描述各个阶段的 <code>Class</code> 名称的对象，扩展到 <code>def</code> 中并返回给 <code>data</code>，这样我们就可以从 <code>data</code> 中获取到过渡相关的所有数据。</p>
<ul>
<li>处理边界情况</li>
</ul>
<div><pre><code><span>// activeInstance will always be the &lt;transition> component managing this</span>
<span>// transition. One edge case to check is when the &lt;transition> is placed</span>
<span>// as the root node of a child component. In that case we need to check</span>
<span>// &lt;transition>'s parent for appear check.</span>
<span>let</span> context <span>=</span> activeInstance
<span>let</span> transitionNode <span>=</span> activeInstance<span>.</span>$vnode
<span>while</span> <span>(</span>transitionNode <span>&amp;&amp;</span> transitionNode<span>.</span>parent<span>)</span> <span>{</span>
  transitionNode <span>=</span> transitionNode<span>.</span>parent
  context <span>=</span> transitionNode<span>.</span>context
<span>}</span>

<span>const</span> isAppear <span>=</span> <span>!</span>context<span>.</span>_isMounted <span>||</span> <span>!</span>vnode<span>.</span>isRootInsert

<span>if</span> <span>(</span>isAppear <span>&amp;&amp;</span> <span>!</span>appear <span>&amp;&amp;</span> appear <span>!==</span> <span>''</span><span>)</span> <span>{</span>
  <span>return</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这是为了处理当 <code>&lt;transition&gt;</code> 作为子组件的根节点，那么我们需要检查它的父组件作为 <code>appear</code> 的检查。<code>isAppear</code> 表示当前上下文实例还没有 <code>mounted</code>，第一次出现的时机。如果是第一次并且 <code>&lt;transition&gt;</code> 组件没有配置 <code>appear</code> 的话，直接返回。</p>
<ul>
<li>定义过渡类名、钩子函数和其它配置</li>
</ul>
<div><pre><code><span>const</span> startClass <span>=</span> isAppear <span>&amp;&amp;</span> appearClass
    <span>?</span> appearClass
    <span>:</span> enterClass
<span>const</span> activeClass <span>=</span> isAppear <span>&amp;&amp;</span> appearActiveClass
  <span>?</span> appearActiveClass
  <span>:</span> enterActiveClass
<span>const</span> toClass <span>=</span> isAppear <span>&amp;&amp;</span> appearToClass
  <span>?</span> appearToClass
  <span>:</span> enterToClass

<span>const</span> beforeEnterHook <span>=</span> isAppear
  <span>?</span> <span>(</span>beforeAppear <span>||</span> beforeEnter<span>)</span>
  <span>:</span> beforeEnter
<span>const</span> enterHook <span>=</span> isAppear
  <span>?</span> <span>(</span><span>typeof</span> appear <span>===</span> <span>'function'</span> <span>?</span> appear <span>:</span> enter<span>)</span>
  <span>:</span> enter
<span>const</span> afterEnterHook <span>=</span> isAppear
  <span>?</span> <span>(</span>afterAppear <span>||</span> afterEnter<span>)</span>
  <span>:</span> afterEnter
<span>const</span> enterCancelledHook <span>=</span> isAppear
  <span>?</span> <span>(</span>appearCancelled <span>||</span> enterCancelled<span>)</span>
  <span>:</span> enterCancelled

<span>const</span> <span>explicitEnterDuration</span><span>:</span> any <span>=</span> <span>toNumber</span><span>(</span>
  <span>isObject</span><span>(</span>duration<span>)</span>
    <span>?</span> duration<span>.</span>enter
    <span>:</span> duration
<span>)</span>

<span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> explicitEnterDuration <span>!=</span> <span>null</span><span>)</span> <span>{</span>
  <span>checkDuration</span><span>(</span>explicitEnterDuration<span>,</span> <span>'enter'</span><span>,</span> vnode<span>)</span>
<span>}</span>

<span>const</span> expectsCSS <span>=</span> css <span>!==</span> <span>false</span> <span>&amp;&amp;</span> <span>!</span>isIE9
<span>const</span> userWantsControl <span>=</span> <span>getHookArgumentsLength</span><span>(</span>enterHook<span>)</span>

<span>const</span> cb <span>=</span> el<span>.</span>_enterCb <span>=</span> <span>once</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
    <span>removeTransitionClass</span><span>(</span>el<span>,</span> toClass<span>)</span>
    <span>removeTransitionClass</span><span>(</span>el<span>,</span> activeClass<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
    <span>}</span>
    enterCancelledHook <span>&amp;&amp;</span> <span>enterCancelledHook</span><span>(</span>el<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    afterEnterHook <span>&amp;&amp;</span> <span>afterEnterHook</span><span>(</span>el<span>)</span>
  <span>}</span>
  el<span>.</span>_enterCb <span>=</span> <span>null</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于过渡类名方面，<code>startClass</code> 定义进入过渡的开始状态，在元素被插入时生效，在下一个帧移除；<code>activeClass</code> 定义过渡的状态，在元素整个过渡过程中作用，在元素被插入时生效，在 <code>transition/animation</code> 完成之后移除；<code>toClass</code> 定义进入过渡的结束状态，在元素被插入一帧后生效 (与此同时 <code>startClass</code> 被删除)，在 <code>&lt;transition&gt;/animation</code> 完成之后移除。</p>
<p>对于过渡钩子函数方面，<code>beforeEnterHook</code> 是过渡开始前执行的钩子函数，<code>enterHook</code> 是在元素插入后或者是 <code>v-show</code> 显示切换后执行的钩子函数。<code>afterEnterHook</code> 是在过渡动画执行完后的钩子函数。</p>
<p><code>explicitEnterDuration</code> 表示 enter 动画执行的时间。</p>
<p><code>expectsCSS</code> 表示过渡动画是受 CSS 的影响。</p>
<p><code>cb</code> 定义的是过渡完成执行的回调函数。</p>
<ul>
<li>合并 <code>insert</code> 钩子函数</li>
</ul>
<div><pre><code><span>if</span> <span>(</span><span>!</span>vnode<span>.</span>data<span>.</span>show<span>)</span> <span>{</span>
  <span>// remove pending leave element on enter by injecting an insert hook</span>
  <span>mergeVNodeHook</span><span>(</span>vnode<span>,</span> <span>'insert'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> parent <span>=</span> el<span>.</span>parentNode
    <span>const</span> pendingNode <span>=</span> parent <span>&amp;&amp;</span> parent<span>.</span>_pending <span>&amp;&amp;</span> parent<span>.</span>_pending<span>[</span>vnode<span>.</span>key<span>]</span>
    <span>if</span> <span>(</span>pendingNode <span>&amp;&amp;</span>
      pendingNode<span>.</span>tag <span>===</span> vnode<span>.</span>tag <span>&amp;&amp;</span>
      pendingNode<span>.</span>elm<span>.</span>_leaveCb
    <span>)</span> <span>{</span>
      pendingNode<span>.</span>elm<span>.</span><span>_leaveCb</span><span>(</span><span>)</span>
    <span>}</span>
    enterHook <span>&amp;&amp;</span> <span>enterHook</span><span>(</span>el<span>,</span> cb<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>mergeVNodeHook</code> 的定义在 <code>src/core/vdom/helpers/merge-hook.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mergeVNodeHook</span> <span>(</span><span><span>def</span><span>:</span> Object<span>,</span> <span>hookKey</span><span>:</span> string<span>,</span> <span>hook</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>def <span>instanceof</span> <span>VNode</span><span>)</span> <span>{</span>
    def <span>=</span> def<span>.</span>data<span>.</span>hook <span>||</span> <span>(</span>def<span>.</span>data<span>.</span>hook <span>=</span> <span>{</span><span>}</span><span>)</span>
  <span>}</span>
  <span>let</span> invoker
  <span>const</span> oldHook <span>=</span> def<span>[</span>hookKey<span>]</span>

  <span>function</span> <span>wrappedHook</span> <span>(</span><span>)</span> <span>{</span>
    <span>hook</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span>
    <span>// important: remove merged hook to ensure it's called only once</span>
    <span>// and prevent memory leak</span>
    <span>remove</span><span>(</span>invoker<span>.</span>fns<span>,</span> wrappedHook<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldHook<span>)</span><span>)</span> <span>{</span>
    <span>// no existing hook</span>
    invoker <span>=</span> <span>createFnInvoker</span><span>(</span><span>[</span>wrappedHook<span>]</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>/* istanbul ignore if */</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldHook<span>.</span>fns<span>)</span> <span>&amp;&amp;</span> <span>isTrue</span><span>(</span>oldHook<span>.</span>merged<span>)</span><span>)</span> <span>{</span>
      <span>// already a merged invoker</span>
      invoker <span>=</span> oldHook
      invoker<span>.</span>fns<span>.</span><span>push</span><span>(</span>wrappedHook<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// existing plain hook</span>
      invoker <span>=</span> <span>createFnInvoker</span><span>(</span><span>[</span>oldHook<span>,</span> wrappedHook<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>

  invoker<span>.</span>merged <span>=</span> <span>true</span>
  def<span>[</span>hookKey<span>]</span> <span>=</span> invoker
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>mergeVNodeHook</code> 的逻辑很简单，就是把 <code>hook</code> 函数合并到 <code>def.data.hook[hookey]</code> 中，生成新的 <code>invoker</code>，<code>createFnInvoker</code> 方法我们在分析事件章节的时候已经介绍过了。</p>
<p>我们之前知道组件的 <code>vnode</code> 原本定义了 <code>init</code>、<code>prepatch</code>、<code>insert</code>、<code>destroy</code> 四个钩子函数，而 <code>mergeVNodeHook</code> 函数就是把一些新的钩子函数合并进来，例如在 <code>&lt;transition&gt;</code> 过程中合并的 <code>insert</code> 钩子函数，就会合并到组件 <code>vnode</code> 的 <code>insert</code> 钩子函数中，这样当组件插入后，就会执行我们定义的 <code>enterHook</code> 了。</p>
<ul>
<li>开始执行过渡动画</li>
</ul>
<div><pre><code><span>// start enter transition</span>
beforeEnterHook <span>&amp;&amp;</span> <span>beforeEnterHook</span><span>(</span>el<span>)</span>
<span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
  <span>addTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
  <span>addTransitionClass</span><span>(</span>el<span>,</span> activeClass<span>)</span>
  <span>nextFrame</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>removeTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
    <span>if</span> <span>(</span><span>!</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
      <span>addTransitionClass</span><span>(</span>el<span>,</span> toClass<span>)</span>
      <span>if</span> <span>(</span><span>!</span>userWantsControl<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isValidDuration</span><span>(</span>explicitEnterDuration<span>)</span><span>)</span> <span>{</span>
          <span>setTimeout</span><span>(</span>cb<span>,</span> explicitEnterDuration<span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>whenTransitionEnds</span><span>(</span>el<span>,</span> type<span>,</span> cb<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先执行 <code>beforeEnterHook</code> 钩子函数，把当前元素的 DOM 节点 <code>el</code> 传入，然后判断 <code>expectsCSS</code>，如果为 true 则表明希望用 CSS 来控制动画，那么会执行 <code> addTransitionClass(el, startClass)</code> 和 <code> addTransitionClass(el, activeClass)</code>，它的定义在 <code>src/platforms/runtime/transition-util.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>addTransitionClass</span> <span>(</span><span><span>el</span><span>:</span> any<span>,</span> <span>cls</span><span>:</span> string</span><span>)</span> <span>{</span>
  <span>const</span> transitionClasses <span>=</span> el<span>.</span>_transitionClasses <span>||</span> <span>(</span>el<span>.</span>_transitionClasses <span>=</span> <span>[</span><span>]</span><span>)</span>
  <span>if</span> <span>(</span>transitionClasses<span>.</span><span>indexOf</span><span>(</span>cls<span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
    transitionClasses<span>.</span><span>push</span><span>(</span>cls<span>)</span>
    <span>addClass</span><span>(</span>el<span>,</span> cls<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实非常简单，就是给当前 DOM 元素 <code>el</code> 添加样式 <code>cls</code>，所以这里添加了 <code>startClass</code> 和 <code>activeClass</code>，在我们的例子中就是给 <code>p</code> 标签添加了 <code>fade-enter</code> 和 <code>fade-enter-active</code> 2 个样式。</p>
<p>接下来执行了 <code>nextFrame</code>：</p>
<div><pre><code><span>const</span> raf <span>=</span> inBrowser
  <span>?</span> window<span>.</span>requestAnimationFrame
    <span>?</span> window<span>.</span><span>requestAnimationFrame</span><span>.</span><span>bind</span><span>(</span>window<span>)</span>
    <span>:</span> <span>setTimeout</span>
  <span>:</span> <span>fn</span> <span>=></span> <span>fn</span><span>(</span><span>)</span>

<span>export</span> <span>function</span> <span>nextFrame</span> <span>(</span><span><span>fn</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>raf</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>raf</span><span>(</span>fn<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它就是一个简单的 <code>requestAnimationFrame</code> 的实现，它的参数 fn 会在下一帧执行，因此下一帧执行了 <code>removeTransitionClass(el, startClass)</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>removeTransitionClass</span> <span>(</span><span><span>el</span><span>:</span> any<span>,</span> <span>cls</span><span>:</span> string</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>el<span>.</span>_transitionClasses<span>)</span> <span>{</span>
    <span>remove</span><span>(</span>el<span>.</span>_transitionClasses<span>,</span> cls<span>)</span>
  <span>}</span>
  <span>removeClass</span><span>(</span>el<span>,</span> cls<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>把 <code>startClass</code> 移除，在我们的等例子中就是移除 <code>fade-enter</code> 样式。然后判断此时过渡没有被取消，则执行 <code>addTransitionClass(el, toClass)</code> 添加 <code>toClass</code>，在我们的例子中就是添加了 <code>fade-enter-to</code>。然后判断 <code>!userWantsControl</code>，也就是用户不通过 <code>enterHook</code> 钩子函数控制动画，这时候如果用户指定了 <code>explicitEnterDuration</code>，则延时这个时间执行 <code>cb</code>，否则通过 <code>whenTransitionEnds(el, type, cb)</code> 决定执行 <code>cb</code> 的时机：</p>
<div><pre><code><span>export</span> <span>function</span> <span>whenTransitionEnds</span> <span>(</span>
  <span><span>el</span><span>:</span> Element<span>,</span>
  <span>expectedType</span><span>:</span> <span>?</span>string<span>,</span>
  <span>cb</span><span>:</span> Function</span>
<span>)</span> <span>{</span>
  <span>const</span> <span>{</span> type<span>,</span> timeout<span>,</span> propCount <span>}</span> <span>=</span> <span>getTransitionInfo</span><span>(</span>el<span>,</span> expectedType<span>)</span>
  <span>if</span> <span>(</span><span>!</span>type<span>)</span> <span>return</span> <span>cb</span><span>(</span><span>)</span>
  <span>const</span> <span>event</span><span>:</span> string <span>=</span> type <span>===</span> <span>&lt;</span>transition<span>></span> <span>?</span> transitionEndEvent <span>:</span> animationEndEvent
  <span>let</span> ended <span>=</span> <span>0</span>
  <span>const</span> <span>end</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    el<span>.</span><span>removeEventListener</span><span>(</span>event<span>,</span> onEnd<span>)</span>
    <span>cb</span><span>(</span><span>)</span>
  <span>}</span>
  <span>const</span> <span>onEnd</span> <span>=</span> <span>e</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>e<span>.</span>target <span>===</span> el<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>++</span>ended <span>>=</span> propCount<span>)</span> <span>{</span>
        <span>end</span><span>(</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>ended <span>&lt;</span> propCount<span>)</span> <span>{</span>
      <span>end</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> timeout <span>+</span> <span>1</span><span>)</span>
  el<span>.</span><span>addEventListener</span><span>(</span>event<span>,</span> onEnd<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>whenTransitionEnds</code> 的逻辑具体不深讲了，本质上就利用了过渡动画的结束事件来决定 <code>cb</code> 函数的执行。</p>
<p>最后再回到 <code>cb</code> 函数：</p>
<div><pre><code><span>const</span> cb <span>=</span> el<span>.</span>_enterCb <span>=</span> <span>once</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
    <span>removeTransitionClass</span><span>(</span>el<span>,</span> toClass<span>)</span>
    <span>removeTransitionClass</span><span>(</span>el<span>,</span> activeClass<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> startClass<span>)</span>
    <span>}</span>
    enterCancelledHook <span>&amp;&amp;</span> <span>enterCancelledHook</span><span>(</span>el<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    afterEnterHook <span>&amp;&amp;</span> <span>afterEnterHook</span><span>(</span>el<span>)</span>
  <span>}</span>
  el<span>.</span>_enterCb <span>=</span> <span>null</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实很简单，执行了 <code>removeTransitionClass(el, toClass)</code> 和 <code>removeTransitionClass(el, activeClass)</code> 把 <code>toClass</code> 和 <code>activeClass</code> 移除，然后判断如果有没有取消，如果取消则移除 <code>startClass</code> 并执行 <code>enterCancelledHook</code>，否则执行 <code>afterEnterHook(el)</code>。</p>
<p>那么到这里，<code>entering</code> 的过程就介绍完了。</p>
<h2 id="leaving" tabindex="-1"> leaving</h2>
<p>与 <code>entering</code> 相对的就是 <code>leaving</code> 阶段了，<code>entering</code> 主要发生在组件插入后，而 <code>leaving</code> 主要发生在组件销毁前。</p>
<div><pre><code><span>export</span> <span>function</span> <span>leave</span> <span>(</span><span><span>vnode</span><span>:</span> VNodeWithData<span>,</span> <span>rm</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> <span>el</span><span>:</span> any <span>=</span> vnode<span>.</span>elm

  <span>// call enter callback now</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>el<span>.</span>_enterCb<span>)</span><span>)</span> <span>{</span>
    el<span>.</span>_enterCb<span>.</span>cancelled <span>=</span> <span>true</span>
    el<span>.</span><span>_enterCb</span><span>(</span><span>)</span>
  <span>}</span>

  <span>const</span> data <span>=</span> <span>resolveTransition</span><span>(</span>vnode<span>.</span>data<span>.</span>transition<span>)</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>data<span>)</span> <span>||</span> el<span>.</span>nodeType <span>!==</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>rm</span><span>(</span><span>)</span>
  <span>}</span>

  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>el<span>.</span>_leaveCb<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> <span>{</span>
    css<span>,</span>
    type<span>,</span>
    leaveClass<span>,</span>
    leaveToClass<span>,</span>
    leaveActiveClass<span>,</span>
    beforeLeave<span>,</span>
    leave<span>,</span>
    afterLeave<span>,</span>
    leaveCancelled<span>,</span>
    delayLeave<span>,</span>
    duration
  <span>}</span> <span>=</span> data

  <span>const</span> expectsCSS <span>=</span> css <span>!==</span> <span>false</span> <span>&amp;&amp;</span> <span>!</span>isIE9
  <span>const</span> userWantsControl <span>=</span> <span>getHookArgumentsLength</span><span>(</span>leave<span>)</span>

  <span>const</span> <span>explicitLeaveDuration</span><span>:</span> any <span>=</span> <span>toNumber</span><span>(</span>
    <span>isObject</span><span>(</span>duration<span>)</span>
      <span>?</span> duration<span>.</span>leave
      <span>:</span> duration
  <span>)</span>

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>explicitLeaveDuration<span>)</span><span>)</span> <span>{</span>
    <span>checkDuration</span><span>(</span>explicitLeaveDuration<span>,</span> <span>'leave'</span><span>,</span> vnode<span>)</span>
  <span>}</span>

  <span>const</span> cb <span>=</span> el<span>.</span>_leaveCb <span>=</span> <span>once</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>el<span>.</span>parentNode <span>&amp;&amp;</span> el<span>.</span>parentNode<span>.</span>_pending<span>)</span> <span>{</span>
      el<span>.</span>parentNode<span>.</span>_pending<span>[</span>vnode<span>.</span>key<span>]</span> <span>=</span> <span>null</span>
    <span>}</span>
    <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> leaveToClass<span>)</span>
      <span>removeTransitionClass</span><span>(</span>el<span>,</span> leaveActiveClass<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
        <span>removeTransitionClass</span><span>(</span>el<span>,</span> leaveClass<span>)</span>
      <span>}</span>
      leaveCancelled <span>&amp;&amp;</span> <span>leaveCancelled</span><span>(</span>el<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>rm</span><span>(</span><span>)</span>
      afterLeave <span>&amp;&amp;</span> <span>afterLeave</span><span>(</span>el<span>)</span>
    <span>}</span>
    el<span>.</span>_leaveCb <span>=</span> <span>null</span>
  <span>}</span><span>)</span>

  <span>if</span> <span>(</span>delayLeave<span>)</span> <span>{</span>
    <span>delayLeave</span><span>(</span>performLeave<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>performLeave</span><span>(</span><span>)</span>
  <span>}</span>

  <span>function</span> <span>performLeave</span> <span>(</span><span>)</span> <span>{</span>
    <span>// the delayed leave may have already been cancelled</span>
    <span>if</span> <span>(</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
    <span>// record leaving element</span>
    <span>if</span> <span>(</span><span>!</span>vnode<span>.</span>data<span>.</span>show<span>)</span> <span>{</span>
      <span>(</span>el<span>.</span>parentNode<span>.</span>_pending <span>||</span> <span>(</span>el<span>.</span>parentNode<span>.</span>_pending <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>[</span><span>(</span>vnode<span>.</span>key<span>:</span> any<span>)</span><span>]</span> <span>=</span> vnode
    <span>}</span>
    beforeLeave <span>&amp;&amp;</span> <span>beforeLeave</span><span>(</span>el<span>)</span>
    <span>if</span> <span>(</span>expectsCSS<span>)</span> <span>{</span>
      <span>addTransitionClass</span><span>(</span>el<span>,</span> leaveClass<span>)</span>
      <span>addTransitionClass</span><span>(</span>el<span>,</span> leaveActiveClass<span>)</span>
      <span>nextFrame</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>removeTransitionClass</span><span>(</span>el<span>,</span> leaveClass<span>)</span>
        <span>if</span> <span>(</span><span>!</span>cb<span>.</span>cancelled<span>)</span> <span>{</span>
          <span>addTransitionClass</span><span>(</span>el<span>,</span> leaveToClass<span>)</span>
          <span>if</span> <span>(</span><span>!</span>userWantsControl<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>isValidDuration</span><span>(</span>explicitLeaveDuration<span>)</span><span>)</span> <span>{</span>
              <span>setTimeout</span><span>(</span>cb<span>,</span> explicitLeaveDuration<span>)</span>
            <span>}</span> <span>else</span> <span>{</span>
              <span>whenTransitionEnds</span><span>(</span>el<span>,</span> type<span>,</span> cb<span>)</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>}</span><span>)</span>
    <span>}</span>
    leave <span>&amp;&amp;</span> <span>leave</span><span>(</span>el<span>,</span> cb<span>)</span>
    <span>if</span> <span>(</span><span>!</span>expectsCSS <span>&amp;&amp;</span> <span>!</span>userWantsControl<span>)</span> <span>{</span>
      <span>cb</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>纵观 <code>leave</code> 的实现，和 <code>enter</code> 的实现几乎是一个镜像过程，不同的是从 <code>data</code> 中解析出来的是 <code>leave</code> 相关的样式类名和钩子函数。还有一点不同是可以配置 <code>delayLeave</code>，它是一个函数，可以延时执行 <code>leave</code> 的相关过渡动画，在 <code>leave</code> 动画执行完后，它会执行 <code>rm</code> 函数把节点从 DOM 中真正做移除。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么到此为止基本的 <code>&lt;transition&gt;</code> 过渡的实现分析完毕了，总结起来，Vue 的过渡实现分为以下几个步骤：</p>
<ol>
<li>
<p>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</p>
</li>
<li>
<p>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</p>
</li>
<li>
<p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。</p>
</li>
</ol>
<p>所以真正执行动画的是我们写的 CSS 或者是 JavaScript 钩子函数，而 Vue 的 <code>&lt;transition&gt;</code> 只是帮我们很好地管理了这些 CSS 的添加/删除，以及钩子函数的执行时机。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">v-model</title>
    <id>https://0808200.xyz/vue2/extend/v-model.html</id>
    <link href="https://0808200.xyz/vue2/extend/v-model.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="v-model" tabindex="-1"> v-model</h1>
<p>很多同学在理解 Vue 的时候都把 Vue 的数据响应原理理解为双向绑定，但实际上这是不准确的，我们之前提到的数据响应，都是通过数据的改变去驱动 DOM 视图的变化，而双向绑定除了数据驱动 DOM 外， DOM 的变化反过来影响数据，是一个双向关系，在 Vue 中，我们可以通过 <code>v-model</code> 来实现双向绑定。</p>
<p><code>v-model</code> 即可以作用在普通表单元素上，又可以作用在组件上，它其实是一个语法糖，接下来我们就来分析 <code>v-model</code> 的实现原理。</p>
<h2 id="表单元素" tabindex="-1"> 表单元素</h2>
<p>为了更加直观，我们还是结合示例来分析:</p>
<div><pre><code><span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span>
  <span>+</span> <span>'&lt;input v-model="message" placeholder="edit me">'</span> <span>+</span>
  <span>'&lt;p>Message is: {{ message }}&lt;/p>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>message</span><span>:</span> <span>''</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这是一个非常简单 demo，我们在 <code>input</code> 元素上设置了 <code>v-model</code> 属性，绑定了 <code>message</code>，当我们在 <code>input</code> 上输入了内容，<code>message</code> 也会同步变化。接下来我们就来分析 Vue 是如何实现这一效果的，其实非常简单。</p>
<p>也是先从编译阶段分析，首先是 <code>parse</code> 阶段， <code>v-model</code> 被当做普通的指令解析到 <code>el.directives</code> 中，然后在 <code>codegen</code> 阶段，执行 <code>genData</code> 的时候，会执行 <code>const dirs = genDirectives(el, state)</code>，它的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<div><pre><code><span>function</span> <span>genDirectives</span> <span>(</span><span><span>el</span><span>:</span> ASTElement<span>,</span> <span>state</span><span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>|</span> <span>void</span> <span>{</span>
  <span>const</span> dirs <span>=</span> el<span>.</span>directives
  <span>if</span> <span>(</span><span>!</span>dirs<span>)</span> <span>return</span>
  <span>let</span> res <span>=</span> <span>'directives:['</span>
  <span>let</span> hasRuntime <span>=</span> <span>false</span>
  <span>let</span> i<span>,</span> l<span>,</span> dir<span>,</span> needRuntime
  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>,</span> l <span>=</span> dirs<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    dir <span>=</span> dirs<span>[</span>i<span>]</span>
    needRuntime <span>=</span> <span>true</span>
    <span>const</span> <span>gen</span><span>:</span> DirectiveFunction <span>=</span> state<span>.</span>directives<span>[</span>dir<span>.</span>name<span>]</span>
    <span>if</span> <span>(</span>gen<span>)</span> <span>{</span>
      <span>// compile-time directive that manipulates AST.</span>
      <span>// returns true if it also needs a runtime counterpart.</span>
      needRuntime <span>=</span> <span>!</span><span>!</span><span>gen</span><span>(</span>el<span>,</span> dir<span>,</span> state<span>.</span>warn<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>needRuntime<span>)</span> <span>{</span>
      hasRuntime <span>=</span> <span>true</span>
      res <span>+=</span> <span><span>`</span><span>{name:"</span><span><span>${</span>dir<span>.</span>name<span>}</span></span><span>",rawName:"</span><span><span>${</span>dir<span>.</span>rawName<span>}</span></span><span>"</span><span><span>${</span>
        dir<span>.</span>value <span>?</span> <span><span>`</span><span>,value:(</span><span><span>${</span>dir<span>.</span>value<span>}</span></span><span>),expression:</span><span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>dir<span>.</span>value<span>)</span><span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
      <span>}</span></span><span><span>${</span>
        dir<span>.</span>arg <span>?</span> <span><span>`</span><span>,arg:"</span><span><span>${</span>dir<span>.</span>arg<span>}</span></span><span>"</span><span>`</span></span> <span>:</span> <span>''</span>
      <span>}</span></span><span><span>${</span>
        dir<span>.</span>modifiers <span>?</span> <span><span>`</span><span>,modifiers:</span><span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>dir<span>.</span>modifiers<span>)</span><span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
      <span>}</span></span><span>},</span><span>`</span></span>
    <span>}</span>
  <span>}</span>
  <span>if</span> <span>(</span>hasRuntime<span>)</span> <span>{</span>
    <span>return</span> res<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span> <span>+</span> <span>']'</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genDrirectives</code> 方法就是遍历 <code>el.directives</code>，然后获取每一个指令对应的方法 <code> const gen: DirectiveFunction = state.directives[dir.name]</code>，这个指令方法实际上是在实例化 <code>CodegenState</code> 的时候通过 <code>option</code>
传入的，这个 <code>option</code> 就是编译相关的配置，它在不同的平台下配置不同，在 <code>web</code> 环境下的定义在 <code>src/platforms/web/compiler/options.js</code> 下：</p>
<div><pre><code><span>export</span> <span>const</span> <span>baseOptions</span><span>:</span> CompilerOptions <span>=</span> <span>{</span>
  <span>expectHTML</span><span>:</span> <span>true</span><span>,</span>
  modules<span>,</span>
  directives<span>,</span>
  isPreTag<span>,</span>
  isUnaryTag<span>,</span>
  mustUseProp<span>,</span>
  canBeLeftOpenTag<span>,</span>
  isReservedTag<span>,</span>
  getTagNamespace<span>,</span>
  <span>staticKeys</span><span>:</span> <span>genStaticKeys</span><span>(</span>modules<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>directives</code> 定义在 <code>src/platforms/web/compiler/directives/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  model<span>,</span>
  text<span>,</span>
  html
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>那么对于 <code>v-model</code> 而言，对应的 <code>directive</code> 函数是在 <code>src/platforms/web/compiler/directives/model.js</code> 中定义的 <code>model</code> 函数：</p>
<div><pre><code><span>export</span> <span>default</span> <span>function</span> <span>model</span> <span>(</span>
  <span><span>el</span><span>:</span> ASTElement<span>,</span>
  <span>dir</span><span>:</span> ASTDirective<span>,</span>
  <span>_warn</span><span>:</span> Function</span>
<span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
  warn <span>=</span> _warn
  <span>const</span> value <span>=</span> dir<span>.</span>value
  <span>const</span> modifiers <span>=</span> dir<span>.</span>modifiers
  <span>const</span> tag <span>=</span> el<span>.</span>tag
  <span>const</span> type <span>=</span> el<span>.</span>attrsMap<span>.</span>type

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>// inputs with type="file" are read only and setting the input's</span>
    <span>// value will throw an error.</span>
    <span>if</span> <span>(</span>tag <span>===</span> <span>'input'</span> <span>&amp;&amp;</span> type <span>===</span> <span>'file'</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>&lt;</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span> v-model="</span><span><span>${</span>value<span>}</span></span><span>" type="file">:\n</span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>File inputs are read only. Use a v-on:change listener instead.</span><span>`</span></span>
      <span>)</span>
    <span>}</span>
  <span>}</span>

  <span>if</span> <span>(</span>el<span>.</span>component<span>)</span> <span>{</span>
    <span>genComponentModel</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span>
    <span>// component v-model doesn't need extra runtime</span>
    <span>return</span> <span>false</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>tag <span>===</span> <span>'select'</span><span>)</span> <span>{</span>
    <span>genSelect</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>tag <span>===</span> <span>'input'</span> <span>&amp;&amp;</span> type <span>===</span> <span>'checkbox'</span><span>)</span> <span>{</span>
    <span>genCheckboxModel</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>tag <span>===</span> <span>'input'</span> <span>&amp;&amp;</span> type <span>===</span> <span>'radio'</span><span>)</span> <span>{</span>
    <span>genRadioModel</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>tag <span>===</span> <span>'input'</span> <span>||</span> tag <span>===</span> <span>'textarea'</span><span>)</span> <span>{</span>
    <span>genDefaultModel</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>config<span>.</span><span>isReservedTag</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
    <span>genComponentModel</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span>
    <span>// component v-model doesn't need extra runtime</span>
    <span>return</span> <span>false</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span><span>`</span><span>&lt;</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span> v-model="</span><span><span>${</span>value<span>}</span></span><span>">: </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>v-model is not supported on this element type. </span><span>`</span></span> <span>+</span>
      <span>'If you are working with contenteditable, it\'s recommended to '</span> <span>+</span>
      <span>'wrap a library dedicated for that purpose inside a custom component.'</span>
    <span>)</span>
  <span>}</span>

  <span>// ensure runtime directive metadata</span>
  <span>return</span> <span>true</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说我们执行 <code>needRuntime = !!gen(el, dir, state.warn)</code> 就是在执行 <code>model</code> 函数，它会根据 AST 元素节点的不同情况去执行不同的逻辑，对于我们这个 case 而言，它会命中 <code>genDefaultModel(el, value, modifiers)</code> 的逻辑，稍后我们也会介绍组件的处理，其它分支同学们可以自行去看。我们来看一下 <code>genDefaultModel</code> 的实现：</p>
<div><pre><code><span>function</span> <span>genDefaultModel</span> <span>(</span>
  <span><span>el</span><span>:</span> ASTElement<span>,</span>
  <span>value</span><span>:</span> string<span>,</span>
  <span>modifiers</span><span>:</span> <span>?</span>ASTModifiers</span>
<span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
  <span>const</span> type <span>=</span> el<span>.</span>attrsMap<span>.</span>type

  <span>// warn if v-bind:value conflicts with v-model</span>
  <span>// except for inputs with v-bind:type</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>const</span> value <span>=</span> el<span>.</span>attrsMap<span>[</span><span>'v-bind:value'</span><span>]</span> <span>||</span> el<span>.</span>attrsMap<span>[</span><span>':value'</span><span>]</span>
    <span>const</span> typeBinding <span>=</span> el<span>.</span>attrsMap<span>[</span><span>'v-bind:type'</span><span>]</span> <span>||</span> el<span>.</span>attrsMap<span>[</span><span>':type'</span><span>]</span>
    <span>if</span> <span>(</span>value <span>&amp;&amp;</span> <span>!</span>typeBinding<span>)</span> <span>{</span>
      <span>const</span> binding <span>=</span> el<span>.</span>attrsMap<span>[</span><span>'v-bind:value'</span><span>]</span> <span>?</span> <span>'v-bind:value'</span> <span>:</span> <span>':value'</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span><span>${</span>binding<span>}</span></span><span>="</span><span><span>${</span>value<span>}</span></span><span>" conflicts with v-model on the same element </span><span>`</span></span> <span>+</span>
        <span>'because the latter already expands to a value binding internally'</span>
      <span>)</span>
    <span>}</span>
  <span>}</span>

  <span>const</span> <span>{</span> lazy<span>,</span> number<span>,</span> trim <span>}</span> <span>=</span> modifiers <span>||</span> <span>{</span><span>}</span>
  <span>const</span> needCompositionGuard <span>=</span> <span>!</span>lazy <span>&amp;&amp;</span> type <span>!==</span> <span>'range'</span>
  <span>const</span> event <span>=</span> lazy
    <span>?</span> <span>'change'</span>
    <span>:</span> type <span>===</span> <span>'range'</span>
      <span>?</span> <span>RANGE_TOKEN</span>
      <span>:</span> <span>'input'</span>

  <span>let</span> valueExpression <span>=</span> <span>'$event.target.value'</span>
  <span>if</span> <span>(</span>trim<span>)</span> <span>{</span>
    valueExpression <span>=</span> <span><span>`</span><span>$event.target.value.trim()</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>number<span>)</span> <span>{</span>
    valueExpression <span>=</span> <span><span>`</span><span>_n(</span><span><span>${</span>valueExpression<span>}</span></span><span>)</span><span>`</span></span>
  <span>}</span>

  <span>let</span> code <span>=</span> <span>genAssignmentCode</span><span>(</span>value<span>,</span> valueExpression<span>)</span>
  <span>if</span> <span>(</span>needCompositionGuard<span>)</span> <span>{</span>
    code <span>=</span> <span><span>`</span><span>if($event.target.composing)return;</span><span><span>${</span>code<span>}</span></span><span>`</span></span>
  <span>}</span>

  <span>addProp</span><span>(</span>el<span>,</span> <span>'value'</span><span>,</span> <span><span>`</span><span>(</span><span><span>${</span>value<span>}</span></span><span>)</span><span>`</span></span><span>)</span>
  <span>addHandler</span><span>(</span>el<span>,</span> event<span>,</span> code<span>,</span> <span>null</span><span>,</span> <span>true</span><span>)</span>
  <span>if</span> <span>(</span>trim <span>||</span> number<span>)</span> <span>{</span>
    <span>addHandler</span><span>(</span>el<span>,</span> <span>'blur'</span><span>,</span> <span>'$forceUpdate()'</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genDefaultModel</code> 函数先处理了 <code>modifiers</code>，它的不同主要影响的是 <code>event</code> 和 <code>valueExpression</code> 的值，对于我们的例子，<code>event</code> 为 <code>input</code>，<code>valueExpression</code> 为 <code>$event.target.value</code>。然后去执行 <code>genAssignmentCode</code> 去生成代码，它的定义在 <code>src/compiler/directives/model.js</code> 中：</p>
<div><pre><code><span>/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */</span>
<span>export</span> <span>function</span> <span>genAssignmentCode</span> <span>(</span>
  <span><span>value</span><span>:</span> string<span>,</span>
  <span>assignment</span><span>:</span> string</span>
<span>)</span><span>:</span> string <span>{</span>
  <span>const</span> res <span>=</span> <span>parseModel</span><span>(</span>value<span>)</span>
  <span>if</span> <span>(</span>res<span>.</span>key <span>===</span> <span>null</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span><span>${</span>value<span>}</span></span><span>=</span><span><span>${</span>assignment<span>}</span></span><span>`</span></span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>$set(</span><span><span>${</span>res<span>.</span>exp<span>}</span></span><span>, </span><span><span>${</span>res<span>.</span>key<span>}</span></span><span>, </span><span><span>${</span>assignment<span>}</span></span><span>)</span><span>`</span></span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该方法首先对 <code>v-model</code> 对应的 <code>value</code> 做了解析，它处理了非常多的情况，对我们的例子，<code>value</code> 就是 <code>messgae</code>，所以返回的 <code>res.key</code> 为 <code>null</code>，然后我们就得到 <code>${value}=${assignment}</code>，也就是 <code>message=$event.target.value</code>。然后我们又命中了 <code>needCompositionGuard</code> 为 true 的逻辑，所以最终的 <code>code</code> 为 <code>if($event.target.composing)return;message=$event.target.value</code>。</p>
<p><code>code</code> 生成完后，又执行了 2 句非常关键的代码：</p>
<div><pre><code><span>addProp</span><span>(</span>el<span>,</span> <span>'value'</span><span>,</span> <span><span>`</span><span>(</span><span><span>${</span>value<span>}</span></span><span>)</span><span>`</span></span><span>)</span>
<span>addHandler</span><span>(</span>el<span>,</span> event<span>,</span> code<span>,</span> <span>null</span><span>,</span> <span>true</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这实际上就是 <code>input</code> 实现 <code>v-model</code> 的精髓，通过修改 AST 元素，给 <code>el</code> 添加一个 <code>prop</code>，相当于我们在 <code>input</code> 上动态绑定了 <code>value</code>，又给 <code>el</code> 添加了事件处理，相当于在 <code>input</code> 上绑定了 <code>input</code> 事件，其实转换成模板如下：</p>
<div><pre><code><span>&lt;</span>input
  v<span>-</span>bind<span>:</span>value<span>=</span><span>"message"</span>
  v<span>-</span>on<span>:</span>input<span>=</span><span>"message=$event.target.value"</span><span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>其实就是动态绑定了 <code>input</code> 的 <code>value</code> 指向了 <code>messgae</code> 变量，并且在触发 <code>input</code> 事件的时候去动态把 <code>message</code> 设置为目标值，这样实际上就完成了数据双向绑定了，所以说 <code>v-model</code> 实际上就是语法糖。</p>
<p>再回到 <code>genDirectives</code>，它接下来的逻辑就是根据指令生成一些 <code>data</code> 的代码：</p>
<div><pre><code><span>if</span> <span>(</span>needRuntime<span>)</span> <span>{</span>
  hasRuntime <span>=</span> <span>true</span>
  res <span>+=</span> <span><span>`</span><span>{name:"</span><span><span>${</span>dir<span>.</span>name<span>}</span></span><span>",rawName:"</span><span><span>${</span>dir<span>.</span>rawName<span>}</span></span><span>"</span><span><span>${</span>
    dir<span>.</span>value <span>?</span> <span><span>`</span><span>,value:(</span><span><span>${</span>dir<span>.</span>value<span>}</span></span><span>),expression:</span><span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>dir<span>.</span>value<span>)</span><span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
  <span>}</span></span><span><span>${</span>
    dir<span>.</span>arg <span>?</span> <span><span>`</span><span>,arg:"</span><span><span>${</span>dir<span>.</span>arg<span>}</span></span><span>"</span><span>`</span></span> <span>:</span> <span>''</span>
  <span>}</span></span><span><span>${</span>
    dir<span>.</span>modifiers <span>?</span> <span><span>`</span><span>,modifiers:</span><span><span>${</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>dir<span>.</span>modifiers<span>)</span><span>}</span></span><span>`</span></span> <span>:</span> <span>''</span>
  <span>}</span></span><span>},</span><span>`</span></span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对我们的例子而言，最终生成的 <code>render</code> 代码如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span> <span>{</span>
  <span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span><span>[</span><span>_c</span><span>(</span><span>'input'</span><span>,</span><span>{</span>
    <span>directives</span><span>:</span><span>[</span><span>{</span>
      <span>name</span><span>:</span><span>"model"</span><span>,</span>
      <span>rawName</span><span>:</span><span>"v-model"</span><span>,</span>
      <span>value</span><span>:</span><span>(</span>message<span>)</span><span>,</span>
      <span>expression</span><span>:</span><span>"message"</span>
    <span>}</span><span>]</span><span>,</span>
    <span>attrs</span><span>:</span><span>{</span><span>"placeholder"</span><span>:</span><span>"edit me"</span><span>}</span><span>,</span>
    <span>domProps</span><span>:</span><span>{</span><span>"value"</span><span>:</span><span>(</span>message<span>)</span><span>}</span><span>,</span>
    <span>on</span><span>:</span><span>{</span><span>"input"</span><span>:</span><span>function</span><span>(</span><span>$event</span><span>)</span><span>{</span>
      <span>if</span><span>(</span>$event<span>.</span>target<span>.</span>composing<span>)</span>
        <span>return</span><span>;</span>
      message<span>=</span>$event<span>.</span>target<span>.</span>value
    <span>}</span><span>}</span><span>}</span><span>)</span><span>,</span><span>_c</span><span>(</span><span>'p'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>"Message is: "</span><span>+</span><span>_s</span><span>(</span>message<span>)</span><span>)</span><span>]</span><span>)</span>
    <span>]</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>关于事件的处理我们之前的章节已经分析过了，所以对于 <code>input</code> 的 <code>v-model</code> 而言，完全就是语法糖，并且对于其它表单元素套路都是一样，区别在于生成的事件代码会略有不同。</p>
<p><code>v-model</code> 除了作用在表单元素上，新版的 Vue 还把这一语法糖用在了组件上，接下来我们来分析它的实现。</p>
<h2 id="组件" tabindex="-1"> 组件</h2>
<p>为了更加直观，我们也是通过一个例子分析：</p>
<div><pre><code><span>let</span> Child <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span>
  <span>+</span> <span>'&lt;input :value="value" @input="updateValue" placeholder="edit me">'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>props</span><span>:</span> <span>[</span><span>'value'</span><span>]</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>updateValue</span><span>(</span><span>e</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'input'</span><span>,</span> e<span>.</span>target<span>.</span>value<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;child v-model="message">&lt;/child>'</span> <span>+</span>
  <span>'&lt;p>Message is: {{ message }}&lt;/p>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>message</span><span>:</span> <span>''</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    Child
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，父组件引用 <code>child</code> 子组件的地方使用了 <code>v-model</code> 关联了数据 <code>message</code>；而子组件定义了一个 <code>value</code> 的 <code>prop</code>，并且在 <code>input</code> 事件的回调函数中，通过 <code>this.$emit('input', e.target.value)</code> 派发了一个事件，为了让 <code>v-model</code> 生效，这两点是必须的。</p>
<p>接着我们从源码角度分析实现原理，还是从编译阶段说起，对于父组件而言，在编译阶段会解析 <code>v-model</code> 指令，依然会执行 <code>genData</code> 函数中的 <code>genDirectives</code> 函数，接着执行 <code>src/platforms/web/compiler/directives/model.js</code> 中定义的 <code>model</code> 函数，并命中如下逻辑：</p>
<div><pre><code><span>else</span> <span>if</span> <span>(</span><span>!</span>config<span>.</span><span>isReservedTag</span><span>(</span>tag<span>)</span><span>)</span> <span>{</span>
  <span>genComponentModel</span><span>(</span>el<span>,</span> value<span>,</span> modifiers<span>)</span><span>;</span>
  <span>return</span> <span>false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>genComponentModel</code> 函数定义在 <code>src/compiler/directives/model.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genComponentModel</span> <span>(</span>
  <span><span>el</span><span>:</span> ASTElement<span>,</span>
  <span>value</span><span>:</span> string<span>,</span>
  <span>modifiers</span><span>:</span> <span>?</span>ASTModifiers</span>
<span>)</span><span>:</span> <span>?</span>boolean <span>{</span>
  <span>const</span> <span>{</span> number<span>,</span> trim <span>}</span> <span>=</span> modifiers <span>||</span> <span>{</span><span>}</span>

  <span>const</span> baseValueExpression <span>=</span> <span>'$$v'</span>
  <span>let</span> valueExpression <span>=</span> baseValueExpression
  <span>if</span> <span>(</span>trim<span>)</span> <span>{</span>
    valueExpression <span>=</span>
      <span><span>`</span><span>(typeof </span><span><span>${</span>baseValueExpression<span>}</span></span><span> === 'string'</span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>? </span><span><span>${</span>baseValueExpression<span>}</span></span><span>.trim()</span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>: </span><span><span>${</span>baseValueExpression<span>}</span></span><span>)</span><span>`</span></span>
  <span>}</span>
  <span>if</span> <span>(</span>number<span>)</span> <span>{</span>
    valueExpression <span>=</span> <span><span>`</span><span>_n(</span><span><span>${</span>valueExpression<span>}</span></span><span>)</span><span>`</span></span>
  <span>}</span>
  <span>const</span> assignment <span>=</span> <span>genAssignmentCode</span><span>(</span>value<span>,</span> valueExpression<span>)</span>

  el<span>.</span>model <span>=</span> <span>{</span>
    <span>value</span><span>:</span> <span><span>`</span><span>(</span><span><span>${</span>value<span>}</span></span><span>)</span><span>`</span></span><span>,</span>
    <span>expression</span><span>:</span> <span><span>`</span><span>"</span><span><span>${</span>value<span>}</span></span><span>"</span><span>`</span></span><span>,</span>
    <span>callback</span><span>:</span> <span><span>`</span><span>function (</span><span><span>${</span>baseValueExpression<span>}</span></span><span>) {</span><span><span>${</span>assignment<span>}</span></span><span>}</span><span>`</span></span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>genComponentModel</code> 的逻辑很简单，对我们的例子而言，生成的 <code>el.model</code> 的值为：</p>
<div><pre><code>el<span>.</span>model <span>=</span> <span>{</span>
  <span>callback</span><span>:</span><span>'function ($$v) {message=$$v}'</span><span>,</span>
  <span>expression</span><span>:</span><span>'"message"'</span><span>,</span>
  <span>value</span><span>:</span><span>'(message)'</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>那么在 <code>genDirectives</code> 之后，<code>genData</code> 函数中有一段逻辑如下：</p>
<div><pre><code><span>if</span> <span>(</span>el<span>.</span>model<span>)</span> <span>{</span>
  data <span>+=</span> <span><span>`</span><span>model:{value:</span><span><span>${</span>
    el<span>.</span>model<span>.</span>value
  <span>}</span></span><span>,callback:</span><span><span>${</span>
    el<span>.</span>model<span>.</span>callback
  <span>}</span></span><span>,expression:</span><span><span>${</span>
    el<span>.</span>model<span>.</span>expression
  <span>}</span></span><span>},</span><span>`</span></span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么父组件最终生成的 <code>render</code> 代码如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span><span>{</span>
  <span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span><span>[</span><span>_c</span><span>(</span><span>'child'</span><span>,</span><span>{</span>
    <span>model</span><span>:</span><span>{</span>
      <span>value</span><span>:</span><span>(</span>message<span>)</span><span>,</span>
      <span>callback</span><span>:</span><span>function</span> <span>(</span><span>$$v</span><span>)</span> <span>{</span>
        message<span>=</span>$$v
      <span>}</span><span>,</span>
      <span>expression</span><span>:</span><span>"message"</span>
    <span>}</span>
  <span>}</span><span>)</span><span>,</span>
  <span>_c</span><span>(</span><span>'p'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>"Message is: "</span><span>+</span><span>_s</span><span>(</span>message<span>)</span><span>)</span><span>]</span><span>)</span><span>]</span><span>,</span><span>1</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后在创建子组件 <code>vnode</code> 阶段，会执行 <code>createComponent</code> 函数，它的定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponent</span> <span>(</span>
 <span><span>Ctor</span><span>:</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object <span>|</span> <span>void</span><span>,</span>
 <span>data</span><span>:</span> <span>?</span>VNodeData<span>,</span>
 <span>context</span><span>:</span> Component<span>,</span>
 <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
 tag<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>|</span> <span>void</span> <span>{</span>
 <span>// ...</span>
 <span>// transform component v-model data into props &amp; events</span>
 <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>.</span>model<span>)</span><span>)</span> <span>{</span>
   <span>transformModel</span><span>(</span>Ctor<span>.</span>options<span>,</span> data<span>)</span>
 <span>}</span>

 <span>// extract props</span>
 <span>const</span> propsData <span>=</span> <span>extractPropsFromVNodeData</span><span>(</span>data<span>,</span> Ctor<span>,</span> tag<span>)</span>
 <span>// ...</span>
 <span>// extract listeners, since these needs to be treated as</span>
 <span>// child component listeners instead of DOM listeners</span>
 <span>const</span> listeners <span>=</span> data<span>.</span>on
 <span>// ...</span>
 <span>const</span> vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
   <span><span>`</span><span>vue-component-</span><span><span>${</span>Ctor<span>.</span>cid<span>}</span></span><span><span>${</span>name <span>?</span> <span><span>`</span><span>-</span><span><span>${</span>name<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span><span>,</span>
   data<span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context<span>,</span>
   <span>{</span> Ctor<span>,</span> propsData<span>,</span> listeners<span>,</span> tag<span>,</span> children <span>}</span><span>,</span>
   asyncFactory
 <span>)</span>
 
 <span>return</span> vnode
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中会对 <code>data.model</code> 的情况做处理，执行 <code>transformModel(Ctor.options, data)</code> 方法：</p>
<div><pre><code><span>// transform component v-model info (value and callback) into</span>
<span>// prop and event handler respectively.</span>
<span>function</span> <span>transformModel</span> <span>(</span><span>options<span>,</span> <span>data</span><span>:</span> any</span><span>)</span> <span>{</span>
  <span>const</span> prop <span>=</span> <span>(</span>options<span>.</span>model <span>&amp;&amp;</span> options<span>.</span>model<span>.</span>prop<span>)</span> <span>||</span> <span>'value'</span>
  <span>const</span> event <span>=</span> <span>(</span>options<span>.</span>model <span>&amp;&amp;</span> options<span>.</span>model<span>.</span>event<span>)</span> <span>||</span> <span>'input'</span>
  <span>;</span><span>(</span>data<span>.</span>props <span>||</span> <span>(</span>data<span>.</span>props <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>[</span>prop<span>]</span> <span>=</span> data<span>.</span>model<span>.</span>value
  <span>const</span> on <span>=</span> data<span>.</span>on <span>||</span> <span>(</span>data<span>.</span>on <span>=</span> <span>{</span><span>}</span><span>)</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>on<span>[</span>event<span>]</span><span>)</span><span>)</span> <span>{</span>
    on<span>[</span>event<span>]</span> <span>=</span> <span>[</span>data<span>.</span>model<span>.</span>callback<span>]</span><span>.</span><span>concat</span><span>(</span>on<span>[</span>event<span>]</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    on<span>[</span>event<span>]</span> <span>=</span> data<span>.</span>model<span>.</span>callback
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>transformModel</code> 逻辑很简单，给 <code>data.props</code> 添加 <code>data.model.value</code>，并且给<code>data.on</code> 添加 <code>data.model.callback</code>，对我们的例子而言，扩展结果如下：</p>
<div><pre><code>data<span>.</span>props <span>=</span> <span>{</span>
  <span>value</span><span>:</span> <span>(</span>message<span>)</span><span>,</span>
<span>}</span>
data<span>.</span>on <span>=</span> <span>{</span>
  <span>input</span><span>:</span> <span>function</span> <span>(</span><span>$$v</span><span>)</span> <span>{</span>
    message<span>=</span>$$v
  <span>}</span>
<span>}</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实就相当于我们在这样编写父组件：</p>
<div><pre><code><span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;child :value="message" @input="message=arguments[0]">&lt;/child>'</span> <span>+</span>
  <span>'&lt;p>Message is: {{ message }}&lt;/p>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>message</span><span>:</span> <span>''</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    Child
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>子组件传递的 <code>value</code> 绑定到当前父组件的 <code>message</code>，同时监听自定义 <code>input</code> 事件，当子组件派发 <code>input</code> 事件的时候，父组件会在事件回调函数中修改 <code>message</code> 的值，同时 <code>value</code> 也会发生变化，子组件的 <code>input</code> 值被更新。</p>
<p>这就是典型的 Vue 的父子组件通讯模式，父组件通过 <code>prop</code> 把数据传递到子组件，子组件修改了数据后把改变通过 <code>$emit</code> 事件的方式通知父组件，所以说组件上的 <code>v-model</code> 也是一种语法糖。</p>
<p>另外我们注意到组件 <code>v-model</code> 的实现，子组件的 <code>value prop</code> 以及派发的 <code>input</code> 事件名是可配的，可以看到 <code>transformModel</code> 中对这部分的处理：</p>
<div><pre><code><span>function</span> <span>transformModel</span> <span>(</span><span>options<span>,</span> <span>data</span><span>:</span> any</span><span>)</span> <span>{</span>
  <span>const</span> prop <span>=</span> <span>(</span>options<span>.</span>model <span>&amp;&amp;</span> options<span>.</span>model<span>.</span>prop<span>)</span> <span>||</span> <span>'value'</span>
  <span>const</span> event <span>=</span> <span>(</span>options<span>.</span>model <span>&amp;&amp;</span> options<span>.</span>model<span>.</span>event<span>)</span> <span>||</span> <span>'input'</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说可以在定义子组件的时候通过 <code>model</code> 选项配置子组件接收的 <code>prop</code> 名以及派发的事件名，举个例子：</p>
<div><pre><code><span>let</span> Child <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span>
  <span>+</span> <span>'&lt;input :value="msg" @input="updateValue" placeholder="edit me">'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>props</span><span>:</span> <span>[</span><span>'msg'</span><span>]</span><span>,</span>
  <span>model</span><span>:</span> <span>{</span>
    <span>prop</span><span>:</span> <span>'msg'</span><span>,</span>
    <span>event</span><span>:</span> <span>'change'</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>updateValue</span><span>(</span><span>e</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'change'</span><span>,</span> e<span>.</span>target<span>.</span>value<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>let</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>template</span><span>:</span> <span>'&lt;div>'</span> <span>+</span>
  <span>'&lt;child v-model="message">&lt;/child>'</span> <span>+</span>
  <span>'&lt;p>Message is: {{ message }}&lt;/p>'</span> <span>+</span>
  <span>'&lt;/div>'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>message</span><span>:</span> <span>''</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>components</span><span>:</span> <span>{</span>
    Child
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>子组件修改了接收的 <code>prop</code> 名以及派发的事件名，然而这一切父组件作为调用方是不用关心的，这样做的好处是我们可以把 <code>value</code> 这个 <code>prop</code> 作为其它的用途。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，<code>v-model</code> 的实现就分析完了，我们了解到它是 Vue 双向绑定的真正实现，但本质上就是一种语法糖，它即可以支持原生表单元素，也可以支持自定义组件。在组件的实现中，我们是可以配置子组件接收的 <code>prop</code> 名称，以及派发的事件名称。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue.js 源码构建</title>
    <id>https://0808200.xyz/vue2/prepare/build.html</id>
    <link href="https://0808200.xyz/vue2/prepare/build.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vue-js-源码构建" tabindex="-1"> Vue.js 源码构建</h1>
<p>Vue.js 源码是基于 <a href="https://github.com/rollup/rollup" target="_blank" rel="noopener noreferrer">Rollup</a> 构建的，它的构建相关配置都在 scripts 目录下。</p>
<h2 id="构建脚本" tabindex="-1"> 构建脚本</h2>
<p>通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件，它的内容实际上是一个标准的 JSON 对象。</p>
<p>我们通常会配置 <code>script</code> 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下：</p>
<div><pre><code><span>{</span>
  <span>"script"</span><span>:</span> <span>{</span>
    <span>"build"</span><span>:</span> <span>"node scripts/build.js"</span><span>,</span>
    <span>"build:ssr"</span><span>:</span> <span>"npm run build -- web-runtime-cjs,web-server-renderer"</span><span>,</span>
    <span>"build:weex"</span><span>:</span> <span>"npm run build -- weex"</span>
  <span>}</span>
<span>}</span>
 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里总共有 3 条命令，作用都是构建 Vue.js，后面 2 条是在第一条命令的基础上，添加一些环境参数。</p>
<p>当在命令行运行 <code>npm run build</code> 的时候，实际上就会执行 <code>node scripts/build.js</code>，接下来我们来看看它实际是怎么构建的。</p>
<h2 id="构建过程" tabindex="-1"> 构建过程</h2>
<p>我们对于构建过程分析是基于源码的，先打开构建的入口 JS 文件，在 <code>scripts/build.js</code> 中：</p>
<div><pre><code><span>let</span> builds <span>=</span> <span>require</span><span>(</span><span>'./config'</span><span>)</span><span>.</span><span>getAllBuilds</span><span>(</span><span>)</span>

<span>// filter builds via command line arg</span>
<span>if</span> <span>(</span>process<span>.</span>argv<span>[</span><span>2</span><span>]</span><span>)</span> <span>{</span>
  <span>const</span> filters <span>=</span> process<span>.</span>argv<span>[</span><span>2</span><span>]</span><span>.</span><span>split</span><span>(</span><span>','</span><span>)</span>
  builds <span>=</span> builds<span>.</span><span>filter</span><span>(</span><span>b</span> <span>=></span> <span>{</span>
    <span>return</span> filters<span>.</span><span>some</span><span>(</span><span>f</span> <span>=></span> b<span>.</span>output<span>.</span>file<span>.</span><span>indexOf</span><span>(</span>f<span>)</span> <span>></span> <span>-</span><span>1</span> <span>||</span> b<span>.</span>_name<span>.</span><span>indexOf</span><span>(</span>f<span>)</span> <span>></span> <span>-</span><span>1</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// filter out weex builds by default</span>
  builds <span>=</span> builds<span>.</span><span>filter</span><span>(</span><span>b</span> <span>=></span> <span>{</span>
    <span>return</span> b<span>.</span>output<span>.</span>file<span>.</span><span>indexOf</span><span>(</span><span>'weex'</span><span>)</span> <span>===</span> <span>-</span><span>1</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>build</span><span>(</span>builds<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。接下来我们看一下配置文件，在 <code>scripts/config.js</code> 中：</p>
<div><pre><code><span>const</span> builds <span>=</span> <span>{</span>
  <span>// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span>
  <span>'web-runtime-cjs'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.runtime.common.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'cjs'</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// Runtime+compiler CommonJS build (CommonJS)</span>
  <span>'web-full-cjs'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime-with-compiler.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.common.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'cjs'</span><span>,</span>
    <span>alias</span><span>:</span> <span>{</span> <span>he</span><span>:</span> <span>'./entity-decoder'</span> <span>}</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// Runtime only (ES Modules). Used by bundlers that support ES Modules,</span>
  <span>// e.g. Rollup &amp; Webpack 2</span>
  <span>'web-runtime-esm'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.runtime.esm.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'es'</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// Runtime+compiler CommonJS build (ES Modules)</span>
  <span>'web-full-esm'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime-with-compiler.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.esm.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'es'</span><span>,</span>
    <span>alias</span><span>:</span> <span>{</span> <span>he</span><span>:</span> <span>'./entity-decoder'</span> <span>}</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// runtime-only build (Browser)</span>
  <span>'web-runtime-dev'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.runtime.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'umd'</span><span>,</span>
    <span>env</span><span>:</span> <span>'development'</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// runtime-only production build (Browser)</span>
  <span>'web-runtime-prod'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.runtime.min.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'umd'</span><span>,</span>
    <span>env</span><span>:</span> <span>'production'</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// Runtime+compiler development build (Browser)</span>
  <span>'web-full-dev'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime-with-compiler.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'umd'</span><span>,</span>
    <span>env</span><span>:</span> <span>'development'</span><span>,</span>
    <span>alias</span><span>:</span> <span>{</span> <span>he</span><span>:</span> <span>'./entity-decoder'</span> <span>}</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// Runtime+compiler production build  (Browser)</span>
  <span>'web-full-prod'</span><span>:</span> <span>{</span>
    <span>entry</span><span>:</span> <span>resolve</span><span>(</span><span>'web/entry-runtime-with-compiler.js'</span><span>)</span><span>,</span>
    <span>dest</span><span>:</span> <span>resolve</span><span>(</span><span>'dist/vue.min.js'</span><span>)</span><span>,</span>
    <span>format</span><span>:</span> <span>'umd'</span><span>,</span>
    <span>env</span><span>:</span> <span>'production'</span><span>,</span>
    <span>alias</span><span>:</span> <span>{</span> <span>he</span><span>:</span> <span>'./entity-decoder'</span> <span>}</span><span>,</span>
    banner
  <span>}</span><span>,</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里列举了一些 Vue.js 构建的配置，关于还有一些服务端渲染 webpack 插件以及 weex 的打包配置就不列举了。</p>
<p>对于单个配置，它是遵循 Rollup 的构建规则的。其中 <code>entry</code> 属性表示构建的入口 JS 文件地址，<code>dest</code> 属性表示构建后的 JS 文件地址。<code>format</code> 属性表示构建的格式，<code>cjs</code> 表示构建出来的文件遵循 <a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="noopener noreferrer">CommonJS</a> 规范，<code>es</code> 表示构建出来的文件遵循 <a href="http://exploringjs.com/es6/ch_modules.html" target="_blank" rel="noopener noreferrer">ES Module</a> 规范。 <code>umd</code> 表示构建出来的文件遵循 <a href="https://github.com/umdjs/umd" target="_blank" rel="noopener noreferrer">UMD</a> 规范。</p>
<p>以 <code>web-runtime-cjs</code> 配置为例，它的 <code>entry</code> 是
<code>resolve('web/entry-runtime.js')</code>，先来看一下 <code>resolve</code> 函数的定义。</p>
<p>源码目录：<code>scripts/config.js</code></p>
<div><pre><code><span>const</span> aliases <span>=</span> <span>require</span><span>(</span><span>'./alias'</span><span>)</span>
<span>const</span> <span>resolve</span> <span>=</span> <span>p</span> <span>=></span> <span>{</span>
  <span>const</span> base <span>=</span> p<span>.</span><span>split</span><span>(</span><span>'/'</span><span>)</span><span>[</span><span>0</span><span>]</span>
  <span>if</span> <span>(</span>aliases<span>[</span>base<span>]</span><span>)</span> <span>{</span>
    <span>return</span> path<span>.</span><span>resolve</span><span>(</span>aliases<span>[</span>base<span>]</span><span>,</span> p<span>.</span><span>slice</span><span>(</span>base<span>.</span>length <span>+</span> <span>1</span><span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../'</span><span>,</span> p<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的 <code>resolve</code> 函数实现非常简单，它先把 <code>resolve</code> 函数传入的参数 <code>p</code> 通过 <code>/</code> 做了分割成数组，然后取数组第一个元素设置为 <code>base</code>。在我们这个例子中，参数 <code>p</code> 是 <code>web/entry-runtime.js</code>，那么 <code>base</code> 则为 <code>web</code>。<code>base</code> 并不是实际的路径，它的真实路径借助了别名的配置，我们来看一下别名配置的代码，在 <code>scripts/alias</code> 中：</p>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>vue</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/platforms/web/entry-runtime-with-compiler'</span><span>)</span><span>,</span>
  <span>compiler</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/compiler'</span><span>)</span><span>,</span>
  <span>core</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/core'</span><span>)</span><span>,</span>
  <span>shared</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/shared'</span><span>)</span><span>,</span>
  <span>web</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/platforms/web'</span><span>)</span><span>,</span>
  <span>weex</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/platforms/weex'</span><span>)</span><span>,</span>
  <span>server</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/server'</span><span>)</span><span>,</span>
  <span>entries</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/entries'</span><span>)</span><span>,</span>
  <span>sfc</span><span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src/sfc'</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>很显然，这里 <code>web</code> 对应的真实的路径是 <code>path.resolve(__dirname, '../src/platforms/web')</code>，这个路径就找到了 Vue.js 源码的 web 目录。然后 <code>resolve</code> 函数通过 <code>path.resolve(aliases[base], p.slice(base.length + 1))</code> 找到了最终路径，它就是 Vue.js 源码 web 目录下的 <code>entry-runtime.js</code>。因此，<code>web-runtime-cjs</code> 配置对应的入口文件就找到了。</p>
<p>它经过 Rollup 的构建打包后，最终会在 dist 目录下生成 <code>vue.runtime.common.js</code>。</p>
<h2 id="runtime-only-vs-runtime-compiler" tabindex="-1"> Runtime Only VS Runtime + Compiler</h2>
<p>通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。下面我们来对比这两个版本。</p>
<ul>
<li>Runtime Only</li>
</ul>
<p>我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。</p>
<ul>
<li>Runtime + Compiler</li>
</ul>
<p>我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：</p>
<div><pre><code><span>// 需要编译器的版本</span>
<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>template</span><span>:</span> <span>'&lt;div>{{ hi }}&lt;/div>'</span>
<span>}</span><span>)</span>

<span>// 这种情况不需要</span>
<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>render</span> <span>(</span><span>h</span><span>)</span> <span>{</span>
    <span>return</span> <span>h</span><span>(</span><span>'div'</span><span>,</span> <span>this</span><span>.</span>hi<span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>因为在 Vue.js 2.0 中，最终渲染都是通过 <code>render</code> 函数，如果写 <code>template</code> 属性，则需要编译成 <code>render</code> 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。</p>
<p>很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 Runtime-Only 的 Vue.js。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节的分析，我们可以了解到 Vue.js 的构建打包过程，也知道了不同作用和功能的 Vue.js 它们对应的入口以及最终编译生成的 JS 文件。尽管在实际开发过程中我们会用 Runtime Only 版本开发比较多，但为了分析 Vue 的编译过程，我们这门课重点分析的源码是 Runtime + Compiler 的 Vue.js。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue.js 源码目录设计</title>
    <id>https://0808200.xyz/vue2/prepare/directory.html</id>
    <link href="https://0808200.xyz/vue2/prepare/directory.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vue-js-源码目录设计" tabindex="-1"> Vue.js 源码目录设计</h1>
<p>Vue.js 的源码都在 src 目录下，其目录结构如下。</p>
<div><pre><code>src
├── compiler        # 编译相关 
├── core            # 核心代码 
├── platforms       # 不同平台的支持
├── server          # 服务端渲染
├── sfc             # .vue 文件解析
├── shared          # 共享代码
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="compiler" tabindex="-1"> compiler</h2>
<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>
<p>编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。</p>
<h2 id="core" tabindex="-1"> core</h2>
<p>core 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p>
<p>这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方。</p>
<h2 id="platform" tabindex="-1"> platform</h2>
<p>Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。</p>
<p>我们会重点分析 web 入口打包后的 Vue.js，对于 weex 入口打包的 Vue.js，感兴趣的同学可以自行研究。</p>
<h2 id="server" tabindex="-1"> server</h2>
<p>Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。</p>
<p>服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。</p>
<h2 id="sfc" tabindex="-1"> sfc</h2>
<p>通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。</p>
<p>这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。</p>
<h2 id="shared" tabindex="-1"> shared</h2>
<p>Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>从 Vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。</p>
<p>这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习和推敲的。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">从入口开始</title>
    <id>https://0808200.xyz/vue2/prepare/entrance.html</id>
    <link href="https://0808200.xyz/vue2/prepare/entrance.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="从入口开始" tabindex="-1"> 从入口开始</h1>
<p>我们之前提到过 Vue.js 构建过程，在 web 应用下，我们来分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 <code>src/platforms/web/entry-runtime-with-compiler.js</code>：</p>
<div><pre><code><span>/* @flow */</span>

<span>import</span> config <span>from</span> <span>'core/config'</span>
<span>import</span> <span>{</span> warn<span>,</span> cached <span>}</span> <span>from</span> <span>'core/util/index'</span>
<span>import</span> <span>{</span> mark<span>,</span> measure <span>}</span> <span>from</span> <span>'core/util/perf'</span>

<span>import</span> Vue <span>from</span> <span>'./runtime/index'</span>
<span>import</span> <span>{</span> query <span>}</span> <span>from</span> <span>'./util/index'</span>
<span>import</span> <span>{</span> compileToFunctions <span>}</span> <span>from</span> <span>'./compiler/index'</span>
<span>import</span> <span>{</span> shouldDecodeNewlines<span>,</span> shouldDecodeNewlinesForHref <span>}</span> <span>from</span> <span>'./util/compat'</span>

<span>const</span> idToTemplate <span>=</span> <span>cached</span><span>(</span><span>id</span> <span>=></span> <span>{</span>
  <span>const</span> el <span>=</span> <span>query</span><span>(</span>id<span>)</span>
  <span>return</span> el <span>&amp;&amp;</span> el<span>.</span>innerHTML
<span>}</span><span>)</span>

<span>const</span> mount <span>=</span> <span>Vue</span><span>.</span>prototype<span>.</span>$mount
<span>Vue</span><span>.</span>prototype<span>.</span><span>$mount</span> <span>=</span> <span>function</span> <span>(</span>
  <span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  el <span>=</span> el <span>&amp;&amp;</span> <span>query</span><span>(</span>el<span>)</span>

  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>el <span>===</span> document<span>.</span>body <span>||</span> el <span>===</span> document<span>.</span>documentElement<span>)</span> <span>{</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
      <span><span>`</span><span>Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.</span><span>`</span></span>
    <span>)</span>
    <span>return</span> <span>this</span>
  <span>}</span>

  <span>const</span> options <span>=</span> <span>this</span><span>.</span>$options
  <span>// resolve template/el and convert to render function</span>
  <span>if</span> <span>(</span><span>!</span>options<span>.</span>render<span>)</span> <span>{</span>
    <span>let</span> template <span>=</span> options<span>.</span>template
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> template <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>template<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'#'</span><span>)</span> <span>{</span>
          template <span>=</span> <span>idToTemplate</span><span>(</span>template<span>)</span>
          <span>/* istanbul ignore if */</span>
          <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>template<span>)</span> <span>{</span>
            <span>warn</span><span>(</span>
              <span><span>`</span><span>Template element not found or is empty: </span><span><span>${</span>options<span>.</span>template<span>}</span></span><span>`</span></span><span>,</span>
              <span>this</span>
            <span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>template<span>.</span>nodeType<span>)</span> <span>{</span>
        template <span>=</span> template<span>.</span>innerHTML
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
          <span>warn</span><span>(</span><span>'invalid template option:'</span> <span>+</span> template<span>,</span> <span>this</span><span>)</span>
        <span>}</span>
        <span>return</span> <span>this</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>)</span> <span>{</span>
      template <span>=</span> <span>getOuterHTML</span><span>(</span>el<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
        <span>mark</span><span>(</span><span>'compile'</span><span>)</span>
      <span>}</span>

      <span>const</span> <span>{</span> render<span>,</span> staticRenderFns <span>}</span> <span>=</span> <span>compileToFunctions</span><span>(</span>template<span>,</span> <span>{</span>
        shouldDecodeNewlines<span>,</span>
        shouldDecodeNewlinesForHref<span>,</span>
        <span>delimiters</span><span>:</span> options<span>.</span>delimiters<span>,</span>
        <span>comments</span><span>:</span> options<span>.</span>comments
      <span>}</span><span>,</span> <span>this</span><span>)</span>
      options<span>.</span>render <span>=</span> render
      options<span>.</span>staticRenderFns <span>=</span> staticRenderFns

      <span>/* istanbul ignore if */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> config<span>.</span>performance <span>&amp;&amp;</span> mark<span>)</span> <span>{</span>
        <span>mark</span><span>(</span><span>'compile end'</span><span>)</span>
        <span>measure</span><span>(</span><span><span>`</span><span>vue </span><span><span>${</span><span>this</span><span>.</span>_name<span>}</span></span><span> compile</span><span>`</span></span><span>,</span> <span>'compile'</span><span>,</span> <span>'compile end'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>mount</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> el<span>,</span> hydrating<span>)</span>
<span>}</span>

<span>/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */</span>
<span>function</span> <span>getOuterHTML</span> <span>(</span><span><span>el</span><span>:</span> Element</span><span>)</span><span>:</span> string <span>{</span>
  <span>if</span> <span>(</span>el<span>.</span>outerHTML<span>)</span> <span>{</span>
    <span>return</span> el<span>.</span>outerHTML
  <span>}</span> <span>else</span> <span>{</span>
    <span>const</span> container <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>)</span>
    container<span>.</span><span>appendChild</span><span>(</span>el<span>.</span><span>cloneNode</span><span>(</span><span>true</span><span>)</span><span>)</span>
    <span>return</span> container<span>.</span>innerHTML
  <span>}</span>
<span>}</span>

Vue<span>.</span>compile <span>=</span> compileToFunctions

<span>export</span> <span>default</span> Vue

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么，当我们的代码执行 <code>import Vue from 'vue'</code> 的时候，就是从这个入口执行代码来初始化 Vue，
那么 Vue 到底是什么，它是怎么初始化的，我们来一探究竟。</p>
<h2 id="vue-的入口" tabindex="-1"> Vue 的入口</h2>
<p>在这个入口 JS 的上方我们可以找到 <code>Vue</code> 的来源：<code>import Vue from './runtime/index'</code>，我们先来看一下这块儿的实现，它定义在 <code>src/platforms/web/runtime/index.js</code> 中：</p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'core/index'</span>
<span>import</span> config <span>from</span> <span>'core/config'</span>
<span>import</span> <span>{</span> extend<span>,</span> noop <span>}</span> <span>from</span> <span>'shared/util'</span>
<span>import</span> <span>{</span> mountComponent <span>}</span> <span>from</span> <span>'core/instance/lifecycle'</span>
<span>import</span> <span>{</span> devtools<span>,</span> inBrowser<span>,</span> isChrome <span>}</span> <span>from</span> <span>'core/util/index'</span>

<span>import</span> <span>{</span>
  query<span>,</span>
  mustUseProp<span>,</span>
  isReservedTag<span>,</span>
  isReservedAttr<span>,</span>
  getTagNamespace<span>,</span>
  isUnknownElement
<span>}</span> <span>from</span> <span>'web/util/index'</span>

<span>import</span> <span>{</span> patch <span>}</span> <span>from</span> <span>'./patch'</span>
<span>import</span> platformDirectives <span>from</span> <span>'./directives/index'</span>
<span>import</span> platformComponents <span>from</span> <span>'./components/index'</span>

<span>// install platform specific utils</span>
Vue<span>.</span>config<span>.</span>mustUseProp <span>=</span> mustUseProp
Vue<span>.</span>config<span>.</span>isReservedTag <span>=</span> isReservedTag
Vue<span>.</span>config<span>.</span>isReservedAttr <span>=</span> isReservedAttr
Vue<span>.</span>config<span>.</span>getTagNamespace <span>=</span> getTagNamespace
Vue<span>.</span>config<span>.</span>isUnknownElement <span>=</span> isUnknownElement

<span>// install platform runtime directives &amp; components</span>
<span>extend</span><span>(</span>Vue<span>.</span>options<span>.</span>directives<span>,</span> platformDirectives<span>)</span>
<span>extend</span><span>(</span>Vue<span>.</span>options<span>.</span>components<span>,</span> platformComponents<span>)</span>

<span>// install platform patch function</span>
<span>Vue</span><span>.</span>prototype<span>.</span>__patch__ <span>=</span> inBrowser <span>?</span> patch <span>:</span> noop

<span>// public mount method</span>
<span>Vue</span><span>.</span>prototype<span>.</span><span>$mount</span> <span>=</span> <span>function</span> <span>(</span>
  <span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  el <span>=</span> el <span>&amp;&amp;</span> inBrowser <span>?</span> <span>query</span><span>(</span>el<span>)</span> <span>:</span> <span>undefined</span>
  <span>return</span> <span>mountComponent</span><span>(</span><span>this</span><span>,</span> el<span>,</span> hydrating<span>)</span>
<span>}</span>

<span>// ...</span>

<span>export</span> <span>default</span> Vue

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里关键的代码是 <code>import Vue from 'core/index'</code>，之后的逻辑都是对 Vue 这个对象做一些扩展，可以先不用看，我们来看一下真正初始化 Vue 的地方，在 <code>src/core/index.js</code> 中：</p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'./instance/index'</span>
<span>import</span> <span>{</span> initGlobalAPI <span>}</span> <span>from</span> <span>'./global-api/index'</span>
<span>import</span> <span>{</span> isServerRendering <span>}</span> <span>from</span> <span>'core/util/env'</span>
<span>import</span> <span>{</span> FunctionalRenderContext <span>}</span> <span>from</span> <span>'core/vdom/create-functional-component'</span>

<span>initGlobalAPI</span><span>(</span>Vue<span>)</span>

Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$isServer'</span><span>,</span> <span>{</span>
  <span>get</span><span>:</span> isServerRendering
<span>}</span><span>)</span>

Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$ssrContext'</span><span>,</span> <span>{</span>
  <span>get</span> <span>(</span><span>)</span> <span>{</span>
    <span>/* istanbul ignore next */</span>
    <span>return</span> <span>this</span><span>.</span>$vnode <span>&amp;&amp;</span> <span>this</span><span>.</span>$vnode<span>.</span>ssrContext
  <span>}</span>
<span>}</span><span>)</span>

<span>// expose FunctionalRenderContext for ssr runtime helper installation</span>
Object<span>.</span><span>defineProperty</span><span>(</span>Vue<span>,</span> <span>'FunctionalRenderContext'</span><span>,</span> <span>{</span>
  <span>value</span><span>:</span> FunctionalRenderContext
<span>}</span><span>)</span>

Vue<span>.</span>version <span>=</span> <span>'__VERSION__'</span>

<span>export</span> <span>default</span> Vue
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里有 2 处关键的代码，<code>import Vue from './instance/index'</code> 和 <code>initGlobalAPI(Vue)</code>，初始化全局 Vue API（我们稍后介绍），我们先来看第一部分，在 <code>src/core/instance/index.js</code> 中：</p>
<h3 id="vue-的定义" tabindex="-1"> Vue 的定义</h3>
<div><pre><code><span>import</span> <span>{</span> initMixin <span>}</span> <span>from</span> <span>'./init'</span>
<span>import</span> <span>{</span> stateMixin <span>}</span> <span>from</span> <span>'./state'</span>
<span>import</span> <span>{</span> renderMixin <span>}</span> <span>from</span> <span>'./render'</span>
<span>import</span> <span>{</span> eventsMixin <span>}</span> <span>from</span> <span>'./events'</span>
<span>import</span> <span>{</span> lifecycleMixin <span>}</span> <span>from</span> <span>'./lifecycle'</span>
<span>import</span> <span>{</span> warn <span>}</span> <span>from</span> <span>'../util/index'</span>

<span>function</span> <span>Vue</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    <span>!</span><span>(</span><span>this</span> <span>instanceof</span> <span>Vue</span><span>)</span>
  <span>)</span> <span>{</span>
    <span>warn</span><span>(</span><span>'Vue is a constructor and should be called with the `new` keyword'</span><span>)</span>
  <span>}</span>
  <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span>
<span>}</span>

<span>initMixin</span><span>(</span>Vue<span>)</span>
<span>stateMixin</span><span>(</span>Vue<span>)</span>
<span>eventsMixin</span><span>(</span>Vue<span>)</span>
<span>lifecycleMixin</span><span>(</span>Vue<span>)</span>
<span>renderMixin</span><span>(</span>Vue<span>)</span>

<span>export</span> <span>default</span> Vue
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在这里，我们终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 <code>new Vue</code> 去实例化它。</p>
<p>有些同学看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 <code>xxxMixin</code> 的函数调用，并把 <code>Vue</code> 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法（这里具体的细节会在之后的文章介绍，这里不展开），Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。</p>
<h3 id="initglobalapi" tabindex="-1"> <code>initGlobalAPI</code></h3>
<p>Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 <code>Vue</code> 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initGlobalAPI</span> <span>(</span><span><span>Vue</span><span>:</span> GlobalAPI</span><span>)</span> <span>{</span>
  <span>// config</span>
  <span>const</span> configDef <span>=</span> <span>{</span><span>}</span>
  configDef<span>.</span><span>get</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> config
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    configDef<span>.</span><span>set</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'Do not replace the Vue.config object, set individual fields instead.'</span>
      <span>)</span>
    <span>}</span>
  <span>}</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>Vue<span>,</span> <span>'config'</span><span>,</span> configDef<span>)</span>

  <span>// exposed util methods.</span>
  <span>// NOTE: these are not considered part of the public API - avoid relying on</span>
  <span>// them unless you are aware of the risk.</span>
  Vue<span>.</span>util <span>=</span> <span>{</span>
    warn<span>,</span>
    extend<span>,</span>
    mergeOptions<span>,</span>
    defineReactive
  <span>}</span>

  Vue<span>.</span>set <span>=</span> <span>set</span>
  Vue<span>.</span>delete <span>=</span> del
  Vue<span>.</span>nextTick <span>=</span> nextTick

  Vue<span>.</span>options <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>ASSET_TYPES</span><span>.</span><span>forEach</span><span>(</span><span>type</span> <span>=></span> <span>{</span>
    Vue<span>.</span>options<span>[</span>type <span>+</span> <span>'s'</span><span>]</span> <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>}</span><span>)</span>

  <span>// this is used to identify the "base" constructor to extend all plain-object</span>
  <span>// components with in Weex's multi-instance scenarios.</span>
  Vue<span>.</span>options<span>.</span>_base <span>=</span> Vue

  <span>extend</span><span>(</span>Vue<span>.</span>options<span>.</span>components<span>,</span> builtInComponents<span>)</span>

  <span>initUse</span><span>(</span>Vue<span>)</span>
  <span>initMixin</span><span>(</span>Vue<span>)</span>
  <span>initExtend</span><span>(</span>Vue<span>)</span>
  <span>initAssetRegisters</span><span>(</span>Vue<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里就是在 Vue 上扩展的一些全局方法的定义，Vue 官网中关于全局 API 都可以在这里找到，这里不会介绍细节，会在之后的章节我们具体介绍到某个 API 的时候会详细介绍。有一点要注意的是，<code>Vue.util</code> 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，Vue 的初始化过程基本介绍完毕。这一节的目的是让同学们对 Vue 是什么有一个直观的认识，它本质上就是一个用 Function 实现的 Class，然后它的原型 prototype 以及它本身都扩展了一系列的方法和属性，那么 Vue 能做什么，它是怎么做的，我们会在后面的章节一层层帮大家揭开 Vue 的神秘面纱。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">认识 Flow</title>
    <id>https://0808200.xyz/vue2/prepare/flow.html</id>
    <link href="https://0808200.xyz/vue2/prepare/flow.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="认识-flow" tabindex="-1"> 认识 Flow</h1>
<p><a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="noopener noreferrer">Flow</a> 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。</p>
<h2 id="为什么用-flow" tabindex="-1"> 为什么用 Flow</h2>
<p>JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。</p>
<p>类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。</p>
<p>项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。 Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。</p>
<h2 id="flow-的工作方式" tabindex="-1"> Flow 的工作方式</h2>
<p>通常类型检查分成 2 种方式：</p>
<ul>
<li>
<p><strong>类型推断</strong>：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。</p>
</li>
<li>
<p><strong>类型注释</strong>：事先注释好我们期待的类型，Flow 会基于这些注释来判断。</p>
</li>
</ul>
<h3 id="类型推断" tabindex="-1"> 类型推断</h3>
<p>它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。它不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的类型推断，Flow 最重要的特性之一。</p>
<p>通过一个简单例子说明一下：</p>
<div><pre><code><span>/*@flow*/</span>

<span>function</span> <span>split</span><span>(</span><span>str</span><span>)</span> <span>{</span>
  <span>return</span> str<span>.</span><span>split</span><span>(</span><span>' '</span><span>)</span>
<span>}</span>

<span>split</span><span>(</span><span>11</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Flow 检查上述代码后会报错，因为函数 <code>split</code>
期待的参数是字符串，而我们输入了数字。</p>
<h3 id="类型注释" tabindex="-1"> 类型注释</h3>
<p>如上所述，类型推断是 Flow 最有用的特性之一，不需要编写类型注释就能获取有用的反馈。但在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。</p>
<p>考虑如下代码：</p>
<div><pre><code><span>/*@flow*/</span>

<span>function</span> <span>add</span><span>(</span><span>x<span>,</span> y</span><span>)</span><span>{</span>
  <span>return</span> x <span>+</span> y
<span>}</span>

<span>add</span><span>(</span><span>'Hello'</span><span>,</span> <span>11</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Flow 检查上述代码时检查不出任何错误，因为从语法层面考虑， <code>+</code> 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 <code>add()</code> 的参数必须为数字。</p>
<p>在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 <code>:</code> 开头，可以在函数参数，返回值，变量声明中使用。</p>
<p>如果我们在上段代码中添加类型注释，就会变成如下：</p>
<div><pre><code><span>/*@flow*/</span>

<span>function</span> <span>add</span><span>(</span><span><span>x</span><span>:</span> number<span>,</span> <span>y</span><span>:</span> number</span><span>)</span><span>:</span> number <span>{</span>
  <span>return</span> x <span>+</span> y
<span>}</span>

<span>add</span><span>(</span><span>'Hello'</span><span>,</span> <span>11</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。</p>
<p>上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释。</p>
<h4 id="数组" tabindex="-1"> 数组</h4>
<div><pre><code><span>/*@flow*/</span>

<span>var</span> <span>arr</span><span>:</span> Array<span>&lt;</span>number<span>></span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>

arr<span>.</span><span>push</span><span>(</span><span>'Hello'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>数组类型注释的格式是 <code>Array&lt;T&gt;</code>，<code>T</code> 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。</p>
<h4 id="类和对象" tabindex="-1"> 类和对象</h4>
<div><pre><code><span>/*@flow*/</span>

<span>class</span> <span>Bar</span> <span>{</span>
  <span>x</span><span>:</span> string<span>;</span>           <span>// x 是字符串</span>
  <span>y</span><span>:</span> string <span>|</span> number<span>;</span>  <span>// y 可以是字符串或者数字</span>
  <span>z</span><span>:</span> boolean<span>;</span>

  <span>constructor</span><span>(</span><span><span>x</span><span>:</span> string<span>,</span> <span>y</span><span>:</span> string <span>|</span> number</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>x <span>=</span> x
    <span>this</span><span>.</span>y <span>=</span> y
    <span>this</span><span>.</span>z <span>=</span> <span>false</span>
  <span>}</span>
<span>}</span>

<span>var</span> <span>bar</span><span>:</span> Bar <span>=</span> <span>new</span> <span>Bar</span><span>(</span><span>'hello'</span><span>,</span> <span>4</span><span>)</span>

<span>var</span> <span>obj</span><span>:</span> <span>{</span> <span>a</span><span>:</span> string<span>,</span> <span>b</span><span>:</span> number<span>,</span> <span>c</span><span>:</span> Array<span>&lt;</span>string<span>></span><span>,</span> <span>d</span><span>:</span> Bar <span>}</span> <span>=</span> <span>{</span>
  <span>a</span><span>:</span> <span>'hello'</span><span>,</span>
  <span>b</span><span>:</span> <span>11</span><span>,</span>
  <span>c</span><span>:</span> <span>[</span><span>'hello'</span><span>,</span> <span>'world'</span><span>]</span><span>,</span>
  <span>d</span><span>:</span> <span>new</span> <span>Bar</span><span>(</span><span>'hello'</span><span>,</span> <span>3</span><span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是，属性 <code>y</code> 的类型中间用 <code>|</code> 做间隔，表示 <code>y</code> 的类型即可以是字符串也可以是数字。</p>
<p>对象的注释类型类似于类，需要指定对象属性的类型。</p>
<h4 id="null" tabindex="-1"> Null</h4>
<p>若想任意类型 <code>T</code> 可以为 <code>null</code> 或者 <code>undefined</code>，只需类似如下写成 <code>?T</code> 的格式即可。</p>
<div><pre><code><span>/*@flow*/</span>

<span>var</span> <span>foo</span><span>:</span> <span>?</span>string <span>=</span> <span>null</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>此时，<code>foo</code> 可以为字符串，也可以为 <code>null</code>。</p>
<p>目前我们只列举了 Flow 的一些常见的类型注释。如果想了解所有类型注释，请移步 Flow 的<a href="https://flow.org/en/docs/types/" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
<h2 id="flow-在-vue-js-源码中的应用" tabindex="-1"> Flow 在 Vue.js 源码中的应用</h2>
<p>有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 <code>libdef</code> 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。</p>
<p>在 Vue.js 的主目录下有 <code>.flowconfig</code> 文件， 它是 Flow 的配置文件，感兴趣的同学可以看<a href="https://flow.org/en/docs/config/" target="_blank" rel="noopener noreferrer">官方文档</a>。这其中的 <code>[libs]</code> 部分用来描述包含指定库定义的目录，默认是名为 <code>flow-typed</code> 的目录。</p>
<p>这里 <code>[libs]</code> 配置的是 <code>flow</code>，表示指定的库定义都在 <code>flow</code> 文件夹内。我们打开这个目录，会发现文件如下：</p>
<div><pre><code>flow
├── compiler.js        # 编译相关
├── component.js       # 组件数据结构
├── global-api.js      # Global API 结构
├── modules.js         # 第三方库定义
├── options.js         # 选项相关
├── ssr.js             # 服务端渲染相关
├── vnode.js           # 虚拟 node 相关
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过对 Flow 的认识，有助于我们阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。类似 Flow 的工具还有如 TypeScript，感兴趣的同学也可以自行去了解一下。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">准备工作</title>
    <id>https://0808200.xyz/vue2/prepare/</id>
    <link href="https://0808200.xyz/vue2/prepare/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="准备工作" tabindex="-1"> 准备工作</h1>
<p>那么从这一章开始我们即将分析 Vue 的源码，我们将会介绍一些前置知识如 flow、源码目录、构建方式、编译入口等。</p>
<p>除此之外，我希望你已经用过 Vue 做过 2 个以上的实际项目，对 Vue 的思想有了一定的了解，对绝大部分的 API 都已经有使用。同时，我也要求你有一定的原生 JavaScript 的功底，并对代码调试有一定的了解。</p>
<p>如果你具备了以上条件，并且对 Vue 的实现原理很感兴趣，那么就可以开始这门课程的学习了，我将会为你打开 Vue 的底层世界大门，对它的实现细节一探究竟。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">组件更新</title>
    <id>https://0808200.xyz/vue2/reactive/component-update.html</id>
    <link href="https://0808200.xyz/vue2/reactive/component-update.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="组件更新" tabindex="-1"> 组件更新</h1>
<p>在组件化章节，我们介绍了 Vue 的组件化实现过程，不过我们只讲了 Vue 组件的创建过程，并没有涉及到组件数据发生变化，更新组件的过程。而通过我们这一章对数据响应式原理的分析，了解到当数据发生变化的时候，会触发渲染 <code>watcher</code> 的回调函数，进而执行组件的更新过程，接下来我们来详细分析这一过程。</p>
<div><pre><code><span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
<span>}</span>
<span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> updateComponent<span>,</span> noop<span>,</span> <span>{</span>
  <span>before</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>vm<span>.</span>_isMounted<span>)</span> <span>{</span>
      <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeUpdate'</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>,</span> <span>true</span> <span>/* isRenderWatcher */</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>组件的更新还是调用了 <code>vm._update</code> 方法，我们再回顾一下这个方法，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>_update</span> <span>=</span> <span>function</span> <span>(</span><span><span>vnode</span><span>:</span> VNode<span>,</span> hydrating<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>// ...</span>
  <span>const</span> prevVnode <span>=</span> vm<span>.</span>_vnode
  <span>if</span> <span>(</span><span>!</span>prevVnode<span>)</span> <span>{</span>
     <span>// initial render</span>
    vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>vm<span>.</span>$el<span>,</span> vnode<span>,</span> hydrating<span>,</span> <span>false</span> <span>/* removeOnly */</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// updates</span>
    vm<span>.</span>$el <span>=</span> vm<span>.</span><span>__patch__</span><span>(</span>prevVnode<span>,</span> vnode<span>)</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>组件更新的过程，会执行 <code>vm.$el = vm.__patch__(prevVnode, vnode)</code>，它仍然会调用 <code>patch</code> 函数，在 <code>src/core/vdom/patch.js</code> 中定义：</p>
<div><pre><code><span>return</span> <span>function</span> <span>patch</span> <span>(</span><span>oldVnode<span>,</span> vnode<span>,</span> hydrating<span>,</span> removeOnly</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>)</span><span>)</span> <span>invokeDestroyHook</span><span>(</span>oldVnode<span>)</span>
    <span>return</span>
  <span>}</span>

  <span>let</span> isInitialPatch <span>=</span> <span>false</span>
  <span>const</span> insertedVnodeQueue <span>=</span> <span>[</span><span>]</span>

  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldVnode<span>)</span><span>)</span> <span>{</span>
    <span>// empty mount (likely as component), create new root element</span>
    isInitialPatch <span>=</span> <span>true</span>
    <span>createElm</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>const</span> isRealElement <span>=</span> <span>isDef</span><span>(</span>oldVnode<span>.</span>nodeType<span>)</span>
    <span>if</span> <span>(</span><span>!</span>isRealElement <span>&amp;&amp;</span> <span>sameVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span><span>)</span> <span>{</span>
      <span>// patch existing root node</span>
      <span>patchVnode</span><span>(</span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>,</span> removeOnly<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>isRealElement<span>)</span> <span>{</span>
         <span>// ...</span>
      <span>}</span>

      <span>// replacing existing element</span>
      <span>const</span> oldElm <span>=</span> oldVnode<span>.</span>elm
      <span>const</span> parentElm <span>=</span> nodeOps<span>.</span><span>parentNode</span><span>(</span>oldElm<span>)</span>

      <span>// create new node</span>
      <span>createElm</span><span>(</span>
        vnode<span>,</span>
        insertedVnodeQueue<span>,</span>
        <span>// extremely rare edge case: do not insert if old element is in a</span>
        <span>// leaving transition. Only happens when combining transition +</span>
        <span>// keep-alive + HOCs. (#4590)</span>
        oldElm<span>.</span>_leaveCb <span>?</span> <span>null</span> <span>:</span> parentElm<span>,</span>
        nodeOps<span>.</span><span>nextSibling</span><span>(</span>oldElm<span>)</span>
      <span>)</span>

      <span>// update parent placeholder node element, recursively</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>parent<span>)</span><span>)</span> <span>{</span>
        <span>let</span> ancestor <span>=</span> vnode<span>.</span>parent
        <span>const</span> patchable <span>=</span> <span>isPatchable</span><span>(</span>vnode<span>)</span>
        <span>while</span> <span>(</span>ancestor<span>)</span> <span>{</span>
          <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>destroy<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            cbs<span>.</span>destroy<span>[</span>i<span>]</span><span>(</span>ancestor<span>)</span>
          <span>}</span>
          ancestor<span>.</span>elm <span>=</span> vnode<span>.</span>elm
          <span>if</span> <span>(</span>patchable<span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>create<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
              cbs<span>.</span>create<span>[</span>i<span>]</span><span>(</span>emptyNode<span>,</span> ancestor<span>)</span>
            <span>}</span>
            <span>// #6513</span>
            <span>// invoke insert hooks that may have been merged by create hooks.</span>
            <span>// e.g. for directives that uses the "inserted" hook.</span>
            <span>const</span> insert <span>=</span> ancestor<span>.</span>data<span>.</span>hook<span>.</span>insert
            <span>if</span> <span>(</span>insert<span>.</span>merged<span>)</span> <span>{</span>
              <span>// start at index 1 to avoid re-invoking component mounted hook</span>
              <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> insert<span>.</span>fns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                insert<span>.</span>fns<span>[</span>i<span>]</span><span>(</span><span>)</span>
              <span>}</span>
            <span>}</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>registerRef</span><span>(</span>ancestor<span>)</span>
          <span>}</span>
          ancestor <span>=</span> ancestor<span>.</span>parent
        <span>}</span>
      <span>}</span>

      <span>// destroy old node</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>parentElm<span>)</span><span>)</span> <span>{</span>
        <span>removeVnodes</span><span>(</span>parentElm<span>,</span> <span>[</span>oldVnode<span>]</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
        <span>invokeDestroyHook</span><span>(</span>oldVnode<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>invokeInsertHook</span><span>(</span>vnode<span>,</span> insertedVnodeQueue<span>,</span> isInitialPatch<span>)</span>
  <span>return</span> vnode<span>.</span>elm
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里执行 <code>patch</code> 的逻辑和首次渲染是不一样的，因为 <code>oldVnode</code> 不为空，并且它和 <code>vnode</code> 都是 VNode 类型，接下来会通过 <code>sameVNode(oldVnode, vnode)</code> 判断它们是否是相同的 VNode 来决定走不同的更新逻辑：</p>
<div><pre><code><span>function</span> <span>sameVnode</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    a<span>.</span>key <span>===</span> b<span>.</span>key <span>&amp;&amp;</span> <span>(</span>
      <span>(</span>
        a<span>.</span>tag <span>===</span> b<span>.</span>tag <span>&amp;&amp;</span>
        a<span>.</span>isComment <span>===</span> b<span>.</span>isComment <span>&amp;&amp;</span>
        <span>isDef</span><span>(</span>a<span>.</span>data<span>)</span> <span>===</span> <span>isDef</span><span>(</span>b<span>.</span>data<span>)</span> <span>&amp;&amp;</span>
        <span>sameInputType</span><span>(</span>a<span>,</span> b<span>)</span>
      <span>)</span> <span>||</span> <span>(</span>
        <span>isTrue</span><span>(</span>a<span>.</span>isAsyncPlaceholder<span>)</span> <span>&amp;&amp;</span>
        a<span>.</span>asyncFactory <span>===</span> b<span>.</span>asyncFactory <span>&amp;&amp;</span>
        <span>isUndef</span><span>(</span>b<span>.</span>asyncFactory<span>.</span>error<span>)</span>
      <span>)</span>
    <span>)</span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>sameVnode</code> 的逻辑非常简单，如果两个 <code>vnode</code> 的 <code>key</code> 不相等，则是不同的；否则继续判断对于同步组件，则判断 <code>isComment</code>、<code>data</code>、<code>input</code> 类型等是否相同，对于异步组件，则判断 <code>asyncFactory</code> 是否相同。</p>
<p>所以根据新旧 <code>vnode</code> 是否为 <code>sameVnode</code>，会走到不同的更新逻辑，我们先来说一下不同的情况。</p>
<h2 id="新旧节点不同" tabindex="-1"> 新旧节点不同</h2>
<p>如果新旧 <code>vnode</code> 不同，那么更新的逻辑非常简单，它本质上是要替换已存在的节点，大致分为 3 步</p>
<ul>
<li>创建新节点</li>
</ul>
<div><pre><code><span>const</span> oldElm <span>=</span> oldVnode<span>.</span>elm
<span>const</span> parentElm <span>=</span> nodeOps<span>.</span><span>parentNode</span><span>(</span>oldElm<span>)</span>
<span>// create new node</span>
<span>createElm</span><span>(</span>
  vnode<span>,</span>
  insertedVnodeQueue<span>,</span>
  <span>// extremely rare edge case: do not insert if old element is in a</span>
  <span>// leaving transition. Only happens when combining  transition +</span>
  <span>// keep-alive + HOCs. (#4590)</span>
  oldElm<span>.</span>_leaveCb <span>?</span> <span>null</span> <span>:</span> parentElm<span>,</span>
  nodeOps<span>.</span><span>nextSibling</span><span>(</span>oldElm<span>)</span>
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以当前旧节点为参考节点，创建新的节点，并插入到 DOM 中，<code>createElm</code> 的逻辑我们之前分析过。</p>
<ul>
<li>更新父的占位符节点</li>
</ul>
<div><pre><code><span>// update parent placeholder node element, recursively</span>
<span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>parent<span>)</span><span>)</span> <span>{</span>
  <span>let</span> ancestor <span>=</span> vnode<span>.</span>parent
  <span>const</span> patchable <span>=</span> <span>isPatchable</span><span>(</span>vnode<span>)</span>
  <span>while</span> <span>(</span>ancestor<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>destroy<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
      cbs<span>.</span>destroy<span>[</span>i<span>]</span><span>(</span>ancestor<span>)</span>
    <span>}</span>
    ancestor<span>.</span>elm <span>=</span> vnode<span>.</span>elm
    <span>if</span> <span>(</span>patchable<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>create<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
        cbs<span>.</span>create<span>[</span>i<span>]</span><span>(</span>emptyNode<span>,</span> ancestor<span>)</span>
      <span>}</span>
      <span>// #6513</span>
      <span>// invoke insert hooks that may have been merged by create hooks.</span>
      <span>// e.g. for directives that uses the "inserted" hook.</span>
      <span>const</span> insert <span>=</span> ancestor<span>.</span>data<span>.</span>hook<span>.</span>insert
      <span>if</span> <span>(</span>insert<span>.</span>merged<span>)</span> <span>{</span>
        <span>// start at index 1 to avoid re-invoking component mounted hook</span>
        <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> insert<span>.</span>fns<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
          insert<span>.</span>fns<span>[</span>i<span>]</span><span>(</span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>registerRef</span><span>(</span>ancestor<span>)</span>
    <span>}</span>
    ancestor <span>=</span> ancestor<span>.</span>parent
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们只关注主要逻辑即可，找到当前 <code>vnode</code> 的父的占位符节点，先执行各个 <code>module</code> 的 <code>destroy</code> 的钩子函数，如果当前占位符是一个可挂载的节点，则执行 <code>module</code> 的 <code>create</code> 钩子函数。对于这些钩子函数的作用，在之后的章节会详细介绍。</p>
<ul>
<li>删除旧节点</li>
</ul>
<div><pre><code><span>// destroy old node</span>
<span>if</span> <span>(</span><span>isDef</span><span>(</span>parentElm<span>)</span><span>)</span> <span>{</span>
  <span>removeVnodes</span><span>(</span>parentElm<span>,</span> <span>[</span>oldVnode<span>]</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
  <span>invokeDestroyHook</span><span>(</span>oldVnode<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>把 <code>oldVnode</code> 从当前 DOM 树中删除，如果父节点存在，则执行 <code>removeVnodes</code> 方法：</p>
<div><pre><code><span>function</span> <span>removeVnodes</span> <span>(</span><span>parentElm<span>,</span> vnodes<span>,</span> startIdx<span>,</span> endIdx</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>;</span> startIdx <span>&lt;=</span> endIdx<span>;</span> <span>++</span>startIdx<span>)</span> <span>{</span>
    <span>const</span> ch <span>=</span> vnodes<span>[</span>startIdx<span>]</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>ch<span>.</span>tag<span>)</span><span>)</span> <span>{</span>
        <span>removeAndInvokeRemoveHook</span><span>(</span>ch<span>)</span>
        <span>invokeDestroyHook</span><span>(</span>ch<span>)</span>
      <span>}</span> <span>else</span> <span>{</span> <span>// Text node</span>
        <span>removeNode</span><span>(</span>ch<span>.</span>elm<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>removeAndInvokeRemoveHook</span> <span>(</span><span>vnode<span>,</span> rm</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>rm<span>)</span> <span>||</span> <span>isDef</span><span>(</span>vnode<span>.</span>data<span>)</span><span>)</span> <span>{</span>
    <span>let</span> i
    <span>const</span> listeners <span>=</span> cbs<span>.</span>remove<span>.</span>length <span>+</span> <span>1</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>rm<span>)</span><span>)</span> <span>{</span>
      <span>// we have a recursively passed down rm callback</span>
      <span>// increase the listeners count</span>
      rm<span>.</span>listeners <span>+=</span> listeners
    <span>}</span> <span>else</span> <span>{</span>
      <span>// directly removing</span>
      rm <span>=</span> <span>createRmCb</span><span>(</span>vnode<span>.</span>elm<span>,</span> listeners<span>)</span>
    <span>}</span>
    <span>// recursively invoke hooks on child component root node</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> vnode<span>.</span>componentInstance<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>_vnode<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i<span>.</span>data<span>)</span><span>)</span> <span>{</span>
      <span>removeAndInvokeRemoveHook</span><span>(</span>i<span>,</span> rm<span>)</span>
    <span>}</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>remove<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
      cbs<span>.</span>remove<span>[</span>i<span>]</span><span>(</span>vnode<span>,</span> rm<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> vnode<span>.</span>data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>remove<span>)</span><span>)</span> <span>{</span>
      <span>i</span><span>(</span>vnode<span>,</span> rm<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>rm</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>removeNode</span><span>(</span>vnode<span>.</span>elm<span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>invokeDestroyHook</span> <span>(</span><span>vnode</span><span>)</span> <span>{</span>
  <span>let</span> i<span>,</span> j
  <span>const</span> data <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>destroy<span>)</span><span>)</span> <span>i</span><span>(</span>vnode<span>)</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>destroy<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> cbs<span>.</span>destroy<span>[</span>i<span>]</span><span>(</span>vnode<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> vnode<span>.</span>children<span>)</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span>j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> vnode<span>.</span>children<span>.</span>length<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
      <span>invokeDestroyHook</span><span>(</span>vnode<span>.</span>children<span>[</span>j<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>删除节点逻辑很简单，就是遍历待删除的 <code>vnodes</code> 做删除，其中 <code>removeAndInvokeRemoveHook</code>  的作用是从 DOM 中移除节点并执行 <code>module</code> 的 <code>remove</code> 钩子函数，并对它的子节点递归调用 <code>removeAndInvokeRemoveHook</code> 函数；<code>invokeDestroyHook</code> 是执行 <code>module</code> 的 <code>destory</code> 钩子函数以及 <code>vnode</code> 的 <code>destory</code> 钩子函数，并对它的子 <code>vnode</code> 递归调用 <code>invokeDestroyHook</code> 函数；<code>removeNode</code> 就是调用平台的 DOM API 去把真正的 DOM 节点移除。</p>
<p>在之前介绍组件生命周期的时候提到 <code>beforeDestroy &amp; destroyed</code> 这两个生命周期钩子函数，它们就是在执行 <code>invokeDestroyHook</code> 过程中，执行了 <code>vnode</code> 的 <code>destory</code> 钩子函数，它的定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>destroy</span> <span>(</span><span><span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> componentInstance <span>}</span> <span>=</span> vnode
    <span>if</span> <span>(</span><span>!</span>componentInstance<span>.</span>_isDestroyed<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>vnode<span>.</span>data<span>.</span>keepAlive<span>)</span> <span>{</span>
        componentInstance<span>.</span><span>$destroy</span><span>(</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>deactivateChildComponent</span><span>(</span>componentInstance<span>,</span> <span>true</span> <span>/* direct */</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当组件并不是 <code>keepAlive</code> 的时候，会执行 <code>componentInstance.$destroy()</code> 方法，然后就会执行 <code>beforeDestroy &amp; destroyed</code> 两个钩子函数。</p>
<h2 id="新旧节点相同" tabindex="-1"> 新旧节点相同</h2>
<p>对于新旧节点不同的情况，这种创建新节点 -&gt; 更新占位符节点 -&gt; 删除旧节点的逻辑是很容易理解的。还有一种组件 <code>vnode</code> 的更新情况是新旧节点相同，它会调用 <code>patchVNode</code> 方法，它的定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<div><pre><code><span>function</span> <span>patchVnode</span> <span>(</span><span>oldVnode<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>,</span> removeOnly</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>oldVnode <span>===</span> vnode<span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> elm <span>=</span> vnode<span>.</span>elm <span>=</span> oldVnode<span>.</span>elm

  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>oldVnode<span>.</span>isAsyncPlaceholder<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>vnode<span>.</span>asyncFactory<span>.</span>resolved<span>)</span><span>)</span> <span>{</span>
      <span>hydrate</span><span>(</span>oldVnode<span>.</span>elm<span>,</span> vnode<span>,</span> insertedVnodeQueue<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      vnode<span>.</span>isAsyncPlaceholder <span>=</span> <span>true</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>

  <span>// reuse element for static trees.</span>
  <span>// note we only do this if the vnode is cloned -</span>
  <span>// if the new node is not cloned it means the render functions have been</span>
  <span>// reset by the hot-reload-api and we need to do a proper re-render.</span>
  <span>if</span> <span>(</span><span>isTrue</span><span>(</span>vnode<span>.</span>isStatic<span>)</span> <span>&amp;&amp;</span>
    <span>isTrue</span><span>(</span>oldVnode<span>.</span>isStatic<span>)</span> <span>&amp;&amp;</span>
    vnode<span>.</span>key <span>===</span> oldVnode<span>.</span>key <span>&amp;&amp;</span>
    <span>(</span><span>isTrue</span><span>(</span>vnode<span>.</span>isCloned<span>)</span> <span>||</span> <span>isTrue</span><span>(</span>vnode<span>.</span>isOnce<span>)</span><span>)</span>
  <span>)</span> <span>{</span>
    vnode<span>.</span>componentInstance <span>=</span> oldVnode<span>.</span>componentInstance
    <span>return</span>
  <span>}</span>

  <span>let</span> i
  <span>const</span> data <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>prepatch<span>)</span><span>)</span> <span>{</span>
    <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
  <span>}</span>

  <span>const</span> oldCh <span>=</span> oldVnode<span>.</span>children
  <span>const</span> ch <span>=</span> vnode<span>.</span>children
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isPatchable</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>update<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> cbs<span>.</span>update<span>[</span>i<span>]</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>update<span>)</span><span>)</span> <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>isUndef</span><span>(</span>vnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>oldCh <span>!==</span> ch<span>)</span> <span>updateChildren</span><span>(</span>elm<span>,</span> oldCh<span>,</span> ch<span>,</span> insertedVnodeQueue<span>,</span> removeOnly<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>text<span>)</span><span>)</span> nodeOps<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> <span>''</span><span>)</span>
      <span>addVnodes</span><span>(</span>elm<span>,</span> <span>null</span><span>,</span> ch<span>,</span> <span>0</span><span>,</span> ch<span>.</span>length <span>-</span> <span>1</span><span>,</span> insertedVnodeQueue<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span><span>)</span> <span>{</span>
      <span>removeVnodes</span><span>(</span>elm<span>,</span> oldCh<span>,</span> <span>0</span><span>,</span> oldCh<span>.</span>length <span>-</span> <span>1</span><span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>
      nodeOps<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> <span>''</span><span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>oldVnode<span>.</span>text <span>!==</span> vnode<span>.</span>text<span>)</span> <span>{</span>
    nodeOps<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> vnode<span>.</span>text<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>postpatch<span>)</span><span>)</span> <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>patchVnode</code> 的作用就是把新的 <code>vnode</code> <code>patch</code> 到旧的 <code>vnode</code> 上，这里我们只关注关键的核心逻辑，我把它拆成四步骤：</p>
<ul>
<li>执行 <code>prepatch</code> 钩子函数</li>
</ul>
<div><pre><code><span>let</span> i
<span>const</span> data <span>=</span> vnode<span>.</span>data
<span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>prepatch<span>)</span><span>)</span> <span>{</span>
  <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>当更新的 <code>vnode</code> 是一个组件 <code>vnode</code> 的时候，会执行 <code>prepatch</code> 的方法，它的定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>const</span> componentVNodeHooks <span>=</span> <span>{</span>
  <span>prepatch</span> <span>(</span><span><span>oldVnode</span><span>:</span> MountedComponentVNode<span>,</span> <span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
    <span>const</span> options <span>=</span> vnode<span>.</span>componentOptions
    <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> oldVnode<span>.</span>componentInstance
    <span>updateChildComponent</span><span>(</span>
      child<span>,</span>
      options<span>.</span>propsData<span>,</span> <span>// updated props</span>
      options<span>.</span>listeners<span>,</span> <span>// updated listeners</span>
      vnode<span>,</span> <span>// new parent vnode</span>
      options<span>.</span>children <span>// new children</span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>prepatch</code> 方法就是拿到新的 <code>vnode</code> 的组件配置以及组件实例，去执行 <code>updateChildComponent</code> 方法，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>updateChildComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>propsData</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>listeners</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>parentVnode</span><span>:</span> MountedComponentVNode<span>,</span>
  <span>renderChildren</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span></span>
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    isUpdatingChildComponent <span>=</span> <span>true</span>
  <span>}</span>

  <span>// determine whether component has slot children</span>
  <span>// we need to do this before overwriting $options._renderChildren</span>
  <span>const</span> hasChildren <span>=</span> <span>!</span><span>!</span><span>(</span>
    renderChildren <span>||</span>               <span>// has new static slots</span>
    vm<span>.</span>$options<span>.</span>_renderChildren <span>||</span>  <span>// has old static slots</span>
    parentVnode<span>.</span>data<span>.</span>scopedSlots <span>||</span> <span>// has new scoped slots</span>
    vm<span>.</span>$scopedSlots <span>!==</span> emptyObject <span>// has old scoped slots</span>
  <span>)</span>

  vm<span>.</span>$options<span>.</span>_parentVnode <span>=</span> parentVnode
  vm<span>.</span>$vnode <span>=</span> parentVnode <span>// update vm's placeholder node without re-render</span>

  <span>if</span> <span>(</span>vm<span>.</span>_vnode<span>)</span> <span>{</span> <span>// update child tree's parent</span>
    vm<span>.</span>_vnode<span>.</span>parent <span>=</span> parentVnode
  <span>}</span>
  vm<span>.</span>$options<span>.</span>_renderChildren <span>=</span> renderChildren

  <span>// update $attrs and $listeners hash</span>
  <span>// these are also reactive so they may trigger child update if the child</span>
  <span>// used them during render</span>
  vm<span>.</span>$attrs <span>=</span> parentVnode<span>.</span>data<span>.</span>attrs <span>||</span> emptyObject
  vm<span>.</span>$listeners <span>=</span> listeners <span>||</span> emptyObject

  <span>// update props</span>
  <span>if</span> <span>(</span>propsData <span>&amp;&amp;</span> vm<span>.</span>$options<span>.</span>props<span>)</span> <span>{</span>
    <span>toggleObserving</span><span>(</span><span>false</span><span>)</span>
    <span>const</span> props <span>=</span> vm<span>.</span>_props
    <span>const</span> propKeys <span>=</span> vm<span>.</span>$options<span>.</span>_propKeys <span>||</span> <span>[</span><span>]</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> propKeys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>const</span> key <span>=</span> propKeys<span>[</span>i<span>]</span>
      <span>const</span> <span>propOptions</span><span>:</span> any <span>=</span> vm<span>.</span>$options<span>.</span>props <span>// wtf flow?</span>
      props<span>[</span>key<span>]</span> <span>=</span> <span>validateProp</span><span>(</span>key<span>,</span> propOptions<span>,</span> propsData<span>,</span> vm<span>)</span>
    <span>}</span>
    <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
    <span>// keep a copy of raw propsData</span>
    vm<span>.</span>$options<span>.</span>propsData <span>=</span> propsData
  <span>}</span>

  <span>// update listeners</span>
  listeners <span>=</span> listeners <span>||</span> emptyObject
  <span>const</span> oldListeners <span>=</span> vm<span>.</span>$options<span>.</span>_parentListeners
  vm<span>.</span>$options<span>.</span>_parentListeners <span>=</span> listeners
  <span>updateComponentListeners</span><span>(</span>vm<span>,</span> listeners<span>,</span> oldListeners<span>)</span>

  <span>// resolve slots + force update if has children</span>
  <span>if</span> <span>(</span>hasChildren<span>)</span> <span>{</span>
    vm<span>.</span>$slots <span>=</span> <span>resolveSlots</span><span>(</span>renderChildren<span>,</span> parentVnode<span>.</span>context<span>)</span>
    vm<span>.</span><span>$forceUpdate</span><span>(</span><span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    isUpdatingChildComponent <span>=</span> <span>false</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>updateChildComponent</code> 的逻辑也非常简单，由于更新了 <code>vnode</code>，那么 <code>vnode</code> 对应的实例 <code>vm</code> 的一系列属性也会发生变化，包括占位符 <code>vm.$vnode</code> 的更新、<code>slot</code> 的更新，<code>listeners</code> 的更新，<code>props</code> 的更新等等。</p>
<ul>
<li>执行 <code>update</code> 钩子函数</li>
</ul>
<div><pre><code><span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isPatchable</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>update<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> cbs<span>.</span>update<span>[</span>i<span>]</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>update<span>)</span><span>)</span> <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>回到 <code>patchVNode</code> 函数，在执行完新的 <code>vnode</code> 的 <code>prepatch</code> 钩子函数，会执行所有 <code>module</code> 的 <code>update</code> 钩子函数以及用户自定义 <code>update</code> 钩子函数，对于 <code>module</code> 的钩子函数，之后我们会有具体的章节针对一些具体的 case 分析。</p>
<ul>
<li>完成 <code>patch</code> 过程</li>
</ul>
<div><pre><code><span>const</span> oldCh <span>=</span> oldVnode<span>.</span>children
<span>const</span> ch <span>=</span> vnode<span>.</span>children
<span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isPatchable</span><span>(</span>vnode<span>)</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cbs<span>.</span>update<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> cbs<span>.</span>update<span>[</span>i<span>]</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>update<span>)</span><span>)</span> <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
<span>}</span>
<span>if</span> <span>(</span><span>isUndef</span><span>(</span>vnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>oldCh <span>!==</span> ch<span>)</span> <span>updateChildren</span><span>(</span>elm<span>,</span> oldCh<span>,</span> ch<span>,</span> insertedVnodeQueue<span>,</span> removeOnly<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>ch<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>text<span>)</span><span>)</span> nodeOps<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> <span>''</span><span>)</span>
    <span>addVnodes</span><span>(</span>elm<span>,</span> <span>null</span><span>,</span> ch<span>,</span> <span>0</span><span>,</span> ch<span>.</span>length <span>-</span> <span>1</span><span>,</span> insertedVnodeQueue<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldCh<span>)</span><span>)</span> <span>{</span>
    <span>removeVnodes</span><span>(</span>elm<span>,</span> oldCh<span>,</span> <span>0</span><span>,</span> oldCh<span>.</span>length <span>-</span> <span>1</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isDef</span><span>(</span>oldVnode<span>.</span>text<span>)</span><span>)</span> <span>{</span>
    nodeOps<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> <span>''</span><span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span>oldVnode<span>.</span>text <span>!==</span> vnode<span>.</span>text<span>)</span> <span>{</span>
  nodeOps<span>.</span><span>setTextContent</span><span>(</span>elm<span>,</span> vnode<span>.</span>text<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果 <code>vnode</code> 是个文本节点且新旧文本不相同，则直接替换文本内容。如果不是文本节点，则判断它们的子节点，并分了几种情况处理：</p>
<ol>
<li><code>oldCh</code> 与 <code>ch</code> 都存在且不相同时，使用 <code>updateChildren</code> 函数来更新子节点，这个后面重点讲。</li>
</ol>
<p>2.如果只有 <code>ch</code> 存在，表示旧节点不需要了。如果旧的节点是文本节点则先将节点的文本清除，然后通过 <code>addVnodes</code> 将 <code>ch</code> 批量插入到新节点 <code>elm</code> 下。</p>
<p>3.如果只有 <code>oldCh</code> 存在，表示更新的是空节点，则需要将旧的节点通过 <code>removeVnodes</code> 全部清除。</p>
<p>4.当只有旧节点是文本节点的时候，则清除其节点文本内容。</p>
<ul>
<li>执行 <code>postpatch</code> 钩子函数</li>
</ul>
<div><pre><code><span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>postpatch<span>)</span><span>)</span> <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>再执行完 <code>patch</code> 过程后，会执行 <code>postpatch</code> 钩子函数，它是组件自定义的钩子函数，有则执行。</p>
<p>那么在整个 <code>pathVnode</code> 过程中，最复杂的就是 <code>updateChildren</code> 方法了，下面我们来单独介绍它。</p>
<h2 id="updatechildren" tabindex="-1"> updateChildren</h2>
<div><pre><code><span>function</span> <span>updateChildren</span> <span>(</span><span>parentElm<span>,</span> oldCh<span>,</span> newCh<span>,</span> insertedVnodeQueue<span>,</span> removeOnly</span><span>)</span> <span>{</span>
  <span>let</span> oldStartIdx <span>=</span> <span>0</span>
  <span>let</span> newStartIdx <span>=</span> <span>0</span>
  <span>let</span> oldEndIdx <span>=</span> oldCh<span>.</span>length <span>-</span> <span>1</span>
  <span>let</span> oldStartVnode <span>=</span> oldCh<span>[</span><span>0</span><span>]</span>
  <span>let</span> oldEndVnode <span>=</span> oldCh<span>[</span>oldEndIdx<span>]</span>
  <span>let</span> newEndIdx <span>=</span> newCh<span>.</span>length <span>-</span> <span>1</span>
  <span>let</span> newStartVnode <span>=</span> newCh<span>[</span><span>0</span><span>]</span>
  <span>let</span> newEndVnode <span>=</span> newCh<span>[</span>newEndIdx<span>]</span>
  <span>let</span> oldKeyToIdx<span>,</span> idxInOld<span>,</span> vnodeToMove<span>,</span> refElm

  <span>// removeOnly is a special flag used only by &lt;transition-group></span>
  <span>// to ensure removed elements stay in correct relative positions</span>
  <span>// during leaving transitions</span>
  <span>const</span> canMove <span>=</span> <span>!</span>removeOnly

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>checkDuplicateKeys</span><span>(</span>newCh<span>)</span>
  <span>}</span>

  <span>while</span> <span>(</span>oldStartIdx <span>&lt;=</span> oldEndIdx <span>&amp;&amp;</span> newStartIdx <span>&lt;=</span> newEndIdx<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldStartVnode<span>)</span><span>)</span> <span>{</span>
      oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span> <span>// Vnode has been moved left</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldEndVnode<span>)</span><span>)</span> <span>{</span>
      oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldStartVnode<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span>
      <span>patchVnode</span><span>(</span>oldStartVnode<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>)</span>
      oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span>
      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldEndVnode<span>,</span> newEndVnode<span>)</span><span>)</span> <span>{</span>
      <span>patchVnode</span><span>(</span>oldEndVnode<span>,</span> newEndVnode<span>,</span> insertedVnodeQueue<span>)</span>
      oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span>
      newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldStartVnode<span>,</span> newEndVnode<span>)</span><span>)</span> <span>{</span> <span>// Vnode moved right</span>
      <span>patchVnode</span><span>(</span>oldStartVnode<span>,</span> newEndVnode<span>,</span> insertedVnodeQueue<span>)</span>
      canMove <span>&amp;&amp;</span> nodeOps<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> oldStartVnode<span>.</span>elm<span>,</span> nodeOps<span>.</span><span>nextSibling</span><span>(</span>oldEndVnode<span>.</span>elm<span>)</span><span>)</span>
      oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span>
      newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldEndVnode<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span> <span>// Vnode moved left</span>
      <span>patchVnode</span><span>(</span>oldEndVnode<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>)</span>
      canMove <span>&amp;&amp;</span> nodeOps<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> oldEndVnode<span>.</span>elm<span>,</span> oldStartVnode<span>.</span>elm<span>)</span>
      oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span>
      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldKeyToIdx<span>)</span><span>)</span> oldKeyToIdx <span>=</span> <span>createKeyToOldIdx</span><span>(</span>oldCh<span>,</span> oldStartIdx<span>,</span> oldEndIdx<span>)</span>
      idxInOld <span>=</span> <span>isDef</span><span>(</span>newStartVnode<span>.</span>key<span>)</span>
        <span>?</span> oldKeyToIdx<span>[</span>newStartVnode<span>.</span>key<span>]</span>
        <span>:</span> <span>findIdxInOld</span><span>(</span>newStartVnode<span>,</span> oldCh<span>,</span> oldStartIdx<span>,</span> oldEndIdx<span>)</span>
      <span>if</span> <span>(</span><span>isUndef</span><span>(</span>idxInOld<span>)</span><span>)</span> <span>{</span> <span>// New element</span>
        <span>createElm</span><span>(</span>newStartVnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> oldStartVnode<span>.</span>elm<span>,</span> <span>false</span><span>,</span> newCh<span>,</span> newStartIdx<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        vnodeToMove <span>=</span> oldCh<span>[</span>idxInOld<span>]</span>
        <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>vnodeToMove<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span>
          <span>patchVnode</span><span>(</span>vnodeToMove<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>)</span>
          oldCh<span>[</span>idxInOld<span>]</span> <span>=</span> <span>undefined</span>
          canMove <span>&amp;&amp;</span> nodeOps<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> vnodeToMove<span>.</span>elm<span>,</span> oldStartVnode<span>.</span>elm<span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>// same key but different element. treat as new element</span>
          <span>createElm</span><span>(</span>newStartVnode<span>,</span> insertedVnodeQueue<span>,</span> parentElm<span>,</span> oldStartVnode<span>.</span>elm<span>,</span> <span>false</span><span>,</span> newCh<span>,</span> newStartIdx<span>)</span>
        <span>}</span>
      <span>}</span>
      newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span>
    <span>}</span>
  <span>}</span>
  <span>if</span> <span>(</span>oldStartIdx <span>></span> oldEndIdx<span>)</span> <span>{</span>
    refElm <span>=</span> <span>isUndef</span><span>(</span>newCh<span>[</span>newEndIdx <span>+</span> <span>1</span><span>]</span><span>)</span> <span>?</span> <span>null</span> <span>:</span> newCh<span>[</span>newEndIdx <span>+</span> <span>1</span><span>]</span><span>.</span>elm
    <span>addVnodes</span><span>(</span>parentElm<span>,</span> refElm<span>,</span> newCh<span>,</span> newStartIdx<span>,</span> newEndIdx<span>,</span> insertedVnodeQueue<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>newStartIdx <span>></span> newEndIdx<span>)</span> <span>{</span>
    <span>removeVnodes</span><span>(</span>parentElm<span>,</span> oldCh<span>,</span> oldStartIdx<span>,</span> oldEndIdx<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>updateChildren</code> 的逻辑比较复杂，直接读源码比较晦涩，我们可以通过一个具体的示例来分析它。</p>
<div><pre><code><span>&lt;</span>template<span>></span>
  <span>&lt;</span>div id<span>=</span><span>"app"</span><span>></span>
    <span>&lt;</span>div<span>></span>
      <span>&lt;</span>ul<span>></span>
        <span>&lt;</span>li v<span>-</span><span>for</span><span>=</span><span>"item in items"</span> <span>:</span>key<span>=</span><span>"item.id"</span><span>></span><span>{</span><span>{</span> item<span>.</span>val <span>}</span><span>}</span><span>&lt;</span><span>/</span>li<span>></span>
      <span>&lt;</span><span>/</span>ul<span>></span>
    <span>&lt;</span><span>/</span>div<span>></span>
    <span>&lt;</span>button @click<span>=</span><span>"change"</span><span>></span>change<span>&lt;</span><span>/</span>button<span>></span>
  <span>&lt;</span><span>/</span>div<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>

<span>&lt;</span>script<span>></span>
  <span>export</span> <span>default</span> <span>{</span>
    <span>name</span><span>:</span> <span>'App'</span><span>,</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span>
        <span>items</span><span>:</span> <span>[</span>
          <span>{</span><span>id</span><span>:</span> <span>0</span><span>,</span> <span>val</span><span>:</span> <span>'A'</span><span>}</span><span>,</span>
          <span>{</span><span>id</span><span>:</span> <span>1</span><span>,</span> <span>val</span><span>:</span> <span>'B'</span><span>}</span><span>,</span>
          <span>{</span><span>id</span><span>:</span> <span>2</span><span>,</span> <span>val</span><span>:</span> <span>'C'</span><span>}</span><span>,</span>
          <span>{</span><span>id</span><span>:</span> <span>3</span><span>,</span> <span>val</span><span>:</span> <span>'D'</span><span>}</span>
        <span>]</span>
      <span>}</span>
    <span>}</span><span>,</span>
    <span>methods</span><span>:</span> <span>{</span>
      <span>change</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>items<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>push</span><span>(</span><span>{</span><span>id</span><span>:</span> <span>4</span><span>,</span> <span>val</span><span>:</span> <span>'E'</span><span>}</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当我们点击 <code>change</code> 按钮去改变数据，最终会执行到 <code>updateChildren</code> 去更新 <code>li</code> 部分的列表数据，我们通过图的方式来描述一下它的更新过程：</p>
<p>第一步：
<img :src="$withBase('/assets/update-children-1.png')"></p>
<p>第二步：
<img :src="$withBase('/assets/update-children-2.png')"></p>
<p>第三步：
<img :src="$withBase('/assets/update-children-3.png')"></p>
<p>第四步：
<img :src="$withBase('/assets/update-children-4.png')"></p>
<p>第五步：
<img :src="$withBase('/assets/update-children-5.png')"></p>
<p>第六步：
<img :src="$withBase('/assets/update-children-6.png')"></p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>组件更新的过程核心就是新旧 vnode diff，对新旧节点相同以及不同的情况分别做不同的处理。新旧节点不同的更新流程是创建新节点-&gt;更新父占位符节点-&gt;删除旧节点；而新旧节点相同的更新流程是去获取它们的 children，根据不同情况做不同的更新逻辑。最复杂的情况是新旧节点相同且它们都存在子节点，那么会执行 <code>updateChildren</code> 逻辑，这块儿可以借助画图的方式配合理解。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">计算属性 VS 侦听属性</title>
    <id>https://0808200.xyz/vue2/reactive/computed-watcher.html</id>
    <link href="https://0808200.xyz/vue2/reactive/computed-watcher.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="计算属性-vs-侦听属性" tabindex="-1"> 计算属性 VS 侦听属性</h1>
<p>Vue 的组件对象支持了计算属性 <code>computed</code> 和侦听属性 <code>watch</code> 2 个选项，很多同学不了解什么时候该用 <code>computed</code> 什么时候该用 <code>watch</code>。先不回答这个问题，我们接下来从源码实现的角度来分析它们两者有什么区别。</p>
<h2 id="computed" tabindex="-1"> <code>computed</code></h2>
<p>计算属性的初始化是发生在 Vue 实例初始化阶段的 <code>initState</code> 函数中，执行了 <code>if (opts.computed) initComputed(vm, opts.computed)</code>，<code>initComputed</code> 的定义在 <code>src/core/instance/state.js</code> 中：</p>
<div><pre><code><span>const</span> computedWatcherOptions <span>=</span> <span>{</span> <span>computed</span><span>:</span> <span>true</span> <span>}</span>
<span>function</span> <span>initComputed</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>computed</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>// $flow-disable-line</span>
  <span>const</span> watchers <span>=</span> vm<span>.</span>_computedWatchers <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>// computed properties are just getters during SSR</span>
  <span>const</span> isSSR <span>=</span> <span>isServerRendering</span><span>(</span><span>)</span>

  <span>for</span> <span>(</span><span>const</span> key <span>in</span> computed<span>)</span> <span>{</span>
    <span>const</span> userDef <span>=</span> computed<span>[</span>key<span>]</span>
    <span>const</span> getter <span>=</span> <span>typeof</span> userDef <span>===</span> <span>'function'</span> <span>?</span> userDef <span>:</span> userDef<span>.</span>get
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> getter <span>==</span> <span>null</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>Getter is missing for computed property "</span><span><span>${</span>key<span>}</span></span><span>".</span><span>`</span></span><span>,</span>
        vm
      <span>)</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>!</span>isSSR<span>)</span> <span>{</span>
      <span>// create internal watcher for the computed property.</span>
      watchers<span>[</span>key<span>]</span> <span>=</span> <span>new</span> <span>Watcher</span><span>(</span>
        vm<span>,</span>
        getter <span>||</span> noop<span>,</span>
        noop<span>,</span>
        computedWatcherOptions
      <span>)</span>
    <span>}</span>

    <span>// component-defined computed properties are already defined on the</span>
    <span>// component prototype. We only need to define computed properties defined</span>
    <span>// at instantiation here.</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>key <span>in</span> vm<span>)</span><span>)</span> <span>{</span>
      <span>defineComputed</span><span>(</span>vm<span>,</span> key<span>,</span> userDef<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>key <span>in</span> vm<span>.</span>$data<span>)</span> <span>{</span>
        <span>warn</span><span>(</span><span><span>`</span><span>The computed property "</span><span><span>${</span>key<span>}</span></span><span>" is already defined in data.</span><span>`</span></span><span>,</span> vm<span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>vm<span>.</span>$options<span>.</span>props <span>&amp;&amp;</span> key <span>in</span> vm<span>.</span>$options<span>.</span>props<span>)</span> <span>{</span>
        <span>warn</span><span>(</span><span><span>`</span><span>The computed property "</span><span><span>${</span>key<span>}</span></span><span>" is already defined as a prop.</span><span>`</span></span><span>,</span> vm<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数首先创建 <code>vm._computedWatchers</code> 为一个空对象，接着对 <code>computed</code> 对象做遍历，拿到计算属性的每一个 <code>userDef</code>，然后尝试获取这个 <code>userDef</code> 对应的 <code>getter</code> 函数，拿不到则在开发环境下报警告。接下来为每一个 <code>getter</code> 创建一个 <code>watcher</code>，这个 <code>watcher</code> 和渲染 <code>watcher</code> 有一点很大的不同，它是一个 <code>computed watcher</code>，因为 <code>const computedWatcherOptions = { computed: true }</code>。<code>computed watcher</code> 和普通 <code>watcher</code> 的差别我稍后会介绍。最后对判断如果 <code>key</code> 不是 <code>vm</code> 的属性，则调用 <code>defineComputed(vm, key, userDef)</code>，否则判断计算属性对于的 <code>key</code> 是否已经被 <code>data</code> 或者 <code>prop</code> 所占用，如果是的话则在开发环境报相应的警告。</p>
<p>那么接下来需要重点关注 <code>defineComputed</code> 的实现：</p>
<div><pre><code><span>export</span> <span>function</span> <span>defineComputed</span> <span>(</span>
  <span><span>target</span><span>:</span> any<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>userDef</span><span>:</span> Object <span>|</span> Function</span>
<span>)</span> <span>{</span>
  <span>const</span> shouldCache <span>=</span> <span>!</span><span>isServerRendering</span><span>(</span><span>)</span>
  <span>if</span> <span>(</span><span>typeof</span> userDef <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
    sharedPropertyDefinition<span>.</span>get <span>=</span> shouldCache
      <span>?</span> <span>createComputedGetter</span><span>(</span>key<span>)</span>
      <span>:</span> userDef
    sharedPropertyDefinition<span>.</span>set <span>=</span> noop
  <span>}</span> <span>else</span> <span>{</span>
    sharedPropertyDefinition<span>.</span>get <span>=</span> userDef<span>.</span>get
      <span>?</span> shouldCache <span>&amp;&amp;</span> userDef<span>.</span>cache <span>!==</span> <span>false</span>
        <span>?</span> <span>createComputedGetter</span><span>(</span>key<span>)</span>
        <span>:</span> userDef<span>.</span>get
      <span>:</span> noop
    sharedPropertyDefinition<span>.</span>set <span>=</span> userDef<span>.</span>set
      <span>?</span> userDef<span>.</span>set
      <span>:</span> noop
  <span>}</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
      sharedPropertyDefinition<span>.</span>set <span>===</span> noop<span>)</span> <span>{</span>
    sharedPropertyDefinition<span>.</span><span>set</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>Computed property "</span><span><span>${</span>key<span>}</span></span><span>" was assigned to but it has no setter.</span><span>`</span></span><span>,</span>
        <span>this</span>
      <span>)</span>
    <span>}</span>
  <span>}</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> key<span>,</span> sharedPropertyDefinition<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段逻辑很简单，其实就是利用 <code>Object.defineProperty</code> 给计算属性对应的 <code>key</code> 值添加 getter 和 setter，setter 通常是计算属性是一个对象，并且拥有 <code>set</code> 方法的时候才有，否则是一个空函数。在平时的开发场景中，计算属性有 setter 的情况比较少，我们重点关注一下 getter 部分，缓存的配置也先忽略，最终 getter 对应的是 <code>createComputedGetter(key)</code> 的返回值，来看一下它的定义：</p>
<div><pre><code><span>function</span> <span>createComputedGetter</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>computedGetter</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> watcher <span>=</span> <span>this</span><span>.</span>_computedWatchers <span>&amp;&amp;</span> <span>this</span><span>.</span>_computedWatchers<span>[</span>key<span>]</span>
    <span>if</span> <span>(</span>watcher<span>)</span> <span>{</span>
      watcher<span>.</span><span>depend</span><span>(</span><span>)</span>
      <span>return</span> watcher<span>.</span><span>evaluate</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createComputedGetter</code> 返回一个函数 <code>computedGetter</code>，它就是计算属性对应的 getter。</p>
<p>整个计算属性的初始化过程到此结束，我们知道计算属性是一个 <code>computed watcher</code>，它和普通的 <code>watcher</code> 有什么区别呢，为了更加直观，接下来来我们来通过一个例子来分析 <code>computed watcher</code> 的实现。</p>
<div><pre><code><span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>firstName</span><span>:</span> <span>'Foo'</span><span>,</span>
    <span>lastName</span><span>:</span> <span>'Bar'</span>
  <span>}</span><span>,</span>
  <span>computed</span><span>:</span> <span>{</span>
    <span>fullName</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>this</span><span>.</span>firstName <span>+</span> <span>' '</span> <span>+</span> <span>this</span><span>.</span>lastName
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当初始化这个 <code>computed watcher</code> 实例的时候，构造函数部分逻辑稍有不同：</p>
<div><pre><code><span>constructor</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>expOrFn</span><span>:</span> string <span>|</span> Function<span>,</span>
  <span>cb</span><span>:</span> Function<span>,</span>
  options<span>?</span><span>:</span> <span>?</span>Object<span>,</span>
  isRenderWatcher<span>?</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>// ...</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>computed<span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span>
    <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以发现 <code>computed watcher</code> 会并不会立刻求值，同时持有一个 <code>dep</code> 实例。</p>
<p>然后当我们的 <code>render</code> 函数执行访问到 <code>this.fullName</code> 的时候，就触发了计算属性的 <code>getter</code>，它会拿到计算属性对应的 <code>watcher</code>，然后执行 <code>watcher.depend()</code>，来看一下它的定义：</p>
<div><pre><code><span>/**
  * Depend on this watcher. Only for computed property watchers.
  */</span>
<span>depend</span> <span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>dep <span>&amp;&amp;</span> Dep<span>.</span>target<span>)</span> <span>{</span>
    <span>this</span><span>.</span>dep<span>.</span><span>depend</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，这时候的 <code>Dep.target</code> 是渲染 <code>watcher</code>，所以 <code>this.dep.depend()</code> 相当于渲染 <code>watcher</code> 订阅了这个 <code>computed watcher</code> 的变化。</p>
<p>然后再执行 <code>watcher.evaluate()</code> 去求值，来看一下它的定义：</p>
<div><pre><code><span>/**
  * Evaluate and return the value of the watcher.
  * This only gets called for computed property watchers.
  */</span>
<span>evaluate</span> <span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>dirty<span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
    <span>this</span><span>.</span>dirty <span>=</span> <span>false</span>
  <span>}</span>
  <span>return</span> <span>this</span><span>.</span>value
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>evaluate</code> 的逻辑非常简单，判断 <code>this.dirty</code>，如果为 <code>true</code> 则通过 <code>this.get()</code> 求值，然后把 <code>this.dirty</code> 设置为 false。在求值过程中，会执行 <code>value = this.getter.call(vm, vm)</code>，这实际上就是执行了计算属性定义的 <code>getter</code> 函数，在我们这个例子就是执行了 <code>return this.firstName + ' ' + this.lastName</code>。</p>
<p>这里需要特别注意的是，由于 <code>this.firstName</code> 和 <code>this.lastName</code> 都是响应式对象，这里会触发它们的 getter，根据我们之前的分析，它们会把自身持有的 <code>dep</code> 添加到当前正在计算的 <code>watcher</code> 中，这个时候 <code>Dep.target</code> 就是这个 <code>computed watcher</code>。</p>
<p>最后通过 <code>return this.value</code> 拿到计算属性对应的值。我们知道了计算属性的求值过程，那么接下来看一下它依赖的数据变化后的逻辑。</p>
<p>一旦我们对计算属性依赖的数据做修改，则会触发 setter 过程，通知所有订阅它变化的 <code>watcher</code> 更新，执行 <code>watcher.update()</code> 方法：</p>
<div><pre><code><span>/* istanbul ignore else */</span>
<span>if</span> <span>(</span><span>this</span><span>.</span>computed<span>)</span> <span>{</span>
  <span>// A computed property watcher has two modes: lazy and activated.</span>
  <span>// It initializes as lazy by default, and only becomes activated when</span>
  <span>// it is depended on by at least one subscriber, which is typically</span>
  <span>// another computed property or a component's render function.</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>dep<span>.</span>subs<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>// In lazy mode, we don't want to perform computations until necessary,</span>
    <span>// so we simply mark the watcher as dirty. The actual computation is</span>
    <span>// performed just-in-time in this.evaluate() when the computed property</span>
    <span>// is accessed.</span>
    <span>this</span><span>.</span>dirty <span>=</span> <span>true</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// In activated mode, we want to proactively perform the computation</span>
    <span>// but only notify our subscribers when the value has indeed changed.</span>
    <span>this</span><span>.</span><span>getAndInvoke</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>this</span><span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span>sync<span>)</span> <span>{</span>
  <span>this</span><span>.</span><span>run</span><span>(</span><span>)</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>queueWatcher</span><span>(</span><span>this</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么对于计算属性这样的 <code>computed watcher</code>，它实际上是有 2 种模式，lazy 和 active。如果 <code>this.dep.subs.length === 0</code> 成立，则说明没有人去订阅这个 <code>computed watcher</code> 的变化，仅仅把 <code>this.dirty = true</code>，只有当下次再访问这个计算属性的时候才会重新求值。在我们的场景下，渲染 <code>watcher</code> 订阅了这个 <code>computed watcher</code> 的变化，那么它会执行：</p>
<div><pre><code><span>this</span><span>.</span><span>getAndInvoke</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>this</span><span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span>
<span>}</span><span>)</span>

<span>getAndInvoke</span> <span>(</span><span><span>cb</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
  <span>if</span> <span>(</span>
    value <span>!==</span> <span>this</span><span>.</span>value <span>||</span>
    <span>// Deep watchers and watchers on Object/Arrays should fire even</span>
    <span>// when the value is the same, because the value may</span>
    <span>// have mutated.</span>
    <span>isObject</span><span>(</span>value<span>)</span> <span>||</span>
    <span>this</span><span>.</span>deep
  <span>)</span> <span>{</span>
    <span>// set new value</span>
    <span>const</span> oldValue <span>=</span> <span>this</span><span>.</span>value
    <span>this</span><span>.</span>value <span>=</span> value
    <span>this</span><span>.</span>dirty <span>=</span> <span>false</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>user<span>)</span> <span>{</span>
      <span>try</span> <span>{</span>
        <span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> value<span>,</span> oldValue<span>)</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
        <span>handleError</span><span>(</span>e<span>,</span> <span>this</span><span>.</span>vm<span>,</span> <span><span>`</span><span>callback for watcher "</span><span><span>${</span><span>this</span><span>.</span>expression<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> value<span>,</span> oldValue<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>getAndInvoke</code> 函数会重新计算，然后对比新旧值，如果变化了则执行回调函数，那么这里这个回调函数是 <code>this.dep.notify()</code>，在我们这个场景下就是触发了渲染 <code>watcher</code> 重新渲染。</p>
<p>通过以上的分析，我们知道计算属性本质上就是一个 <code>computed watcher</code>，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 <code>watcher</code> 重新渲染，本质上是一种优化。</p>
<p>接下来我们来分析一下侦听属性 <code>watch</code> 是怎么实现的。</p>
<h2 id="watch" tabindex="-1"> watch</h2>
<p>侦听属性的初始化也是发生在 Vue 的实例初始化阶段的 <code>initState</code> 函数中，在 <code>computed</code> 初始化之后，执行了：</p>
<div><pre><code><span>if</span> <span>(</span>opts<span>.</span>watch <span>&amp;&amp;</span> opts<span>.</span>watch <span>!==</span> nativeWatch<span>)</span> <span>{</span>
  <span>initWatch</span><span>(</span>vm<span>,</span> opts<span>.</span>watch<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>来看一下 <code>initWatch</code> 的实现，它的定义在 <code>src/core/instance/state.js</code> 中：</p>
<div><pre><code><span>function</span> <span>initWatch</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>watch</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> watch<span>)</span> <span>{</span>
    <span>const</span> handler <span>=</span> watch<span>[</span>key<span>]</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>handler<span>)</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> handler<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>createWatcher</span><span>(</span>vm<span>,</span> key<span>,</span> handler<span>[</span>i<span>]</span><span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>createWatcher</span><span>(</span>vm<span>,</span> key<span>,</span> handler<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里就是对 <code>watch</code> 对象做遍历，拿到每一个  <code>handler</code>，因为 Vue 是支持 <code>watch</code> 的同一个 <code>key</code> 对应多个 <code>handler</code>，所以如果 <code>handler</code> 是一个数组，则遍历这个数组，调用 <code>createWatcher</code> 方法，否则直接调用 <code>createWatcher</code>：</p>
<div><pre><code><span>function</span> <span>createWatcher</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>expOrFn</span><span>:</span> string <span>|</span> Function<span>,</span>
  <span>handler</span><span>:</span> any<span>,</span>
  options<span>?</span><span>:</span> Object</span>
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isPlainObject</span><span>(</span>handler<span>)</span><span>)</span> <span>{</span>
    options <span>=</span> handler
    handler <span>=</span> handler<span>.</span>handler
  <span>}</span>
  <span>if</span> <span>(</span><span>typeof</span> handler <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
    handler <span>=</span> vm<span>[</span>handler<span>]</span>
  <span>}</span>
  <span>return</span> vm<span>.</span><span>$watch</span><span>(</span>expOrFn<span>,</span> handler<span>,</span> options<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的逻辑也很简单，首先对 <code>hanlder</code> 的类型做判断，拿到它最终的回调函数，最后调用 <code>vm.$watch(keyOrFn, handler, options)</code> 函数，<code>$watch</code> 是 Vue 原型上的方法，它是在执行 <code>stateMixin</code> 的时候定义的：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>$watch</span> <span>=</span> <span>function</span> <span>(</span>
  <span><span>expOrFn</span><span>:</span> string <span>|</span> Function<span>,</span>
  <span>cb</span><span>:</span> any<span>,</span>
  options<span>?</span><span>:</span> Object</span>
<span>)</span><span>:</span> Function <span>{</span>
  <span>const</span> <span>vm</span><span>:</span> Component <span>=</span> <span>this</span>
  <span>if</span> <span>(</span><span>isPlainObject</span><span>(</span>cb<span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span>createWatcher</span><span>(</span>vm<span>,</span> expOrFn<span>,</span> cb<span>,</span> options<span>)</span>
  <span>}</span>
  options <span>=</span> options <span>||</span> <span>{</span><span>}</span>
  options<span>.</span>user <span>=</span> <span>true</span>
  <span>const</span> watcher <span>=</span> <span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> expOrFn<span>,</span> cb<span>,</span> options<span>)</span>
  <span>if</span> <span>(</span>options<span>.</span>immediate<span>)</span> <span>{</span>
    <span>cb</span><span>.</span><span>call</span><span>(</span>vm<span>,</span> watcher<span>.</span>value<span>)</span>
  <span>}</span>
  <span>return</span> <span>function</span> <span>unwatchFn</span> <span>(</span><span>)</span> <span>{</span>
    watcher<span>.</span><span>teardown</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，侦听属性 <code>watch</code> 最终会调用 <code>$watch</code> 方法，这个方法首先判断 <code>cb</code> 如果是一个对象，则调用 <code>createWatcher</code> 方法，这是因为 <code>$watch</code> 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 <code>const watcher = new Watcher(vm, expOrFn, cb, options)</code> 实例化了一个 <code>watcher</code>，这里需要注意一点这是一个 <code>user watcher</code>，因为 <code>options.user = true</code>。通过实例化 <code>watcher</code> 的方式，一旦我们 <code>watch</code> 的数据发送变化，它最终会执行 <code>watcher</code> 的 <code>run</code> 方法，执行回调函数 <code>cb</code>，并且如果我们设置了 <code>immediate</code> 为 true，则直接会执行回调函数 <code>cb</code>。最后返回了一个 <code>unwatchFn</code> 方法，它会调用 <code>teardown</code> 方法去移除这个 <code>watcher</code>。</p>
<p>所以本质上侦听属性也是基于 <code>Watcher</code> 实现的，它是一个 <code>user watcher</code>。其实 <code>Watcher</code> 支持了不同的类型，下面我们梳理一下它有哪些类型以及它们的作用。</p>
<h2 id="watcher-options" tabindex="-1"> Watcher options</h2>
<p><code>Watcher</code> 的构造函数对 <code>options</code> 做的了处理，代码如下：</p>
<div><pre><code><span>if</span> <span>(</span>options<span>)</span> <span>{</span>
  <span>this</span><span>.</span>deep <span>=</span> <span>!</span><span>!</span>options<span>.</span>deep
  <span>this</span><span>.</span>user <span>=</span> <span>!</span><span>!</span>options<span>.</span>user
  <span>this</span><span>.</span>computed <span>=</span> <span>!</span><span>!</span>options<span>.</span>computed
  <span>this</span><span>.</span>sync <span>=</span> <span>!</span><span>!</span>options<span>.</span>sync
  <span>// ...</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>this</span><span>.</span>deep <span>=</span> <span>this</span><span>.</span>user <span>=</span> <span>this</span><span>.</span>computed <span>=</span> <span>this</span><span>.</span>sync <span>=</span> <span>false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以 <code>watcher</code> 总共有 4 种类型，我们来一一分析它们，看看不同的类型执行的逻辑有哪些差别。</p>
<h3 id="deep-watcher" tabindex="-1"> deep watcher</h3>
<p>通常，如果我们想对一下对象做深度观测的时候，需要设置这个属性为 true，考虑到这种情况：</p>
<div><pre><code><span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>a</span><span>:</span> <span>{</span>
      <span>b</span><span>:</span> <span>1</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>watch</span><span>:</span> <span>{</span>
    <span>a</span><span>:</span> <span>{</span>
      <span>handler</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>newVal<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
vm<span>.</span>a<span>.</span>b <span>=</span> <span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个时候是不会 log 任何数据的，因为我们是 watch 了 <code>a</code> 对象，只触发了 <code>a</code> 的 getter，并没有触发 <code>a.b</code> 的 getter，所以并没有订阅它的变化，导致我们对 <code>vm.a.b = 2</code> 赋值的时候，虽然触发了 setter，但没有可通知的对象，所以也并不会触发 watch 的回调函数了。</p>
<p>而我们只需要对代码做稍稍修改，就可以观测到这个变化了</p>
<div><pre><code><span>watch</span><span>:</span> <span>{</span>
  <span>a</span><span>:</span> <span>{</span>
    <span>deep</span><span>:</span> <span>true</span><span>,</span>
    <span>handler</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>newVal<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样就创建了一个 <code>deep watcher</code> 了，在 <code>watcher </code> 执行 <code>get</code> 求值的过程中有一段逻辑：</p>
<div><pre><code><span>get</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> value <span>=</span> <span>this</span><span>.</span><span>getter</span><span>.</span><span>call</span><span>(</span>vm<span>,</span> vm<span>)</span>
  <span>// ...</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>deep<span>)</span> <span>{</span>
    <span>traverse</span><span>(</span>value<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在对 watch 的表达式或者函数求值后，会调用 <code>traverse</code> 函数，它的定义在 <code>src/core/observer/traverse.js</code> 中：</p>
<div><pre><code><span>import</span> <span>{</span> _Set <span>as</span> Set<span>,</span> isObject <span>}</span> <span>from</span> <span>'../util/index'</span>
<span>import</span> type <span>{</span> SimpleSet <span>}</span> <span>from</span> <span>'../util/index'</span>
<span>import</span> VNode <span>from</span> <span>'../vdom/vnode'</span>

<span>const</span> seenObjects <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>

<span>/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */</span>
<span>export</span> <span>function</span> <span>traverse</span> <span>(</span><span><span>val</span><span>:</span> any</span><span>)</span> <span>{</span>
  <span>_traverse</span><span>(</span>val<span>,</span> seenObjects<span>)</span>
  seenObjects<span>.</span><span>clear</span><span>(</span><span>)</span>
<span>}</span>

<span>function</span> <span>_traverse</span> <span>(</span><span><span>val</span><span>:</span> any<span>,</span> <span>seen</span><span>:</span> SimpleSet</span><span>)</span> <span>{</span>
  <span>let</span> i<span>,</span> keys
  <span>const</span> isA <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>val<span>)</span>
  <span>if</span> <span>(</span><span>(</span><span>!</span>isA <span>&amp;&amp;</span> <span>!</span><span>isObject</span><span>(</span>val<span>)</span><span>)</span> <span>||</span> Object<span>.</span><span>isFrozen</span><span>(</span>val<span>)</span> <span>||</span> val <span>instanceof</span> <span>VNode</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>if</span> <span>(</span>val<span>.</span>__ob__<span>)</span> <span>{</span>
    <span>const</span> depId <span>=</span> val<span>.</span>__ob__<span>.</span>dep<span>.</span>id
    <span>if</span> <span>(</span>seen<span>.</span><span>has</span><span>(</span>depId<span>)</span><span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
    seen<span>.</span><span>add</span><span>(</span>depId<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>isA<span>)</span> <span>{</span>
    i <span>=</span> val<span>.</span>length
    <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>_traverse</span><span>(</span>val<span>[</span>i<span>]</span><span>,</span> seen<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>val<span>)</span>
    i <span>=</span> keys<span>.</span>length
    <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>_traverse</span><span>(</span>val<span>[</span>keys<span>[</span>i<span>]</span><span>]</span><span>,</span> seen<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>traverse</code> 的逻辑也很简单，它实际上就是对一个对象做深层递归遍历，因为遍历过程中就是对一个子对象的访问，会触发它们的 getter 过程，这样就可以收集到依赖，也就是订阅它们变化的 <code>watcher</code>，这个函数实现还有一个小的优化，遍历过程中会把子响应式对象通过它们的 <code>dep id</code> 记录到 <code>seenObjects</code>，避免以后重复访问。</p>
<p>那么在执行了 <code>traverse</code> 后，我们再对 watch 的对象内部任何一个值做修改，也会调用 <code>watcher</code> 的回调函数了。</p>
<p>对 <code>deep watcher</code> 的理解非常重要，今后工作中如果大家观测了一个复杂对象，并且会改变对象内部深层某个值的时候也希望触发回调，一定要设置 <code>deep</code> 为 true，但是因为设置了 <code>deep</code> 后会执行 <code>traverse</code> 函数，会有一定的性能开销，所以一定要根据应用场景权衡是否要开启这个配置。</p>
<h3 id="user-watcher" tabindex="-1"> user watcher</h3>
<p>前面我们分析过，通过 <code>vm.$watch</code> 创建的 <code>watcher</code> 是一个 <code>user watcher</code>，其实它的功能很简单，在对 <code>watcher</code> 求值以及在执行回调函数的时候，会处理一下错误，如下：</p>
<div><pre><code><span>get</span><span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>user<span>)</span> <span>{</span>
    <span>handleError</span><span>(</span>e<span>,</span> vm<span>,</span> <span><span>`</span><span>getter for watcher "</span><span><span>${</span><span>this</span><span>.</span>expression<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>throw</span> e
  <span>}</span>
<span>}</span><span>,</span>
<span>getAndInvoke</span><span>(</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>user<span>)</span> <span>{</span>
    <span>try</span> <span>{</span>
      <span>this</span><span>.</span><span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> value<span>,</span> oldValue<span>)</span>
    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
      <span>handleError</span><span>(</span>e<span>,</span> <span>this</span><span>.</span>vm<span>,</span> <span><span>`</span><span>callback for watcher "</span><span><span>${</span><span>this</span><span>.</span>expression<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>this</span><span>.</span><span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> value<span>,</span> oldValue<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>handleError</code> 在 Vue 中是一个错误捕获并且暴露给用户的一个利器。</p>
<h3 id="computed-watcher" tabindex="-1"> computed watcher</h3>
<p><code>computed watcher</code> 几乎就是为计算属性量身定制的，我们刚才已经对它做了详细的分析，这里不再赘述了。</p>
<h3 id="sync-watcher" tabindex="-1"> sync watcher</h3>
<p>在我们之前对 <code>setter</code> 的分析过程知道，当响应式数据发送变化后，触发了 <code>watcher.update()</code>，只是把这个 <code>watcher</code> 推送到一个队列中，在 <code>nextTick</code> 后才会真正执行 <code>watcher</code> 的回调函数。而一旦我们设置了 <code>sync</code>，就可以在当前 <code>Tick</code> 中同步执行 <code>watcher</code> 的回调函数。</p>
<div><pre><code><span>update</span> <span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>computed<span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span>sync<span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>run</span><span>(</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>queueWatcher</span><span>(</span><span>this</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>只有当我们需要 watch 的值的变化到执行 <code>watcher</code> 的回调函数是一个同步过程的时候才会去设置该属性为 true。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一小节的分析我们对计算属性和侦听属性的实现有了深入的了解，计算属性本质上是 <code>computed watcher</code>，而侦听属性本质上是 <code>user watcher</code>。就应用场景而言，计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<p>同时我们又了解了 <code>watcher</code> 的 4 个 <code>options</code>，通常我们会在创建 <code>user watcher</code> 的时候配置 <code>deep</code> 和 <code>sync</code>，可以根据不同的场景做相应的配置。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">依赖收集</title>
    <id>https://0808200.xyz/vue2/reactive/getters.html</id>
    <link href="https://0808200.xyz/vue2/reactive/getters.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="依赖收集" tabindex="-1"> 依赖收集</h1>
<p>通过上一节的分析我们了解 Vue 会把普通对象变成响应式对象，响应式对象 getter 相关的逻辑就是做依赖收集，这一节我们来详细分析这个过程。</p>
<p>我们先来回顾一下 getter 部分的逻辑：</p>
<div><pre><code><span>export</span> <span>function</span> <span>defineReactive</span> <span>(</span>
  <span><span>obj</span><span>:</span> Object<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>val</span><span>:</span> any<span>,</span>
  customSetter<span>?</span><span>:</span> <span>?</span>Function<span>,</span>
  shallow<span>?</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>

  <span>const</span> property <span>=</span> Object<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span>obj<span>,</span> key<span>)</span>
  <span>if</span> <span>(</span>property <span>&amp;&amp;</span> property<span>.</span>configurable <span>===</span> <span>false</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>// cater for pre-defined getter/setters</span>
  <span>const</span> getter <span>=</span> property <span>&amp;&amp;</span> property<span>.</span>get
  <span>const</span> setter <span>=</span> property <span>&amp;&amp;</span> property<span>.</span>set
  <span>if</span> <span>(</span><span>(</span><span>!</span>getter <span>||</span> setter<span>)</span> <span>&amp;&amp;</span> arguments<span>.</span>length <span>===</span> <span>2</span><span>)</span> <span>{</span>
    val <span>=</span> obj<span>[</span>key<span>]</span>
  <span>}</span>

  <span>let</span> childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>val<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span> <span>(</span><span>)</span> <span>{</span>
      <span>const</span> value <span>=</span> getter <span>?</span> <span>getter</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>:</span> val
      <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> <span>{</span>
        dep<span>.</span><span>depend</span><span>(</span><span>)</span>
        <span>if</span> <span>(</span>childOb<span>)</span> <span>{</span>
          childOb<span>.</span>dep<span>.</span><span>depend</span><span>(</span><span>)</span>
          <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
            <span>dependArray</span><span>(</span>value<span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
      <span>return</span> value
    <span>}</span><span>,</span>
    <span>// ...</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这段代码我们只需要关注 2 个地方，一个是 <code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 的实例，另一个是在 <code>get</code> 函数中通过 <code>dep.depend</code> 做依赖收集，这里还有个对 <code>childOb</code> 判断的逻辑，我们之后会介绍它的作用。</p>
<h2 id="dep" tabindex="-1"> Dep</h2>
<p><code>Dep</code> 是整个 getter 依赖收集的核心，它的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<div><pre><code><span>import</span> type Watcher <span>from</span> <span>'./watcher'</span>
<span>import</span> <span>{</span> remove <span>}</span> <span>from</span> <span>'../util/index'</span>

<span>let</span> uid <span>=</span> <span>0</span>

<span>/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */</span>
<span>export</span> <span>default</span> <span>class</span> <span>Dep</span> <span>{</span>
  <span>static</span> <span>target</span><span>:</span> <span>?</span>Watcher<span>;</span>
  <span>id</span><span>:</span> number<span>;</span>
  <span>subs</span><span>:</span> Array<span>&lt;</span>Watcher<span>></span><span>;</span>

  <span>constructor</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>id <span>=</span> uid<span>++</span>
    <span>this</span><span>.</span>subs <span>=</span> <span>[</span><span>]</span>
  <span>}</span>

  <span>addSub</span> <span>(</span><span><span>sub</span><span>:</span> Watcher</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs<span>.</span><span>push</span><span>(</span>sub<span>)</span>
  <span>}</span>

  <span>removeSub</span> <span>(</span><span><span>sub</span><span>:</span> Watcher</span><span>)</span> <span>{</span>
    <span>remove</span><span>(</span><span>this</span><span>.</span>subs<span>,</span> sub<span>)</span>
  <span>}</span>

  <span>depend</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> <span>{</span>
      Dep<span>.</span>target<span>.</span><span>addDep</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>notify</span> <span>(</span><span>)</span> <span>{</span>
    <span>// stabilize the subscriber list first</span>
    <span>const</span> subs <span>=</span> <span>this</span><span>.</span>subs<span>.</span><span>slice</span><span>(</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> subs<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      subs<span>[</span>i<span>]</span><span>.</span><span>update</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>// the current target watcher being evaluated.</span>
<span>// this is globally unique because there could be only one</span>
<span>// watcher being evaluated at any time.</span>
Dep<span>.</span>target <span>=</span> <span>null</span>
<span>const</span> targetStack <span>=</span> <span>[</span><span>]</span>

<span>export</span> <span>function</span> <span>pushTarget</span> <span>(</span><span><span>_target</span><span>:</span> <span>?</span>Watcher</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> targetStack<span>.</span><span>push</span><span>(</span>Dep<span>.</span>target<span>)</span>
  Dep<span>.</span>target <span>=</span> _target
<span>}</span>

<span>export</span> <span>function</span> <span>popTarget</span> <span>(</span><span>)</span> <span>{</span>
  Dep<span>.</span>target <span>=</span> targetStack<span>.</span><span>pop</span><span>(</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Dep</code> 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 <code>target</code>，这是一个全局唯一 <code>Watcher</code>，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算，另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组。</p>
<p><code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code>  脱离 <code>Watcher</code> 单独存在是没有意义的，为了完整地讲清楚依赖收集过程，我们有必要看一下 <code>Watcher</code> 的一些相关实现，它的定义在 <code>src/core/observer/watcher.js</code> 中：</p>
<h2 id="watcher" tabindex="-1"> <code>Watcher</code></h2>
<div><pre><code><span>let</span> uid <span>=</span> <span>0</span>

<span>/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */</span>
<span>export</span> <span>default</span> <span>class</span> <span>Watcher</span> <span>{</span>
  <span>vm</span><span>:</span> Component<span>;</span>
  <span>expression</span><span>:</span> string<span>;</span>
  <span>cb</span><span>:</span> Function<span>;</span>
  <span>id</span><span>:</span> number<span>;</span>
  <span>deep</span><span>:</span> boolean<span>;</span>
  <span>user</span><span>:</span> boolean<span>;</span>
  <span>computed</span><span>:</span> boolean<span>;</span>
  <span>sync</span><span>:</span> boolean<span>;</span>
  <span>dirty</span><span>:</span> boolean<span>;</span>
  <span>active</span><span>:</span> boolean<span>;</span>
  <span>dep</span><span>:</span> Dep<span>;</span>
  <span>deps</span><span>:</span> Array<span>&lt;</span>Dep<span>></span><span>;</span>
  <span>newDeps</span><span>:</span> Array<span>&lt;</span>Dep<span>></span><span>;</span>
  <span>depIds</span><span>:</span> SimpleSet<span>;</span>
  <span>newDepIds</span><span>:</span> SimpleSet<span>;</span>
  <span>before</span><span>:</span> <span>?</span>Function<span>;</span>
  <span>getter</span><span>:</span> Function<span>;</span>
  <span>value</span><span>:</span> any<span>;</span>

  <span>constructor</span> <span>(</span>
    <span><span>vm</span><span>:</span> Component<span>,</span>
    <span>expOrFn</span><span>:</span> string <span>|</span> Function<span>,</span>
    <span>cb</span><span>:</span> Function<span>,</span>
    options<span>?</span><span>:</span> <span>?</span>Object<span>,</span>
    isRenderWatcher<span>?</span><span>:</span> boolean</span>
  <span>)</span> <span>{</span>
    <span>this</span><span>.</span>vm <span>=</span> vm
    <span>if</span> <span>(</span>isRenderWatcher<span>)</span> <span>{</span>
      vm<span>.</span>_watcher <span>=</span> <span>this</span>
    <span>}</span>
    vm<span>.</span>_watchers<span>.</span><span>push</span><span>(</span><span>this</span><span>)</span>
    <span>// options</span>
    <span>if</span> <span>(</span>options<span>)</span> <span>{</span>
      <span>this</span><span>.</span>deep <span>=</span> <span>!</span><span>!</span>options<span>.</span>deep
      <span>this</span><span>.</span>user <span>=</span> <span>!</span><span>!</span>options<span>.</span>user
      <span>this</span><span>.</span>computed <span>=</span> <span>!</span><span>!</span>options<span>.</span>computed
      <span>this</span><span>.</span>sync <span>=</span> <span>!</span><span>!</span>options<span>.</span>sync
      <span>this</span><span>.</span>before <span>=</span> options<span>.</span>before
    <span>}</span> <span>else</span> <span>{</span>
      <span>this</span><span>.</span>deep <span>=</span> <span>this</span><span>.</span>user <span>=</span> <span>this</span><span>.</span>computed <span>=</span> <span>this</span><span>.</span>sync <span>=</span> <span>false</span>
    <span>}</span>
    <span>this</span><span>.</span>cb <span>=</span> cb
    <span>this</span><span>.</span>id <span>=</span> <span>++</span>uid <span>// uid for batching</span>
    <span>this</span><span>.</span>active <span>=</span> <span>true</span>
    <span>this</span><span>.</span>dirty <span>=</span> <span>this</span><span>.</span>computed <span>// for computed watchers</span>
    <span>this</span><span>.</span>deps <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>newDeps <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>depIds <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
    <span>this</span><span>.</span>newDepIds <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
    <span>this</span><span>.</span>expression <span>=</span> process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span>
      <span>?</span> expOrFn<span>.</span><span>toString</span><span>(</span><span>)</span>
      <span>:</span> <span>''</span>
    <span>// parse expression for getter</span>
    <span>if</span> <span>(</span><span>typeof</span> expOrFn <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>getter <span>=</span> expOrFn
    <span>}</span> <span>else</span> <span>{</span>
      <span>this</span><span>.</span>getter <span>=</span> <span>parsePath</span><span>(</span>expOrFn<span>)</span>
      <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>getter<span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>getter</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
        process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
          <span><span>`</span><span>Failed watching path: "</span><span><span>${</span>expOrFn<span>}</span></span><span>" </span><span>`</span></span> <span>+</span>
          <span>'Watcher only accepts simple dot-delimited paths. '</span> <span>+</span>
          <span>'For full control, use a function instead.'</span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>computed<span>)</span> <span>{</span>
      <span>this</span><span>.</span>value <span>=</span> <span>undefined</span>
      <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>/**
   * Evaluate the getter, and re-collect dependencies.
   */</span>
  <span>get</span> <span>(</span><span>)</span> <span>{</span>
    <span>pushTarget</span><span>(</span><span>this</span><span>)</span>
    <span>let</span> value
    <span>const</span> vm <span>=</span> <span>this</span><span>.</span>vm
    <span>try</span> <span>{</span>
      value <span>=</span> <span>this</span><span>.</span><span>getter</span><span>.</span><span>call</span><span>(</span>vm<span>,</span> vm<span>)</span>
    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>user<span>)</span> <span>{</span>
        <span>handleError</span><span>(</span>e<span>,</span> vm<span>,</span> <span><span>`</span><span>getter for watcher "</span><span><span>${</span><span>this</span><span>.</span>expression<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>throw</span> e
      <span>}</span>
    <span>}</span> <span>finally</span> <span>{</span>
      <span>// "touch" every property so they are all tracked as</span>
      <span>// dependencies for deep watching</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>deep<span>)</span> <span>{</span>
        <span>traverse</span><span>(</span>value<span>)</span>
      <span>}</span>
      <span>popTarget</span><span>(</span><span>)</span>
      <span>this</span><span>.</span><span>cleanupDeps</span><span>(</span><span>)</span>
    <span>}</span>
    <span>return</span> value
  <span>}</span>

  <span>/**
   * Add a dependency to this directive.
   */</span>
  <span>addDep</span> <span>(</span><span><span>dep</span><span>:</span> Dep</span><span>)</span> <span>{</span>
    <span>const</span> id <span>=</span> dep<span>.</span>id
    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>newDepIds<span>.</span><span>has</span><span>(</span>id<span>)</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>newDepIds<span>.</span><span>add</span><span>(</span>id<span>)</span>
      <span>this</span><span>.</span>newDeps<span>.</span><span>push</span><span>(</span>dep<span>)</span>
      <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>depIds<span>.</span><span>has</span><span>(</span>id<span>)</span><span>)</span> <span>{</span>
        dep<span>.</span><span>addSub</span><span>(</span><span>this</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>/**
   * Clean up for dependency collection.
   */</span>
  <span>cleanupDeps</span> <span>(</span><span>)</span> <span>{</span>
    <span>let</span> i <span>=</span> <span>this</span><span>.</span>deps<span>.</span>length
    <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
      <span>const</span> dep <span>=</span> <span>this</span><span>.</span>deps<span>[</span>i<span>]</span>
      <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>newDepIds<span>.</span><span>has</span><span>(</span>dep<span>.</span>id<span>)</span><span>)</span> <span>{</span>
        dep<span>.</span><span>removeSub</span><span>(</span><span>this</span><span>)</span>
      <span>}</span>
    <span>}</span>
    <span>let</span> tmp <span>=</span> <span>this</span><span>.</span>depIds
    <span>this</span><span>.</span>depIds <span>=</span> <span>this</span><span>.</span>newDepIds
    <span>this</span><span>.</span>newDepIds <span>=</span> tmp
    <span>this</span><span>.</span>newDepIds<span>.</span><span>clear</span><span>(</span><span>)</span>
    tmp <span>=</span> <span>this</span><span>.</span>deps
    <span>this</span><span>.</span>deps <span>=</span> <span>this</span><span>.</span>newDeps
    <span>this</span><span>.</span>newDeps <span>=</span> tmp
    <span>this</span><span>.</span>newDeps<span>.</span>length <span>=</span> <span>0</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Watcher</code> 是一个 Class，在它的构造函数中，定义了一些和 <code>Dep</code> 相关的属性：</p>
<div><pre><code><span>this</span><span>.</span>deps <span>=</span> <span>[</span><span>]</span>
<span>this</span><span>.</span>newDeps <span>=</span> <span>[</span><span>]</span>
<span>this</span><span>.</span>depIds <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
<span>this</span><span>.</span>newDepIds <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>其中，<code>this.deps</code> 和 <code>this.newDeps</code> 表示 <code>Watcher</code> 实例持有的 <code>Dep</code> 实例的数组；而 <code>this.depIds</code> 和 <code>this.newDepIds</code> 分别代表 <code>this.deps</code> 和 <code>this.newDeps</code> 的 <code>id</code> Set（这个 Set 是 ES6 的数据结构，它的实现在 <code>src/core/util/env.js</code> 中）。那么这里为何需要有 2 个 <code>Dep</code> 实例数组呢，稍后我们会解释。</p>
<p><code>Watcher</code> 还定义了一些原型的方法，和依赖收集相关的有 <code>get</code>、<code>addDep</code> 和 <code>cleanupDeps</code> 方法，单个介绍它们的实现不方便理解，我会结合整个依赖收集的过程把这几个方法讲清楚。</p>
<h2 id="过程分析" tabindex="-1"> 过程分析</h2>
<p>之前我们介绍当对数据对象的访问会触发他们的 getter 方法，那么这些对象什么时候被访问呢？还记得之前我们介绍过 Vue 的 mount 过程是通过 <code>mountComponent</code> 函数，其中有一段比较重要的逻辑，大致如下：</p>
<div><pre><code><span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
<span>}</span>
<span>new</span> <span>Watcher</span><span>(</span>vm<span>,</span> updateComponent<span>,</span> noop<span>,</span> <span>{</span>
  <span>before</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>vm<span>.</span>_isMounted<span>)</span> <span>{</span>
      <span>callHook</span><span>(</span>vm<span>,</span> <span>'beforeUpdate'</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>,</span> <span>true</span> <span>/* isRenderWatcher */</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当我们去实例化一个渲染 <code>watcher</code> 的时候，首先进入 <code>watcher</code> 的构造函数逻辑，然后会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，首先会执行：</p>
<div><pre><code><span>pushTarget</span><span>(</span><span>this</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>pushTarget</code> 的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>pushTarget</span> <span>(</span><span><span>_target</span><span>:</span> Watcher</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> targetStack<span>.</span><span>push</span><span>(</span>Dep<span>.</span>target<span>)</span>
  Dep<span>.</span>target <span>=</span> _target
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈（为了恢复用）。接着又执行了：</p>
<div><pre><code>value <span>=</span> <span>this</span><span>.</span><span>getter</span><span>.</span><span>call</span><span>(</span>vm<span>,</span> vm<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>this.getter</code> 对应就是 <code>updateComponent</code> 函数，这实际上就是在执行：</p>
<div><pre><code>vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>它会先执行 <code>vm._render()</code> 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 <code>vm</code> 上的数据访问，这个时候就触发了数据对象的 getter。</p>
<p>那么每个对象值的 getter 都持有一个 <code>dep</code>，在触发 getter 的时候会调用 <code>dep.depend()</code> 方法，也就会执行 <code>Dep.target.addDep(this)</code>。</p>
<p>刚才我们提到这个时候 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code>，那么就执行到 <code>addDep</code> 方法：</p>
<div><pre><code><span>addDep</span> <span>(</span><span><span>dep</span><span>:</span> Dep</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> dep<span>.</span>id
  <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>newDepIds<span>.</span><span>has</span><span>(</span>id<span>)</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>newDepIds<span>.</span><span>add</span><span>(</span>id<span>)</span>
    <span>this</span><span>.</span>newDeps<span>.</span><span>push</span><span>(</span>dep<span>)</span>
    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>depIds<span>.</span><span>has</span><span>(</span>id<span>)</span><span>)</span> <span>{</span>
      dep<span>.</span><span>addSub</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code>，也就是说把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，这个目的是为后续数据变化时候能通知到哪些 <code>subs</code> 做准备。</p>
<p>所以在 <code>vm._render()</code> 过程中，会触发所有数据的 getter，这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了么，其实并没有，在完成依赖收集后，还有几个逻辑要执行，首先是：</p>
<div><pre><code><span>if</span> <span>(</span><span>this</span><span>.</span>deep<span>)</span> <span>{</span>
  <span>traverse</span><span>(</span>value<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这个是要递归去访问 <code>value</code>，触发它所有子项的 <code>getter</code>，这个之后会详细讲。接下来执行：</p>
<div><pre><code><span>popTarget</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>popTarget</code> 的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<div><pre><code>Dep<span>.</span>target <span>=</span> targetStack<span>.</span><span>pop</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染<code>Dep.target</code> 也需要改变。最后执行：</p>
<div><pre><code><span>this</span><span>.</span><span>cleanupDeps</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>其实很多人都分析过并了解到 Vue 有依赖收集的过程，但我几乎没有看到有人分析依赖清空的过程，其实这是大部分同学会忽视的一点，也是 Vue 考虑特别细的一点。</p>
<div><pre><code><span>cleanupDeps</span> <span>(</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> <span>this</span><span>.</span>deps<span>.</span>length
  <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
    <span>const</span> dep <span>=</span> <span>this</span><span>.</span>deps<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>newDepIds<span>.</span><span>has</span><span>(</span>dep<span>.</span>id<span>)</span><span>)</span> <span>{</span>
      dep<span>.</span><span>removeSub</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>let</span> tmp <span>=</span> <span>this</span><span>.</span>depIds
  <span>this</span><span>.</span>depIds <span>=</span> <span>this</span><span>.</span>newDepIds
  <span>this</span><span>.</span>newDepIds <span>=</span> tmp
  <span>this</span><span>.</span>newDepIds<span>.</span><span>clear</span><span>(</span><span>)</span>
  tmp <span>=</span> <span>this</span><span>.</span>deps
  <span>this</span><span>.</span>deps <span>=</span> <span>this</span><span>.</span>newDeps
  <span>this</span><span>.</span>newDeps <span>=</span> tmp
  <span>this</span><span>.</span>newDeps<span>.</span>length <span>=</span> <span>0</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>考虑到 Vue 是数据驱动的，所以每次数据变化都会重新 render，那么 <code>vm._render()</code> 方法又会再次执行，并再次触发数据的 getters，所以 <code>Watcher</code> 在构造函数中会初始化 2 个 <code>Dep</code> 实例数组，<code>newDeps</code> 表示新添加的 <code>Dep</code> 实例数组，而 <code>deps</code> 表示上一次添加的 <code>Dep</code> 实例数组。</p>
<p>在执行 <code>cleanupDeps</code> 函数的时候，会首先遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Wathcer</code> 的订阅，然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换，并把 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</p>
<p>那么为什么需要做 <code>deps</code> 订阅的移除呢，在添加 <code>deps</code> 的订阅过程，已经能通过 <code>id</code> 去重避免重复订阅了。</p>
<p>考虑到一种场景，我们的模板会根据 <code>v-if</code> 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。</p>
<p>因此 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了，所以不会有任何浪费，真的是非常赞叹 Vue 对一些细节上的处理。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节的分析，我们对 Vue 数据的依赖收集过程已经有了认识，并且对这其中的一些细节做了分析。收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新，其实 <code>Watcher</code> 和 <code>Dep</code> 就是一个非常经典的观察者设计模式的实现，下一节我们来详细分析一下派发更新的过程。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">深入响应式原理</title>
    <id>https://0808200.xyz/vue2/reactive/</id>
    <link href="https://0808200.xyz/vue2/reactive/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="深入响应式原理" tabindex="-1"> 深入响应式原理</h1>
<p>前面 2 章介绍的都是 Vue 怎么实现数据渲染和组件化的，主要讲的是初始化的过程，把原始的数据最终映射到 DOM 中，但并没有涉及到数据变化到 DOM 变化的部分。而 Vue 的数据驱动除了数据渲染 DOM 之外，还有一个很重要的体现就是数据的变更会触发 DOM 的变化。</p>
<p>其实前端开发最重要的 2 个工作，一个是把数据渲染到页面，另一个是处理用户交互。Vue 把数据渲染到页面的能力我们已经通过源码分析出其中的原理了，但是由于一些用户交互或者是其它方面导致数据发生变化重新对页面渲染的原理我们还未分析。</p>
<p>考虑如下示例：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>changeMsg<span>"</span></span><span>></span></span>
  {{ message }}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>'Hello Vue!'</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>changeMsg</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>message <span>=</span> <span>'Hello World!'</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当我们去修改 <code>this.message</code> 的时候，模板对应的插值也会渲染成新的数据，那么这一切是怎么做到的呢？</p>
<p>在分析前，我们先直观的想一下，如果不用 Vue 的话，我们会通过最简单的方法实现这个需求：监听点击事件，修改数据，手动操作 DOM 重新渲染。这个过程和使用 Vue 的最大区别就是多了一步“手动操作 DOM 重新渲染”。这一步看上去并不多，但它背后又潜在的几个要处理的问题：</p>
<ol>
<li>
<p>我需要修改哪块的 DOM？</p>
</li>
<li>
<p>我的修改效率和性能是不是最优的？</p>
</li>
<li>
<p>我需要对数据每一次的修改都去操作 DOM 吗？</p>
</li>
<li>
<p>我需要 case by case 去写修改 DOM 的逻辑吗？</p>
</li>
</ol>
<p>如果我们使用了 Vue，那么上面几个问题 Vue 内部就帮你做了，那么 Vue 是如何在我们对数据修改后自动做这些事情呢，接下来我们将进入一些 Vue 响应式系统的底层的细节。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">nextTick</title>
    <id>https://0808200.xyz/vue2/reactive/next-tick.html</id>
    <link href="https://0808200.xyz/vue2/reactive/next-tick.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nexttick" tabindex="-1"> nextTick</h1>
<p><code>nextTick</code> 是 Vue 的一个核心实现，在介绍 Vue 的 nextTick 之前，为了方便大家理解，我先简单介绍一下 JS 的运行机制。</p>
<h2 id="js-运行机制" tabindex="-1"> JS 运行机制</h2>
<p>JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：</p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</p>
<p>（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<img :src="$withBase('/assets/event-loop.png')"/>
<p>主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。</p>
<p>关于 macro task 和 micro task 的概念，这里不会细讲，简单通过一段代码演示他们的执行顺序：</p>
<div><pre><code><span>for</span> <span>(</span>macroTask <span>of</span> macroTaskQueue<span>)</span> <span>{</span>
    <span>// 1. Handle current MACRO-TASK</span>
    <span>handleMacroTask</span><span>(</span><span>)</span><span>;</span>
      
    <span>// 2. Handle all MICRO-TASK</span>
    <span>for</span> <span>(</span>microTask <span>of</span> microTaskQueue<span>)</span> <span>{</span>
        <span>handleMicroTask</span><span>(</span>microTask<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then。</p>
<h2 id="vue-的实现" tabindex="-1"> Vue 的实现</h2>
<p>在 Vue 源码 2.5+ 后，<code>nextTick</code> 的实现单独有一个 JS 文件来维护它，它的源码并不多，总共也就 100 多行。接下来我们来看一下它的实现，在 <code>src/core/util/next-tick.js</code> 中：</p>
<div><pre><code><span>import</span> <span>{</span> noop <span>}</span> <span>from</span> <span>'shared/util'</span>
<span>import</span> <span>{</span> handleError <span>}</span> <span>from</span> <span>'./error'</span>
<span>import</span> <span>{</span> isIOS<span>,</span> isNative <span>}</span> <span>from</span> <span>'./env'</span>

<span>const</span> callbacks <span>=</span> <span>[</span><span>]</span>
<span>let</span> pending <span>=</span> <span>false</span>

<span>function</span> <span>flushCallbacks</span> <span>(</span><span>)</span> <span>{</span>
  pending <span>=</span> <span>false</span>
  <span>const</span> copies <span>=</span> callbacks<span>.</span><span>slice</span><span>(</span><span>0</span><span>)</span>
  callbacks<span>.</span>length <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> copies<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    copies<span>[</span>i<span>]</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span>
<span>// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span>
<span>// microtasks have too high a priority and fire in between supposedly</span>
<span>// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span>
<span>// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span>
<span>// when state is changed right before repaint (e.g. #6813, out-in transitions).</span>
<span>// Here we use microtask by default, but expose a way to force (macro) task when</span>
<span>// needed (e.g. in event handlers attached by v-on).</span>
<span>let</span> microTimerFunc
<span>let</span> macroTimerFunc
<span>let</span> useMacroTask <span>=</span> <span>false</span>

<span>// Determine (macro) task defer implementation.</span>
<span>// Technically setImmediate should be the ideal choice, but it's only available</span>
<span>// in IE. The only polyfill that consistently queues the callback after all DOM</span>
<span>// events triggered in the same loop is by using MessageChannel.</span>
<span>/* istanbul ignore if */</span>
<span>if</span> <span>(</span><span>typeof</span> setImmediate <span>!==</span> <span>'undefined'</span> <span>&amp;&amp;</span> <span>isNative</span><span>(</span>setImmediate<span>)</span><span>)</span> <span>{</span>
  <span>macroTimerFunc</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>setImmediate</span><span>(</span>flushCallbacks<span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> MessageChannel <span>!==</span> <span>'undefined'</span> <span>&amp;&amp;</span> <span>(</span>
  <span>isNative</span><span>(</span>MessageChannel<span>)</span> <span>||</span>
  <span>// PhantomJS</span>
  MessageChannel<span>.</span><span>toString</span><span>(</span><span>)</span> <span>===</span> <span>'[object MessageChannelConstructor]'</span>
<span>)</span><span>)</span> <span>{</span>
  <span>const</span> channel <span>=</span> <span>new</span> <span>MessageChannel</span><span>(</span><span>)</span>
  <span>const</span> port <span>=</span> channel<span>.</span>port2
  channel<span>.</span>port1<span>.</span>onmessage <span>=</span> flushCallbacks
  <span>macroTimerFunc</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    port<span>.</span><span>postMessage</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>/* istanbul ignore next */</span>
  <span>macroTimerFunc</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span>flushCallbacks<span>,</span> <span>0</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// Determine microtask defer implementation.</span>
<span>/* istanbul ignore next, $flow-disable-line */</span>
<span>if</span> <span>(</span><span>typeof</span> Promise <span>!==</span> <span>'undefined'</span> <span>&amp;&amp;</span> <span>isNative</span><span>(</span>Promise<span>)</span><span>)</span> <span>{</span>
  <span>const</span> p <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>)</span>
  <span>microTimerFunc</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    p<span>.</span><span>then</span><span>(</span>flushCallbacks<span>)</span>
    <span>// in problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span>// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span>// microtask queue but the queue isn't being flushed, until the browser</span>
    <span>// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span>// "force" the microtask queue to be flushed by adding an empty timer.</span>
    <span>if</span> <span>(</span>isIOS<span>)</span> <span>setTimeout</span><span>(</span>noop<span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// fallback to macro</span>
  microTimerFunc <span>=</span> macroTimerFunc
<span>}</span>

<span>/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */</span>
<span>export</span> <span>function</span> <span>withMacroTask</span> <span>(</span><span><span>fn</span><span>:</span> Function</span><span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> fn<span>.</span>_withTask <span>||</span> <span>(</span>fn<span>.</span><span>_withTask</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    useMacroTask <span>=</span> <span>true</span>
    <span>const</span> res <span>=</span> <span>fn</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> arguments<span>)</span>
    useMacroTask <span>=</span> <span>false</span>
    <span>return</span> res
  <span>}</span><span>)</span>
<span>}</span>

<span>export</span> <span>function</span> <span>nextTick</span> <span>(</span><span>cb<span>?</span><span>:</span> Function<span>,</span> ctx<span>?</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>let</span> _resolve
  callbacks<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>cb<span>)</span> <span>{</span>
      <span>try</span> <span>{</span>
        <span>cb</span><span>.</span><span>call</span><span>(</span>ctx<span>)</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
        <span>handleError</span><span>(</span>e<span>,</span> ctx<span>,</span> <span>'nextTick'</span><span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>_resolve<span>)</span> <span>{</span>
      <span>_resolve</span><span>(</span>ctx<span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>if</span> <span>(</span><span>!</span>pending<span>)</span> <span>{</span>
    pending <span>=</span> <span>true</span>
    <span>if</span> <span>(</span>useMacroTask<span>)</span> <span>{</span>
      <span>macroTimerFunc</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>microTimerFunc</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>// $flow-disable-line</span>
  <span>if</span> <span>(</span><span>!</span>cb <span>&amp;&amp;</span> <span>typeof</span> Promise <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>
      _resolve <span>=</span> resolve
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>next-tick.js</code> 申明了 <code>microTimerFunc</code> 和 <code>macroTimerFunc</code> 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。对于 macro task 的实现，优先检测是否支持原生 <code>setImmediate</code>，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 <code>MessageChannel</code>，如果也不支持的话就会降级为 <code>setTimeout 0</code>；而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。</p>
<p><code>next-tick.js</code> 对外暴露了 2 个函数，先来看 <code>nextTick</code>，这就是我们在上一节执行 <code>nextTick(flushSchedulerQueue)</code> 所用到的函数。它的逻辑也很简单，把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>macroTimerFunc</code> 或者是 <code>microTimerFunc</code>，而它们都会在下一个 tick 执行 <code>flushCallbacks</code>，<code>flushCallbacks</code> 的逻辑非常简单，对 <code>callbacks</code> 遍历，然后执行相应的回调函数。</p>
<p>这里使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因是保证在同一个 tick 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。</p>
<p><code>nextTick</code> 函数最后还有一段逻辑：</p>
<div><pre><code> <span>if</span> <span>(</span><span>!</span>cb <span>&amp;&amp;</span> <span>typeof</span> Promise <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>
    _resolve <span>=</span> resolve
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这是当 <code>nextTick</code> 不传 <code>cb</code> 参数的时候，提供一个 Promise 化的调用，比如：</p>
<div><pre><code><span>nextTick</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>当 <code>_resolve</code> 函数执行，就会跳到 <code>then</code> 的逻辑中。</p>
<p><code>next-tick.js</code> 还对外暴露了 <code>withMacroTask</code> 函数，它是对函数做一层包装，确保函数执行过程中对数据任意的修改，触发变化执行 <code>nextTick</code> 的时候强制走 <code>macroTimerFunc</code>。比如对于一些 DOM 交互事件，如 <code>v-on</code> 绑定的事件回调函数的处理，会强制走 macro task。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节对 <code>nextTick</code> 的分析，并结合上一节的 setter 分析，我们了解到数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。这就是我们平时在开发的过程中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 <code>nextTick</code> 后执行。比如下面的伪代码：</p>
<div><pre><code><span>getData</span><span>(</span>res<span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span><span>=></span><span>{</span>
  <span>this</span><span>.</span>xxx <span>=</span> res<span>.</span>data
  <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 这里我们可以获取变化后的 DOM</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Vue.js 提供了 2 种调用 <code>nextTick</code> 的方式，一种是全局 API <code>Vue.nextTick</code>，一种是实例上的方法 <code>vm.$nextTick</code>，无论我们使用哪一种，最后都是调用 <code>next-tick.js</code> 中实现的 <code>nextTick</code> 方法。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Props (v2.6.11)</title>
    <id>https://0808200.xyz/vue2/reactive/props.html</id>
    <link href="https://0808200.xyz/vue2/reactive/props.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="props-v2-6-11" tabindex="-1"> Props (v2.6.11)</h1>
<p><code>Props</code> 作为组件的核心特性之一，也是我们平时开发 Vue 项目中接触最多的特性之一，它可以让组件的功能变得丰富，也是父子组件通讯的一个渠道。那么它的实现原理是怎样的，我们来一探究竟。</p>
<h2 id="规范化" tabindex="-1"> 规范化</h2>
<p>在初始化 <code>props</code> 之前，首先会对 <code>props</code> 做一次 <code>normalize</code>，它发生在 <code>mergeOptions</code> 的时候，在 <code>src/core/util/options.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>mergeOptions</span> <span>(</span>
  <span><span>parent</span><span>:</span> Object<span>,</span>
  <span>child</span><span>:</span> Object<span>,</span>
  vm<span>?</span><span>:</span> Component</span>
<span>)</span><span>:</span> Object <span>{</span>
  <span>// ...</span>
  <span>normalizeProps</span><span>(</span>child<span>,</span> vm<span>)</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>normalizeProps</span> <span>(</span><span><span>options</span><span>:</span> Object<span>,</span> <span>vm</span><span>:</span> <span>?</span>Component</span><span>)</span> <span>{</span>
  <span>const</span> props <span>=</span> options<span>.</span>props
  <span>if</span> <span>(</span><span>!</span>props<span>)</span> <span>return</span>
  <span>const</span> res <span>=</span> <span>{</span><span>}</span>
  <span>let</span> i<span>,</span> val<span>,</span> name
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>props<span>)</span><span>)</span> <span>{</span>
    i <span>=</span> props<span>.</span>length
    <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
      val <span>=</span> props<span>[</span>i<span>]</span>
      <span>if</span> <span>(</span><span>typeof</span> val <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
        name <span>=</span> <span>camelize</span><span>(</span>val<span>)</span>
        res<span>[</span>name<span>]</span> <span>=</span> <span>{</span> <span>type</span><span>:</span> <span>null</span> <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span><span>'props must be strings when using array syntax.'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isPlainObject</span><span>(</span>props<span>)</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> props<span>)</span> <span>{</span>
      val <span>=</span> props<span>[</span>key<span>]</span>
      name <span>=</span> <span>camelize</span><span>(</span>key<span>)</span>
      res<span>[</span>name<span>]</span> <span>=</span> <span>isPlainObject</span><span>(</span>val<span>)</span>
        <span>?</span> val
        <span>:</span> <span>{</span> <span>type</span><span>:</span> val <span>}</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span><span>`</span><span>Invalid value for option "props": expected an Array or an Object, </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>but got </span><span><span>${</span><span>toRawType</span><span>(</span>props<span>)</span><span>}</span></span><span>.</span><span>`</span></span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  options<span>.</span>props <span>=</span> res
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>合并配置我们在组件化章节讲过，它主要就是处理我们定义组件的对象 <code>option</code>，然后挂载到组件的实例 <code>this.$options</code> 中。</p>
<p>我们接下来重点看 <code>normalizeProps</code> 的实现，其实这个函数的主要目的就是把我们编写的 <code>props</code> 转成对象格式，因为实际上 <code>props</code> 除了对象格式，还允许写成数组格式。</p>
<p>当 <code>props</code> 是一个数组，每一个数组元素 <code>prop</code> 只能是一个 <code>string</code>，表示 <code>prop</code> 的 <code>key</code>，转成驼峰格式，<code>prop</code> 的类型为空。</p>
<p>当 <code>props</code> 是一个对象，对于 <code>props</code> 中每个 <code>prop</code> 的 <code>key</code>，我们会转驼峰格式，而它的 <code>value</code>，如果不是一个对象，我们就把它规范成一个对象。</p>
<p>如果 <code>props</code> 既不是数组也不是对象，就抛出一个警告。</p>
<p>举个例子：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>props</span><span>:</span> <span>[</span><span>'name'</span><span>,</span> <span>'nick-name'</span><span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>经过 <code>normalizeProps</code> 后，会被规范成：</p>
<div><pre><code>options<span>.</span>props <span>=</span> <span>{</span>
  <span>name</span><span>:</span> <span>{</span> <span>type</span><span>:</span> <span>null</span> <span>}</span><span>,</span>
  <span>nickName</span><span>:</span> <span>{</span> <span>type</span><span>:</span> <span>null</span> <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>name</span><span>:</span> String<span>,</span>
    <span>nickName</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> Boolean
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>经过 <code>normalizeProps</code> 后，会被规范成：</p>
<div><pre><code>options<span>.</span>props <span>=</span> <span>{</span>
  <span>name</span><span>:</span> <span>{</span> <span>type</span><span>:</span> String <span>}</span><span>,</span>
  <span>nickName</span><span>:</span> <span>{</span> <span>type</span><span>:</span> Boolean <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>由于对象形式的 <code>props</code> 可以指定每个 <code>prop</code> 的类型和定义其它的一些属性，推荐用对象形式定义 <code>props</code>。</p>
<h2 id="初始化" tabindex="-1"> 初始化</h2>
<p><code>Props</code> 的初始化主要发生在 <code>new Vue</code> 中的 <code>initState</code> 阶段，在 <code>src/core/instance/state.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initState</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  <span>// ....</span>
  <span>const</span> opts <span>=</span> vm<span>.</span>$options
  <span>if</span> <span>(</span>opts<span>.</span>props<span>)</span> <span>initProps</span><span>(</span>vm<span>,</span> opts<span>.</span>props<span>)</span>
  <span>// ...</span>
<span>}</span>


<span>function</span> <span>initProps</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>propsOptions</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>const</span> propsData <span>=</span> vm<span>.</span>$options<span>.</span>propsData <span>||</span> <span>{</span><span>}</span>
  <span>const</span> props <span>=</span> vm<span>.</span>_props <span>=</span> <span>{</span><span>}</span>
  <span>// cache prop keys so that future props updates can iterate using Array</span>
  <span>// instead of dynamic object key enumeration.</span>
  <span>const</span> keys <span>=</span> vm<span>.</span>$options<span>.</span>_propKeys <span>=</span> <span>[</span><span>]</span>
  <span>const</span> isRoot <span>=</span> <span>!</span>vm<span>.</span>$parent
  <span>// root instance props should be converted</span>
  <span>if</span> <span>(</span><span>!</span>isRoot<span>)</span> <span>{</span>
    <span>toggleObserving</span><span>(</span><span>false</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> propsOptions<span>)</span> <span>{</span>
    keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
    <span>const</span> value <span>=</span> <span>validateProp</span><span>(</span>key<span>,</span> propsOptions<span>,</span> propsData<span>,</span> vm<span>)</span>
    <span>/* istanbul ignore else */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>const</span> hyphenatedKey <span>=</span> <span>hyphenate</span><span>(</span>key<span>)</span>
      <span>if</span> <span>(</span><span>isReservedAttribute</span><span>(</span>hyphenatedKey<span>)</span> <span>||</span>
          config<span>.</span><span>isReservedAttr</span><span>(</span>hyphenatedKey<span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>"</span><span><span>${</span>hyphenatedKey<span>}</span></span><span>" is a reserved attribute and cannot be used as component prop.</span><span>`</span></span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
      <span>defineReactive</span><span>(</span>props<span>,</span> key<span>,</span> value<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>isRoot <span>&amp;&amp;</span> <span>!</span>isUpdatingChildComponent<span>)</span> <span>{</span>
          <span>warn</span><span>(</span>
            <span><span>`</span><span>Avoid mutating a prop directly since the value will be </span><span>`</span></span> <span>+</span>
            <span><span>`</span><span>overwritten whenever the parent component re-renders. </span><span>`</span></span> <span>+</span>
            <span><span>`</span><span>Instead, use a data or computed property based on the prop's </span><span>`</span></span> <span>+</span>
            <span><span>`</span><span>value. Prop being mutated: "</span><span><span>${</span>key<span>}</span></span><span>"</span><span>`</span></span><span>,</span>
            vm
          <span>)</span>
        <span>}</span>
      <span>}</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>defineReactive</span><span>(</span>props<span>,</span> key<span>,</span> value<span>)</span>
    <span>}</span>
    <span>// static props are already proxied on the component's prototype</span>
    <span>// during Vue.extend(). We only need to proxy props defined at</span>
    <span>// instantiation here.</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>key <span>in</span> vm<span>)</span><span>)</span> <span>{</span>
      <span>proxy</span><span>(</span>vm<span>,</span> <span><span>`</span><span>_props</span><span>`</span></span><span>,</span> key<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>initProps</code> 主要做 3 件事情：校验、响应式和代理。</p>
<h3 id="校验" tabindex="-1"> 校验</h3>
<p>校验的逻辑很简单，遍历 <code>propsOptions</code>，执行 <code>validateProp(key, propsOptions, propsData, vm)</code> 方法。这里的 <code>propsOptions</code> 就是我们定义的 <code>props</code> 在规范后生成的 <code>options.props</code> 对象，<code>propsData</code> 是从父组件传递的 <code>prop</code> 数据。所谓校验的目的就是检查一下我们传递的数据是否满足 <code>prop </code>的定义规范。再来看一下 <code>validateProp</code> 方法，它定义在 <code>src/core/util/props.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>validateProp</span> <span>(</span>
  <span><span>key</span><span>:</span> string<span>,</span>
  <span>propOptions</span><span>:</span> Object<span>,</span>
  <span>propsData</span><span>:</span> Object<span>,</span>
  vm<span>?</span><span>:</span> Component</span>
<span>)</span><span>:</span> any <span>{</span>
  <span>const</span> prop <span>=</span> propOptions<span>[</span>key<span>]</span>
  <span>const</span> absent <span>=</span> <span>!</span><span>hasOwn</span><span>(</span>propsData<span>,</span> key<span>)</span>
  <span>let</span> value <span>=</span> propsData<span>[</span>key<span>]</span>
  <span>// boolean casting</span>
  <span>const</span> booleanIndex <span>=</span> <span>getTypeIndex</span><span>(</span>Boolean<span>,</span> prop<span>.</span>type<span>)</span>
  <span>if</span> <span>(</span>booleanIndex <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>absent <span>&amp;&amp;</span> <span>!</span><span>hasOwn</span><span>(</span>prop<span>,</span> <span>'default'</span><span>)</span><span>)</span> <span>{</span>
      value <span>=</span> <span>false</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>value <span>===</span> <span>''</span> <span>||</span> value <span>===</span> <span>hyphenate</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
      <span>// only cast empty string / same name to boolean if</span>
      <span>// boolean has higher priority</span>
      <span>const</span> stringIndex <span>=</span> <span>getTypeIndex</span><span>(</span>String<span>,</span> prop<span>.</span>type<span>)</span>
      <span>if</span> <span>(</span>stringIndex <span>&lt;</span> <span>0</span> <span>||</span> booleanIndex <span>&lt;</span> stringIndex<span>)</span> <span>{</span>
        value <span>=</span> <span>true</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>// check default value</span>
  <span>if</span> <span>(</span>value <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
    value <span>=</span> <span>getPropDefaultValue</span><span>(</span>vm<span>,</span> prop<span>,</span> key<span>)</span>
    <span>// since the default value is a fresh copy,</span>
    <span>// make sure to observe it.</span>
    <span>const</span> prevShouldObserve <span>=</span> shouldObserve
    <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
    <span>observe</span><span>(</span>value<span>)</span>
    <span>toggleObserving</span><span>(</span>prevShouldObserve<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    <span>// skip validation for weex recycle-list child component props</span>
    <span>!</span><span>(</span>__WEEX__ <span>&amp;&amp;</span> <span>isObject</span><span>(</span>value<span>)</span> <span>&amp;&amp;</span> <span>(</span><span>'@binding'</span> <span>in</span> value<span>)</span><span>)</span>
  <span>)</span> <span>{</span>
    <span>assertProp</span><span>(</span>prop<span>,</span> key<span>,</span> value<span>,</span> vm<span>,</span> absent<span>)</span>
  <span>}</span>
  <span>return</span> value
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>validateProp</code> 主要就做 3 件事情：处理 <code>Boolean</code> 类型的数据，处理默认数据，<code>prop</code> 断言，并最终返回 <code>prop</code> 的值。</p>
<p>先来看 <code>Boolean</code> 类型数据的处理逻辑：</p>
<div><pre><code><span>const</span> prop <span>=</span> propOptions<span>[</span>key<span>]</span>
<span>const</span> absent <span>=</span> <span>!</span><span>hasOwn</span><span>(</span>propsData<span>,</span> key<span>)</span>
<span>let</span> value <span>=</span> propsData<span>[</span>key<span>]</span>
<span>// boolean casting</span>
<span>const</span> booleanIndex <span>=</span> <span>getTypeIndex</span><span>(</span>Boolean<span>,</span> prop<span>.</span>type<span>)</span>
<span>if</span> <span>(</span>booleanIndex <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>absent <span>&amp;&amp;</span> <span>!</span><span>hasOwn</span><span>(</span>prop<span>,</span> <span>'default'</span><span>)</span><span>)</span> <span>{</span>
    value <span>=</span> <span>false</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>value <span>===</span> <span>''</span> <span>||</span> value <span>===</span> <span>hyphenate</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
    <span>// only cast empty string / same name to boolean if</span>
    <span>// boolean has higher priority</span>
    <span>const</span> stringIndex <span>=</span> <span>getTypeIndex</span><span>(</span>String<span>,</span> prop<span>.</span>type<span>)</span>
    <span>if</span> <span>(</span>stringIndex <span>&lt;</span> <span>0</span> <span>||</span> booleanIndex <span>&lt;</span> stringIndex<span>)</span> <span>{</span>
      value <span>=</span> <span>true</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>先通过 <code>const booleanIndex = getTypeIndex(Boolean, prop.type)</code> 来判断 <code>prop</code> 的定义是否是 <code>Boolean</code> 类型的。</p>
<div><pre><code><span>function</span> <span>getType</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>const</span> match <span>=</span> fn <span>&amp;&amp;</span> fn<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>^\s*function (\w+)</span><span>/</span></span><span>)</span>
  <span>return</span> match <span>?</span> match<span>[</span><span>1</span><span>]</span> <span>:</span> <span>''</span>
<span>}</span>

<span>function</span> <span>isSameType</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
  <span>return</span> <span>getType</span><span>(</span>a<span>)</span> <span>===</span> <span>getType</span><span>(</span>b<span>)</span>
<span>}</span>

<span>function</span> <span>getTypeIndex</span> <span>(</span><span>type<span>,</span> expectedTypes</span><span>)</span><span>:</span> number <span>{</span>
  <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>expectedTypes<span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span>isSameType</span><span>(</span>expectedTypes<span>,</span> type<span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>-</span><span>1</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> expectedTypes<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isSameType</span><span>(</span>expectedTypes<span>[</span>i<span>]</span><span>,</span> type<span>)</span><span>)</span> <span>{</span>
      <span>return</span> i
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>-</span><span>1</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>getTypeIndex</code> 函数就是找到 <code>type</code> 和 <code>expectedTypes</code> 匹配的索引并返回。</p>
<p><code>prop</code> 类型定义的时候可以是某个原生构造函数，也可以是原生构造函数的数组，比如：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>name</span><span>:</span> String<span>,</span>
    <span>value</span><span>:</span> <span>[</span>String<span>,</span> Boolean<span>]</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果 <code>expectedTypes</code> 是单个构造函数，就执行 <code>isSameType</code> 去判断是否是同一个类型；如果是数组，那么就遍历这个数组，找到第一个同类型的，返回它的索引。</p>
<p>回到 <code>validateProp</code> 函数，通过 <code>const booleanIndex = getTypeIndex(Boolean, prop.type)</code> 得到 <code>booleanIndex</code>，如果 <code>prop.type</code> 是一个 <code>Boolean</code> 类型，则通过 <code>absent &amp;&amp; !hasOwn(prop, 'default')</code> 来判断如果父组件没有传递这个 <code>prop</code> 数据并且没有设置 <code>default</code> 的情况，则 <code>value</code> 为 false。</p>
<p>接着判断<code>value === '' || value === hyphenate(key)</code> 的情况，如果满足则先通过 <code>const stringIndex = getTypeIndex(String, prop.type)</code> 获取匹配 <code>String</code> 类型的索引，然后判断 <code>stringIndex &lt; 0 || booleanIndex &lt; stringIndex</code> 的值来决定 <code>value</code> 的值是否为 <code>true</code>。这块逻辑稍微有点绕，我们举 2 个例子来说明：</p>
<p>例如你定义一个组件 <code>Student</code>:</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> String<span>,</span>
  <span>nickName</span><span>:</span> <span>[</span>Boolean<span>,</span> String<span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>然后在父组件中引入这个组件：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>student</span> <span>name</span><span><span>=</span><span>"</span>Kate<span>"</span></span> <span>nick-name</span><span>></span></span><span><span><span>&lt;/</span>student</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>或者是：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>student</span> <span>name</span><span><span>=</span><span>"</span>Kate<span>"</span></span> <span>nick-name</span><span><span>=</span><span>"</span>nick-name<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>student</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>第一种情况没有写属性的值，满足 <code>value === ''</code>，第二种满足 <code>value === hyphenate(key)</code> 的情况，另外 <code>nickName</code> 这个 <code>prop</code> 的类型是 <code>Boolean</code> 或者是 <code>String</code>，并且满足 <code>booleanIndex &lt; stringIndex</code>，所以对 <code>nickName</code> 这个 <code>prop</code> 的 <code>value</code> 为 <code>true</code>。</p>
<p>接下来看一下默认数据处理逻辑：</p>
<div><pre><code><span>// check default value</span>
<span>if</span> <span>(</span>value <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
  value <span>=</span> <span>getPropDefaultValue</span><span>(</span>vm<span>,</span> prop<span>,</span> key<span>)</span>
  <span>// since the default value is a fresh copy,</span>
  <span>// make sure to observe it.</span>
  <span>const</span> prevShouldObserve <span>=</span> shouldObserve
  <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
  <span>observe</span><span>(</span>value<span>)</span>
  <span>toggleObserving</span><span>(</span>prevShouldObserve<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当 <code>value</code> 的值为 <code>undefined</code> 的时候，说明父组件根本就没有传这个 <code>prop</code>，那么我们就需要通过 <code>getPropDefaultValue(vm, prop, key)</code> 获取这个 <code>prop</code> 的默认值。我们这里只关注 <code>getPropDefaultValue</code> 的实现，<code>toggleObserving</code> 和 <code>observe</code> 的作用我们之后会说。</p>
<div><pre><code><span>function</span> <span>getPropDefaultValue</span> <span>(</span><span><span>vm</span><span>:</span> <span>?</span>Component<span>,</span> <span>prop</span><span>:</span> PropOptions<span>,</span> <span>key</span><span>:</span> string</span><span>)</span><span>:</span> any <span>{</span>
  <span>// no default, return undefined</span>
  <span>if</span> <span>(</span><span>!</span><span>hasOwn</span><span>(</span>prop<span>,</span> <span>'default'</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span>undefined</span>
  <span>}</span>
  <span>const</span> def <span>=</span> prop<span>.</span>default
  <span>// warn against non-factory defaults for Object &amp; Array</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>isObject</span><span>(</span>def<span>)</span><span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span>'Invalid default value for prop "'</span> <span>+</span> key <span>+</span> <span>'": '</span> <span>+</span>
      <span>'Props with type Object/Array must use a factory function '</span> <span>+</span>
      <span>'to return the default value.'</span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  <span>// the raw prop value was also undefined from previous render,</span>
  <span>// return previous default value to avoid unnecessary watcher trigger</span>
  <span>if</span> <span>(</span>vm <span>&amp;&amp;</span> vm<span>.</span>$options<span>.</span>propsData <span>&amp;&amp;</span>
    vm<span>.</span>$options<span>.</span>propsData<span>[</span>key<span>]</span> <span>===</span> <span>undefined</span> <span>&amp;&amp;</span>
    vm<span>.</span>_props<span>[</span>key<span>]</span> <span>!==</span> <span>undefined</span>
  <span>)</span> <span>{</span>
    <span>return</span> vm<span>.</span>_props<span>[</span>key<span>]</span>
  <span>}</span>
  <span>// call factory function for non-Function types</span>
  <span>// a value is Function if its prototype is function even across different execution context</span>
  <span>return</span> <span>typeof</span> def <span>===</span> <span>'function'</span> <span>&amp;&amp;</span> <span>getType</span><span>(</span>prop<span>.</span>type<span>)</span> <span>!==</span> <span>'Function'</span>
    <span>?</span> <span>def</span><span>.</span><span>call</span><span>(</span>vm<span>)</span>
    <span>:</span> def
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>检测如果 <code>prop</code> 没有定义 <code>default</code> 属性，那么返回 <code>undefined</code>，通过这块逻辑我们知道除了 <code>Boolean</code> 类型的数据，其余没有设置 <code>default</code> 属性的 <code>prop</code> 默认值都是 <code>undefined</code>。</p>
<p>接着是开发环境下对 <code>prop</code> 的默认值是否为对象或者数组类型的判断，如果是的话会报警告，因为对象和数组类型的 <code>prop</code>，他们的默认值必须要返回一个工厂函数。</p>
<p>接下来的判断是如果上一次组件渲染父组件传递的 <code>prop</code> 的值是 <code>undefined</code>，则直接返回 上一次的默认值 <code>vm._props[key]</code>，这样可以避免触发不必要的 <code>watcher</code> 的更新。</p>
<p>最后就是判断 <code>def</code> 如果是工厂函数且 <code>prop</code> 的类型不是 <code>Function</code> 的时候，返回工厂函数的返回值，否则直接返回 <code>def</code>。</p>
<p>至此，我们讲完了 <code>validateProp</code> 函数的 <code>Boolean</code> 类型数据的处理逻辑和默认数据处理逻辑，最后来看一下 <code>prop</code> 断言逻辑。</p>
<div><pre><code><span>if</span> <span>(</span>
process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
<span>// skip validation for weex recycle-list child component props</span>
<span>!</span><span>(</span>__WEEX__ <span>&amp;&amp;</span> <span>isObject</span><span>(</span>value<span>)</span> <span>&amp;&amp;</span> <span>(</span><span>'@binding'</span> <span>in</span> value<span>)</span><span>)</span>
<span>)</span> <span>{</span>
  <span>assertProp</span><span>(</span>prop<span>,</span> key<span>,</span> value<span>,</span> vm<span>,</span> absent<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在开发环境且非 <code>weex</code> 的某种环境下，执行 <code>assertProp</code> 做属性断言。</p>
<div><pre><code><span>function</span> <span>assertProp</span> <span>(</span>
  <span><span>prop</span><span>:</span> PropOptions<span>,</span>
  <span>name</span><span>:</span> string<span>,</span>
  <span>value</span><span>:</span> any<span>,</span>
  <span>vm</span><span>:</span> <span>?</span>Component<span>,</span>
  <span>absent</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>prop<span>.</span>required <span>&amp;&amp;</span> absent<span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span>'Missing required prop: "'</span> <span>+</span> name <span>+</span> <span>'"'</span><span>,</span>
      vm
    <span>)</span>
    <span>return</span>
  <span>}</span>
  <span>if</span> <span>(</span>value <span>==</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>prop<span>.</span>required<span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>let</span> type <span>=</span> prop<span>.</span>type
  <span>let</span> valid <span>=</span> <span>!</span>type <span>||</span> type <span>===</span> <span>true</span>
  <span>const</span> expectedTypes <span>=</span> <span>[</span><span>]</span>
  <span>if</span> <span>(</span>type<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>
      type <span>=</span> <span>[</span>type<span>]</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> type<span>.</span>length <span>&amp;&amp;</span> <span>!</span>valid<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>const</span> assertedType <span>=</span> <span>assertType</span><span>(</span>value<span>,</span> type<span>[</span>i<span>]</span><span>)</span>
      expectedTypes<span>.</span><span>push</span><span>(</span>assertedType<span>.</span>expectedType <span>||</span> <span>''</span><span>)</span>
      valid <span>=</span> assertedType<span>.</span>valid
    <span>}</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>!</span>valid<span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span>getInvalidTypeMessage</span><span>(</span>name<span>,</span> value<span>,</span> expectedTypes<span>)</span><span>,</span>
      vm
    <span>)</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> validator <span>=</span> prop<span>.</span>validator
  <span>if</span> <span>(</span>validator<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>validator</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'Invalid prop: custom validator check failed for prop "'</span> <span>+</span> name <span>+</span> <span>'".'</span><span>,</span>
        vm
      <span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>assertProp</code> 函数的目的是断言这个 <code>prop</code> 是否合法。</p>
<p>首先判断如果 <code>prop</code> 定义了 <code>required</code> 属性但父组件没有传递这个 <code>prop</code> 数据的话会报一个警告。</p>
<p>接着判断如果 <code>value</code> 为空且 <code>prop</code> 没有定义 <code>required</code> 属性则直接返回。</p>
<p>然后再去对 <code>prop</code> 的类型做校验，先是拿到 <code>prop</code> 中定义的类型 <code>type</code>，并尝试把它转成一个类型数组，然后依次遍历这个数组，执行 <code>assertType(value, type[i])</code> 去获取断言的结果，直到遍历完成或者是 <code>valid</code> 为 <code>true</code> 的时候跳出循环。</p>
<div><pre><code><span>const</span> simpleCheckRE <span>=</span> <span><span>/</span><span>^(String|Number|Boolean|Function|Symbol)$</span><span>/</span></span>
<span>function</span> <span>assertType</span> <span>(</span><span><span>value</span><span>:</span> any<span>,</span> <span>type</span><span>:</span> Function</span><span>)</span><span>:</span> <span>{</span>
  <span>valid</span><span>:</span> boolean<span>;</span>
  <span>expectedType</span><span>:</span> string<span>;</span>
<span>}</span> <span>{</span>
  <span>let</span> valid
  <span>const</span> expectedType <span>=</span> <span>getType</span><span>(</span>type<span>)</span>
  <span>if</span> <span>(</span>simpleCheckRE<span>.</span><span>test</span><span>(</span>expectedType<span>)</span><span>)</span> <span>{</span>
    <span>const</span> t <span>=</span> <span>typeof</span> value
    valid <span>=</span> t <span>===</span> expectedType<span>.</span><span>toLowerCase</span><span>(</span><span>)</span>
    <span>// for primitive wrapper objects</span>
    <span>if</span> <span>(</span><span>!</span>valid <span>&amp;&amp;</span> t <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
      valid <span>=</span> value <span>instanceof</span> <span>type</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>expectedType <span>===</span> <span>'Object'</span><span>)</span> <span>{</span>
    valid <span>=</span> <span>isPlainObject</span><span>(</span>value<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>expectedType <span>===</span> <span>'Array'</span><span>)</span> <span>{</span>
    valid <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    valid <span>=</span> value <span>instanceof</span> <span>type</span>
  <span>}</span>
  <span>return</span> <span>{</span>
    valid<span>,</span>
    expectedType
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>assertType</code> 的逻辑很简单，先通过 <code>getType(type)</code> 获取 <code>prop</code> 期望的类型 <code>expectedType</code>，然后再去根据几种不同的情况对比 <code>prop</code> 的值 <code>value</code> 是否和 <code>expectedType</code> 匹配，最后返回匹配的结果。</p>
<p>如果循环结束后 <code>valid</code> 仍然为 <code>false</code>，那么说明 <code>prop</code> 的值 <code>value</code> 与 <code>prop</code> 定义的类型都不匹配，那么就会输出一段通过 <code>getInvalidTypeMessage(name, value, expectedTypes)</code> 生成的警告信息，就不细说了。</p>
<p>最后判断当 <code>prop</code> 自己定义了 <code>validator</code> 自定义校验器，则执行 <code>validator</code> 校验器方法，如果校验不通过则输出警告信息。</p>
<h3 id="响应式" tabindex="-1"> 响应式</h3>
<p>回到 <code>initProps</code> 方法，当我们通过 <code>const value = validateProp(key, propsOptions, propsData, vm)</code> 对 <code>prop</code> 做验证并且获取到 <code>prop</code> 的值后，接下来需要通过 <code>defineReactive</code> 把 <code>prop</code> 变成响应式。</p>
<p><code>defineReactive</code> 我们之前已经介绍过，这里要注意的是，在开发环境中我们会校验 <code>prop</code> 的 <code>key</code> 是否是 <code>HTML</code> 的保留属性，并且在 <code>defineReactive</code> 的时候会添加一个自定义 <code>setter</code>，当我们直接对 <code>prop</code> 赋值的时候会输出警告：</p>
<div><pre><code><span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
  <span>const</span> hyphenatedKey <span>=</span> <span>hyphenate</span><span>(</span>key<span>)</span>
  <span>if</span> <span>(</span><span>isReservedAttribute</span><span>(</span>hyphenatedKey<span>)</span> <span>||</span>
      config<span>.</span><span>isReservedAttr</span><span>(</span>hyphenatedKey<span>)</span><span>)</span> <span>{</span>
    <span>warn</span><span>(</span>
      <span><span>`</span><span>"</span><span><span>${</span>hyphenatedKey<span>}</span></span><span>" is a reserved attribute and cannot be used as component prop.</span><span>`</span></span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  <span>defineReactive</span><span>(</span>props<span>,</span> key<span>,</span> value<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>isRoot <span>&amp;&amp;</span> <span>!</span>isUpdatingChildComponent<span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span><span>`</span><span>Avoid mutating a prop directly since the value will be </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>overwritten whenever the parent component re-renders. </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>Instead, use a data or computed property based on the prop's </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>value. Prop being mutated: "</span><span><span>${</span>key<span>}</span></span><span>"</span><span>`</span></span><span>,</span>
        vm
      <span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>关于 <code>prop</code> 的响应式有一点不同的是当 <code>vm</code> 是非根实例的时候，会先执行 <code>toggleObserving(false)</code>，它的目的是为了响应式的优化，我们先跳过，之后会详细说明。</p>
<h3 id="代理" tabindex="-1"> 代理</h3>
<p>在经过响应式处理后，我们会把 <code>prop</code> 的值添加到 <code>vm._props</code> 中，比如 key 为 <code>name</code> 的 <code>prop</code>，它的值保存在 <code>vm._props.name</code> 中，但是我们在组件中可以通过 <code>this.name</code> 访问到这个 <code>prop</code>，这就是代理做的事情。</p>
<div><pre><code><span>// static props are already proxied on the component's prototype</span>
<span>// during Vue.extend(). We only need to proxy props defined at</span>
<span>// instantiation here.</span>
<span>if</span> <span>(</span><span>!</span><span>(</span>key <span>in</span> vm<span>)</span><span>)</span> <span>{</span>
  <span>proxy</span><span>(</span>vm<span>,</span> <span><span>`</span><span>_props</span><span>`</span></span><span>,</span> key<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通过 <code>proxy</code> 函数实现了上述需求。</p>
<div><pre><code><span>const</span> sharedPropertyDefinition <span>=</span> <span>{</span>
  <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
  <span>configurable</span><span>:</span> <span>true</span><span>,</span>
  <span>get</span><span>:</span> noop<span>,</span>
  <span>set</span><span>:</span> noop
<span>}</span>

<span>export</span> <span>function</span> <span>proxy</span> <span>(</span><span><span>target</span><span>:</span> Object<span>,</span> <span>sourceKey</span><span>:</span> string<span>,</span> <span>key</span><span>:</span> string</span><span>)</span> <span>{</span>
  sharedPropertyDefinition<span>.</span><span>get</span> <span>=</span> <span>function</span> <span>proxyGetter</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>[</span>sourceKey<span>]</span><span>[</span>key<span>]</span>
  <span>}</span>
  sharedPropertyDefinition<span>.</span><span>set</span> <span>=</span> <span>function</span> <span>proxySetter</span> <span>(</span><span>val</span><span>)</span> <span>{</span>
    <span>this</span><span>[</span>sourceKey<span>]</span><span>[</span>key<span>]</span> <span>=</span> val
  <span>}</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> key<span>,</span> sharedPropertyDefinition<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当访问 <code>this.name</code> 的时候就相当于访问 <code>this._props.name</code>。</p>
<p>其实对于非根实例的子组件而言，<code>prop</code> 的代理发生在 <code>Vue.extend</code> 阶段，在 <code>src/core/global-api/extend.js</code> 中：</p>
<div><pre><code>Vue<span>.</span><span>extend</span> <span>=</span> <span>function</span> <span>(</span><span><span>extendOptions</span><span>:</span> Object</span><span>)</span><span>:</span> Function <span>{</span>
  <span>// ...</span>
  <span>const</span> <span>Sub</span> <span>=</span> <span>function</span> <span>VueComponent</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span>
  <span>}</span>
  <span>// ...</span>

  <span>// For props and computed properties, we define the proxy getters on</span>
  <span>// the Vue instances at extension time, on the extended prototype. This</span>
  <span>// avoids Object.defineProperty calls for each instance created.</span>
  <span>if</span> <span>(</span>Sub<span>.</span>options<span>.</span>props<span>)</span> <span>{</span>
    <span>initProps</span><span>(</span>Sub<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>Sub<span>.</span>options<span>.</span>computed<span>)</span> <span>{</span>
    <span>initComputed</span><span>(</span>Sub<span>)</span>
  <span>}</span>

  <span>// ...</span>
  <span>return</span> Sub
<span>}</span>

<span>function</span> <span>initProps</span> <span>(</span><span>Comp</span><span>)</span> <span>{</span>
  <span>const</span> props <span>=</span> Comp<span>.</span>options<span>.</span>props
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> props<span>)</span> <span>{</span>
    <span>proxy</span><span>(</span><span>Comp</span><span>.</span>prototype<span>,</span> <span><span>`</span><span>_props</span><span>`</span></span><span>,</span> key<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这么做的好处是不用为每个组件实例都做一层 <code>proxy</code>，是一种优化手段。</p>
<h2 id="props-更新" tabindex="-1"> Props 更新</h2>
<p>我们知道，当父组件传递给子组件的 <code>props</code> 值变化，子组件对应的值也会改变，同时会触发子组件的重新渲染。那么接下来我们就从源码角度来分析这两个过程。</p>
<h3 id="子组件-props-更新" tabindex="-1"> 子组件 props 更新</h3>
<p>首先，<code>prop</code> 数据的值变化在父组件，我们知道在父组件的 <code>render</code> 过程中会访问到这个 <code>prop</code> 数据，所以当 <code>prop</code> 数据变化一定会触发父组件的重新渲染，那么重新渲染是如何更新子组件对应的 <code>prop</code> 的值呢？</p>
<p>在父组件重新渲染的最后，会执行 <code>patch</code> 过程，进而执行 <code>patchVnode</code> 函数，<code>patchVnode</code> 通常是一个递归过程，当它遇到组件 <code>vnode</code> 的时候，会执行组件更新过程的 <code>prepatch</code> 钩子函数，在 <code>src/core/vdom/patch.js</code> 中：</p>
<div><pre><code><span>function</span> <span>patchVnode</span> <span>(</span>
  <span>oldVnode<span>,</span>
  vnode<span>,</span>
  insertedVnodeQueue<span>,</span>
  ownerArray<span>,</span>
  index<span>,</span>
  removeOnly</span>
<span>)</span> <span>{</span>
  <span>// ...</span>

  <span>let</span> i
  <span>const</span> data <span>=</span> vnode<span>.</span>data
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> data<span>.</span>hook<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>prepatch<span>)</span><span>)</span> <span>{</span>
    <span>i</span><span>(</span>oldVnode<span>,</span> vnode<span>)</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>prepatch</code> 函数定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<div><pre><code><span>prepatch</span> <span>(</span><span><span>oldVnode</span><span>:</span> MountedComponentVNode<span>,</span> <span>vnode</span><span>:</span> MountedComponentVNode</span><span>)</span> <span>{</span>
  <span>const</span> options <span>=</span> vnode<span>.</span>componentOptions
  <span>const</span> child <span>=</span> vnode<span>.</span>componentInstance <span>=</span> oldVnode<span>.</span>componentInstance
  <span>updateChildComponent</span><span>(</span>
    child<span>,</span>
    options<span>.</span>propsData<span>,</span> <span>// updated props</span>
    options<span>.</span>listeners<span>,</span> <span>// updated listeners</span>
    vnode<span>,</span> <span>// new parent vnode</span>
    options<span>.</span>children <span>// new children</span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>内部会调用 <code>updateChildComponent</code> 方法来更新 <code>props</code>，注意第二个参数就是父组件的 <code>propData</code>，那么为什么 <code>vnode.componentOptions.propsData</code> 就是父组件传递给子组件的 <code>prop</code> 数据呢（这个也同样解释了第一次渲染的 <code>propsData</code> 来源）？原来在组件的 <code>render</code> 过程中，对于组件节点会通过 <code>createComponent</code> 方法来创建组件 <code>vnode</code>：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createComponent</span> <span>(</span>
  <span><span>Ctor</span><span>:</span> Class<span>&lt;</span>Component<span>></span> <span>|</span> Function <span>|</span> Object <span>|</span> <span>void</span><span>,</span>
  <span>data</span><span>:</span> <span>?</span>VNodeData<span>,</span>
  <span>context</span><span>:</span> Component<span>,</span>
  <span>children</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span><span>,</span>
  tag<span>?</span><span>:</span> string</span>
<span>)</span><span>:</span> VNode <span>|</span> Array<span>&lt;</span>VNode<span>></span> <span>|</span> <span>void</span> <span>{</span>
  <span>// ...</span>

  <span>// extract props</span>
  <span>const</span> propsData <span>=</span> <span>extractPropsFromVNodeData</span><span>(</span>data<span>,</span> Ctor<span>,</span> tag<span>)</span>

  <span>// ...</span>
  
  <span>const</span> vnode <span>=</span> <span>new</span> <span>VNode</span><span>(</span>
    <span><span>`</span><span>vue-component-</span><span><span>${</span>Ctor<span>.</span>cid<span>}</span></span><span><span>${</span>name <span>?</span> <span><span>`</span><span>-</span><span><span>${</span>name<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span><span>}</span></span><span>`</span></span><span>,</span>
    data<span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> <span>undefined</span><span>,</span> context<span>,</span>
    <span>{</span> Ctor<span>,</span> propsData<span>,</span> listeners<span>,</span> tag<span>,</span> children <span>}</span><span>,</span>
    asyncFactory
  <span>)</span>

  <span>// ...</span>
  
  <span>return</span> vnode
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在创建组件 <code>vnode</code> 的过程中，首先从 <code>data</code> 中提取出 <code>propData</code>，然后在 <code>new VNode</code> 的时候，作为第七个参数 <code>VNodeComponentOptions</code> 中的一个属性传入，所以我们可以通过 <code>vnode.componentOptions.propsData</code> 拿到 <code>prop</code> 数据。</p>
<p>接着看 <code>updateChildComponent</code> 函数，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>updateChildComponent</span> <span>(</span>
  <span><span>vm</span><span>:</span> Component<span>,</span>
  <span>propsData</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>listeners</span><span>:</span> <span>?</span>Object<span>,</span>
  <span>parentVnode</span><span>:</span> MountedComponentVNode<span>,</span>
  <span>renderChildren</span><span>:</span> <span>?</span>Array<span>&lt;</span>VNode<span>></span></span>
<span>)</span> <span>{</span>
  <span>// ...</span>

  <span>// update props</span>
  <span>if</span> <span>(</span>propsData <span>&amp;&amp;</span> vm<span>.</span>$options<span>.</span>props<span>)</span> <span>{</span>
    <span>toggleObserving</span><span>(</span><span>false</span><span>)</span>
    <span>const</span> props <span>=</span> vm<span>.</span>_props
    <span>const</span> propKeys <span>=</span> vm<span>.</span>$options<span>.</span>_propKeys <span>||</span> <span>[</span><span>]</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> propKeys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>const</span> key <span>=</span> propKeys<span>[</span>i<span>]</span>
      <span>const</span> <span>propOptions</span><span>:</span> any <span>=</span> vm<span>.</span>$options<span>.</span>props <span>// wtf flow?</span>
      props<span>[</span>key<span>]</span> <span>=</span> <span>validateProp</span><span>(</span>key<span>,</span> propOptions<span>,</span> propsData<span>,</span> vm<span>)</span>
    <span>}</span>
    <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
    <span>// keep a copy of raw propsData</span>
    vm<span>.</span>$options<span>.</span>propsData <span>=</span> propsData
  <span>}</span>

  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们重点来看更新 <code>props</code> 的相关逻辑，这里的 <code>propsData</code> 是父组件传递的 <code>props</code> 数据，<code>vm</code> 是子组件的实例。<code>vm._props</code> 指向的就是子组件的 <code>props</code> 值，<code>propKeys</code> 就是在之前 <code>initProps</code> 过程中，缓存的子组件中定义的所有 <code>prop</code> 的 <code>key</code>。主要逻辑就是遍历 <code>propKeys</code>，然后执行 <code>props[key] = validateProp(key, propOptions, propsData, vm)</code> 重新验证和计算新的 <code>prop</code> 数据，更新 <code>vm._props</code>，也就是子组件的 <code>props</code>，这个就是子组件  <code>props</code> 的更新过程。</p>
<h3 id="子组件重新渲染" tabindex="-1"> 子组件重新渲染</h3>
<p>其实子组件的重新渲染有 2 种情况，一个是 <code>prop</code> 值被修改，另一个是对象类型的 <code>prop</code> 内部属性的变化。</p>
<p>先来看一下 <code>prop</code> 值被修改的情况，当执行 <code>props[key] = validateProp(key, propOptions, propsData, vm)</code> 更新子组件 <code>prop</code> 的时候，会触发 <code>prop</code> 的 <code>setter</code> 过程，只要在渲染子组件的时候访问过这个 <code>prop</code> 值，那么根据响应式原理，就会触发子组件的重新渲染。</p>
<p>再来看一下当对象类型的 <code>prop</code> 的内部属性发生变化的时候，这个时候其实并没有触发子组件 <code>prop</code> 的更新。但是在子组件的渲染过程中，访问过这个对象 <code>prop</code>，所以这个对象 <code>prop</code> 在触发 <code>getter</code> 的时候会把子组件的 <code>render watcher</code> 收集到依赖中，然后当我们在父组件更新这个对象 <code>prop</code> 的某个属性的时候，会触发 <code>setter</code> 过程，也就会通知子组件 <code>render watcher</code> 的 <code>update</code>，进而触发子组件的重新渲染。</p>
<p>以上就是当父组件 <code>props</code> 更新，触发子组件重新渲染的 2 种情况。</p>
<h2 id="toggleobserving" tabindex="-1"> toggleObserving</h2>
<p>最后我们在来聊一下 <code>toggleObserving</code>，它的定义在 <code>src/core/observer/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>let</span> <span>shouldObserve</span><span>:</span> boolean <span>=</span> <span>true</span>

<span>export</span> <span>function</span> <span>toggleObserving</span> <span>(</span><span><span>value</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  shouldObserve <span>=</span> value
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>它在当前模块中定义了 <code>shouldObserve</code> 变量，用来控制在 <code>observe</code> 的过程中是否需要把当前值变成一个 <code>Observer</code> 对象。</p>
<p>那么为什么在 <code>props</code> 的初始化和更新过程中，多次执行 <code>toggleObserving(false)</code> 呢，接下来我们就来分析这几种情况。</p>
<p>在 <code>initProps</code> 的过程中：</p>
<div><pre><code><span>const</span> isRoot <span>=</span> <span>!</span>vm<span>.</span>$parent
<span>// root instance props should be converted</span>
<span>if</span> <span>(</span><span>!</span>isRoot<span>)</span> <span>{</span>
  <span>toggleObserving</span><span>(</span><span>false</span><span>)</span>
<span>}</span>
<span>for</span> <span>(</span><span>const</span> key <span>in</span> propsOptions<span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> value <span>=</span> <span>validateProp</span><span>(</span>key<span>,</span> propsOptions<span>,</span> propsData<span>,</span> vm<span>)</span>
  <span>defineReactive</span><span>(</span>props<span>,</span> key<span>,</span> value<span>)</span>
  <span>// ...</span>
<span>}</span>
<span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对于非根实例的情况，我们会执行 <code>toggleObserving(false)</code>，然后对于每一个 <code>prop</code> 值，去执行 <code>defineReactive(props, key, value)</code> 去把它变成响应式。</p>
<p>回顾一下 <code>defineReactive</code> 的定义：</p>
<div><pre><code><span>export</span> <span>function</span> <span>defineReactive</span> <span>(</span>
  <span><span>obj</span><span>:</span> Object<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>val</span><span>:</span> any<span>,</span>
  customSetter<span>?</span><span>:</span> <span>?</span>Function<span>,</span>
  shallow<span>?</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>// ...</span>
  
  <span>let</span> childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>val<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span> <span>(</span><span>)</span> <span>{</span>
      <span>// ...</span>
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span> <span>(</span><span>newVal</span><span>)</span> <span>{</span>
      <span>// ...</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通常对于值 <code>val</code> 会执行 <code>observe</code> 函数，然后遇到 <code>val</code> 是对象或者数组的情况会递归执行 <code>defineReactive</code> 把它们的子属性都变成响应式的，但是由于 <code>shouldObserve</code> 的值变成了 <code>false</code>，这个递归过程被省略了。为什么会这样呢？</p>
<p>因为正如我们前面分析的，对于对象的 <code>prop</code> 值，子组件的 <code>prop</code> 值始终指向父组件的 <code>prop</code> 值，只要父组件的 <code>prop</code> 值变化，就会触发子组件的重新渲染，所以这个 <code>observe</code> 过程是可以省略的。</p>
<p>最后再执行 <code>toggleObserving(true)</code> 恢复 <code>shouldObserve</code> 为 <code>true</code>。</p>
<p>在 <code>validateProp</code> 的过程中：</p>
<div><pre><code><span>// check default value</span>
<span>if</span> <span>(</span>value <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
  value <span>=</span> <span>getPropDefaultValue</span><span>(</span>vm<span>,</span> prop<span>,</span> key<span>)</span>
  <span>// since the default value is a fresh copy,</span>
  <span>// make sure to observe it.</span>
  <span>const</span> prevShouldObserve <span>=</span> shouldObserve
  <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
  <span>observe</span><span>(</span>value<span>)</span>
  <span>toggleObserving</span><span>(</span>prevShouldObserve<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这种是父组件没有传递 <code>prop</code> 值对默认值的处理逻辑，因为这个值是一个拷贝，所以我们需要 <code>toggleObserving(true)</code>，然后执行 <code>observe(value)</code> 把值变成响应式。</p>
<p>在 <code>updateChildComponent</code> 过程中：</p>
<div><pre><code><span>// update props</span>
<span>if</span> <span>(</span>propsData <span>&amp;&amp;</span> vm<span>.</span>$options<span>.</span>props<span>)</span> <span>{</span>
  <span>toggleObserving</span><span>(</span><span>false</span><span>)</span>
  <span>const</span> props <span>=</span> vm<span>.</span>_props
  <span>const</span> propKeys <span>=</span> vm<span>.</span>$options<span>.</span>_propKeys <span>||</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> propKeys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> propKeys<span>[</span>i<span>]</span>
    <span>const</span> <span>propOptions</span><span>:</span> any <span>=</span> vm<span>.</span>$options<span>.</span>props <span>// wtf flow?</span>
    props<span>[</span>key<span>]</span> <span>=</span> <span>validateProp</span><span>(</span>key<span>,</span> propOptions<span>,</span> propsData<span>,</span> vm<span>)</span>
  <span>}</span>
  <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
  <span>// keep a copy of raw propsData</span>
  vm<span>.</span>$options<span>.</span>propsData <span>=</span> propsData
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其实和 <code>initProps</code> 的逻辑一样，不需要对引用类型 <code>props</code> 递归做响应式处理，所以也需要 <code>toggleObserving(false)</code>。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节的分析，我们了解了 <code>props</code> 的规范化、初始化、更新等过程的实现原理；也了解了 Vue 内部对 <code>props</code> 如何做响应式的优化；同时还了解到 <code>props</code> 的变化是如何触发子组件的更新。了解这些对我们平时对 <code>props</code> 的应用，遇到问题时的定位追踪会有很大的帮助。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">检测变化的注意事项</title>
    <id>https://0808200.xyz/vue2/reactive/questions.html</id>
    <link href="https://0808200.xyz/vue2/reactive/questions.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="检测变化的注意事项" tabindex="-1"> 检测变化的注意事项</h1>
<p>通过前面几节的分析，我们对响应式数据对象以及它的 getter 和 setter 部分做了了解，但是对于一些特殊情况是需要注意的，接下来我们就从源码的角度来看 Vue 是如何处理这些特殊情况的。</p>
<h2 id="对象添加属性" tabindex="-1"> 对象添加属性</h2>
<p>对于使用 <code>Object.defineProperty</code> 实现响应式的对象，当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 setter 的，比如：</p>
<div><pre><code><span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span><span>{</span>
    <span>a</span><span>:</span><span>1</span>
  <span>}</span>
<span>}</span><span>)</span>
<span>// vm.b 是非响应的</span>
vm<span>.</span>b <span>=</span> <span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是添加新属性的场景我们在平时开发中会经常遇到，那么 Vue 为了解决这个问题，定义了一个全局 API <code>Vue.set</code> 方法，它在 <code>src/core/global-api/index.js</code> 中初始化：</p>
<div><pre><code>Vue<span>.</span>set <span>=</span> <span>set</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个 <code>set</code> 方法的定义在 <code>src/core/observer/index.js</code> 中：</p>
<div><pre><code><span>/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */</span>
<span>export</span> <span>function</span> <span>set</span> <span>(</span><span><span>target</span><span>:</span> Array<span>&lt;</span>any<span>></span> <span>|</span> Object<span>,</span> <span>key</span><span>:</span> any<span>,</span> <span>val</span><span>:</span> any</span><span>)</span><span>:</span> any <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    <span>(</span><span>isUndef</span><span>(</span>target<span>)</span> <span>||</span> <span>isPrimitive</span><span>(</span>target<span>)</span><span>)</span>
  <span>)</span> <span>{</span>
    <span>warn</span><span>(</span><span><span>`</span><span>Cannot set reactive property on undefined, null, or primitive value: </span><span><span>${</span><span>(</span>target<span>:</span> any<span>)</span><span>}</span></span><span>`</span></span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>target<span>)</span> <span>&amp;&amp;</span> <span>isValidArrayIndex</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
    target<span>.</span>length <span>=</span> Math<span>.</span><span>max</span><span>(</span>target<span>.</span>length<span>,</span> key<span>)</span>
    target<span>.</span><span>splice</span><span>(</span>key<span>,</span> <span>1</span><span>,</span> val<span>)</span>
    <span>return</span> val
  <span>}</span>
  <span>if</span> <span>(</span>key <span>in</span> target <span>&amp;&amp;</span> <span>!</span><span>(</span>key <span>in</span> <span>Object</span><span>.</span>prototype<span>)</span><span>)</span> <span>{</span>
    target<span>[</span>key<span>]</span> <span>=</span> val
    <span>return</span> val
  <span>}</span>
  <span>const</span> ob <span>=</span> <span>(</span>target<span>:</span> any<span>)</span><span>.</span>__ob__
  <span>if</span> <span>(</span>target<span>.</span>_isVue <span>||</span> <span>(</span>ob <span>&amp;&amp;</span> ob<span>.</span>vmCount<span>)</span><span>)</span> <span>{</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
      <span>'Avoid adding reactive properties to a Vue instance or its root $data '</span> <span>+</span>
      <span>'at runtime - declare it upfront in the data option.'</span>
    <span>)</span>
    <span>return</span> val
  <span>}</span>
  <span>if</span> <span>(</span><span>!</span>ob<span>)</span> <span>{</span>
    target<span>[</span>key<span>]</span> <span>=</span> val
    <span>return</span> val
  <span>}</span>
  <span>defineReactive</span><span>(</span>ob<span>.</span>value<span>,</span> key<span>,</span> val<span>)</span>
  ob<span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span>
  <span>return</span> val
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>set</code> 方法接收 3个参数，<code>target</code> 可能是数组或者是普通对象，<code>key</code> 代表的是数组的下标或者是对象的键值，<code>val</code> 代表添加的值。首先判断如果 <code>target</code> 是数组且 <code>key</code> 是一个合法的下标，则之前通过 <code>splice</code> 去添加进数组然后返回，这里的 <code>splice</code> 其实已经不仅仅是原生数组的 <code>splice</code> 了，稍后我会详细介绍数组的逻辑。接着又判断 <code>key</code> 已经存在于 <code>target</code> 中，则直接赋值返回，因为这样的变化是可以观测到了。接着再获取到 <code>target.__ob__</code> 并赋值给 <code>ob</code>，之前分析过它是在 <code>Observer</code> 的构造函数执行的时候初始化的，表示 <code>Observer</code> 的一个实例，如果它不存在，则说明 <code>target</code> 不是一个响应式的对象，则直接赋值并返回。最后通过 <code> defineReactive(ob.value, key, val)</code> 把新添加的属性变成响应式对象，然后再通过 <code>ob.dep.notify()</code> 手动的触发依赖通知，还记得我们在给对象添加 getter 的时候有这么一段逻辑：</p>
<div><pre><code><span>export</span> <span>function</span> <span>defineReactive</span> <span>(</span>
  <span><span>obj</span><span>:</span> Object<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>val</span><span>:</span> any<span>,</span>
  customSetter<span>?</span><span>:</span> <span>?</span>Function<span>,</span>
  shallow<span>?</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>// ...</span>
  <span>let</span> childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>val<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span> <span>(</span><span>)</span> <span>{</span>
      <span>const</span> value <span>=</span> getter <span>?</span> <span>getter</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>:</span> val
      <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> <span>{</span>
        dep<span>.</span><span>depend</span><span>(</span><span>)</span>
        <span>if</span> <span>(</span>childOb<span>)</span> <span>{</span>
          childOb<span>.</span>dep<span>.</span><span>depend</span><span>(</span><span>)</span>
          <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
            <span>dependArray</span><span>(</span>value<span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
      <span>return</span> value
    <span>}</span><span>,</span>
    <span>// ...</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在 getter 过程中判断了 <code>childOb</code>，并调用了 <code>childOb.dep.depend()</code> 收集了依赖，这就是为什么执行 <code>Vue.set</code> 的时候通过 <code>ob.dep.notify()</code> 能够通知到 <code>watcher </code>，从而让添加新的属性到对象也可以检测到变化。这里如果 <code>value</code> 是个数组，那么就通过 <code>dependArray</code> 把数组每个元素也去做依赖收集。</p>
<h2 id="数组" tabindex="-1"> 数组</h2>
<p>接着说一下数组的情况，Vue 也是不能检测到以下变动的数组：</p>
<p>1.当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></p>
<p>2.当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p>
<p>对于第一种情况，可以使用：<code>Vue.set(example1.items, indexOfItem, newValue)</code>；而对于第二种情况，可以使用 <code>vm.items.splice(newLength)</code>。</p>
<p>我们刚才也分析到，对于 <code>Vue.set</code> 的实现，当 <code>target</code> 是数组的时候，也是通过 <code>target.splice(key, 1, val)</code> 来添加的，那么这里的 <code>splice</code> 到底有什么黑魔法，能让添加的对象变成响应式的呢。</p>
<p>其实之前我们也分析过，在通过 <code>observe</code> 方法去观察对象的时候会实例化 <code>Observer</code>，在它的构造函数中是专门对数组做了处理，它的定义在 <code>src/core/observer/index.js</code> 中。</p>
<div><pre><code><span>export</span> <span>class</span> <span>Observer</span> <span>{</span>
  <span>constructor</span> <span>(</span><span><span>value</span><span>:</span> any</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> value
    <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    <span>this</span><span>.</span>vmCount <span>=</span> <span>0</span>
    <span>def</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>,</span> <span>this</span><span>)</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
      <span>const</span> augment <span>=</span> hasProto
        <span>?</span> protoAugment
        <span>:</span> copyAugment
      <span>augment</span><span>(</span>value<span>,</span> arrayMethods<span>,</span> arrayKeys<span>)</span>
      <span>this</span><span>.</span><span>observeArray</span><span>(</span>value<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// ...</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们只需要关注 <code>value</code> 是 Array 的情况，首先获取 <code>augment</code>，这里的 <code>hasProto</code> 实际上就是判断对象中是否存在 <code>__proto__</code>，如果存在则 <code>augment</code> 指向 <code>protoAugment</code>， 否则指向 <code>copyAugment</code>，来看一下这两个函数的定义：</p>
<div><pre><code><span>/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */</span>
<span>function</span> <span>protoAugment</span> <span>(</span><span>target<span>,</span> <span>src</span><span>:</span> Object<span>,</span> <span>keys</span><span>:</span> any</span><span>)</span> <span>{</span>
  <span>/* eslint-disable no-proto */</span>
  target<span>.</span>__proto__ <span>=</span> src
  <span>/* eslint-enable no-proto */</span>
<span>}</span>

<span>/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */</span>
<span>/* istanbul ignore next */</span>
<span>function</span> <span>copyAugment</span> <span>(</span><span><span>target</span><span>:</span> Object<span>,</span> <span>src</span><span>:</span> Object<span>,</span> <span>keys</span><span>:</span> Array<span>&lt;</span>string<span>></span></span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> keys<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> keys<span>[</span>i<span>]</span>
    <span>def</span><span>(</span>target<span>,</span> key<span>,</span> src<span>[</span>key<span>]</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>protoAugment</code> 方法是直接把 <code>target.__proto__</code> 原型直接修改为 <code>src</code>，而 <code>copyAugment</code> 方法是遍历 keys，通过 <code>def</code>，也就是 <code>Object.defineProperty</code> 去定义它自身的属性值。对于大部分现代浏览器都会走到 <code>protoAugment</code>，那么它实际上就把 <code>value</code> 的原型指向了 <code>arrayMethods</code>，<code>arrayMethods</code> 的定义在 <code>src/core/observer/array.js</code> 中：</p>
<div><pre><code><span>import</span> <span>{</span> def <span>}</span> <span>from</span> <span>'../util/index'</span>

<span>const</span> arrayProto <span>=</span> <span>Array</span><span>.</span>prototype
<span>export</span> <span>const</span> arrayMethods <span>=</span> Object<span>.</span><span>create</span><span>(</span>arrayProto<span>)</span>

<span>const</span> methodsToPatch <span>=</span> <span>[</span>
  <span>'push'</span><span>,</span>
  <span>'pop'</span><span>,</span>
  <span>'shift'</span><span>,</span>
  <span>'unshift'</span><span>,</span>
  <span>'splice'</span><span>,</span>
  <span>'sort'</span><span>,</span>
  <span>'reverse'</span>
<span>]</span>

<span>/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>method</span><span>)</span> <span>{</span>
  <span>// cache original method</span>
  <span>const</span> original <span>=</span> arrayProto<span>[</span>method<span>]</span>
  <span>def</span><span>(</span>arrayMethods<span>,</span> method<span>,</span> <span>function</span> <span>mutator</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>const</span> result <span>=</span> <span>original</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
    <span>const</span> ob <span>=</span> <span>this</span><span>.</span>__ob__
    <span>let</span> inserted
    <span>switch</span> <span>(</span>method<span>)</span> <span>{</span>
      <span>case</span> <span>'push'</span><span>:</span>
      <span>case</span> <span>'unshift'</span><span>:</span>
        inserted <span>=</span> args
        <span>break</span>
      <span>case</span> <span>'splice'</span><span>:</span>
        inserted <span>=</span> args<span>.</span><span>slice</span><span>(</span><span>2</span><span>)</span>
        <span>break</span>
    <span>}</span>
    <span>if</span> <span>(</span>inserted<span>)</span> ob<span>.</span><span>observeArray</span><span>(</span>inserted<span>)</span>
    <span>// notify change</span>
    ob<span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>return</span> result
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，<code>arrayMethods</code> 首先继承了 <code>Array</code>，然后对数组中所有能改变数组自身的方法，如 <code>push、pop</code> 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 <code>push、unshift、splice</code> 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 <code> ob.dep.notify()</code> 手动触发依赖通知，这就很好地解释了之前的示例中调用 <code>vm.items.splice(newLength)</code> 方法可以检测到变化。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节的分析，我们对响应式对象又有了更全面的认识，如果在实际工作中遇到了这些特殊情况，我们就可以知道如何把它们也变成响应式的对象。其实对于对象属性的删除也会用同样的问题，Vue 同样提供了 <code>Vue.del</code> 的全局 API，它的实现和 <code>Vue.set</code> 大同小异，甚至还要更简单一些，这里我就不去分析了，感兴趣的同学可以自行去了解。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">响应式对象</title>
    <id>https://0808200.xyz/vue2/reactive/reactive-object.html</id>
    <link href="https://0808200.xyz/vue2/reactive/reactive-object.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="响应式对象" tabindex="-1"> 响应式对象</h1>
<p>可能很多小伙伴之前都了解过 Vue.js 实现响应式的核心是利用了 ES5 的 <code>Object.defineProperty</code>，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。</p>
<h2 id="object-defineproperty" tabindex="-1"> Object.defineProperty</h2>
<p><code>Object.defineProperty</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：</p>
<div><pre><code>Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> prop<span>,</span> descriptor<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>obj</code> 是要在其上定义属性的对象；<code>prop</code> 是要定义或修改的属性的名称；<code>descriptor</code> 是将被定义或修改的属性描述符。</p>
<p>比较核心的是 <code>descriptor</code>，它有很多可选键值，具体的可以去参阅它的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener noreferrer">文档</a>。这里我们最关心的是 <code>get</code> 和 <code>set</code>，<code>get</code> 是一个给属性提供的 getter 方法，当我们访问了该属性的时候会触发 getter 方法；<code>set</code> 是一个给属性提供的 setter 方法，当我们对该属性做修改的时候会触发 setter 方法。</p>
<p>一旦对象拥有了 getter 和 setter，我们可以简单地把这个对象称为响应式对象。那么 Vue.js 把哪些对象变成了响应式对象了呢，接下来我们从源码层面分析。</p>
<h2 id="initstate" tabindex="-1"> initState</h2>
<p>在 Vue 的初始化阶段，<code>_init</code> 方法执行的时候，会执行 <code>initState(vm)</code> 方法，它的定义在 <code>src/core/instance/state.js</code> 中。</p>
<div><pre><code><span>export</span> <span>function</span> <span>initState</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  vm<span>.</span>_watchers <span>=</span> <span>[</span><span>]</span>
  <span>const</span> opts <span>=</span> vm<span>.</span>$options
  <span>if</span> <span>(</span>opts<span>.</span>props<span>)</span> <span>initProps</span><span>(</span>vm<span>,</span> opts<span>.</span>props<span>)</span>
  <span>if</span> <span>(</span>opts<span>.</span>methods<span>)</span> <span>initMethods</span><span>(</span>vm<span>,</span> opts<span>.</span>methods<span>)</span>
  <span>if</span> <span>(</span>opts<span>.</span>data<span>)</span> <span>{</span>
    <span>initData</span><span>(</span>vm<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>observe</span><span>(</span>vm<span>.</span>_data <span>=</span> <span>{</span><span>}</span><span>,</span> <span>true</span> <span>/* asRootData */</span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>opts<span>.</span>computed<span>)</span> <span>initComputed</span><span>(</span>vm<span>,</span> opts<span>.</span>computed<span>)</span>
  <span>if</span> <span>(</span>opts<span>.</span>watch <span>&amp;&amp;</span> opts<span>.</span>watch <span>!==</span> nativeWatch<span>)</span> <span>{</span>
    <span>initWatch</span><span>(</span>vm<span>,</span> opts<span>.</span>watch<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>initState</code> 方法主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。这里我们重点分析 <code>props</code> 和 <code>data</code>，对于其它属性的初始化我们之后再详细分析。</p>
<ul>
<li>initProps</li>
</ul>
<div><pre><code><span>function</span> <span>initProps</span> <span>(</span><span><span>vm</span><span>:</span> Component<span>,</span> <span>propsOptions</span><span>:</span> Object</span><span>)</span> <span>{</span>
  <span>const</span> propsData <span>=</span> vm<span>.</span>$options<span>.</span>propsData <span>||</span> <span>{</span><span>}</span>
  <span>const</span> props <span>=</span> vm<span>.</span>_props <span>=</span> <span>{</span><span>}</span>
  <span>// cache prop keys so that future props updates can iterate using Array</span>
  <span>// instead of dynamic object key enumeration.</span>
  <span>const</span> keys <span>=</span> vm<span>.</span>$options<span>.</span>_propKeys <span>=</span> <span>[</span><span>]</span>
  <span>const</span> isRoot <span>=</span> <span>!</span>vm<span>.</span>$parent
  <span>// root instance props should be converted</span>
  <span>if</span> <span>(</span><span>!</span>isRoot<span>)</span> <span>{</span>
    <span>toggleObserving</span><span>(</span><span>false</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> key <span>in</span> propsOptions<span>)</span> <span>{</span>
    keys<span>.</span><span>push</span><span>(</span>key<span>)</span>
    <span>const</span> value <span>=</span> <span>validateProp</span><span>(</span>key<span>,</span> propsOptions<span>,</span> propsData<span>,</span> vm<span>)</span>
    <span>/* istanbul ignore else */</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>const</span> hyphenatedKey <span>=</span> <span>hyphenate</span><span>(</span>key<span>)</span>
      <span>if</span> <span>(</span><span>isReservedAttribute</span><span>(</span>hyphenatedKey<span>)</span> <span>||</span>
          config<span>.</span><span>isReservedAttr</span><span>(</span>hyphenatedKey<span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>"</span><span><span>${</span>hyphenatedKey<span>}</span></span><span>" is a reserved attribute and cannot be used as component prop.</span><span>`</span></span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
      <span>defineReactive</span><span>(</span>props<span>,</span> key<span>,</span> value<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>if</span> <span>(</span>vm<span>.</span>$parent <span>&amp;&amp;</span> <span>!</span>isUpdatingChildComponent<span>)</span> <span>{</span>
          <span>warn</span><span>(</span>
            <span><span>`</span><span>Avoid mutating a prop directly since the value will be </span><span>`</span></span> <span>+</span>
            <span><span>`</span><span>overwritten whenever the parent component re-renders. </span><span>`</span></span> <span>+</span>
            <span><span>`</span><span>Instead, use a data or computed property based on the prop's </span><span>`</span></span> <span>+</span>
            <span><span>`</span><span>value. Prop being mutated: "</span><span><span>${</span>key<span>}</span></span><span>"</span><span>`</span></span><span>,</span>
            vm
          <span>)</span>
        <span>}</span>
      <span>}</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>defineReactive</span><span>(</span>props<span>,</span> key<span>,</span> value<span>)</span>
    <span>}</span>
    <span>// static props are already proxied on the component's prototype</span>
    <span>// during Vue.extend(). We only need to proxy props defined at</span>
    <span>// instantiation here.</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>key <span>in</span> vm<span>)</span><span>)</span> <span>{</span>
      <span>proxy</span><span>(</span>vm<span>,</span> <span><span>`</span><span>_props</span><span>`</span></span><span>,</span> key<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>toggleObserving</span><span>(</span><span>true</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>props</code> 的初始化主要过程，就是遍历定义的 <code>props</code> 配置。遍历的过程主要做两件事情：一个是调用 <code>defineReactive</code> 方法把每个 <code>prop</code> 对应的值变成响应式，可以通过 <code>vm._props.xxx</code> 访问到定义 <code>props</code> 中对应的属性。对于 <code>defineReactive</code> 方法，我们稍后会介绍；另一个是通过 <code>proxy</code> 把 <code>vm._props.xxx</code> 的访问代理到 <code>vm.xxx</code> 上，我们稍后也会介绍。</p>
<ul>
<li>initData</li>
</ul>
<div><pre><code><span>function</span> <span>initData</span> <span>(</span><span><span>vm</span><span>:</span> Component</span><span>)</span> <span>{</span>
  <span>let</span> data <span>=</span> vm<span>.</span>$options<span>.</span>data
  data <span>=</span> vm<span>.</span>_data <span>=</span> <span>typeof</span> data <span>===</span> <span>'function'</span>
    <span>?</span> <span>getData</span><span>(</span>data<span>,</span> vm<span>)</span>
    <span>:</span> data <span>||</span> <span>{</span><span>}</span>
  <span>if</span> <span>(</span><span>!</span><span>isPlainObject</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
    data <span>=</span> <span>{</span><span>}</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
      <span>'data functions should return an object:\n'</span> <span>+</span>
      <span>'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span>,</span>
      vm
    <span>)</span>
  <span>}</span>
  <span>// proxy data on instance</span>
  <span>const</span> keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>data<span>)</span>
  <span>const</span> props <span>=</span> vm<span>.</span>$options<span>.</span>props
  <span>const</span> methods <span>=</span> vm<span>.</span>$options<span>.</span>methods
  <span>let</span> i <span>=</span> keys<span>.</span>length
  <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> keys<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>methods <span>&amp;&amp;</span> <span>hasOwn</span><span>(</span>methods<span>,</span> key<span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span><span>`</span><span>Method "</span><span><span>${</span>key<span>}</span></span><span>" has already been defined as a data property.</span><span>`</span></span><span>,</span>
          vm
        <span>)</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>props <span>&amp;&amp;</span> <span>hasOwn</span><span>(</span>props<span>,</span> key<span>)</span><span>)</span> <span>{</span>
      process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span>
        <span><span>`</span><span>The data property "</span><span><span>${</span>key<span>}</span></span><span>" is already declared as a prop. </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>Use prop default value instead.</span><span>`</span></span><span>,</span>
        vm
      <span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>isReserved</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
      <span>proxy</span><span>(</span>vm<span>,</span> <span><span>`</span><span>_data</span><span>`</span></span><span>,</span> key<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>// observe data</span>
  <span>observe</span><span>(</span>data<span>,</span> <span>true</span> <span>/* asRootData */</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>data</code> 的初始化主要过程也是做两件事，一个是对定义 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上；另一个是调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式，可以通过 <code>vm._data.xxx</code> 访问到定义 <code>data</code> 返回函数中对应的属性，<code>observe</code> 我们稍后会介绍。</p>
<p>可以看到，无论是 <code>props</code> 或是 <code>data</code> 的初始化都是把它们变成响应式对象，这个过程我们接触到几个函数，接下来我们来详细分析它们。</p>
<h2 id="proxy" tabindex="-1"> proxy</h2>
<p>首先介绍一下代理，代理的作用是把 <code>props</code> 和 <code>data</code> 上的属性代理到 <code>vm</code> 实例上，这也就是为什么比如我们定义了如下 props，却可以通过 vm 实例访问到它。</p>
<div><pre><code><span>let</span> comP <span>=</span> <span>{</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>msg</span><span>:</span> <span>'hello'</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>say</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>msg<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以在 <code>say</code> 函数中通过 <code>this.msg</code> 访问到我们定义在 <code>props</code> 中的 <code>msg</code>，这个过程发生在 <code>proxy</code> 阶段：</p>
<div><pre><code><span>const</span> sharedPropertyDefinition <span>=</span> <span>{</span>
  <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
  <span>configurable</span><span>:</span> <span>true</span><span>,</span>
  <span>get</span><span>:</span> noop<span>,</span>
  <span>set</span><span>:</span> noop
<span>}</span>

<span>export</span> <span>function</span> <span>proxy</span> <span>(</span><span><span>target</span><span>:</span> Object<span>,</span> <span>sourceKey</span><span>:</span> string<span>,</span> <span>key</span><span>:</span> string</span><span>)</span> <span>{</span>
  sharedPropertyDefinition<span>.</span><span>get</span> <span>=</span> <span>function</span> <span>proxyGetter</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>[</span>sourceKey<span>]</span><span>[</span>key<span>]</span>
  <span>}</span>
  sharedPropertyDefinition<span>.</span><span>set</span> <span>=</span> <span>function</span> <span>proxySetter</span> <span>(</span><span>val</span><span>)</span> <span>{</span>
    <span>this</span><span>[</span>sourceKey<span>]</span><span>[</span>key<span>]</span> <span>=</span> val
  <span>}</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> key<span>,</span> sharedPropertyDefinition<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>proxy</code> 方法的实现很简单，通过 <code>Object.defineProperty</code> 把 <code>target[sourceKey][key]</code> 的读写变成了对 <code>target[key]</code>  的读写。所以对于 <code>props</code> 而言，对 <code>vm._props.xxx</code> 的读写变成了 <code>vm.xxx</code> 的读写，而对于 <code>vm._props.xxx</code> 我们可以访问到定义在 <code>props</code> 中的属性，所以我们就可以通过 <code>vm.xxx</code> 访问到定义在 <code>props</code> 中的 <code>xxx</code> 属性了。同理，对于 <code>data</code> 而言，对 <code>vm._data.xxxx</code> 的读写变成了对 <code>vm.xxxx</code> 的读写，而对于 <code>vm._data.xxxx</code> 我们可以访问到定义在 <code>data</code> 函数返回对象中的属性，所以我们就可以通过 <code>vm.xxxx</code> 访问到定义在 <code>data</code> 函数返回对象中的 <code>xxxx</code> 属性了。</p>
<h2 id="observe" tabindex="-1"> <code>observe</code></h2>
<p><code>observe</code> 的功能就是用来监测数据的变化，它的定义在 <code>src/core/observer/index.js</code> 中：</p>
<div><pre><code><span>/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */</span>
<span>export</span> <span>function</span> <span>observe</span> <span>(</span><span><span>value</span><span>:</span> any<span>,</span> <span>asRootData</span><span>:</span> <span>?</span>boolean</span><span>)</span><span>:</span> Observer <span>|</span> <span>void</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>isObject</span><span>(</span>value<span>)</span> <span>||</span> value <span>instanceof</span> <span>VNode</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>let</span> <span>ob</span><span>:</span> Observer <span>|</span> <span>void</span>
  <span>if</span> <span>(</span><span>hasOwn</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>)</span> <span>&amp;&amp;</span> value<span>.</span>__ob__ <span>instanceof</span> <span>Observer</span><span>)</span> <span>{</span>
    ob <span>=</span> value<span>.</span>__ob__
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>
    shouldObserve <span>&amp;&amp;</span>
    <span>!</span><span>isServerRendering</span><span>(</span><span>)</span> <span>&amp;&amp;</span>
    <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span> <span>||</span> <span>isPlainObject</span><span>(</span>value<span>)</span><span>)</span> <span>&amp;&amp;</span>
    Object<span>.</span><span>isExtensible</span><span>(</span>value<span>)</span> <span>&amp;&amp;</span>
    <span>!</span>value<span>.</span>_isVue
  <span>)</span> <span>{</span>
    ob <span>=</span> <span>new</span> <span>Observer</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>asRootData <span>&amp;&amp;</span> ob<span>)</span> <span>{</span>
    ob<span>.</span>vmCount<span>++</span>
  <span>}</span>
  <span>return</span> ob
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>observe</code> 方法的作用就是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。接下来我们来看一下 <code>Observer</code> 的作用。</p>
<h2 id="observer" tabindex="-1"> Observer</h2>
<p><code>Observer</code> 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新：</p>
<div><pre><code><span>/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */</span>
<span>export</span> <span>class</span> <span>Observer</span> <span>{</span>
  <span>value</span><span>:</span> any<span>;</span>
  <span>dep</span><span>:</span> Dep<span>;</span>
  <span>vmCount</span><span>:</span> number<span>;</span> <span>// number of vms that has this object as root $data</span>

  <span>constructor</span> <span>(</span><span><span>value</span><span>:</span> any</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> value
    <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    <span>this</span><span>.</span>vmCount <span>=</span> <span>0</span>
    <span>def</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>,</span> <span>this</span><span>)</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
      <span>const</span> augment <span>=</span> hasProto
        <span>?</span> protoAugment
        <span>:</span> copyAugment
      <span>augment</span><span>(</span>value<span>,</span> arrayMethods<span>,</span> arrayKeys<span>)</span>
      <span>this</span><span>.</span><span>observeArray</span><span>(</span>value<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>/**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */</span>
  <span>walk</span> <span>(</span><span><span>obj</span><span>:</span> Object</span><span>)</span> <span>{</span>
    <span>const</span> keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> keys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>defineReactive</span><span>(</span>obj<span>,</span> keys<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>/**
   * Observe a list of Array items.
   */</span>
  <span>observeArray</span> <span>(</span><span><span>items</span><span>:</span> Array<span>&lt;</span>any<span>></span></span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> items<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>observe</span><span>(</span>items<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Observer</code> 的构造函数逻辑很简单，首先实例化 <code>Dep</code> 对象，这块稍后会介绍，接着通过执行 <code>def</code> 函数把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上，<code>def</code> 的定义在 <code>src/core/util/lang.js</code> 中：</p>
<div><pre><code><span>/**
 * Define a property.
 */</span>
<span>export</span> <span>function</span> <span>def</span> <span>(</span><span><span>obj</span><span>:</span> Object<span>,</span> <span>key</span><span>:</span> string<span>,</span> <span>val</span><span>:</span> any<span>,</span> enumerable<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>value</span><span>:</span> val<span>,</span>
    <span>enumerable</span><span>:</span> <span>!</span><span>!</span>enumerable<span>,</span>
    <span>writable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>def</code> 函数是一个非常简单的<code>Object.defineProperty</code> 的封装，这就是为什么我在开发中输出 <code>data</code> 上对象类型的数据，会发现该对象多了一个 <code>__ob__</code> 的属性。</p>
<p>回到 <code>Observer</code> 的构造函数，接下来会对 <code>value</code> 做判断，对于数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code> 方法。可以看到 <code>observeArray</code> 是遍历数组再次调用 <code>observe</code> 方法，而 <code>walk</code> 方法是遍历对象的 key 调用 <code>defineReactive</code> 方法，那么我们来看一下这个方法是做什么的。</p>
<h2 id="definereactive" tabindex="-1"> defineReactive</h2>
<p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 <code>src/core/observer/index.js</code> 中：</p>
<div><pre><code><span>/**
 * Define a reactive property on an Object.
 */</span>
<span>export</span> <span>function</span> <span>defineReactive</span> <span>(</span>
  <span><span>obj</span><span>:</span> Object<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>val</span><span>:</span> any<span>,</span>
  customSetter<span>?</span><span>:</span> <span>?</span>Function<span>,</span>
  shallow<span>?</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>

  <span>const</span> property <span>=</span> Object<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span>obj<span>,</span> key<span>)</span>
  <span>if</span> <span>(</span>property <span>&amp;&amp;</span> property<span>.</span>configurable <span>===</span> <span>false</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>// cater for pre-defined getter/setters</span>
  <span>const</span> getter <span>=</span> property <span>&amp;&amp;</span> property<span>.</span>get
  <span>const</span> setter <span>=</span> property <span>&amp;&amp;</span> property<span>.</span>set
  <span>if</span> <span>(</span><span>(</span><span>!</span>getter <span>||</span> setter<span>)</span> <span>&amp;&amp;</span> arguments<span>.</span>length <span>===</span> <span>2</span><span>)</span> <span>{</span>
    val <span>=</span> obj<span>[</span>key<span>]</span>
  <span>}</span>

  <span>let</span> childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>val<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span> <span>(</span><span>)</span> <span>{</span>
      <span>const</span> value <span>=</span> getter <span>?</span> <span>getter</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>:</span> val
      <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> <span>{</span>
        dep<span>.</span><span>depend</span><span>(</span><span>)</span>
        <span>if</span> <span>(</span>childOb<span>)</span> <span>{</span>
          childOb<span>.</span>dep<span>.</span><span>depend</span><span>(</span><span>)</span>
          <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
            <span>dependArray</span><span>(</span>value<span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
      <span>return</span> value
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span> <span>(</span><span>newVal</span><span>)</span> <span>{</span>
      <span>const</span> value <span>=</span> getter <span>?</span> <span>getter</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>:</span> val
      <span>/* eslint-disable no-self-compare */</span>
      <span>if</span> <span>(</span>newVal <span>===</span> value <span>||</span> <span>(</span>newVal <span>!==</span> newVal <span>&amp;&amp;</span> value <span>!==</span> value<span>)</span><span>)</span> <span>{</span>
        <span>return</span>
      <span>}</span>
      <span>/* eslint-enable no-self-compare */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> customSetter<span>)</span> <span>{</span>
        <span>customSetter</span><span>(</span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>setter<span>)</span> <span>{</span>
        <span>setter</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> newVal<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        val <span>=</span> newVal
      <span>}</span>
      childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>newVal<span>)</span>
      dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>defineReactive</code> 函数最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 <code>Object.defineProperty</code> 去给 <code>obj</code> 的属性 <code>key</code> 添加 getter 和 setter。而关于 getter 和 setter 的具体实现，我们会在之后介绍。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>这一节我们介绍了响应式对象，核心就是利用 <code>Object.defineProperty</code> 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新，那么在接下来的章节我们会重点对这两个过程分析。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">派发更新</title>
    <id>https://0808200.xyz/vue2/reactive/setters.html</id>
    <link href="https://0808200.xyz/vue2/reactive/setters.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="派发更新" tabindex="-1"> 派发更新</h1>
<p>通过上一节分析我们了解了响应式数据依赖收集过程，收集的目的就是为了当我们修改数据的时候，可以对相关的依赖派发更新，那么这一节我们来详细分析这个过程。</p>
<p>我们先来回顾一下 setter 部分的逻辑：</p>
<div><pre><code><span>/**
 * Define a reactive property on an Object.
 */</span>
<span>export</span> <span>function</span> <span>defineReactive</span> <span>(</span>
  <span><span>obj</span><span>:</span> Object<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>val</span><span>:</span> any<span>,</span>
  customSetter<span>?</span><span>:</span> <span>?</span>Function<span>,</span>
  shallow<span>?</span><span>:</span> boolean</span>
<span>)</span> <span>{</span>
  <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>

  <span>const</span> property <span>=</span> Object<span>.</span><span>getOwnPropertyDescriptor</span><span>(</span>obj<span>,</span> key<span>)</span>
  <span>if</span> <span>(</span>property <span>&amp;&amp;</span> property<span>.</span>configurable <span>===</span> <span>false</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>// cater for pre-defined getter/setters</span>
  <span>const</span> getter <span>=</span> property <span>&amp;&amp;</span> property<span>.</span>get
  <span>const</span> setter <span>=</span> property <span>&amp;&amp;</span> property<span>.</span>set
  <span>if</span> <span>(</span><span>(</span><span>!</span>getter <span>||</span> setter<span>)</span> <span>&amp;&amp;</span> arguments<span>.</span>length <span>===</span> <span>2</span><span>)</span> <span>{</span>
    val <span>=</span> obj<span>[</span>key<span>]</span>
  <span>}</span>

  <span>let</span> childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>val<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    <span>enumerable</span><span>:</span> <span>true</span><span>,</span>
    <span>configurable</span><span>:</span> <span>true</span><span>,</span>
    <span>// ...</span>
    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span> <span>(</span><span>newVal</span><span>)</span> <span>{</span>
      <span>const</span> value <span>=</span> getter <span>?</span> <span>getter</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>:</span> val
      <span>/* eslint-disable no-self-compare */</span>
      <span>if</span> <span>(</span>newVal <span>===</span> value <span>||</span> <span>(</span>newVal <span>!==</span> newVal <span>&amp;&amp;</span> value <span>!==</span> value<span>)</span><span>)</span> <span>{</span>
        <span>return</span>
      <span>}</span>
      <span>/* eslint-enable no-self-compare */</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> customSetter<span>)</span> <span>{</span>
        <span>customSetter</span><span>(</span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>setter<span>)</span> <span>{</span>
        <span>setter</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> newVal<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        val <span>=</span> newVal
      <span>}</span>
      childOb <span>=</span> <span>!</span>shallow <span>&amp;&amp;</span> <span>observe</span><span>(</span>newVal<span>)</span>
      dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>setter 的逻辑有 2 个关键的点，一个是 <code>childOb = !shallow &amp;&amp; observe(newVal)</code>，如果 <code>shallow</code> 为 false 的情况，会对新设置的值变成一个响应式对象；另一个是 <code>dep.notify()</code>，通知所有的订阅者，这是本节的关键，接下来我会带大家完整的分析整个派发更新的过程。</p>
<h2 id="过程分析" tabindex="-1"> 过程分析</h2>
<p>当我们在组件中对响应的数据做了修改，就会触发 setter 的逻辑，最后调用 <code>dep.notify()</code> 方法，
它是 <code>Dep</code> 的一个实例方法，定义在 <code>src/core/observer/dep.js</code> 中：</p>
<div><pre><code><span>class</span> <span>Dep</span> <span>{</span>
  <span>// ...</span>
  <span>notify</span> <span>(</span><span>)</span> <span>{</span>
  <span>// stabilize the subscriber list first</span>
    <span>const</span> subs <span>=</span> <span>this</span><span>.</span>subs<span>.</span><span>slice</span><span>(</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> subs<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      subs<span>[</span>i<span>]</span><span>.</span><span>update</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的逻辑非常简单，遍历所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法，它的定义在 <code>src/core/observer/watcher.js</code> 中：</p>
<div><pre><code><span>class</span> <span>Watcher</span> <span>{</span>
  <span>// ...</span>
  <span>update</span> <span>(</span><span>)</span> <span>{</span>
    <span>/* istanbul ignore else */</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>computed<span>)</span> <span>{</span>
      <span>// A computed property watcher has two modes: lazy and activated.</span>
      <span>// It initializes as lazy by default, and only becomes activated when</span>
      <span>// it is depended on by at least one subscriber, which is typically</span>
      <span>// another computed property or a component's render function.</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>dep<span>.</span>subs<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
        <span>// In lazy mode, we don't want to perform computations until necessary,</span>
        <span>// so we simply mark the watcher as dirty. The actual computation is</span>
        <span>// performed just-in-time in this.evaluate() when the computed property</span>
        <span>// is accessed.</span>
        <span>this</span><span>.</span>dirty <span>=</span> <span>true</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>// In activated mode, we want to proactively perform the computation</span>
        <span>// but only notify our subscribers when the value has indeed changed.</span>
        <span>this</span><span>.</span><span>getAndInvoke</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>this</span><span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span>
        <span>}</span><span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span>sync<span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>run</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>queueWatcher</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里对于 <code>Watcher</code> 的不同状态，会执行不同的逻辑，<code>computed</code> 和 <code>sync</code> 等状态的分析我会之后抽一小节详细介绍，在一般组件数据更新的场景，会走到最后一个 <code>queueWatcher(this)</code> 的逻辑，<code>queueWatcher</code> 的定义在 <code>src/core/observer/scheduler.js</code> 中：</p>
<div><pre><code><span>const</span> <span>queue</span><span>:</span> Array<span>&lt;</span>Watcher<span>></span> <span>=</span> <span>[</span><span>]</span>
<span>let</span> <span>has</span><span>:</span> <span>{</span> <span>[</span>key<span>:</span> number<span>]</span><span>:</span> <span>?</span><span>true</span> <span>}</span> <span>=</span> <span>{</span><span>}</span>
<span>let</span> waiting <span>=</span> <span>false</span>
<span>let</span> flushing <span>=</span> <span>false</span>
<span>/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */</span>
<span>export</span> <span>function</span> <span>queueWatcher</span> <span>(</span><span><span>watcher</span><span>:</span> Watcher</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> watcher<span>.</span>id
  <span>if</span> <span>(</span>has<span>[</span>id<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
    has<span>[</span>id<span>]</span> <span>=</span> <span>true</span>
    <span>if</span> <span>(</span><span>!</span>flushing<span>)</span> <span>{</span>
      queue<span>.</span><span>push</span><span>(</span>watcher<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// if already flushing, splice the watcher based on its id</span>
      <span>// if already past its id, it will be run next immediately.</span>
      <span>let</span> i <span>=</span> queue<span>.</span>length <span>-</span> <span>1</span>
      <span>while</span> <span>(</span>i <span>></span> index <span>&amp;&amp;</span> queue<span>[</span>i<span>]</span><span>.</span>id <span>></span> watcher<span>.</span>id<span>)</span> <span>{</span>
        i<span>--</span>
      <span>}</span>
      queue<span>.</span><span>splice</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> <span>0</span><span>,</span> watcher<span>)</span>
    <span>}</span>
    <span>// queue the flush</span>
    <span>if</span> <span>(</span><span>!</span>waiting<span>)</span> <span>{</span>
      waiting <span>=</span> <span>true</span>
      <span>nextTick</span><span>(</span>flushSchedulerQueue<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里引入了一个队列的概念，这也是 Vue 在做派发更新的时候的一个优化的点，它并不会每次数据改变都触发 <code>watcher</code> 的回调，而是把这些 <code>watcher</code> 先添加到一个队列里，然后在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code>。</p>
<p>这里有几个细节要注意一下，首先用 <code>has</code> 对象保证同一个 <code>Watcher</code> 只添加一次；接着对 <code>flushing</code> 的判断，else 部分的逻辑稍后我会讲；最后通过 <code>waiting</code> 保证对 <code>nextTick(flushSchedulerQueue)</code> 的调用逻辑只有一次，另外 <code>nextTick</code> 的实现我之后会抽一小节专门去讲，目前就可以理解它是在下一个 tick，也就是异步的去执行 <code>flushSchedulerQueue</code>。</p>
<p>接下来我们来看 <code>flushSchedulerQueue</code> 的实现，它的定义在 <code>src/core/observer/scheduler.js</code> 中。</p>
<div><pre><code><span>let</span> flushing <span>=</span> <span>false</span>
<span>let</span> index <span>=</span> <span>0</span>
<span>/**
 * Flush both queues and run the watchers.
 */</span>
<span>function</span> <span>flushSchedulerQueue</span> <span>(</span><span>)</span> <span>{</span>
  flushing <span>=</span> <span>true</span>
  <span>let</span> watcher<span>,</span> id

  <span>// Sort queue before flush.</span>
  <span>// This ensures that:</span>
  <span>// 1. Components are updated from parent to child. (because parent is always</span>
  <span>//    created before the child)</span>
  <span>// 2. A component's user watchers are run before its render watcher (because</span>
  <span>//    user watchers are created before the render watcher)</span>
  <span>// 3. If a component is destroyed during a parent component's watcher run,</span>
  <span>//    its watchers can be skipped.</span>
  queue<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a<span>.</span>id <span>-</span> b<span>.</span>id<span>)</span>

  <span>// do not cache length because more watchers might be pushed</span>
  <span>// as we run existing watchers</span>
  <span>for</span> <span>(</span>index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> queue<span>.</span>length<span>;</span> index<span>++</span><span>)</span> <span>{</span>
    watcher <span>=</span> queue<span>[</span>index<span>]</span>
    <span>if</span> <span>(</span>watcher<span>.</span>before<span>)</span> <span>{</span>
      watcher<span>.</span><span>before</span><span>(</span><span>)</span>
    <span>}</span>
    id <span>=</span> watcher<span>.</span>id
    has<span>[</span>id<span>]</span> <span>=</span> <span>null</span>
    watcher<span>.</span><span>run</span><span>(</span><span>)</span>
    <span>// in dev build, check and stop circular updates.</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> has<span>[</span>id<span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      circular<span>[</span>id<span>]</span> <span>=</span> <span>(</span>circular<span>[</span>id<span>]</span> <span>||</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>
      <span>if</span> <span>(</span>circular<span>[</span>id<span>]</span> <span>></span> <span>MAX_UPDATE_COUNT</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>'You may have an infinite update loop '</span> <span>+</span> <span>(</span>
            watcher<span>.</span>user
              <span>?</span> <span><span>`</span><span>in watcher with expression "</span><span><span>${</span>watcher<span>.</span>expression<span>}</span></span><span>"</span><span>`</span></span>
              <span>:</span> <span><span>`</span><span>in a component render function.</span><span>`</span></span>
          <span>)</span><span>,</span>
          watcher<span>.</span>vm
        <span>)</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>// keep copies of post queues before resetting state</span>
  <span>const</span> activatedQueue <span>=</span> activatedChildren<span>.</span><span>slice</span><span>(</span><span>)</span>
  <span>const</span> updatedQueue <span>=</span> queue<span>.</span><span>slice</span><span>(</span><span>)</span>

  <span>resetSchedulerState</span><span>(</span><span>)</span>

  <span>// call component updated and activated hooks</span>
  <span>callActivatedHooks</span><span>(</span>activatedQueue<span>)</span>
  <span>callUpdatedHooks</span><span>(</span>updatedQueue<span>)</span>

  <span>// devtool hook</span>
  <span>/* istanbul ignore if */</span>
  <span>if</span> <span>(</span>devtools <span>&amp;&amp;</span> config<span>.</span>devtools<span>)</span> <span>{</span>
    devtools<span>.</span><span>emit</span><span>(</span><span>'flush'</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里有几个重要的逻辑要梳理一下，对于一些分支逻辑如 <code>keep-alive</code> 组件相关和之前提到过的 <code>updated</code> 钩子函数的执行会略过。</p>
<ul>
<li>队列排序</li>
</ul>
<p><code>queue.sort((a, b) =&gt; a.id - b.id)</code> 对队列做了从小到大的排序，这么做主要有以下要确保以下几点：</p>
<p>1.组件的更新由父到子；因为父组件的创建过程是先于子的，所以 <code>watcher</code> 的创建也是先父后子，执行顺序也应该保持先父后子。</p>
<p>2.用户的自定义 <code>watcher</code> 要优先于渲染 <code>watcher</code> 执行；因为用户自定义 <code>watcher</code> 是在渲染 <code>watcher</code> 之前创建的。</p>
<p>3.如果一个组件在父组件的 <code>watcher</code> 执行期间被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过，所以父组件的 <code>watcher</code> 应该先执行。</p>
<ul>
<li>队列遍历</li>
</ul>
<p>在对 <code>queue</code> 排序后，接着就是要对它做遍历，拿到对应的 <code>watcher</code>，执行 <code>watcher.run()</code>。这里需要注意一个细节，在遍历的时候每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 的时候，很可能用户会再次添加新的 <code>watcher</code>，这样会再次执行到 <code>queueWatcher</code>，如下：</p>
<div><pre><code><span>export</span> <span>function</span> <span>queueWatcher</span> <span>(</span><span><span>watcher</span><span>:</span> Watcher</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> watcher<span>.</span>id
  <span>if</span> <span>(</span>has<span>[</span>id<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
    has<span>[</span>id<span>]</span> <span>=</span> <span>true</span>
    <span>if</span> <span>(</span><span>!</span>flushing<span>)</span> <span>{</span>
      queue<span>.</span><span>push</span><span>(</span>watcher<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// if already flushing, splice the watcher based on its id</span>
      <span>// if already past its id, it will be run next immediately.</span>
      <span>let</span> i <span>=</span> queue<span>.</span>length <span>-</span> <span>1</span>
      <span>while</span> <span>(</span>i <span>></span> index <span>&amp;&amp;</span> queue<span>[</span>i<span>]</span><span>.</span>id <span>></span> watcher<span>.</span>id<span>)</span> <span>{</span>
        i<span>--</span>
      <span>}</span>
      queue<span>.</span><span>splice</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> <span>0</span><span>,</span> watcher<span>)</span>
    <span>}</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，这时候 <code>flushing</code> 为 true，就会执行到 else 的逻辑，然后就会从后往前找，找到第一个待插入 <code>watcher</code> 的 id 比当前队列中 <code>watcher</code> 的 id 大的位置。把 <code>watcher</code> 按照 <code>id </code>的插入到队列中，因此 <code>queue</code> 的长度发生了变化。</p>
<ul>
<li>状态恢复</li>
</ul>
<p>这个过程就是执行 <code>resetSchedulerState</code> 函数，它的定义在 <code>src/core/observer/scheduler.js</code> 中。</p>
<div><pre><code><span>const</span> <span>queue</span><span>:</span> Array<span>&lt;</span>Watcher<span>></span> <span>=</span> <span>[</span><span>]</span>
<span>let</span> <span>has</span><span>:</span> <span>{</span> <span>[</span>key<span>:</span> number<span>]</span><span>:</span> <span>?</span><span>true</span> <span>}</span> <span>=</span> <span>{</span><span>}</span>
<span>let</span> <span>circular</span><span>:</span> <span>{</span> <span>[</span>key<span>:</span> number<span>]</span><span>:</span> number <span>}</span> <span>=</span> <span>{</span><span>}</span>
<span>let</span> waiting <span>=</span> <span>false</span>
<span>let</span> flushing <span>=</span> <span>false</span>
<span>let</span> index <span>=</span> <span>0</span>
<span>/**
 * Reset the scheduler's state.
 */</span>
<span>function</span> <span>resetSchedulerState</span> <span>(</span><span>)</span> <span>{</span>
  index <span>=</span> queue<span>.</span>length <span>=</span> activatedChildren<span>.</span>length <span>=</span> <span>0</span>
  has <span>=</span> <span>{</span><span>}</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    circular <span>=</span> <span>{</span><span>}</span>
  <span>}</span>
  waiting <span>=</span> flushing <span>=</span> <span>false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>逻辑非常简单，就是把这些控制流程状态的一些变量恢复到初始值，把 <code>watcher</code> 队列清空。</p>
<p>接下来我们继续分析 <code>watcher.run()</code> 的逻辑，它的定义在 <code>src/core/observer/watcher.js</code> 中。</p>
<div><pre><code><span>class</span> <span>Watcher</span> <span>{</span>
  <span>/**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */</span>
  <span>run</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>active<span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>getAndInvoke</span><span>(</span><span>this</span><span>.</span>cb<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>getAndInvoke</span> <span>(</span><span><span>cb</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>const</span> value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span>
      value <span>!==</span> <span>this</span><span>.</span>value <span>||</span>
      <span>// Deep watchers and watchers on Object/Arrays should fire even</span>
      <span>// when the value is the same, because the value may</span>
      <span>// have mutated.</span>
      <span>isObject</span><span>(</span>value<span>)</span> <span>||</span>
      <span>this</span><span>.</span>deep
    <span>)</span> <span>{</span>
      <span>// set new value</span>
      <span>const</span> oldValue <span>=</span> <span>this</span><span>.</span>value
      <span>this</span><span>.</span>value <span>=</span> value
      <span>this</span><span>.</span>dirty <span>=</span> <span>false</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>user<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
          <span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> value<span>,</span> oldValue<span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
          <span>handleError</span><span>(</span>e<span>,</span> <span>this</span><span>.</span>vm<span>,</span> <span><span>`</span><span>callback for watcher "</span><span><span>${</span><span>this</span><span>.</span>expression<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> value<span>,</span> oldValue<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>run</code> 函数实际上就是执行 <code>this.getAndInvoke</code> 方法，并传入 <code>watcher</code> 的回调函数。<code>getAndInvoke</code> 函数逻辑也很简单，先通过 <code>this.get()</code> 得到它当前的值，然后做判断，如果满足新旧值不等、新值是对象类型、<code>deep</code> 模式任何一个条件，则执行 <code>watcher</code> 的回调，注意回调函数执行的时候会把第一个和第二个参数传入新值 <code>value</code> 和旧值 <code>oldValue</code>，这就是当我们添加自定义 <code>watcher</code> 的时候能在回调函数的参数中拿到新旧值的原因。</p>
<p>那么对于渲染 <code>watcher</code> 而言，它在执行 <code>this.get()</code> 方法求值的时候，会执行 <code>getter</code> 方法：</p>
<div><pre><code><span>updateComponent</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  vm<span>.</span><span>_update</span><span>(</span>vm<span>.</span><span>_render</span><span>(</span><span>)</span><span>,</span> hydrating<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>所以这就是当我们去修改组件相关的响应式数据的时候，会触发组件重新渲染的原因，接着就会重新执行 <code>patch</code> 的过程，但它和首次渲染有所不同，之后我们会花一小节去详细介绍。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节的分析，我们对 Vue 数据修改派发更新的过程也有了认识，实际上就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 <code>watcher</code>，都触发它们的 <code>update</code> 过程，这个过程又利用了队列做了进一步优化，在 <code>nextTick</code> 后执行所有 <code>watcher</code> 的 <code>run</code>，最后执行它们的回调函数。<code>nextTick</code> 是 Vue 一个比较核心的实现了，下一节我们来重点分析它的实现。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">原理图</title>
    <id>https://0808200.xyz/vue2/reactive/summary.html</id>
    <link href="https://0808200.xyz/vue2/reactive/summary.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原理图" tabindex="-1"> 原理图</h1>
<img :src="$withBase('/assets/reactive.png')">
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue-Router</title>
    <id>https://0808200.xyz/vue2/vue-router/</id>
    <link href="https://0808200.xyz/vue2/vue-router/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vue-router" tabindex="-1"> Vue-Router</h1>
<p>路由的概念相信大部分同学并不陌生，它的作用就是根据不同的路径映射到不同的视图。我们在用 Vue 开发过实际项目的时候都会用到 Vue-Router 这个官方插件来帮我们解决路由的问题。Vue-Router 的能力十分强大，它支持 <code>hash</code>、<code>history</code>、<code>abstract</code> 3 种路由方式，提供了 <code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code> 2 种组件，还提供了简单的路由配置和一系列好用的 API。</p>
<p>大部分同学已经掌握了路由的基本使用，但使用的过程中也难免会遇到一些坑，那么这一章我们就来深挖 Vue-Router 的实现细节，一旦我们掌握了它的实现原理，那么就能在开发中对路由的使用更加游刃有余。</p>
<p>同样我们也会通过一些具体的示例来配合讲解，先来看一个最基本使用例子：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>Hello App!<span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    <span>&lt;!-- 使用 router-link 组件来导航. --></span>
    <span>&lt;!-- 通过传入 `to` 属性指定链接. --></span>
    <span>&lt;!-- &lt;router-link> 默认会被渲染成一个 `&lt;a>` 标签 --></span>
    <span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/foo<span>"</span></span><span>></span></span>Go to Foo<span><span><span>&lt;/</span>router-link</span><span>></span></span>
    <span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/bar<span>"</span></span><span>></span></span>Go to Bar<span><span><span>&lt;/</span>router-link</span><span>></span></span>
  <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span>&lt;!-- 路由出口 --></span>
  <span>&lt;!-- 路由匹配到的组件将渲染在这里 --></span>
  <span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> VueRouter <span>from</span> <span>'vue-router'</span>
<span>import</span> App <span>from</span> <span>'./App'</span>

Vue<span>.</span><span>use</span><span>(</span>VueRouter<span>)</span>

<span>// 1. 定义（路由）组件。</span>
<span>// 可以从其他文件 import 进来</span>
<span>const</span> Foo <span>=</span> <span>{</span> <span>template</span><span>:</span> <span>'&lt;div>foo&lt;/div>'</span> <span>}</span>
<span>const</span> Bar <span>=</span> <span>{</span> <span>template</span><span>:</span> <span>'&lt;div>bar&lt;/div>'</span> <span>}</span>

<span>// 2. 定义路由</span>
<span>// 每个路由应该映射一个组件。 其中"component" 可以是</span>
<span>// 通过 Vue.extend() 创建的组件构造器，</span>
<span>// 或者，只是一个组件配置对象。</span>
<span>// 我们晚点再讨论嵌套路由。</span>
<span>const</span> routes <span>=</span> <span>[</span>
  <span>{</span> <span>path</span><span>:</span> <span>'/foo'</span><span>,</span> <span>component</span><span>:</span> Foo <span>}</span><span>,</span>
  <span>{</span> <span>path</span><span>:</span> <span>'/bar'</span><span>,</span> <span>component</span><span>:</span> Bar <span>}</span>
<span>]</span>

<span>// 3. 创建 router 实例，然后传 `routes` 配置</span>
<span>// 你还可以传别的配置参数, 不过先这么简单着吧。</span>
<span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>
  routes <span>// （缩写）相当于 routes: routes</span>
<span>}</span><span>)</span>

<span>// 4. 创建和挂载根实例。</span>
<span>// 记得要通过 router 配置参数注入路由，</span>
<span>// 从而让整个应用都有路由功能</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>'#app'</span><span>,</span>
  <span>render</span><span>(</span><span>h</span><span>)</span> <span>{</span>
    <span>return</span> <span>h</span><span>(</span>App<span>)</span>
  <span>}</span><span>,</span>
  router
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这是一个非常简单的例子，接下来我们先从 <code>Vue.use(VueRouter)</code> 说起。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">路由注册</title>
    <id>https://0808200.xyz/vue2/vue-router/install.html</id>
    <link href="https://0808200.xyz/vue2/vue-router/install.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="路由注册" tabindex="-1"> 路由注册</h1>
<p>Vue 从它的设计上就是一个渐进式 JavaScript 框架，它本身的核心是解决视图渲染的问题，其它的能力就通过插件的方式来解决。Vue-Router 就是官方维护的路由插件，在介绍它的注册实现之前，我们先来分析一下 Vue 通用的插件注册原理。</p>
<h2 id="vue-use" tabindex="-1"> <code>Vue.use</code></h2>
<p>Vue 提供了 <code>Vue.use</code> 的全局 API 来注册这些插件，所以我们先来分析一下它的实现原理，定义在 <code>vue/src/core/global-api/use.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initUse</span> <span>(</span><span><span>Vue</span><span>:</span> GlobalAPI</span><span>)</span> <span>{</span>
  Vue<span>.</span><span>use</span> <span>=</span> <span>function</span> <span>(</span><span><span>plugin</span><span>:</span> Function <span>|</span> Object</span><span>)</span> <span>{</span>
    <span>const</span> installedPlugins <span>=</span> <span>(</span><span>this</span><span>.</span>_installedPlugins <span>||</span> <span>(</span><span>this</span><span>.</span>_installedPlugins <span>=</span> <span>[</span><span>]</span><span>)</span><span>)</span>
    <span>if</span> <span>(</span>installedPlugins<span>.</span><span>indexOf</span><span>(</span>plugin<span>)</span> <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      <span>return</span> <span>this</span>
    <span>}</span>

    <span>const</span> args <span>=</span> <span>toArray</span><span>(</span>arguments<span>,</span> <span>1</span><span>)</span>
    args<span>.</span><span>unshift</span><span>(</span><span>this</span><span>)</span>
    <span>if</span> <span>(</span><span>typeof</span> plugin<span>.</span>install <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      plugin<span>.</span><span>install</span><span>.</span><span>apply</span><span>(</span>plugin<span>,</span> args<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> plugin <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>plugin</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> args<span>)</span>
    <span>}</span>
    installedPlugins<span>.</span><span>push</span><span>(</span>plugin<span>)</span>
    <span>return</span> <span>this</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Vue.use</code> 接受一个 <code>plugin</code> 参数，并且维护了一个 <code>_installedPlugins</code> 数组，它存储所有注册过的 <code>plugin</code>；接着又会判断 <code>plugin</code> 有没有定义 <code>install</code> 方法，如果有的话则调用该方法，并且该方法执行的第一个参数是 <code>Vue</code>；最后把 <code>plugin</code> 存储到 <code>installedPlugins</code> 中。</p>
<p>可以看到 Vue 提供的插件注册机制很简单，每个插件都需要实现一个静态的 <code>install</code> 方法，当我们执行 <code>Vue.use</code> 注册插件的时候，就会执行这个 <code>install</code> 方法，并且在这个 <code>install</code> 方法的第一个参数我们可以拿到 <code>Vue</code> 对象，这样的好处就是作为插件的编写方不需要再额外去<code>import Vue</code> 了。</p>
<h2 id="路由安装" tabindex="-1"> 路由安装</h2>
<p>Vue-Router 的入口文件是 <code>src/index.js</code>，其中定义了 <code>VueRouter</code> 类，也实现了 <code>install</code> 的静态方法：<code>VueRouter.install = install</code>，它的定义在 <code>src/install.js</code> 中。</p>
<div><pre><code><span>export</span> <span>let</span> _Vue
<span>export</span> <span>function</span> <span>install</span> <span>(</span><span>Vue</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>install<span>.</span>installed <span>&amp;&amp;</span> _Vue <span>===</span> Vue<span>)</span> <span>return</span>
  install<span>.</span>installed <span>=</span> <span>true</span>

  _Vue <span>=</span> Vue

  <span>const</span> <span>isDef</span> <span>=</span> <span>v</span> <span>=></span> v <span>!==</span> <span>undefined</span>

  <span>const</span> <span>registerInstance</span> <span>=</span> <span>(</span><span>vm<span>,</span> callVal</span><span>)</span> <span>=></span> <span>{</span>
    <span>let</span> i <span>=</span> vm<span>.</span>$options<span>.</span>_parentVnode
    <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>registerRouteInstance<span>)</span><span>)</span> <span>{</span>
      <span>i</span><span>(</span>vm<span>,</span> callVal<span>)</span>
    <span>}</span>
  <span>}</span>

  Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
    <span>beforeCreate</span> <span>(</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isDef</span><span>(</span><span>this</span><span>.</span>$options<span>.</span>router<span>)</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>_routerRoot <span>=</span> <span>this</span>
        <span>this</span><span>.</span>_router <span>=</span> <span>this</span><span>.</span>$options<span>.</span>router
        <span>this</span><span>.</span>_router<span>.</span><span>init</span><span>(</span><span>this</span><span>)</span>
        Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'_route'</span><span>,</span> <span>this</span><span>.</span>_router<span>.</span>history<span>.</span>current<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>this</span><span>.</span>_routerRoot <span>=</span> <span>(</span><span>this</span><span>.</span>$parent <span>&amp;&amp;</span> <span>this</span><span>.</span>$parent<span>.</span>_routerRoot<span>)</span> <span>||</span> <span>this</span>
      <span>}</span>
      <span>registerInstance</span><span>(</span><span>this</span><span>,</span> <span>this</span><span>)</span>
    <span>}</span><span>,</span>
    <span>destroyed</span> <span>(</span><span>)</span> <span>{</span>
      <span>registerInstance</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>

  Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$router'</span><span>,</span> <span>{</span>
    <span>get</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>this</span><span>.</span>_routerRoot<span>.</span>_router <span>}</span>
  <span>}</span><span>)</span>

  Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$route'</span><span>,</span> <span>{</span>
    <span>get</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>this</span><span>.</span>_routerRoot<span>.</span>_route <span>}</span>
  <span>}</span><span>)</span>

  Vue<span>.</span><span>component</span><span>(</span><span>'RouterView'</span><span>,</span> View<span>)</span>
  Vue<span>.</span><span>component</span><span>(</span><span>'RouterLink'</span><span>,</span> Link<span>)</span>

  <span>const</span> strats <span>=</span> Vue<span>.</span>config<span>.</span>optionMergeStrategies
  strats<span>.</span>beforeRouteEnter <span>=</span> strats<span>.</span>beforeRouteLeave <span>=</span> strats<span>.</span>beforeRouteUpdate <span>=</span> strats<span>.</span>created
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当用户执行 <code>Vue.use(VueRouter)</code> 的时候，实际上就是在执行 <code>install</code> 函数，为了确保 <code>install</code> 逻辑只执行一次，用了 <code>install.installed</code> 变量做已安装的标志位。另外用一个全局的 <code>_Vue</code> 来接收参数 <code>Vue</code>，因为作为 Vue 的插件对 <code>Vue</code> 对象是有依赖的，但又不能去单独去 <code>import Vue</code>，因为那样会增加包体积，所以就通过这种方式拿到 <code>Vue</code> 对象。</p>
<p>Vue-Router 安装最重要的一步就是利用 <code>Vue.mixin</code> 去把 <code>beforeCreate</code> 和 <code>destroyed</code> 钩子函数注入到每一个组件中。<code>Vue.mixin</code> 的定义，在 <code>vue/src/core/global-api/mixin.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>initMixin</span> <span>(</span><span><span>Vue</span><span>:</span> GlobalAPI</span><span>)</span> <span>{</span>
  Vue<span>.</span><span>mixin</span> <span>=</span> <span>function</span> <span>(</span><span><span>mixin</span><span>:</span> Object</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>options <span>=</span> <span>mergeOptions</span><span>(</span><span>this</span><span>.</span>options<span>,</span> mixin<span>)</span>
    <span>return</span> <span>this</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它的实现实际上非常简单，就是把要混入的对象通过 <code>mergeOptions</code> 合并到 <code>Vue</code> 的 <code>options</code> 中，由于每个组件的构造函数都会在 <code>extend</code> 阶段合并 <code>Vue.options</code> 到自身的 <code>options</code> 中，所以也就相当于每个组件都定义了 <code>mixin</code> 定义的选项。</p>
<p>回到 <code>Vue-Router</code> 的 <code>install</code> 方法，先看混入的 <code>beforeCreate</code> 钩子函数，对于根 <code>Vue</code> 实例而言，执行该钩子函数时定义了 <code>this._routerRoot</code> 表示它自身；<code>this._router</code> 表示 <code>VueRouter</code> 的实例 <code>router</code>，它是在 <code>new Vue</code> 的时候传入的；另外执行了 <code>this._router.init()</code> 方法初始化 <code>router</code>，这个逻辑之后介绍，然后用 <code>defineReactive</code> 方法把 <code>this._route</code> 变成响应式对象，这个作用我们之后会介绍。而对于子组件而言，由于组件是树状结构，在遍历组件树的过程中，它们在执行该钩子函数的时候 <code>this._routerRoot</code> 始终指向的离它最近的传入了 <code>router</code> 对象作为配置而实例化的父实例。</p>
<p>对于 <code>beforeCreate</code> 和 <code>destroyed</code> 钩子函数，它们都会执行 <code>registerInstance</code> 方法，这个方法的作用我们也是之后会介绍。</p>
<p>接着给 Vue 原型上定义了 <code>$router</code> 和 <code>$route</code> 2 个属性的 get 方法，这就是为什么我们可以在组件实例上可以访问 <code>this.$router</code> 以及 <code>this.$route</code>，它们的作用之后介绍。</p>
<p>接着又通过 <code>Vue.component</code> 方法定义了全局的 <code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code> 2 个组件，这也是为什么我们在写模板的时候可以使用这两个标签，它们的作用也是之后介绍。</p>
<p>最后定义了路由中的钩子函数的合并策略，和普通的钩子函数一样。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么到此为止，我们分析了 Vue-Router 的安装过程，Vue 编写插件的时候通常要提供静态的 <code>install</code> 方法，我们通过 <code>Vue.use(plugin)</code> 时候，就是在执行 <code>install</code> 方法。<code>Vue-Router</code> 的 <code>install</code> 方法会给每一个组件注入 <code>beforeCreate</code> 和 <code>destoryed</code> 钩子函数，在 <code>beforeCreate</code> 做一些私有属性定义和路由初始化工作，下一节我们就来分析一下 <code>VueRouter</code> 对象的实现和它的初始化工作。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">matcher</title>
    <id>https://0808200.xyz/vue2/vue-router/matcher.html</id>
    <link href="https://0808200.xyz/vue2/vue-router/matcher.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="matcher" tabindex="-1"> matcher</h1>
<p><code>matcher</code> 相关的实现都在 <code>src/create-matcher.js</code> 中，我们先来看一下 <code>matcher</code> 的数据结构：</p>
<div><pre><code><span>export</span> type Matcher <span>=</span> <span>{</span>
  <span>match</span><span>:</span> <span>(</span><span><span>raw</span><span>:</span> RawLocation<span>,</span> current<span>?</span><span>:</span> Route<span>,</span> redirectedFrom<span>?</span><span>:</span> Location</span><span>)</span> <span>=></span> Route<span>;</span>
  <span>addRoutes</span><span>:</span> <span>(</span><span><span>routes</span><span>:</span> Array<span>&lt;</span>RouteConfig<span>></span></span><span>)</span> <span>=></span> <span>void</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>Matcher</code> 返回了 2 个方法，<code>match</code> 和 <code>addRoutes</code>，在上一节我们接触到了 <code>match</code> 方法，顾名思义它是做匹配，那么匹配的是什么，在介绍之前，我们先了解路由中重要的 2 个概念，<code>Loaction</code> 和 <code>Route</code>，它们的数据结构定义在 <code>flow/declarations.js</code> 中。</p>
<ul>
<li>Location</li>
</ul>
<div><pre><code>declare type Location <span>=</span> <span>{</span>
  _normalized<span>?</span><span>:</span> boolean<span>;</span>
  name<span>?</span><span>:</span> string<span>;</span>
  path<span>?</span><span>:</span> string<span>;</span>
  hash<span>?</span><span>:</span> string<span>;</span>
  query<span>?</span><span>:</span> Dictionary<span>&lt;</span>string<span>></span><span>;</span>
  params<span>?</span><span>:</span> Dictionary<span>&lt;</span>string<span>></span><span>;</span>
  append<span>?</span><span>:</span> boolean<span>;</span>
  replace<span>?</span><span>:</span> boolean<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Vue-Router 中定义的 <code>Location</code> 数据结构和浏览器提供的 <code>window.location</code> 部分结构有点类似，它们都是对 <code>url</code> 的结构化描述。举个例子：<code>/abc?foo=bar&amp;baz=qux#hello</code>，它的 <code>path</code> 是 <code>/abc</code>，<code>query</code> 是 <code>{foo:'bar',baz:'qux'}</code>。<code>Location</code> 的其他属性我们之后会介绍。</p>
<ul>
<li>Route</li>
</ul>
<div><pre><code>declare type Route <span>=</span> <span>{</span>
  <span>path</span><span>:</span> string<span>;</span>
  <span>name</span><span>:</span> <span>?</span>string<span>;</span>
  <span>hash</span><span>:</span> string<span>;</span>
  <span>query</span><span>:</span> Dictionary<span>&lt;</span>string<span>></span><span>;</span>
  <span>params</span><span>:</span> Dictionary<span>&lt;</span>string<span>></span><span>;</span>
  <span>fullPath</span><span>:</span> string<span>;</span>
  <span>matched</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>;</span>
  redirectedFrom<span>?</span><span>:</span> string<span>;</span>
  meta<span>?</span><span>:</span> any<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Route</code> 表示的是路由中的一条线路，它除了描述了类似 <code>Loctaion</code> 的 <code>path</code>、<code>query</code>、<code>hash</code> 这些概念，还有 <code>matched</code> 表示匹配到的所有的 <code>RouteRecord</code>。<code>Route</code> 的其他属性我们之后会介绍。</p>
<h2 id="creatematcher" tabindex="-1"> <code>createMatcher</code></h2>
<p>在了解了 <code>Location</code> 和 <code>Route</code> 后，我们来看一下 <code>matcher</code> 的创建过程：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createMatcher</span> <span>(</span>
  <span><span>routes</span><span>:</span> Array<span>&lt;</span>RouteConfig<span>></span><span>,</span>
  <span>router</span><span>:</span> VueRouter</span>
<span>)</span><span>:</span> Matcher <span>{</span>
  <span>const</span> <span>{</span> pathList<span>,</span> pathMap<span>,</span> nameMap <span>}</span> <span>=</span> <span>createRouteMap</span><span>(</span>routes<span>)</span>

  <span>function</span> <span>addRoutes</span> <span>(</span><span>routes</span><span>)</span> <span>{</span>
    <span>createRouteMap</span><span>(</span>routes<span>,</span> pathList<span>,</span> pathMap<span>,</span> nameMap<span>)</span>
  <span>}</span>

  <span>function</span> <span>match</span> <span>(</span>
    <span><span>raw</span><span>:</span> RawLocation<span>,</span>
    currentRoute<span>?</span><span>:</span> Route<span>,</span>
    redirectedFrom<span>?</span><span>:</span> Location</span>
  <span>)</span><span>:</span> Route <span>{</span>
    <span>const</span> location <span>=</span> <span>normalizeLocation</span><span>(</span>raw<span>,</span> currentRoute<span>,</span> <span>false</span><span>,</span> router<span>)</span>
    <span>const</span> <span>{</span> name <span>}</span> <span>=</span> location

    <span>if</span> <span>(</span>name<span>)</span> <span>{</span>
      <span>const</span> record <span>=</span> nameMap<span>[</span>name<span>]</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>record<span>,</span> <span><span>`</span><span>Route with name '</span><span><span>${</span>name<span>}</span></span><span>' does not exist</span><span>`</span></span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span><span>!</span>record<span>)</span> <span>return</span> <span>_createRoute</span><span>(</span><span>null</span><span>,</span> location<span>)</span>
      <span>const</span> paramNames <span>=</span> record<span>.</span>regex<span>.</span>keys
        <span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span>key<span>.</span>optional<span>)</span>
        <span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> key<span>.</span>name<span>)</span>

      <span>if</span> <span>(</span><span>typeof</span> location<span>.</span>params <span>!==</span> <span>'object'</span><span>)</span> <span>{</span>
        location<span>.</span>params <span>=</span> <span>{</span><span>}</span>
      <span>}</span>

      <span>if</span> <span>(</span>currentRoute <span>&amp;&amp;</span> <span>typeof</span> currentRoute<span>.</span>params <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>const</span> key <span>in</span> currentRoute<span>.</span>params<span>)</span> <span>{</span>
          <span>if</span> <span>(</span><span>!</span><span>(</span>key <span>in</span> location<span>.</span>params<span>)</span> <span>&amp;&amp;</span> paramNames<span>.</span><span>indexOf</span><span>(</span>key<span>)</span> <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
            location<span>.</span>params<span>[</span>key<span>]</span> <span>=</span> currentRoute<span>.</span>params<span>[</span>key<span>]</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>

      <span>if</span> <span>(</span>record<span>)</span> <span>{</span>
        location<span>.</span>path <span>=</span> <span>fillParams</span><span>(</span>record<span>.</span>path<span>,</span> location<span>.</span>params<span>,</span> <span><span>`</span><span>named route "</span><span><span>${</span>name<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
        <span>return</span> <span>_createRoute</span><span>(</span>record<span>,</span> location<span>,</span> redirectedFrom<span>)</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>location<span>.</span>path<span>)</span> <span>{</span>
      location<span>.</span>params <span>=</span> <span>{</span><span>}</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> pathList<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>const</span> path <span>=</span> pathList<span>[</span>i<span>]</span>
        <span>const</span> record <span>=</span> pathMap<span>[</span>path<span>]</span>
        <span>if</span> <span>(</span><span>matchRoute</span><span>(</span>record<span>.</span>regex<span>,</span> location<span>.</span>path<span>,</span> location<span>.</span>params<span>)</span><span>)</span> <span>{</span>
          <span>return</span> <span>_createRoute</span><span>(</span>record<span>,</span> location<span>,</span> redirectedFrom<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> <span>_createRoute</span><span>(</span><span>null</span><span>,</span> location<span>)</span>
  <span>}</span>

  <span>// ...</span>

  <span>function</span> <span>_createRoute</span> <span>(</span>
    <span><span>record</span><span>:</span> <span>?</span>RouteRecord<span>,</span>
    <span>location</span><span>:</span> Location<span>,</span>
    redirectedFrom<span>?</span><span>:</span> Location</span>
  <span>)</span><span>:</span> Route <span>{</span>
    <span>if</span> <span>(</span>record <span>&amp;&amp;</span> record<span>.</span>redirect<span>)</span> <span>{</span>
      <span>return</span> <span>redirect</span><span>(</span>record<span>,</span> redirectedFrom <span>||</span> location<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>record <span>&amp;&amp;</span> record<span>.</span>matchAs<span>)</span> <span>{</span>
      <span>return</span> <span>alias</span><span>(</span>record<span>,</span> location<span>,</span> record<span>.</span>matchAs<span>)</span>
    <span>}</span>
    <span>return</span> <span>createRoute</span><span>(</span>record<span>,</span> location<span>,</span> redirectedFrom<span>,</span> router<span>)</span>
  <span>}</span>

  <span>return</span> <span>{</span>
    match<span>,</span>
    addRoutes
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createMatcher</code> 接收 2 个参数，一个是 <code>router</code>，它是我们 <code>new VueRouter</code> 返回的实例，一个是 <code>routes</code>，它是用户定义的路由配置，来看一下我们之前举的例子中的配置：</p>
<div><pre><code><span>const</span> Foo <span>=</span> <span>{</span> <span>template</span><span>:</span> <span>'&lt;div>foo&lt;/div>'</span> <span>}</span>
<span>const</span> Bar <span>=</span> <span>{</span> <span>template</span><span>:</span> <span>'&lt;div>bar&lt;/div>'</span> <span>}</span>

<span>const</span> routes <span>=</span> <span>[</span>
  <span>{</span> <span>path</span><span>:</span> <span>'/foo'</span><span>,</span> <span>component</span><span>:</span> Foo <span>}</span><span>,</span>
  <span>{</span> <span>path</span><span>:</span> <span>'/bar'</span><span>,</span> <span>component</span><span>:</span> Bar <span>}</span>
<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createMathcer</code> 首先执行的逻辑是 <code>const { pathList, pathMap, nameMap } = createRouteMap(routes)</code> 创建一个路由映射表，<code>createRouteMap</code> 的定义在 <code>src/create-route-map</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createRouteMap</span> <span>(</span>
  <span><span>routes</span><span>:</span> Array<span>&lt;</span>RouteConfig<span>></span><span>,</span>
  oldPathList<span>?</span><span>:</span> Array<span>&lt;</span>string<span>></span><span>,</span>
  oldPathMap<span>?</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  oldNameMap<span>?</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span></span>
<span>)</span><span>:</span> <span>{</span>
  <span>pathList</span><span>:</span> Array<span>&lt;</span>string<span>></span><span>;</span>
  <span>pathMap</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span><span>;</span>
  <span>nameMap</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span><span>;</span>
<span>}</span> <span>{</span>
  <span>const</span> <span>pathList</span><span>:</span> Array<span>&lt;</span>string<span>></span> <span>=</span> oldPathList <span>||</span> <span>[</span><span>]</span>
  <span>const</span> <span>pathMap</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span> <span>=</span> oldPathMap <span>||</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>const</span> <span>nameMap</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span> <span>=</span> oldNameMap <span>||</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>

  routes<span>.</span><span>forEach</span><span>(</span><span>route</span> <span>=></span> <span>{</span>
    <span>addRouteRecord</span><span>(</span>pathList<span>,</span> pathMap<span>,</span> nameMap<span>,</span> route<span>)</span>
  <span>}</span><span>)</span>

  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> pathList<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pathList<span>[</span>i<span>]</span> <span>===</span> <span>'*'</span><span>)</span> <span>{</span>
      pathList<span>.</span><span>push</span><span>(</span>pathList<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span><span>[</span><span>0</span><span>]</span><span>)</span>
      l<span>--</span>
      i<span>--</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>{</span>
    pathList<span>,</span>
    pathMap<span>,</span>
    nameMap
  <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createRouteMap</code> 函数的目标是把用户的路由配置转换成一张路由映射表，它包含 3 个部分，<code>pathList</code> 存储所有的 <code>path</code>，<code>pathMap</code> 表示一个 <code>path</code> 到 <code>RouteRecord</code> 的映射关系，而 <code>nameMap</code> 表示 <code>name</code> 到 <code>RouteRecord</code> 的映射关系。那么 <code>RouteRecord</code> 到底是什么，先来看一下它的数据结构：</p>
<div><pre><code>declare type RouteRecord <span>=</span> <span>{</span>
  <span>path</span><span>:</span> string<span>;</span>
  <span>regex</span><span>:</span> RouteRegExp<span>;</span>
  <span>components</span><span>:</span> Dictionary<span>&lt;</span>any<span>></span><span>;</span>
  <span>instances</span><span>:</span> Dictionary<span>&lt;</span>any<span>></span><span>;</span>
  <span>name</span><span>:</span> <span>?</span>string<span>;</span>
  <span>parent</span><span>:</span> <span>?</span>RouteRecord<span>;</span>
  <span>redirect</span><span>:</span> <span>?</span>RedirectOption<span>;</span>
  <span>matchAs</span><span>:</span> <span>?</span>string<span>;</span>
  <span>beforeEnter</span><span>:</span> <span>?</span>NavigationGuard<span>;</span>
  <span>meta</span><span>:</span> any<span>;</span>
  <span>props</span><span>:</span> boolean <span>|</span> Object <span>|</span> Function <span>|</span> Dictionary<span>&lt;</span>boolean <span>|</span> Object <span>|</span> Function<span>></span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它的创建是通过遍历 <code>routes</code> 为每一个 <code>route</code> 执行 <code>addRouteRecord</code> 方法生成一条记录，来看一下它的定义：</p>
<div><pre><code><span>function</span> <span>addRouteRecord</span> <span>(</span>
  <span><span>pathList</span><span>:</span> Array<span>&lt;</span>string<span>></span><span>,</span>
  <span>pathMap</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>nameMap</span><span>:</span> Dictionary<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>route</span><span>:</span> RouteConfig<span>,</span>
  parent<span>?</span><span>:</span> RouteRecord<span>,</span>
  matchAs<span>?</span><span>:</span> string</span>
<span>)</span> <span>{</span>
  <span>const</span> <span>{</span> path<span>,</span> name <span>}</span> <span>=</span> route
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>assert</span><span>(</span>path <span>!=</span> <span>null</span><span>,</span> <span><span>`</span><span>"path" is required in a route configuration.</span><span>`</span></span><span>)</span>
    <span>assert</span><span>(</span>
      <span>typeof</span> route<span>.</span>component <span>!==</span> <span>'string'</span><span>,</span>
      <span><span>`</span><span>route config "component" for path: </span><span><span>${</span><span>String</span><span>(</span>path <span>||</span> name<span>)</span><span>}</span></span><span> cannot be a </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>string id. Use an actual component instead.</span><span>`</span></span>
    <span>)</span>
  <span>}</span>

  <span>const</span> <span>pathToRegexpOptions</span><span>:</span> PathToRegexpOptions <span>=</span> route<span>.</span>pathToRegexpOptions <span>||</span> <span>{</span><span>}</span>
  <span>const</span> normalizedPath <span>=</span> <span>normalizePath</span><span>(</span>
    path<span>,</span>
    parent<span>,</span>
    pathToRegexpOptions<span>.</span>strict
  <span>)</span>

  <span>if</span> <span>(</span><span>typeof</span> route<span>.</span>caseSensitive <span>===</span> <span>'boolean'</span><span>)</span> <span>{</span>
    pathToRegexpOptions<span>.</span>sensitive <span>=</span> route<span>.</span>caseSensitive
  <span>}</span>

  <span>const</span> <span>record</span><span>:</span> RouteRecord <span>=</span> <span>{</span>
    <span>path</span><span>:</span> normalizedPath<span>,</span>
    <span>regex</span><span>:</span> <span>compileRouteRegex</span><span>(</span>normalizedPath<span>,</span> pathToRegexpOptions<span>)</span><span>,</span>
    <span>components</span><span>:</span> route<span>.</span>components <span>||</span> <span>{</span> <span>default</span><span>:</span> route<span>.</span>component <span>}</span><span>,</span>
    <span>instances</span><span>:</span> <span>{</span><span>}</span><span>,</span>
    name<span>,</span>
    parent<span>,</span>
    matchAs<span>,</span>
    <span>redirect</span><span>:</span> route<span>.</span>redirect<span>,</span>
    <span>beforeEnter</span><span>:</span> route<span>.</span>beforeEnter<span>,</span>
    <span>meta</span><span>:</span> route<span>.</span>meta <span>||</span> <span>{</span><span>}</span><span>,</span>
    <span>props</span><span>:</span> route<span>.</span>props <span>==</span> <span>null</span>
      <span>?</span> <span>{</span><span>}</span>
      <span>:</span> route<span>.</span>components
        <span>?</span> route<span>.</span>props
        <span>:</span> <span>{</span> <span>default</span><span>:</span> route<span>.</span>props <span>}</span>
  <span>}</span>

  <span>if</span> <span>(</span>route<span>.</span>children<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>route<span>.</span>name <span>&amp;&amp;</span> <span>!</span>route<span>.</span>redirect <span>&amp;&amp;</span> route<span>.</span>children<span>.</span><span>some</span><span>(</span><span>child</span> <span>=></span> <span><span>/</span><span>^\/?$</span><span>/</span></span><span>.</span><span>test</span><span>(</span>child<span>.</span>path<span>)</span><span>)</span><span>)</span> <span>{</span>
        <span>warn</span><span>(</span>
          <span>false</span><span>,</span>
          <span><span>`</span><span>Named Route '</span><span><span>${</span>route<span>.</span>name<span>}</span></span><span>' has a default child route. </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>When navigating to this named route (:to="{name: '</span><span><span>${</span>route<span>.</span>name<span>}</span></span><span>'"), </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>the default child route will not be rendered. Remove the name from </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>this route and use the name of the default child route for named </span><span>`</span></span> <span>+</span>
          <span><span>`</span><span>links instead.</span><span>`</span></span>
        <span>)</span>
      <span>}</span>
    <span>}</span>
    route<span>.</span>children<span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span> <span>{</span>
      <span>const</span> childMatchAs <span>=</span> matchAs
        <span>?</span> <span>cleanPath</span><span>(</span><span><span>`</span><span><span>${</span>matchAs<span>}</span></span><span>/</span><span><span>${</span>child<span>.</span>path<span>}</span></span><span>`</span></span><span>)</span>
        <span>:</span> <span>undefined</span>
      <span>addRouteRecord</span><span>(</span>pathList<span>,</span> pathMap<span>,</span> nameMap<span>,</span> child<span>,</span> record<span>,</span> childMatchAs<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span>route<span>.</span>alias <span>!==</span> <span>undefined</span><span>)</span> <span>{</span>
    <span>const</span> aliases <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>route<span>.</span>alias<span>)</span>
      <span>?</span> route<span>.</span>alias
      <span>:</span> <span>[</span>route<span>.</span>alias<span>]</span>

    aliases<span>.</span><span>forEach</span><span>(</span><span>alias</span> <span>=></span> <span>{</span>
      <span>const</span> aliasRoute <span>=</span> <span>{</span>
        <span>path</span><span>:</span> alias<span>,</span>
        <span>children</span><span>:</span> route<span>.</span>children
      <span>}</span>
      <span>addRouteRecord</span><span>(</span>
        pathList<span>,</span>
        pathMap<span>,</span>
        nameMap<span>,</span>
        aliasRoute<span>,</span>
        parent<span>,</span>
        record<span>.</span>path <span>||</span> <span>'/'</span>
      <span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>!</span>pathMap<span>[</span>record<span>.</span>path<span>]</span><span>)</span> <span>{</span>
    pathList<span>.</span><span>push</span><span>(</span>record<span>.</span>path<span>)</span>
    pathMap<span>[</span>record<span>.</span>path<span>]</span> <span>=</span> record
  <span>}</span>

  <span>if</span> <span>(</span>name<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>nameMap<span>[</span>name<span>]</span><span>)</span> <span>{</span>
      nameMap<span>[</span>name<span>]</span> <span>=</span> record
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>matchAs<span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>false</span><span>,</span>
        <span><span>`</span><span>Duplicate named routes definition: </span><span>`</span></span> <span>+</span>
        <span><span>`</span><span>{ name: "</span><span><span>${</span>name<span>}</span></span><span>", path: "</span><span><span>${</span>record<span>.</span>path<span>}</span></span><span>" }</span><span>`</span></span>
      <span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们只看几个关键逻辑，首先创建 <code>RouteRecord</code> 的代码如下：</p>
<div><pre><code> <span>const</span> <span>record</span><span>:</span> RouteRecord <span>=</span> <span>{</span>
  <span>path</span><span>:</span> normalizedPath<span>,</span>
  <span>regex</span><span>:</span> <span>compileRouteRegex</span><span>(</span>normalizedPath<span>,</span> pathToRegexpOptions<span>)</span><span>,</span>
  <span>components</span><span>:</span> route<span>.</span>components <span>||</span> <span>{</span> <span>default</span><span>:</span> route<span>.</span>component <span>}</span><span>,</span>
  <span>instances</span><span>:</span> <span>{</span><span>}</span><span>,</span>
  name<span>,</span>
  parent<span>,</span>
  matchAs<span>,</span>
  <span>redirect</span><span>:</span> route<span>.</span>redirect<span>,</span>
  <span>beforeEnter</span><span>:</span> route<span>.</span>beforeEnter<span>,</span>
  <span>meta</span><span>:</span> route<span>.</span>meta <span>||</span> <span>{</span><span>}</span><span>,</span>
  <span>props</span><span>:</span> route<span>.</span>props <span>==</span> <span>null</span>
    <span>?</span> <span>{</span><span>}</span>
    <span>:</span> route<span>.</span>components
      <span>?</span> route<span>.</span>props
      <span>:</span> <span>{</span> <span>default</span><span>:</span> route<span>.</span>props <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里要注意几个点，<code>path</code> 是规范化后的路径，它会根据 <code>parent</code> 的 <code>path</code> 做计算；<code>regex</code> 是一个正则表达式的扩展，它利用了<code>path-to-regexp</code> 这个工具库，把 <code>path</code> 解析成一个正则表达式的扩展，举个例子：</p>
<div><pre><code><span>var</span> keys <span>=</span> <span>[</span><span>]</span>
<span>var</span> re <span>=</span> <span>pathToRegexp</span><span>(</span><span>'/foo/:bar'</span><span>,</span> keys<span>)</span>
<span>// re = /^\/foo\/([^\/]+?)\/?$/i</span>
<span>// keys = [{ name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\/]+?' }]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>components</code> 是一个对象，通常我们在配置中写的 <code>component</code> 实际上这里会被转换成 <code>{components: route.component}</code>；<code>instances</code> 表示组件的实例，也是一个对象类型；<code>parent</code> 表示父的 <code>RouteRecord</code>，因为我们配置的时候有时候会配置子路由，所以整个 <code>RouteRecord</code> 也就是一个树型结构。</p>
<div><pre><code><span>if</span> <span>(</span>route<span>.</span>children<span>)</span> <span>{</span>
  <span>// ...</span>
  route<span>.</span>children<span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span> <span>{</span>
  <span>const</span> childMatchAs <span>=</span> matchAs
    <span>?</span> <span>cleanPath</span><span>(</span><span><span>`</span><span><span>${</span>matchAs<span>}</span></span><span>/</span><span><span>${</span>child<span>.</span>path<span>}</span></span><span>`</span></span><span>)</span>
    <span>:</span> <span>undefined</span>
  <span>addRouteRecord</span><span>(</span>pathList<span>,</span> pathMap<span>,</span> nameMap<span>,</span> child<span>,</span> record<span>,</span> childMatchAs<span>)</span>
<span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果配置了 <code>children</code>，那么递归执行 <code>addRouteRecord</code> 方法，并把当前的 <code>record</code> 作为 <code>parent</code> 传入，通过这样的深度遍历，我们就可以拿到一个 <code>route</code> 下的完整记录。</p>
<div><pre><code><span>if</span> <span>(</span><span>!</span>pathMap<span>[</span>record<span>.</span>path<span>]</span><span>)</span> <span>{</span>
  pathList<span>.</span><span>push</span><span>(</span>record<span>.</span>path<span>)</span>
  pathMap<span>[</span>record<span>.</span>path<span>]</span> <span>=</span> record
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>为 <code>pathList</code> 和 <code>pathMap</code> 各添加一条记录。</p>
<div><pre><code><span>if</span> <span>(</span>name<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>nameMap<span>[</span>name<span>]</span><span>)</span> <span>{</span>
    nameMap<span>[</span>name<span>]</span> <span>=</span> record
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果我们在路由配置中配置了 <code>name</code>，则给 <code>nameMap</code> 添加一条记录。</p>
<p>由于 <code>pathList</code>、<code>pathMap</code>、<code>nameMap</code> 都是引用类型，所以在遍历整个 <code>routes</code> 过程中去执行 <code>addRouteRecord</code> 方法，会不断给他们添加数据。那么经过整个 <code>createRouteMap</code> 方法的执行，我们得到的就是 <code>pathList</code>、<code>pathMap</code> 和 <code>nameMap</code>。其中 <code>pathList</code> 是为了记录路由配置中的所有 <code>path</code>，而 <code>pathMap</code> 和 <code>nameMap</code> 都是为了通过 <code>path</code> 和 <code>name</code> 能快速查到对应的 <code>RouteRecord</code>。</p>
<p>再回到 <code>createMatcher</code> 函数，接下来就定义了一系列方法，最后返回了一个对象。</p>
<div><pre><code><span>return</span> <span>{</span>
  match<span>,</span>
  addRoutes
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>也就是说，<code>matcher</code> 是一个对象，它对外暴露了 <code>match</code> 和 <code>addRoutes</code> 方法。</p>
<h2 id="addroutes" tabindex="-1"> addRoutes</h2>
<p><code>addRoutes</code> 方法的作用是动态添加路由配置，因为在实际开发中有些场景是不能提前把路由写死的，需要根据一些条件动态添加路由，所以 Vue-Router 也提供了这一接口：</p>
<div><pre><code><span>function</span> <span>addRoutes</span> <span>(</span><span>routes</span><span>)</span> <span>{</span>
  <span>createRouteMap</span><span>(</span>routes<span>,</span> pathList<span>,</span> pathMap<span>,</span> nameMap<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>addRoutes</code> 的方法十分简单，再次调用 <code>createRouteMap</code> 即可，传入新的 <code>routes</code> 配置，由于 <code>pathList</code>、<code>pathMap</code>、<code>nameMap</code> 都是引用类型，执行 <code>addRoutes</code> 后会修改它们的值。</p>
<h2 id="match" tabindex="-1"> match</h2>
<div><pre><code><span>function</span> <span>match</span> <span>(</span>
  <span><span>raw</span><span>:</span> RawLocation<span>,</span>
  currentRoute<span>?</span><span>:</span> Route<span>,</span>
  redirectedFrom<span>?</span><span>:</span> Location</span>
<span>)</span><span>:</span> Route <span>{</span>
  <span>const</span> location <span>=</span> <span>normalizeLocation</span><span>(</span>raw<span>,</span> currentRoute<span>,</span> <span>false</span><span>,</span> router<span>)</span>
  <span>const</span> <span>{</span> name <span>}</span> <span>=</span> location

  <span>if</span> <span>(</span>name<span>)</span> <span>{</span>
    <span>const</span> record <span>=</span> nameMap<span>[</span>name<span>]</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>record<span>,</span> <span><span>`</span><span>Route with name '</span><span><span>${</span>name<span>}</span></span><span>' does not exist</span><span>`</span></span><span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>record<span>)</span> <span>return</span> <span>_createRoute</span><span>(</span><span>null</span><span>,</span> location<span>)</span>
    <span>const</span> paramNames <span>=</span> record<span>.</span>regex<span>.</span>keys
      <span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span>key<span>.</span>optional<span>)</span>
      <span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> key<span>.</span>name<span>)</span>

    <span>if</span> <span>(</span><span>typeof</span> location<span>.</span>params <span>!==</span> <span>'object'</span><span>)</span> <span>{</span>
      location<span>.</span>params <span>=</span> <span>{</span><span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span>currentRoute <span>&amp;&amp;</span> <span>typeof</span> currentRoute<span>.</span>params <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>const</span> key <span>in</span> currentRoute<span>.</span>params<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>(</span>key <span>in</span> location<span>.</span>params<span>)</span> <span>&amp;&amp;</span> paramNames<span>.</span><span>indexOf</span><span>(</span>key<span>)</span> <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
          location<span>.</span>params<span>[</span>key<span>]</span> <span>=</span> currentRoute<span>.</span>params<span>[</span>key<span>]</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span>record<span>)</span> <span>{</span>
      location<span>.</span>path <span>=</span> <span>fillParams</span><span>(</span>record<span>.</span>path<span>,</span> location<span>.</span>params<span>,</span> <span><span>`</span><span>named route "</span><span><span>${</span>name<span>}</span></span><span>"</span><span>`</span></span><span>)</span>
      <span>return</span> <span>_createRoute</span><span>(</span>record<span>,</span> location<span>,</span> redirectedFrom<span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>location<span>.</span>path<span>)</span> <span>{</span>
    location<span>.</span>params <span>=</span> <span>{</span><span>}</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> pathList<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>const</span> path <span>=</span> pathList<span>[</span>i<span>]</span>
      <span>const</span> record <span>=</span> pathMap<span>[</span>path<span>]</span>
      <span>if</span> <span>(</span><span>matchRoute</span><span>(</span>record<span>.</span>regex<span>,</span> location<span>.</span>path<span>,</span> location<span>.</span>params<span>)</span><span>)</span> <span>{</span>
        <span>return</span> <span>_createRoute</span><span>(</span>record<span>,</span> location<span>,</span> redirectedFrom<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  
  <span>return</span> <span>_createRoute</span><span>(</span><span>null</span><span>,</span> location<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>match</code> 方法接收 3 个参数，其中 <code>raw</code> 是 <code>RawLocation</code> 类型，它可以是一个 <code>url</code> 字符串，也可以是一个 <code>Location</code> 对象；<code>currentRoute</code> 是 <code>Route</code> 类型，它表示当前的路径；<code>redirectedFrom</code> 和重定向相关，这里先忽略。<code>match</code> 方法返回的是一个路径，它的作用是根据传入的 <code>raw</code> 和当前的路径 <code>currentRoute</code> 计算出一个新的路径并返回。</p>
<p>首先执行了 <code>normalizeLocation</code>，它的定义在 <code>src/util/location.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>normalizeLocation</span> <span>(</span>
  <span><span>raw</span><span>:</span> RawLocation<span>,</span>
  <span>current</span><span>:</span> <span>?</span>Route<span>,</span>
  <span>append</span><span>:</span> <span>?</span>boolean<span>,</span>
  <span>router</span><span>:</span> <span>?</span>VueRouter</span>
<span>)</span><span>:</span> Location <span>{</span>
  <span>let</span> <span>next</span><span>:</span> Location <span>=</span> <span>typeof</span> raw <span>===</span> <span>'string'</span> <span>?</span> <span>{</span> <span>path</span><span>:</span> raw <span>}</span> <span>:</span> raw
  <span>if</span> <span>(</span>next<span>.</span>name <span>||</span> next<span>.</span>_normalized<span>)</span> <span>{</span>
    <span>return</span> next
  <span>}</span>

  <span>if</span> <span>(</span><span>!</span>next<span>.</span>path <span>&amp;&amp;</span> next<span>.</span>params <span>&amp;&amp;</span> current<span>)</span> <span>{</span>
    next <span>=</span> <span>assign</span><span>(</span><span>{</span><span>}</span><span>,</span> next<span>)</span>
    next<span>.</span>_normalized <span>=</span> <span>true</span>
    <span>const</span> <span>params</span><span>:</span> any <span>=</span> <span>assign</span><span>(</span><span>assign</span><span>(</span><span>{</span><span>}</span><span>,</span> current<span>.</span>params<span>)</span><span>,</span> next<span>.</span>params<span>)</span>
    <span>if</span> <span>(</span>current<span>.</span>name<span>)</span> <span>{</span>
      next<span>.</span>name <span>=</span> current<span>.</span>name
      next<span>.</span>params <span>=</span> params
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>current<span>.</span>matched<span>.</span>length<span>)</span> <span>{</span>
      <span>const</span> rawPath <span>=</span> current<span>.</span>matched<span>[</span>current<span>.</span>matched<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span>path
      next<span>.</span>path <span>=</span> <span>fillParams</span><span>(</span>rawPath<span>,</span> params<span>,</span> <span><span>`</span><span>path </span><span><span>${</span>current<span>.</span>path<span>}</span></span><span>`</span></span><span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span><span>false</span><span>,</span> <span><span>`</span><span>relative params navigation requires a current route.</span><span>`</span></span><span>)</span>
    <span>}</span>
    <span>return</span> next
  <span>}</span>

  <span>const</span> parsedPath <span>=</span> <span>parsePath</span><span>(</span>next<span>.</span>path <span>||</span> <span>''</span><span>)</span>
  <span>const</span> basePath <span>=</span> <span>(</span>current <span>&amp;&amp;</span> current<span>.</span>path<span>)</span> <span>||</span> <span>'/'</span>
  <span>const</span> path <span>=</span> parsedPath<span>.</span>path
    <span>?</span> <span>resolvePath</span><span>(</span>parsedPath<span>.</span>path<span>,</span> basePath<span>,</span> append <span>||</span> next<span>.</span>append<span>)</span>
    <span>:</span> basePath

  <span>const</span> query <span>=</span> <span>resolveQuery</span><span>(</span>
    parsedPath<span>.</span>query<span>,</span>
    next<span>.</span>query<span>,</span>
    router <span>&amp;&amp;</span> router<span>.</span>options<span>.</span>parseQuery
  <span>)</span>

  <span>let</span> hash <span>=</span> next<span>.</span>hash <span>||</span> parsedPath<span>.</span>hash
  <span>if</span> <span>(</span>hash <span>&amp;&amp;</span> hash<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>!==</span> <span>'#'</span><span>)</span> <span>{</span>
    hash <span>=</span> <span><span>`</span><span>#</span><span><span>${</span>hash<span>}</span></span><span>`</span></span>
  <span>}</span>

  <span>return</span> <span>{</span>
    <span>_normalized</span><span>:</span> <span>true</span><span>,</span>
    path<span>,</span>
    query<span>,</span>
    hash
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>normalizeLocation</code> 方法的作用是根据 <code>raw</code>，<code>current</code> 计算出新的 <code>location</code>，它主要处理了 <code>raw</code> 的两种情况，一种是有 <code>params</code> 且没有 <code>path</code>，一种是有 <code>path</code> 的，对于第一种情况，如果 <code>current</code> 有 <code>name</code>，则计算出的 <code>location</code> 也有 <code>name</code>。</p>
<p>计算出新的 <code>location</code> 后，对 <code>location</code> 的 <code>name</code> 和 <code>path</code> 的两种情况做了处理。</p>
<ul>
<li><code>name</code></li>
</ul>
<p>有 <code>name</code> 的情况下就根据 <code>nameMap</code> 匹配到 <code>record</code>，它就是一个 <code>RouterRecord</code> 对象，如果 <code>record</code> 不存在，则匹配失败，返回一个空路径；然后拿到 <code>record</code> 对应的 <code>paramNames</code>，再对比 <code>currentRoute</code> 中的 <code>params</code>，把交集部分的 <code>params</code> 添加到 <code>location</code> 中，然后在通过 <code>fillParams</code> 方法根据 <code>record.path</code> 和 <code>location.path</code> 计算出 <code>location.path</code>，最后调用 <code>_createRoute(record, location, redirectedFrom)</code> 去生成一条新路径，该方法我们之后会介绍。</p>
<ul>
<li><code>path</code></li>
</ul>
<p>通过 <code>name</code> 我们可以很快的找到 <code>record</code>，但是通过 <code>path</code> 并不能，因为我们计算后的 <code>location.path</code> 是一个真实路径，而 <code>record</code> 中的 <code>path</code> 可能会有 <code>param</code>，因此需要对所有的 <code>pathList</code> 做顺序遍历， 然后通过 <code>matchRoute</code> 方法根据 <code>record.regex</code>、<code>location.path</code>、<code>location.params</code> 匹配，如果匹配到则也通过 <code>_createRoute(record, location, redirectedFrom)</code> 去生成一条新路径。因为是顺序遍历，所以我们书写路由配置要注意路径的顺序，因为写在前面的会优先尝试匹配。</p>
<p>最后我们来看一下 <code>_createRoute</code> 的实现：</p>
<div><pre><code><span>function</span> <span>_createRoute</span> <span>(</span>
  <span><span>record</span><span>:</span> <span>?</span>RouteRecord<span>,</span>
  <span>location</span><span>:</span> Location<span>,</span>
  redirectedFrom<span>?</span><span>:</span> Location</span>
<span>)</span><span>:</span> Route <span>{</span>
  <span>if</span> <span>(</span>record <span>&amp;&amp;</span> record<span>.</span>redirect<span>)</span> <span>{</span>
    <span>return</span> <span>redirect</span><span>(</span>record<span>,</span> redirectedFrom <span>||</span> location<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>record <span>&amp;&amp;</span> record<span>.</span>matchAs<span>)</span> <span>{</span>
    <span>return</span> <span>alias</span><span>(</span>record<span>,</span> location<span>,</span> record<span>.</span>matchAs<span>)</span>
  <span>}</span>
  <span>return</span> <span>createRoute</span><span>(</span>record<span>,</span> location<span>,</span> redirectedFrom<span>,</span> router<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们先不考虑 <code>record.redirect</code> 和 <code>record.matchAs</code> 的情况，最终会调用 <code>createRoute</code> 方法，它的定义在 <code>src/uitl/route.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>createRoute</span> <span>(</span>
  <span><span>record</span><span>:</span> <span>?</span>RouteRecord<span>,</span>
  <span>location</span><span>:</span> Location<span>,</span>
  redirectedFrom<span>?</span><span>:</span> <span>?</span>Location<span>,</span>
  router<span>?</span><span>:</span> VueRouter</span>
<span>)</span><span>:</span> Route <span>{</span>
  <span>const</span> stringifyQuery <span>=</span> router <span>&amp;&amp;</span> router<span>.</span>options<span>.</span>stringifyQuery

  <span>let</span> <span>query</span><span>:</span> any <span>=</span> location<span>.</span>query <span>||</span> <span>{</span><span>}</span>
  <span>try</span> <span>{</span>
    query <span>=</span> <span>clone</span><span>(</span>query<span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span><span>}</span>

  <span>const</span> <span>route</span><span>:</span> Route <span>=</span> <span>{</span>
    <span>name</span><span>:</span> location<span>.</span>name <span>||</span> <span>(</span>record <span>&amp;&amp;</span> record<span>.</span>name<span>)</span><span>,</span>
    <span>meta</span><span>:</span> <span>(</span>record <span>&amp;&amp;</span> record<span>.</span>meta<span>)</span> <span>||</span> <span>{</span><span>}</span><span>,</span>
    <span>path</span><span>:</span> location<span>.</span>path <span>||</span> <span>'/'</span><span>,</span>
    <span>hash</span><span>:</span> location<span>.</span>hash <span>||</span> <span>''</span><span>,</span>
    query<span>,</span>
    <span>params</span><span>:</span> location<span>.</span>params <span>||</span> <span>{</span><span>}</span><span>,</span>
    <span>fullPath</span><span>:</span> <span>getFullPath</span><span>(</span>location<span>,</span> stringifyQuery<span>)</span><span>,</span>
    <span>matched</span><span>:</span> record <span>?</span> <span>formatMatch</span><span>(</span>record<span>)</span> <span>:</span> <span>[</span><span>]</span>
  <span>}</span>
  <span>if</span> <span>(</span>redirectedFrom<span>)</span> <span>{</span>
    route<span>.</span>redirectedFrom <span>=</span> <span>getFullPath</span><span>(</span>redirectedFrom<span>,</span> stringifyQuery<span>)</span>
  <span>}</span>
  <span>return</span> Object<span>.</span><span>freeze</span><span>(</span>route<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>createRoute</code> 可以根据 <code>record</code> 和 <code>location</code> 创建出来，最终返回的是一条 <code>Route</code> 路径，我们之前也介绍过它的数据结构。在 Vue-Router 中，所有的 <code>Route</code> 最终都会通过 <code>createRoute</code> 函数创建，并且它最后是不可以被外部修改的。<code>Route</code> 对象中有一个非常重要属性是 <code>matched</code>，它通过 <code>formatMatch(record)</code> 计算而来：</p>
<div><pre><code><span>function</span> <span>formatMatch</span> <span>(</span><span><span>record</span><span>:</span> <span>?</span>RouteRecord</span><span>)</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>while</span> <span>(</span>record<span>)</span> <span>{</span>
    res<span>.</span><span>unshift</span><span>(</span>record<span>)</span>
    record <span>=</span> record<span>.</span>parent
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看它是通过 <code>record</code> 循环向上找 <code>parent</code>，直到找到最外层，并把所有的 <code>record</code> 都 push 到一个数组中，最终返回的就是 <code>record</code> 的数组，它记录了一条线路上的所有 <code>record</code>。<code>matched</code> 属性非常有用，它为之后渲染组件提供了依据。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么到此，<code>matcher</code> 相关的主流程的分析就结束了，我们了解了 <code>Location</code>、<code>Route</code>、<code>RouteRecord</code> 等概念。并通过 <code>matcher</code> 的 <code>match</code> 方法，我们会找到匹配的路径 <code>Route</code>，这个对 <code>Route</code> 的切换，组件的渲染都有非常重要的指导意义。下一节我们会回到 <code>transitionTo</code> 方法，看一看路径的切换都做了哪些事情。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">VueRouter 对象</title>
    <id>https://0808200.xyz/vue2/vue-router/router.html</id>
    <link href="https://0808200.xyz/vue2/vue-router/router.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vuerouter-对象" tabindex="-1"> VueRouter 对象</h1>
<p>VueRouter 的实现是一个类，我们先对它做一个简单地分析，它的定义在 <code>src/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>VueRouter</span> <span>{</span>
  <span>static</span> <span>install</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>void</span><span>;</span>
  <span>static</span> <span>version</span><span>:</span> string<span>;</span>

  <span>app</span><span>:</span> any<span>;</span>
  <span>apps</span><span>:</span> Array<span>&lt;</span>any<span>></span><span>;</span>
  <span>ready</span><span>:</span> boolean<span>;</span>
  <span>readyCbs</span><span>:</span> Array<span>&lt;</span>Function<span>></span><span>;</span>
  <span>options</span><span>:</span> RouterOptions<span>;</span>
  <span>mode</span><span>:</span> string<span>;</span>
  <span>history</span><span>:</span> HashHistory <span>|</span> HTML5History <span>|</span> AbstractHistory<span>;</span>
  <span>matcher</span><span>:</span> Matcher<span>;</span>
  <span>fallback</span><span>:</span> boolean<span>;</span>
  <span>beforeHooks</span><span>:</span> Array<span>&lt;</span><span>?</span>NavigationGuard<span>></span><span>;</span>
  <span>resolveHooks</span><span>:</span> Array<span>&lt;</span><span>?</span>NavigationGuard<span>></span><span>;</span>
  <span>afterHooks</span><span>:</span> Array<span>&lt;</span><span>?</span>AfterNavigationHook<span>></span><span>;</span>

  <span>constructor</span> <span>(</span><span><span>options</span><span>:</span> RouterOptions <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>app <span>=</span> <span>null</span>
    <span>this</span><span>.</span>apps <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>options <span>=</span> options
    <span>this</span><span>.</span>beforeHooks <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>resolveHooks <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>afterHooks <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>matcher <span>=</span> <span>createMatcher</span><span>(</span>options<span>.</span>routes <span>||</span> <span>[</span><span>]</span><span>,</span> <span>this</span><span>)</span>

    <span>let</span> mode <span>=</span> options<span>.</span>mode <span>||</span> <span>'hash'</span>
    <span>this</span><span>.</span>fallback <span>=</span> mode <span>===</span> <span>'history'</span> <span>&amp;&amp;</span> <span>!</span>supportsPushState <span>&amp;&amp;</span> options<span>.</span>fallback <span>!==</span> <span>false</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>fallback<span>)</span> <span>{</span>
      mode <span>=</span> <span>'hash'</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>inBrowser<span>)</span> <span>{</span>
      mode <span>=</span> <span>'abstract'</span>
    <span>}</span>
    <span>this</span><span>.</span>mode <span>=</span> mode

    <span>switch</span> <span>(</span>mode<span>)</span> <span>{</span>
      <span>case</span> <span>'history'</span><span>:</span>
        <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>HTML5History</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>)</span>
        <span>break</span>
      <span>case</span> <span>'hash'</span><span>:</span>
        <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>HashHistory</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>,</span> <span>this</span><span>.</span>fallback<span>)</span>
        <span>break</span>
      <span>case</span> <span>'abstract'</span><span>:</span>
        <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>AbstractHistory</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>)</span>
        <span>break</span>
      <span>default</span><span>:</span>
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
          <span>assert</span><span>(</span><span>false</span><span>,</span> <span><span>`</span><span>invalid mode: </span><span><span>${</span>mode<span>}</span></span><span>`</span></span><span>)</span>
        <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>match</span> <span>(</span>
    <span>raw</span><span>:</span> RawLocation<span>,</span>
    current<span>?</span><span>:</span> Route<span>,</span>
    redirectedFrom<span>?</span><span>:</span> Location
  <span>)</span><span>:</span> Route <span>{</span>
    <span>return</span> <span>this</span><span>.</span>matcher<span>.</span><span>match</span><span>(</span>raw<span>,</span> current<span>,</span> redirectedFrom<span>)</span>
  <span>}</span>

  <span>get</span> <span>currentRoute</span> <span>(</span><span>)</span><span>:</span> <span>?</span>Route <span>{</span>
    <span>return</span> <span>this</span><span>.</span>history <span>&amp;&amp;</span> <span>this</span><span>.</span>history<span>.</span>current
  <span>}</span>

  <span>init</span> <span>(</span><span><span>app</span><span>:</span> any</span><span>)</span> <span>{</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>assert</span><span>(</span>
      install<span>.</span>installed<span>,</span>
      <span><span>`</span><span>not installed. Make sure to call \`Vue.use(VueRouter)\` </span><span>`</span></span> <span>+</span>
      <span><span>`</span><span>before creating root instance.</span><span>`</span></span>
    <span>)</span>

    <span>this</span><span>.</span>apps<span>.</span><span>push</span><span>(</span>app<span>)</span>

    <span>if</span> <span>(</span><span>this</span><span>.</span>app<span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>

    <span>this</span><span>.</span>app <span>=</span> app

    <span>const</span> history <span>=</span> <span>this</span><span>.</span>history

    <span>if</span> <span>(</span>history <span>instanceof</span> <span>HTML5History</span><span>)</span> <span>{</span>
      history<span>.</span><span>transitionTo</span><span>(</span>history<span>.</span><span>getCurrentLocation</span><span>(</span><span>)</span><span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>history <span>instanceof</span> <span>HashHistory</span><span>)</span> <span>{</span>
      <span>const</span> <span>setupHashListener</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        history<span>.</span><span>setupListeners</span><span>(</span><span>)</span>
      <span>}</span>
      history<span>.</span><span>transitionTo</span><span>(</span>
        history<span>.</span><span>getCurrentLocation</span><span>(</span><span>)</span><span>,</span>
        setupHashListener<span>,</span>
        setupHashListener
      <span>)</span>
    <span>}</span>

    history<span>.</span><span>listen</span><span>(</span><span>route</span> <span>=></span> <span>{</span>
      <span>this</span><span>.</span>apps<span>.</span><span>forEach</span><span>(</span><span>(</span><span>app</span><span>)</span> <span>=></span> <span>{</span>
        app<span>.</span>_route <span>=</span> route
      <span>}</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>beforeEach</span> <span>(</span>fn<span>:</span> Function<span>)</span><span>:</span> Function <span>{</span>
    <span>return</span> <span>registerHook</span><span>(</span><span>this</span><span>.</span>beforeHooks<span>,</span> fn<span>)</span>
  <span>}</span>

  <span>beforeResolve</span> <span>(</span>fn<span>:</span> Function<span>)</span><span>:</span> Function <span>{</span>
    <span>return</span> <span>registerHook</span><span>(</span><span>this</span><span>.</span>resolveHooks<span>,</span> fn<span>)</span>
  <span>}</span>

  <span>afterEach</span> <span>(</span>fn<span>:</span> Function<span>)</span><span>:</span> Function <span>{</span>
    <span>return</span> <span>registerHook</span><span>(</span><span>this</span><span>.</span>afterHooks<span>,</span> fn<span>)</span>
  <span>}</span>

  <span>onReady</span> <span>(</span><span><span>cb</span><span>:</span> Function<span>,</span> errorCb<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>history<span>.</span><span>onReady</span><span>(</span>cb<span>,</span> errorCb<span>)</span>
  <span>}</span>

  <span>onError</span> <span>(</span><span><span>errorCb</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>history<span>.</span><span>onError</span><span>(</span>errorCb<span>)</span>
  <span>}</span>

  <span>push</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>history<span>.</span><span>push</span><span>(</span>location<span>,</span> onComplete<span>,</span> onAbort<span>)</span>
  <span>}</span>

  <span>replace</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>history<span>.</span><span>replace</span><span>(</span>location<span>,</span> onComplete<span>,</span> onAbort<span>)</span>
  <span>}</span>

  <span>go</span> <span>(</span><span><span>n</span><span>:</span> number</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>history<span>.</span><span>go</span><span>(</span>n<span>)</span>
  <span>}</span>

  <span>back</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>go</span><span>(</span><span>-</span><span>1</span><span>)</span>
  <span>}</span>

  <span>forward</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>go</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>

  <span>getMatchedComponents</span> <span>(</span>to<span>?</span><span>:</span> RawLocation <span>|</span> Route<span>)</span><span>:</span> Array<span>&lt;</span>any<span>></span> <span>{</span>
    <span>const</span> <span>route</span><span>:</span> any <span>=</span> to
      <span>?</span> to<span>.</span>matched
        <span>?</span> to
        <span>:</span> <span>this</span><span>.</span><span>resolve</span><span>(</span>to<span>)</span><span>.</span>route
      <span>:</span> <span>this</span><span>.</span>currentRoute
    <span>if</span> <span>(</span><span>!</span>route<span>)</span> <span>{</span>
      <span>return</span> <span>[</span><span>]</span>
    <span>}</span>
    <span>return</span> <span>[</span><span>]</span><span>.</span><span>concat</span><span>.</span><span>apply</span><span>(</span><span>[</span><span>]</span><span>,</span> route<span>.</span>matched<span>.</span><span>map</span><span>(</span><span>m</span> <span>=></span> <span>{</span>
      <span>return</span> Object<span>.</span><span>keys</span><span>(</span>m<span>.</span>components<span>)</span><span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
        <span>return</span> m<span>.</span>components<span>[</span>key<span>]</span>
      <span>}</span><span>)</span>
    <span>}</span><span>)</span><span>)</span>
  <span>}</span>

  <span>resolve</span> <span>(</span>
    <span>to</span><span>:</span> RawLocation<span>,</span>
    current<span>?</span><span>:</span> Route<span>,</span>
    append<span>?</span><span>:</span> boolean
  <span>)</span><span>:</span> <span>{</span>
    <span>location</span><span>:</span> Location<span>,</span>
    <span>route</span><span>:</span> Route<span>,</span>
    <span>href</span><span>:</span> string<span>,</span>
    <span>normalizedTo</span><span>:</span> Location<span>,</span>
    <span>resolved</span><span>:</span> Route
  <span>}</span> <span>{</span>
    <span>const</span> location <span>=</span> <span>normalizeLocation</span><span>(</span>
      to<span>,</span>
      current <span>||</span> <span>this</span><span>.</span>history<span>.</span>current<span>,</span>
      append<span>,</span>
      <span>this</span>
    <span>)</span>
    <span>const</span> route <span>=</span> <span>this</span><span>.</span><span>match</span><span>(</span>location<span>,</span> current<span>)</span>
    <span>const</span> fullPath <span>=</span> route<span>.</span>redirectedFrom <span>||</span> route<span>.</span>fullPath
    <span>const</span> base <span>=</span> <span>this</span><span>.</span>history<span>.</span>base
    <span>const</span> href <span>=</span> <span>createHref</span><span>(</span>base<span>,</span> fullPath<span>,</span> <span>this</span><span>.</span>mode<span>)</span>
    <span>return</span> <span>{</span>
      location<span>,</span>
      route<span>,</span>
      href<span>,</span>
      <span>normalizedTo</span><span>:</span> location<span>,</span>
      <span>resolved</span><span>:</span> route
    <span>}</span>
  <span>}</span>

  <span>addRoutes</span> <span>(</span><span><span>routes</span><span>:</span> Array<span>&lt;</span>RouteConfig<span>></span></span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>matcher<span>.</span><span>addRoutes</span><span>(</span>routes<span>)</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>history<span>.</span>current <span>!==</span> <span>START</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>history<span>.</span><span>transitionTo</span><span>(</span><span>this</span><span>.</span>history<span>.</span><span>getCurrentLocation</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>VueRouter</code> 定义了一些属性和方法，我们先从它的构造函数看，当我们执行 <code>new VueRouter</code> 的时候做了哪些事情。</p>
<div><pre><code><span>constructor</span> <span>(</span><span><span>options</span><span>:</span> RouterOptions <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>app <span>=</span> <span>null</span>
  <span>this</span><span>.</span>apps <span>=</span> <span>[</span><span>]</span>
  <span>this</span><span>.</span>options <span>=</span> options
  <span>this</span><span>.</span>beforeHooks <span>=</span> <span>[</span><span>]</span>
  <span>this</span><span>.</span>resolveHooks <span>=</span> <span>[</span><span>]</span>
  <span>this</span><span>.</span>afterHooks <span>=</span> <span>[</span><span>]</span>
  <span>this</span><span>.</span>matcher <span>=</span> <span>createMatcher</span><span>(</span>options<span>.</span>routes <span>||</span> <span>[</span><span>]</span><span>,</span> <span>this</span><span>)</span>

  <span>let</span> mode <span>=</span> options<span>.</span>mode <span>||</span> <span>'hash'</span>
  <span>this</span><span>.</span>fallback <span>=</span> mode <span>===</span> <span>'history'</span> <span>&amp;&amp;</span> <span>!</span>supportsPushState <span>&amp;&amp;</span> options<span>.</span>fallback <span>!==</span> <span>false</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>fallback<span>)</span> <span>{</span>
    mode <span>=</span> <span>'hash'</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>!</span>inBrowser<span>)</span> <span>{</span>
    mode <span>=</span> <span>'abstract'</span>
  <span>}</span>
  <span>this</span><span>.</span>mode <span>=</span> mode

  <span>switch</span> <span>(</span>mode<span>)</span> <span>{</span>
    <span>case</span> <span>'history'</span><span>:</span>
      <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>HTML5History</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>)</span>
      <span>break</span>
    <span>case</span> <span>'hash'</span><span>:</span>
      <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>HashHistory</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>,</span> <span>this</span><span>.</span>fallback<span>)</span>
      <span>break</span>
    <span>case</span> <span>'abstract'</span><span>:</span>
      <span>this</span><span>.</span>history <span>=</span> <span>new</span> <span>AbstractHistory</span><span>(</span><span>this</span><span>,</span> options<span>.</span>base<span>)</span>
      <span>break</span>
    <span>default</span><span>:</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
        <span>assert</span><span>(</span><span>false</span><span>,</span> <span><span>`</span><span>invalid mode: </span><span><span>${</span>mode<span>}</span></span><span>`</span></span><span>)</span>
      <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>构造函数定义了一些属性，其中 <code>this.app</code> 表示根 <code>Vue</code> 实例，<code>this.apps</code> 保存持有 <code>$options.router</code> 属性的 <code>Vue</code> 实例，<code>this.options</code> 保存传入的路由配置，<code>this.beforeHooks</code>、
<code>this.resolveHooks</code>、<code>this.afterHooks</code> 表示一些钩子函数，我们之后会介绍，<code>this.matcher</code> 表示路由匹配器，我们之后会介绍，<code>this.fallback</code> 表示在浏览器不支持 <code>history.pushState</code> 的情况下，根据传入的 <code>fallback</code> 配置参数，决定是否回退到hash模式，<code>this.mode</code> 表示路由创建的模式，<code>this.history</code> 表示路由历史的具体的实现实例，它是根据 <code>this.mode</code> 的不同实现不同，它有 <code>History</code> 基类，然后不同的 <code>history</code> 实现都是继承 <code>History</code>。</p>
<p>实例化 <code>VueRouter</code> 后会返回它的实例 <code>router</code>，我们在 <code>new Vue</code> 的时候会把 <code>router</code> 作为配置的属性传入，回顾一下上一节我们讲 <code>beforeCreate</code> 混入的时候有这么一段代码：</p>
<div><pre><code><span>beforeCreate</span><span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>isDef</span><span>(</span><span>this</span><span>.</span>$options<span>.</span>router<span>)</span><span>)</span> <span>{</span>
    <span>// ...</span>
    <span>this</span><span>.</span>_router <span>=</span> <span>this</span><span>.</span>$options<span>.</span>router
    <span>this</span><span>.</span>_router<span>.</span><span>init</span><span>(</span><span>this</span><span>)</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以组件在执行 <code>beforeCreate</code> 钩子函数的时候，如果传入了 <code>router</code> 实例，都会执行 <code>router.init</code> 方法：</p>
<div><pre><code><span>init</span> <span>(</span><span><span>app</span><span>:</span> any</span><span>)</span> <span>{</span>
  process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>assert</span><span>(</span>
    install<span>.</span>installed<span>,</span>
    <span><span>`</span><span>not installed. Make sure to call \`Vue.use(VueRouter)\` </span><span>`</span></span> <span>+</span>
    <span><span>`</span><span>before creating root instance.</span><span>`</span></span>
  <span>)</span>

  <span>this</span><span>.</span>apps<span>.</span><span>push</span><span>(</span>app<span>)</span>

  <span>if</span> <span>(</span><span>this</span><span>.</span>app<span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>this</span><span>.</span>app <span>=</span> app

  <span>const</span> history <span>=</span> <span>this</span><span>.</span>history

  <span>if</span> <span>(</span>history <span>instanceof</span> <span>HTML5History</span><span>)</span> <span>{</span>
    history<span>.</span><span>transitionTo</span><span>(</span>history<span>.</span><span>getCurrentLocation</span><span>(</span><span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>history <span>instanceof</span> <span>HashHistory</span><span>)</span> <span>{</span>
    <span>const</span> <span>setupHashListener</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      history<span>.</span><span>setupListeners</span><span>(</span><span>)</span>
    <span>}</span>
    history<span>.</span><span>transitionTo</span><span>(</span>
      history<span>.</span><span>getCurrentLocation</span><span>(</span><span>)</span><span>,</span>
      setupHashListener<span>,</span>
      setupHashListener
    <span>)</span>
  <span>}</span>

  history<span>.</span><span>listen</span><span>(</span><span>route</span> <span>=></span> <span>{</span>
    <span>this</span><span>.</span>apps<span>.</span><span>forEach</span><span>(</span><span>(</span><span>app</span><span>)</span> <span>=></span> <span>{</span>
      app<span>.</span>_route <span>=</span> route
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>init</code> 的逻辑很简单，它传入的参数是 <code>Vue</code> 实例，然后存储到 <code>this.apps</code> 中；只有根 <code>Vue</code> 实例会保存到 <code>this.app</code> 中，并且会拿到当前的 <code>this.history</code>，根据它的不同类型来执行不同逻辑，由于我们平时使用 <code>hash</code> 路由多一些，所以我们先看这部分逻辑，先定义了 <code>setupHashListener</code> 函数，接着执行了 <code>history.transitionTo</code> 方法，它是定义在 <code>History</code> 基类中，代码在 <code>src/history/base.js</code>：</p>
<div><pre><code><span>transitionTo</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> route <span>=</span> <span>this</span><span>.</span>router<span>.</span><span>match</span><span>(</span>location<span>,</span> <span>this</span><span>.</span>current<span>)</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>我们先不着急去看 <code>transitionTo</code> 的具体实现，先看第一行代码，它调用了 <code>this.router.match</code> 函数：</p>
<div><pre><code><span>match</span> <span>(</span>
  <span>raw</span><span>:</span> RawLocation<span>,</span>
  current<span>?</span><span>:</span> Route<span>,</span>
  redirectedFrom<span>?</span><span>:</span> Location
<span>)</span><span>:</span> Route <span>{</span>
  <span>return</span> <span>this</span><span>.</span>matcher<span>.</span><span>match</span><span>(</span>raw<span>,</span> current<span>,</span> redirectedFrom<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上是调用了 <code>this.matcher.match</code> 方法去做匹配，所以接下来我们先来了解一下 <code>matcher</code> 的相关实现。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>通过这一节的分析，我们大致对 <code>VueRouter</code> 类有了大致了解，知道了它的一些属性和方法，同时了解到在组件的初始化阶段，执行到 <code>beforeCreate</code> 钩子函数的时候会执行 <code>router.init</code> 方法，然后又会执行 <code>history.transitionTo</code> 方法做路由过渡，进而引出了 <code>matcher</code> 的概念，接下来我们先研究一下 <code>matcher</code> 的相关实现。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">路径切换</title>
    <id>https://0808200.xyz/vue2/vue-router/transition-to.html</id>
    <link href="https://0808200.xyz/vue2/vue-router/transition-to.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="路径切换" tabindex="-1"> 路径切换</h1>
<p><code>history.transitionTo</code> 是 Vue-Router 中非常重要的方法，当我们切换路由线路的时候，就会执行到该方法，前一节我们分析了 <code>matcher</code> 的相关实现，知道它是如何找到匹配的新线路，那么匹配到新线路后又做了哪些事情，接下来我们来完整分析一下 <code>transitionTo</code> 的实现，它的定义在 <code>src/history/base.js</code> 中：</p>
<div><pre><code><span>transitionTo</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> route <span>=</span> <span>this</span><span>.</span>router<span>.</span><span>match</span><span>(</span>location<span>,</span> <span>this</span><span>.</span>current<span>)</span>
  <span>this</span><span>.</span><span>confirmTransition</span><span>(</span>route<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>this</span><span>.</span><span>updateRoute</span><span>(</span>route<span>)</span>
    onComplete <span>&amp;&amp;</span> <span>onComplete</span><span>(</span>route<span>)</span>
    <span>this</span><span>.</span><span>ensureURL</span><span>(</span><span>)</span>

    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>ready<span>)</span> <span>{</span>
      <span>this</span><span>.</span>ready <span>=</span> <span>true</span>
      <span>this</span><span>.</span>readyCbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>{</span> <span>cb</span><span>(</span>route<span>)</span> <span>}</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>err</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>onAbort<span>)</span> <span>{</span>
      <span>onAbort</span><span>(</span>err<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>err <span>&amp;&amp;</span> <span>!</span><span>this</span><span>.</span>ready<span>)</span> <span>{</span>
      <span>this</span><span>.</span>ready <span>=</span> <span>true</span>
      <span>this</span><span>.</span>readyErrorCbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>{</span> <span>cb</span><span>(</span>err<span>)</span> <span>}</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>transitionTo</code> 首先根据目标 <code>location</code> 和当前路径 <code>this.current</code> 执行 <code>this.router.match</code> 方法去匹配到目标的路径。这里 <code>this.current</code> 是 <code>history</code> 维护的当前路径，它的初始值是在 <code>history</code> 的构造函数中初始化的：</p>
<div><pre><code><span>this</span><span>.</span>current <span>=</span> <span>START</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>START</code> 的定义在 <code>src/util/route.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> <span>START</span> <span>=</span> <span>createRoute</span><span>(</span><span>null</span><span>,</span> <span>{</span>
  <span>path</span><span>:</span> <span>'/'</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这样就创建了一个初始的 <code>Route</code>，而 <code>transitionTo</code> 实际上也就是在切换 <code>this.current</code>，稍后我们会看到。</p>
<p>拿到新的路径后，那么接下来就会执行 <code>confirmTransition</code> 方法去做真正的切换，由于这个过程可能有一些异步的操作（如异步组件），所以整个 <code>confirmTransition</code> API 设计成带有成功回调函数和失败回调函数，先来看一下它的定义：</p>
<div><pre><code><span>confirmTransition</span> <span>(</span><span><span>route</span><span>:</span> Route<span>,</span> <span>onComplete</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> current <span>=</span> <span>this</span><span>.</span>current
  <span>const</span> <span>abort</span> <span>=</span> <span>err</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>isError</span><span>(</span>err<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>errorCbs<span>.</span>length<span>)</span> <span>{</span>
        <span>this</span><span>.</span>errorCbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>{</span> <span>cb</span><span>(</span>err<span>)</span> <span>}</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>warn</span><span>(</span><span>false</span><span>,</span> <span>'uncaught error during route navigation:'</span><span>)</span>
        console<span>.</span><span>error</span><span>(</span>err<span>)</span>
      <span>}</span>
    <span>}</span>
    onAbort <span>&amp;&amp;</span> <span>onAbort</span><span>(</span>err<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>
    <span>isSameRoute</span><span>(</span>route<span>,</span> current<span>)</span> <span>&amp;&amp;</span>
    route<span>.</span>matched<span>.</span>length <span>===</span> current<span>.</span>matched<span>.</span>length
  <span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>ensureURL</span><span>(</span><span>)</span>
    <span>return</span> <span>abort</span><span>(</span><span>)</span>
  <span>}</span>

  <span>const</span> <span>{</span>
    updated<span>,</span>
    deactivated<span>,</span>
    activated
  <span>}</span> <span>=</span> <span>resolveQueue</span><span>(</span><span>this</span><span>.</span>current<span>.</span>matched<span>,</span> route<span>.</span>matched<span>)</span>

  <span>const</span> <span>queue</span><span>:</span> Array<span>&lt;</span><span>?</span>NavigationGuard<span>></span> <span>=</span> <span>[</span><span>]</span><span>.</span><span>concat</span><span>(</span>
    <span>extractLeaveGuards</span><span>(</span>deactivated<span>)</span><span>,</span>
    <span>this</span><span>.</span>router<span>.</span>beforeHooks<span>,</span>
    <span>extractUpdateHooks</span><span>(</span>updated<span>)</span><span>,</span>
    activated<span>.</span><span>map</span><span>(</span><span>m</span> <span>=></span> m<span>.</span>beforeEnter<span>)</span><span>,</span>
    <span>resolveAsyncComponents</span><span>(</span>activated<span>)</span>
  <span>)</span>

  <span>this</span><span>.</span>pending <span>=</span> route
  <span>const</span> <span>iterator</span> <span>=</span> <span>(</span><span><span>hook</span><span>:</span> NavigationGuard<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>pending <span>!==</span> route<span>)</span> <span>{</span>
      <span>return</span> <span>abort</span><span>(</span><span>)</span>
    <span>}</span>
    <span>try</span> <span>{</span>
      <span>hook</span><span>(</span>route<span>,</span> current<span>,</span> <span>(</span><span><span>to</span><span>:</span> any</span><span>)</span> <span>=></span> <span>{</span>
        <span>if</span> <span>(</span>to <span>===</span> <span>false</span> <span>||</span> <span>isError</span><span>(</span>to<span>)</span><span>)</span> <span>{</span>
          <span>this</span><span>.</span><span>ensureURL</span><span>(</span><span>true</span><span>)</span>
          <span>abort</span><span>(</span>to<span>)</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>
          <span>typeof</span> to <span>===</span> <span>'string'</span> <span>||</span>
          <span>(</span><span>typeof</span> to <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> <span>(</span>
            <span>typeof</span> to<span>.</span>path <span>===</span> <span>'string'</span> <span>||</span>
            <span>typeof</span> to<span>.</span>name <span>===</span> <span>'string'</span>
          <span>)</span><span>)</span>
        <span>)</span> <span>{</span>
          <span>abort</span><span>(</span><span>)</span>
          <span>if</span> <span>(</span><span>typeof</span> to <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> to<span>.</span>replace<span>)</span> <span>{</span>
            <span>this</span><span>.</span><span>replace</span><span>(</span>to<span>)</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>this</span><span>.</span><span>push</span><span>(</span>to<span>)</span>
          <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>next</span><span>(</span>to<span>)</span>
        <span>}</span>
      <span>}</span><span>)</span>
    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
      <span>abort</span><span>(</span>e<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>runQueue</span><span>(</span>queue<span>,</span> iterator<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> postEnterCbs <span>=</span> <span>[</span><span>]</span>
    <span>const</span> <span>isValid</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>this</span><span>.</span>current <span>===</span> route
    <span>const</span> enterGuards <span>=</span> <span>extractEnterGuards</span><span>(</span>activated<span>,</span> postEnterCbs<span>,</span> isValid<span>)</span>
    <span>const</span> queue <span>=</span> enterGuards<span>.</span><span>concat</span><span>(</span><span>this</span><span>.</span>router<span>.</span>resolveHooks<span>)</span>
    <span>runQueue</span><span>(</span>queue<span>,</span> iterator<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>pending <span>!==</span> route<span>)</span> <span>{</span>
        <span>return</span> <span>abort</span><span>(</span><span>)</span>
      <span>}</span>
      <span>this</span><span>.</span>pending <span>=</span> <span>null</span>
      <span>onComplete</span><span>(</span>route<span>)</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span>router<span>.</span>app<span>)</span> <span>{</span>
        <span>this</span><span>.</span>router<span>.</span>app<span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
          postEnterCbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>{</span> <span>cb</span><span>(</span><span>)</span> <span>}</span><span>)</span>
        <span>}</span><span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先定义了 <code>abort</code> 函数，然后判断如果满足计算后的 <code>route</code> 和 <code>current</code> 是相同路径的话，则直接调用 <code>this.ensureUrl</code> 和 <code>abort</code>，<code>ensureUrl</code> 这个函数我们之后会介绍。</p>
<p>接着又根据 <code>current.matched</code> 和 <code>route.matched</code> 执行了 <code>resolveQueue</code> 方法解析出 3 个队列：</p>
<div><pre><code><span>function</span> <span>resolveQueue</span> <span>(</span>
  <span><span>current</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>next</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span></span>
<span>)</span><span>:</span> <span>{</span>
  <span>updated</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>activated</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>deactivated</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span>
<span>}</span> <span>{</span>
  <span>let</span> i
  <span>const</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span>current<span>.</span>length<span>,</span> next<span>.</span>length<span>)</span>
  <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>current<span>[</span>i<span>]</span> <span>!==</span> next<span>[</span>i<span>]</span><span>)</span> <span>{</span>
      <span>break</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>{</span>
    <span>updated</span><span>:</span> next<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> i<span>)</span><span>,</span>
    <span>activated</span><span>:</span> next<span>.</span><span>slice</span><span>(</span>i<span>)</span><span>,</span>
    <span>deactivated</span><span>:</span> current<span>.</span><span>slice</span><span>(</span>i<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>因为 <code>route.matched</code> 是一个 <code>RouteRecord</code> 的数组，由于路径是由 <code>current</code> 变向 <code>route</code>，那么就遍历对比 2 边的 <code>RouteRecord</code>，找到一个不一样的位置 <code>i</code>，那么 <code>next</code> 中从 0 到 <code>i</code> 的 <code>RouteRecord</code> 是两边都一样，则为 <code>updated</code> 的部分；从 <code>i</code> 到最后的 <code>RouteRecord</code> 是 <code>next</code> 独有的，为 <code>activated</code> 的部分；而 <code>current</code> 中从 <code>i</code> 到最后的 <code>RouteRecord</code> 则没有了，为 <code>deactivated</code> 的部分。</p>
<p>拿到 <code>updated</code>、<code>activated</code>、<code>deactivated</code> 3 个 <code>ReouteRecord</code> 数组后，接下来就是路径变换后的一个重要部分，执行一系列的钩子函数。</p>
<h2 id="导航守卫" tabindex="-1"> 导航守卫</h2>
<p>官方的说法叫导航守卫，实际上就是发生在路由路径切换的时候，执行的一系列钩子函数。</p>
<p>我们先从整体上看一下这些钩子函数执行的逻辑，首先构造一个队列 <code>queue</code>，它实际上是一个数组；然后再定义一个迭代器函数 <code>iterator</code>；最后再执行 <code>runQueue</code> 方法来执行这个队列。我们先来看一下 <code>runQueue</code> 的定义，在 <code>src/util/async.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>runQueue</span> <span>(</span><span><span>queue</span><span>:</span> Array<span>&lt;</span><span>?</span>NavigationGuard<span>></span><span>,</span> <span>fn</span><span>:</span> Function<span>,</span> <span>cb</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> <span>step</span> <span>=</span> <span>index</span> <span>=></span> <span>{</span> 
    <span>if</span> <span>(</span>index <span>>=</span> queue<span>.</span>length<span>)</span> <span>{</span>
      <span>cb</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>queue<span>[</span>index<span>]</span><span>)</span> <span>{</span>
        <span>fn</span><span>(</span>queue<span>[</span>index<span>]</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>step</span><span>(</span>index <span>+</span> <span>1</span><span>)</span>
        <span>}</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>step</span><span>(</span>index <span>+</span> <span>1</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>step</span><span>(</span><span>0</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这是一个非常经典的异步函数队列化执行的模式， <code>queue</code> 是一个 <code>NavigationGuard</code> 类型的数组，我们定义了 <code>step</code> 函数，每次根据 <code>index</code> 从 <code>queue</code> 中取一个 <code>guard</code>，然后执行 <code>fn</code> 函数，并且把 <code>guard</code> 作为参数传入，第二个参数是一个函数，当这个函数执行的时候再递归执行 <code>step</code> 函数，前进到下一个，注意这里的 <code>fn</code> 就是我们刚才的 <code>iterator</code> 函数，那么我们再回到 <code>iterator</code> 函数的定义：</p>
<div><pre><code><span>const</span> <span>iterator</span> <span>=</span> <span>(</span><span><span>hook</span><span>:</span> NavigationGuard<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>pending <span>!==</span> route<span>)</span> <span>{</span>
    <span>return</span> <span>abort</span><span>(</span><span>)</span>
  <span>}</span>
  <span>try</span> <span>{</span>
    <span>hook</span><span>(</span>route<span>,</span> current<span>,</span> <span>(</span><span><span>to</span><span>:</span> any</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>to <span>===</span> <span>false</span> <span>||</span> <span>isError</span><span>(</span>to<span>)</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>ensureURL</span><span>(</span><span>true</span><span>)</span>
        <span>abort</span><span>(</span>to<span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>
        <span>typeof</span> to <span>===</span> <span>'string'</span> <span>||</span>
        <span>(</span><span>typeof</span> to <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> <span>(</span>
          <span>typeof</span> to<span>.</span>path <span>===</span> <span>'string'</span> <span>||</span>
          <span>typeof</span> to<span>.</span>name <span>===</span> <span>'string'</span>
        <span>)</span><span>)</span>
      <span>)</span> <span>{</span>
        <span>abort</span><span>(</span><span>)</span>
        <span>if</span> <span>(</span><span>typeof</span> to <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> to<span>.</span>replace<span>)</span> <span>{</span>
          <span>this</span><span>.</span><span>replace</span><span>(</span>to<span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>this</span><span>.</span><span>push</span><span>(</span>to<span>)</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>next</span><span>(</span>to<span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    <span>abort</span><span>(</span>e<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>iterator</code> 函数逻辑很简单，它就是去执行每一个 导航守卫 <code>hook</code>，并传入 <code>route</code>、<code>current</code> 和匿名函数，这些参数对应文档中的 <code>to</code>、<code>from</code>、<code>next</code>，当执行了匿名函数，会根据一些条件执行 <code>abort</code> 或 <code>next</code>，只有执行 <code>next</code> 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 <code>next</code> 方法来 <code>resolve</code> 这个钩子函数。</p>
<p>那么最后我们来看 <code>queue</code> 是怎么构造的：</p>
<div><pre><code><span>const</span> <span>queue</span><span>:</span> Array<span>&lt;</span><span>?</span>NavigationGuard<span>></span> <span>=</span> <span>[</span><span>]</span><span>.</span><span>concat</span><span>(</span>
  <span>extractLeaveGuards</span><span>(</span>deactivated<span>)</span><span>,</span>
  <span>this</span><span>.</span>router<span>.</span>beforeHooks<span>,</span>
  <span>extractUpdateHooks</span><span>(</span>updated<span>)</span><span>,</span>
  activated<span>.</span><span>map</span><span>(</span><span>m</span> <span>=></span> m<span>.</span>beforeEnter<span>)</span><span>,</span>
  <span>resolveAsyncComponents</span><span>(</span>activated<span>)</span>
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>按照顺序如下：</p>
<ol>
<li>
<p>在失活的组件里调用离开守卫。</p>
</li>
<li>
<p>调用全局的 <code>beforeEach</code> 守卫。</p>
</li>
<li>
<p>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫</p>
</li>
<li>
<p>在激活的路由配置里调用 <code>beforeEnter</code>。</p>
</li>
<li>
<p>解析异步路由组件。</p>
</li>
</ol>
<p>接下来我们来分别介绍这 5 步的实现。</p>
<p>第一步是通过执行 <code>extractLeaveGuards(deactivated)</code>，先来看一下 <code>extractLeaveGuards</code> 的定义：</p>
<div><pre><code><span>function</span> <span>extractLeaveGuards</span> <span>(</span><span><span>deactivated</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span></span><span>)</span><span>:</span> Array<span>&lt;</span><span>?</span>Function<span>></span> <span>{</span>
  <span>return</span> <span>extractGuards</span><span>(</span>deactivated<span>,</span> <span>'beforeRouteLeave'</span><span>,</span> bindGuard<span>,</span> <span>true</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>它内部调用了 <code>extractGuards</code> 的通用方法，可以从 <code>RouteRecord</code> 数组中提取各个阶段的守卫：</p>
<div><pre><code><span>function</span> <span>extractGuards</span> <span>(</span>
  <span><span>records</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>name</span><span>:</span> string<span>,</span>
  <span>bind</span><span>:</span> Function<span>,</span>
  reverse<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Array<span>&lt;</span><span>?</span>Function<span>></span> <span>{</span>
  <span>const</span> guards <span>=</span> <span>flatMapComponents</span><span>(</span>records<span>,</span> <span>(</span><span>def<span>,</span> instance<span>,</span> match<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> guard <span>=</span> <span>extractGuard</span><span>(</span>def<span>,</span> name<span>)</span>
    <span>if</span> <span>(</span>guard<span>)</span> <span>{</span>
      <span>return</span> Array<span>.</span><span>isArray</span><span>(</span>guard<span>)</span>
        <span>?</span> guard<span>.</span><span>map</span><span>(</span><span>guard</span> <span>=></span> <span>bind</span><span>(</span>guard<span>,</span> instance<span>,</span> match<span>,</span> key<span>)</span><span>)</span>
        <span>:</span> <span>bind</span><span>(</span>guard<span>,</span> instance<span>,</span> match<span>,</span> key<span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>return</span> <span>flatten</span><span>(</span>reverse <span>?</span> guards<span>.</span><span>reverse</span><span>(</span><span>)</span> <span>:</span> guards<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里用到了 <code>flatMapComponents</code> 方法去从 <code>records</code> 中获取所有的导航，它的定义在 <code>src/util/resolve-components.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>flatMapComponents</span> <span>(</span>
  <span><span>matched</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>fn</span><span>:</span> Function</span>
<span>)</span><span>:</span> Array<span>&lt;</span><span>?</span>Function<span>></span> <span>{</span>
  <span>return</span> <span>flatten</span><span>(</span>matched<span>.</span><span>map</span><span>(</span><span>m</span> <span>=></span> <span>{</span>
    <span>return</span> Object<span>.</span><span>keys</span><span>(</span>m<span>.</span>components<span>)</span><span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> <span>fn</span><span>(</span>
      m<span>.</span>components<span>[</span>key<span>]</span><span>,</span>
      m<span>.</span>instances<span>[</span>key<span>]</span><span>,</span>
      m<span>,</span> key
    <span>)</span><span>)</span>
  <span>}</span><span>)</span><span>)</span>
<span>}</span>

<span>export</span> <span>function</span> <span>flatten</span> <span>(</span><span><span>arr</span><span>:</span> Array<span>&lt;</span>any<span>></span></span><span>)</span><span>:</span> Array<span>&lt;</span>any<span>></span> <span>{</span>
  <span>return</span> <span>Array</span><span>.</span>prototype<span>.</span><span>concat</span><span>.</span><span>apply</span><span>(</span><span>[</span><span>]</span><span>,</span> arr<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>flatMapComponents</code> 的作用就是返回一个数组，数组的元素是从 <code>matched</code> 里获取到所有组件的 <code>key</code>，然后返回 <code>fn</code> 函数执行的结果，<code>flatten</code> 作用是把二维数组拍平成一维数组。</p>
<p>那么对于 <code>extractGuards</code> 中 <code>flatMapComponents</code> 的调用，执行每个 <code>fn</code> 的时候，通过 <code>extractGuard(def, name)</code> 获取到组件中对应 <code>name</code> 的导航守卫：</p>
<div><pre><code><span>function</span> <span>extractGuard</span> <span>(</span>
  <span><span>def</span><span>:</span> Object <span>|</span> Function<span>,</span>
  <span>key</span><span>:</span> string</span>
<span>)</span><span>:</span> NavigationGuard <span>|</span> Array<span>&lt;</span>NavigationGuard<span>></span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> def <span>!==</span> <span>'function'</span><span>)</span> <span>{</span>
    def <span>=</span> _Vue<span>.</span><span>extend</span><span>(</span>def<span>)</span>
  <span>}</span>
  <span>return</span> def<span>.</span>options<span>[</span>key<span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>获取到 <code>guard</code> 后，还会调用 <code>bind</code> 方法把组件的实例 <code>instance</code> 作为函数执行的上下文绑定到 <code>guard</code> 上，<code>bind </code> 方法的对应的是 <code>bindGuard</code>：</p>
<div><pre><code><span>function</span> <span>bindGuard</span> <span>(</span><span><span>guard</span><span>:</span> NavigationGuard<span>,</span> <span>instance</span><span>:</span> <span>?</span>_Vue</span><span>)</span><span>:</span> <span>?</span>NavigationGuard <span>{</span>
  <span>if</span> <span>(</span>instance<span>)</span> <span>{</span>
    <span>return</span> <span>function</span> <span>boundRouteGuard</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>guard</span><span>.</span><span>apply</span><span>(</span>instance<span>,</span> arguments<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>那么对于 <code>extractLeaveGuards(deactivated)</code> 而言，获取到的就是所有失活组件中定义的 <code>beforeRouteLeave</code> 钩子函数。</p>
<p>第二步是 <code>this.router.beforeHooks</code>，在我们的 <code>VueRouter</code> 类中定义了 <code>beforeEach</code> 方法，在 <code>src/index.js</code> 中：</p>
<div><pre><code><span>beforeEach</span> <span>(</span>fn<span>:</span> Function<span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> <span>registerHook</span><span>(</span><span>this</span><span>.</span>beforeHooks<span>,</span> fn<span>)</span>
<span>}</span>

<span>function</span> <span>registerHook</span> <span>(</span><span><span>list</span><span>:</span> Array<span>&lt;</span>any<span>></span><span>,</span> <span>fn</span><span>:</span> Function</span><span>)</span><span>:</span> Function <span>{</span>
  list<span>.</span><span>push</span><span>(</span>fn<span>)</span>
  <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> i <span>=</span> list<span>.</span><span>indexOf</span><span>(</span>fn<span>)</span>
    <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> list<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当用户使用 <code>router.beforeEach</code> 注册了一个全局守卫，就会往 <code>router.beforeHooks</code> 添加一个钩子函数，这样 <code>this.router.beforeHooks</code> 获取的就是用户注册的全局 <code>beforeEach</code> 守卫。</p>
<p>第三步执行了 <code>extractUpdateHooks(updated)</code>，来看一下 <code>extractUpdateHooks</code> 的定义：</p>
<div><pre><code><span>function</span> <span>extractUpdateHooks</span> <span>(</span><span><span>updated</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span></span><span>)</span><span>:</span> Array<span>&lt;</span><span>?</span>Function<span>></span> <span>{</span>
  <span>return</span> <span>extractGuards</span><span>(</span>updated<span>,</span> <span>'beforeRouteUpdate'</span><span>,</span> bindGuard<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>和 <code>extractLeaveGuards(deactivated)</code> 类似，<code>extractUpdateHooks(updated)</code> 获取到的就是所有重用的组件中定义的 <code>beforeRouteUpdate</code> 钩子函数。</p>
<p>第四步是执行 <code>activated.map(m =&gt; m.beforeEnter)</code>，获取的是在激活的路由配置中定义的 <code>beforeEnter</code> 函数。</p>
<p>第五步是执行 <code>resolveAsyncComponents(activated)</code> 解析异步组件，先来看一下 <code>resolveAsyncComponents</code> 的定义，在 <code>src/util/resolve-components.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>resolveAsyncComponents</span> <span>(</span><span><span>matched</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span></span><span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>let</span> hasAsync <span>=</span> <span>false</span>
    <span>let</span> pending <span>=</span> <span>0</span>
    <span>let</span> error <span>=</span> <span>null</span>

    <span>flatMapComponents</span><span>(</span>matched<span>,</span> <span>(</span><span>def<span>,</span> _<span>,</span> match<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> def <span>===</span> <span>'function'</span> <span>&amp;&amp;</span> def<span>.</span>cid <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
        hasAsync <span>=</span> <span>true</span>
        pending<span>++</span>

        <span>const</span> resolve <span>=</span> <span>once</span><span>(</span><span>resolvedDef</span> <span>=></span> <span>{</span>
          <span>if</span> <span>(</span><span>isESModule</span><span>(</span>resolvedDef<span>)</span><span>)</span> <span>{</span>
            resolvedDef <span>=</span> resolvedDef<span>.</span>default
          <span>}</span>
          def<span>.</span>resolved <span>=</span> <span>typeof</span> resolvedDef <span>===</span> <span>'function'</span>
            <span>?</span> resolvedDef
            <span>:</span> _Vue<span>.</span><span>extend</span><span>(</span>resolvedDef<span>)</span>
          match<span>.</span>components<span>[</span>key<span>]</span> <span>=</span> resolvedDef
          pending<span>--</span>
          <span>if</span> <span>(</span>pending <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
            <span>next</span><span>(</span><span>)</span>
          <span>}</span>
        <span>}</span><span>)</span>

        <span>const</span> reject <span>=</span> <span>once</span><span>(</span><span>reason</span> <span>=></span> <span>{</span>
          <span>const</span> msg <span>=</span> <span><span>`</span><span>Failed to resolve async component </span><span><span>${</span>key<span>}</span></span><span>: </span><span><span>${</span>reason<span>}</span></span><span>`</span></span>
          process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>warn</span><span>(</span><span>false</span><span>,</span> msg<span>)</span>
          <span>if</span> <span>(</span><span>!</span>error<span>)</span> <span>{</span>
            error <span>=</span> <span>isError</span><span>(</span>reason<span>)</span>
              <span>?</span> reason
              <span>:</span> <span>new</span> <span>Error</span><span>(</span>msg<span>)</span>
            <span>next</span><span>(</span>error<span>)</span>
          <span>}</span>
        <span>}</span><span>)</span>

        <span>let</span> res
        <span>try</span> <span>{</span>
          res <span>=</span> <span>def</span><span>(</span>resolve<span>,</span> reject<span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
          <span>reject</span><span>(</span>e<span>)</span>
        <span>}</span>
        <span>if</span> <span>(</span>res<span>)</span> <span>{</span>
          <span>if</span> <span>(</span><span>typeof</span> res<span>.</span>then <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
            res<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>const</span> comp <span>=</span> res<span>.</span>component
            <span>if</span> <span>(</span>comp <span>&amp;&amp;</span> <span>typeof</span> comp<span>.</span>then <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
              comp<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span><span>)</span>

    <span>if</span> <span>(</span><span>!</span>hasAsync<span>)</span> <span>next</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>resolveAsyncComponents</code> 返回的是一个导航守卫函数，有标准的 <code>to</code>、<code>from</code>、<code>next</code> 参数。它的内部实现很简单，利用了 <code>flatMapComponents</code> 方法从 <code>matched</code> 中获取到每个组件的定义，判断如果是异步组件，则执行异步组件加载逻辑，这块和我们之前分析 <code>Vue</code> 加载异步组件很类似，加载成功后会执行 <code> match.components[key] = resolvedDef</code> 把解析好的异步组件放到对应的 <code>components</code> 上，并且执行 <code>next</code> 函数。</p>
<p>这样在 <code>resolveAsyncComponents(activated)</code> 解析完所有激活的异步组件后，我们就可以拿到这一次所有激活的组件。这样我们在做完这 5 步后又做了一些事情：</p>
<div><pre><code><span>runQueue</span><span>(</span>queue<span>,</span> iterator<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> postEnterCbs <span>=</span> <span>[</span><span>]</span>
  <span>const</span> <span>isValid</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>this</span><span>.</span>current <span>===</span> route
  <span>const</span> enterGuards <span>=</span> <span>extractEnterGuards</span><span>(</span>activated<span>,</span> postEnterCbs<span>,</span> isValid<span>)</span>
  <span>const</span> queue <span>=</span> enterGuards<span>.</span><span>concat</span><span>(</span><span>this</span><span>.</span>router<span>.</span>resolveHooks<span>)</span>
  <span>runQueue</span><span>(</span>queue<span>,</span> iterator<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>pending <span>!==</span> route<span>)</span> <span>{</span>
      <span>return</span> <span>abort</span><span>(</span><span>)</span>
    <span>}</span>
    <span>this</span><span>.</span>pending <span>=</span> <span>null</span>
    <span>onComplete</span><span>(</span>route<span>)</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>router<span>.</span>app<span>)</span> <span>{</span>
      <span>this</span><span>.</span>router<span>.</span>app<span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        postEnterCbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>{</span> <span>cb</span><span>(</span><span>)</span> <span>}</span><span>)</span>
      <span>}</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="6">
<li>
<p>在被激活的组件里调用 <code>beforeRouteEnter</code>。</p>
</li>
<li>
<p>调用全局的 <code>beforeResolve</code> 守卫。</p>
</li>
<li>
<p>调用全局的 <code>afterEach</code> 钩子。</p>
</li>
</ol>
<p>对于第六步有这些相关的逻辑：</p>
<div><pre><code><span>const</span> postEnterCbs <span>=</span> <span>[</span><span>]</span>
<span>const</span> <span>isValid</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>this</span><span>.</span>current <span>===</span> route
<span>const</span> enterGuards <span>=</span> <span>extractEnterGuards</span><span>(</span>activated<span>,</span> postEnterCbs<span>,</span> isValid<span>)</span>

<span>function</span> <span>extractEnterGuards</span> <span>(</span>
  <span>activated</span><span>:</span> Array<span>&lt;</span>RouteRecord<span>></span><span>,</span>
  <span>cbs</span><span>:</span> Array<span>&lt;</span>Function<span>></span><span>,</span>
  <span>isValid</span><span>:</span> <span>(</span><span>)</span> <span>=></span> boolean
<span>)</span><span>:</span> Array<span>&lt;</span><span>?</span>Function<span>></span> <span>{</span>
  <span>return</span> <span>extractGuards</span><span>(</span>activated<span>,</span> <span>'beforeRouteEnter'</span><span>,</span> <span>(</span><span>guard<span>,</span> _<span>,</span> match<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>bindEnterGuard</span><span>(</span>guard<span>,</span> match<span>,</span> key<span>,</span> cbs<span>,</span> isValid<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>function</span> <span>bindEnterGuard</span> <span>(</span>
  <span>guard</span><span>:</span> NavigationGuard<span>,</span>
  <span>match</span><span>:</span> RouteRecord<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>cbs</span><span>:</span> Array<span>&lt;</span>Function<span>></span><span>,</span>
  <span>isValid</span><span>:</span> <span>(</span><span>)</span> <span>=></span> boolean
<span>)</span><span>:</span> NavigationGuard <span>{</span>
  <span>return</span> <span>function</span> <span>routeEnterGuard</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>
    <span>return</span> <span>guard</span><span>(</span>to<span>,</span> from<span>,</span> <span>cb</span> <span>=></span> <span>{</span>
      <span>next</span><span>(</span>cb<span>)</span>
      <span>if</span> <span>(</span><span>typeof</span> cb <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
        cbs<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>poll</span><span>(</span>cb<span>,</span> match<span>.</span>instances<span>,</span> key<span>,</span> isValid<span>)</span>
        <span>}</span><span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>poll</span> <span>(</span>
  <span>cb</span><span>:</span> any<span>,</span>
  <span>instances</span><span>:</span> Object<span>,</span>
  <span>key</span><span>:</span> string<span>,</span>
  <span>isValid</span><span>:</span> <span>(</span><span>)</span> <span>=></span> boolean
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>instances<span>[</span>key<span>]</span><span>)</span> <span>{</span>
    <span>cb</span><span>(</span>instances<span>[</span>key<span>]</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isValid</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>poll</span><span>(</span>cb<span>,</span> instances<span>,</span> key<span>,</span> isValid<span>)</span>
    <span>}</span><span>,</span> <span>16</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>extractEnterGuards</code> 函数的实现也是利用了 <code>extractGuards</code> 方法提取组件中的 <code>beforeRouteEnter</code> 导航钩子函数，和之前不同的是 <code>bind</code> 方法的不同。文档中特意强调了 <code>beforeRouteEnter</code> 钩子函数中是拿不到组件实例的，因为当守卫执行前，组件实例还没被创建，但是我们可以通过传一个回调给 <code>next</code> 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：</p>
<div><pre><code><span>beforeRouteEnter</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>
  <span>next</span><span>(</span><span>vm</span> <span>=></span> <span>{</span>
    <span>// 通过 `vm` 访问组件实例</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>来看一下这是怎么实现的。</p>
<p>在 <code>bindEnterGuard</code> 函数中，返回的是 <code>routeEnterGuard</code> 函数，所以在执行 <code>iterator</code> 中的 <code>hook</code> 函数的时候，就相当于执行 <code>routeEnterGuard</code> 函数，那么就会执行我们定义的导航守卫 <code>guard</code> 函数，并且当这个回调函数执行的时候，首先执行 <code>next</code> 函数 <code>rersolve</code> 当前导航钩子，然后把回调函数的参数，它也是一个回调函数用 <code>cbs</code> 收集起来，其实就是收集到外面定义的 <code>postEnterCbs</code> 中，然后在最后会执行：</p>
<div><pre><code><span>if</span> <span>(</span><span>this</span><span>.</span>router<span>.</span>app<span>)</span> <span>{</span>
  <span>this</span><span>.</span>router<span>.</span>app<span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    postEnterCbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>{</span> <span>cb</span><span>(</span><span>)</span> <span>}</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>在根路由组件重新渲染后，遍历 <code>postEnterCbs</code> 执行回调，每一个回调执行的时候，其实是执行 <code> poll(cb, match.instances, key, isValid)</code> 方法，因为考虑到一些了路由组件被套 <code>transition</code> 組件在一些缓动模式下不一定能拿到实例，所以用一个轮询方法不断去判断，直到能获取到组件实例，再去调用 <code>cb</code>，并把组件实例作为参数传入，这就是我们在回调函数中能拿到组件实例的原因。</p>
<p>第七步是获取 <code>this.router.resolveHooks</code>，这个和
<code>this.router.beforeHooks</code> 的获取类似，在我们的 <code>VueRouter</code> 类中定义了 <code>beforeResolve</code> 方法：</p>
<div><pre><code><span>beforeResolve</span> <span>(</span>fn<span>:</span> Function<span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> <span>registerHook</span><span>(</span><span>this</span><span>.</span>resolveHooks<span>,</span> fn<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>当用户使用 <code>router.beforeResolve</code> 注册了一个全局守卫，就会往 <code>router.resolveHooks</code> 添加一个钩子函数，这样 <code>this.router.resolveHooks</code> 获取的就是用户注册的全局 <code>beforeResolve</code> 守卫。</p>
<p>第八步是在最后执行了 <code>onComplete(route)</code> 后，会执行 <code>this.updateRoute(route)</code> 方法：</p>
<div><pre><code><span>updateRoute</span> <span>(</span><span><span>route</span><span>:</span> Route</span><span>)</span> <span>{</span>
  <span>const</span> prev <span>=</span> <span>this</span><span>.</span>current
  <span>this</span><span>.</span>current <span>=</span> route
  <span>this</span><span>.</span>cb <span>&amp;&amp;</span> <span>this</span><span>.</span><span>cb</span><span>(</span>route<span>)</span>
  <span>this</span><span>.</span>router<span>.</span>afterHooks<span>.</span><span>forEach</span><span>(</span><span>hook</span> <span>=></span> <span>{</span>
    hook <span>&amp;&amp;</span> <span>hook</span><span>(</span>route<span>,</span> prev<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同样在我们的 <code>VueRouter</code> 类中定义了 <code>afterEach</code> 方法：</p>
<div><pre><code><span>afterEach</span> <span>(</span>fn<span>:</span> Function<span>)</span><span>:</span> Function <span>{</span>
  <span>return</span> <span>registerHook</span><span>(</span><span>this</span><span>.</span>afterHooks<span>,</span> fn<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>当用户使用 <code>router.afterEach</code> 注册了一个全局守卫，就会往 <code>router.afterHooks</code> 添加一个钩子函数，这样 <code>this.router.afterHooks</code> 获取的就是用户注册的全局 <code>afterHooks</code> 守卫。</p>
<p>那么至此我们把所有导航守卫的执行分析完毕了，我们知道路由切换除了执行这些钩子函数，从表象上有 2 个地方会发生变化，一个是 url 发生变化，一个是组件发生变化。接下来我们分别介绍这两块的实现原理。</p>
<h2 id="url" tabindex="-1"> url</h2>
<p>当我们点击 <code>router-link</code> 的时候，实际上最终会执行 <code>router.push</code>，如下：</p>
<div><pre><code><span>push</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>history<span>.</span><span>push</span><span>(</span>location<span>,</span> onComplete<span>,</span> onAbort<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>this.history.push</code> 函数，这个函数是子类实现的，不同模式下该函数的实现略有不同，我们来看一下平时使用比较多的 <code>hash</code> 模式该函数的实现，在 <code>src/history/hash.js</code> 中：</p>
<div><pre><code><span>push</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> <span>current</span><span>:</span> fromRoute <span>}</span> <span>=</span> <span>this</span>
  <span>this</span><span>.</span><span>transitionTo</span><span>(</span>location<span>,</span> <span>route</span> <span>=></span> <span>{</span>
    <span>pushHash</span><span>(</span>route<span>.</span>fullPath<span>)</span>
    <span>handleScroll</span><span>(</span><span>this</span><span>.</span>router<span>,</span> route<span>,</span> fromRoute<span>,</span> <span>false</span><span>)</span>
    onComplete <span>&amp;&amp;</span> <span>onComplete</span><span>(</span>route<span>)</span>
  <span>}</span><span>,</span> onAbort<span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>push</code> 函数会先执行 <code>this.transitionTo</code> 做路径切换，在切换完成的回调函数中，执行 <code>pushHash</code> 函数：</p>
<div><pre><code><span>function</span> <span>pushHash</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>supportsPushState<span>)</span> <span>{</span>
    <span>pushState</span><span>(</span><span>getUrl</span><span>(</span>path<span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    window<span>.</span>location<span>.</span>hash <span>=</span> path
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>supportsPushState</code> 的定义在 <code>src/util/push-state.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> supportsPushState <span>=</span> inBrowser <span>&amp;&amp;</span> <span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>const</span> ua <span>=</span> window<span>.</span>navigator<span>.</span>userAgent

  <span>if</span> <span>(</span>
    <span>(</span>ua<span>.</span><span>indexOf</span><span>(</span><span>'Android 2.'</span><span>)</span> <span>!==</span> <span>-</span><span>1</span> <span>||</span> ua<span>.</span><span>indexOf</span><span>(</span><span>'Android 4.0'</span><span>)</span> <span>!==</span> <span>-</span><span>1</span><span>)</span> <span>&amp;&amp;</span>
    ua<span>.</span><span>indexOf</span><span>(</span><span>'Mobile Safari'</span><span>)</span> <span>!==</span> <span>-</span><span>1</span> <span>&amp;&amp;</span>
    ua<span>.</span><span>indexOf</span><span>(</span><span>'Chrome'</span><span>)</span> <span>===</span> <span>-</span><span>1</span> <span>&amp;&amp;</span>
    ua<span>.</span><span>indexOf</span><span>(</span><span>'Windows Phone'</span><span>)</span> <span>===</span> <span>-</span><span>1</span>
  <span>)</span> <span>{</span>
    <span>return</span> <span>false</span>
  <span>}</span>

  <span>return</span> window<span>.</span>history <span>&amp;&amp;</span> <span>'pushState'</span> <span>in</span> window<span>.</span>history
<span>}</span><span>)</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果支持的话，则获取当前完整的 <code>url</code>，执行 <code>pushState</code> 方法：</p>
<div><pre><code><span>export</span> <span>function</span> <span>pushState</span> <span>(</span><span>url<span>?</span><span>:</span> string<span>,</span> replace<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span>
  <span>saveScrollPosition</span><span>(</span><span>)</span>
  <span>const</span> history <span>=</span> window<span>.</span>history
  <span>try</span> <span>{</span>
    <span>if</span> <span>(</span>replace<span>)</span> <span>{</span>
      history<span>.</span><span>replaceState</span><span>(</span><span>{</span> <span>key</span><span>:</span> _key <span>}</span><span>,</span> <span>''</span><span>,</span> url<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      _key <span>=</span> <span>genKey</span><span>(</span><span>)</span>
      history<span>.</span><span>pushState</span><span>(</span><span>{</span> <span>key</span><span>:</span> _key <span>}</span><span>,</span> <span>''</span><span>,</span> url<span>)</span>
    <span>}</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    window<span>.</span>location<span>[</span>replace <span>?</span> <span>'replace'</span> <span>:</span> <span>'assign'</span><span>]</span><span>(</span>url<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>pushState</code> 会调用浏览器原生的 <code>history</code> 的 <code>pushState</code> 接口或者 <code>replaceState</code> 接口，更新浏览器的 url 地址，并把当前 url 压入历史栈中。</p>
<p>然后在 <code>history</code> 的初始化中，会设置一个监听器，监听历史栈的变化：</p>
<div><pre><code><span>setupListeners</span> <span>(</span><span>)</span> <span>{</span>
  <span>const</span> router <span>=</span> <span>this</span><span>.</span>router
  <span>const</span> expectScroll <span>=</span> router<span>.</span>options<span>.</span>scrollBehavior
  <span>const</span> supportsScroll <span>=</span> supportsPushState <span>&amp;&amp;</span> expectScroll

  <span>if</span> <span>(</span>supportsScroll<span>)</span> <span>{</span>
    <span>setupScroll</span><span>(</span><span>)</span>
  <span>}</span>

  window<span>.</span><span>addEventListener</span><span>(</span>supportsPushState <span>?</span> <span>'popstate'</span> <span>:</span> <span>'hashchange'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> current <span>=</span> <span>this</span><span>.</span>current
    <span>if</span> <span>(</span><span>!</span><span>ensureSlash</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>return</span>
    <span>}</span>
    <span>this</span><span>.</span><span>transitionTo</span><span>(</span><span>getHash</span><span>(</span><span>)</span><span>,</span> <span>route</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>supportsScroll<span>)</span> <span>{</span>
        <span>handleScroll</span><span>(</span><span>this</span><span>.</span>router<span>,</span> route<span>,</span> current<span>,</span> <span>true</span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span><span>!</span>supportsPushState<span>)</span> <span>{</span>
        <span>replaceHash</span><span>(</span>route<span>.</span>fullPath<span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 <code>popstate</code> 事件，然后拿到当前要跳转的 <code>hash</code>，执行 <code>transtionTo</code> 方法做一次路径转换。</p>
<p>同学们在使用 Vue-Router 开发项目的时候，打开调试页面 <code>http://localhost:8080</code> 后会自动把 url 修改为 <code>http://localhost:8080/#/</code>，这是怎么做到呢？原来在实例化 <code>HashHistory</code> 的时候，构造函数会执行 <code>ensureSlash()</code> 方法：</p>
<div><pre><code><span>function</span> <span>ensureSlash</span> <span>(</span><span>)</span><span>:</span> boolean <span>{</span>
  <span>const</span> path <span>=</span> <span>getHash</span><span>(</span><span>)</span>
  <span>if</span> <span>(</span>path<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'/'</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span>
  <span>}</span>
  <span>replaceHash</span><span>(</span><span>'/'</span> <span>+</span> path<span>)</span>
  <span>return</span> <span>false</span>
<span>}</span>

<span>export</span> <span>function</span> <span>getHash</span> <span>(</span><span>)</span><span>:</span> string <span>{</span>
  <span>// We can't use window.location.hash here because it's not</span>
  <span>// consistent across browsers - Firefox will pre-decode it!</span>
  <span>const</span> href <span>=</span> window<span>.</span>location<span>.</span>href
  <span>const</span> index <span>=</span> href<span>.</span><span>indexOf</span><span>(</span><span>'#'</span><span>)</span>
  <span>return</span> index <span>===</span> <span>-</span><span>1</span> <span>?</span> <span>''</span> <span>:</span> href<span>.</span><span>slice</span><span>(</span>index <span>+</span> <span>1</span><span>)</span>
<span>}</span>

<span>function</span> <span>getUrl</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>const</span> href <span>=</span> window<span>.</span>location<span>.</span>href
  <span>const</span> i <span>=</span> href<span>.</span><span>indexOf</span><span>(</span><span>'#'</span><span>)</span>
  <span>const</span> base <span>=</span> i <span>>=</span> <span>0</span> <span>?</span> href<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> i<span>)</span> <span>:</span> href
  <span>return</span> <span><span>`</span><span><span>${</span>base<span>}</span></span><span>#</span><span><span>${</span>path<span>}</span></span><span>`</span></span>
<span>}</span>

<span>function</span> <span>replaceHash</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>supportsPushState<span>)</span> <span>{</span>
    <span>replaceState</span><span>(</span><span>getUrl</span><span>(</span>path<span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    window<span>.</span>location<span>.</span><span>replace</span><span>(</span><span>getUrl</span><span>(</span>path<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>function</span> <span>replaceState</span> <span>(</span><span>url<span>?</span><span>:</span> string</span><span>)</span> <span>{</span>
  <span>pushState</span><span>(</span>url<span>,</span> <span>true</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个时候 <code>path</code> 为空，所以执行 <code>replaceHash('/' + path)</code>，然后内部会执行一次 <code>getUrl</code>，计算出来的新的 <code>url</code> 为 <code>http://localhost:8080/#/</code>，最终会执行 <code>pushState(url, true)</code>，这就是 url 会改变的原因。</p>
<h2 id="组件" tabindex="-1"> 组件</h2>
<p>路由最终的渲染离不开组件，Vue-Router 内置了 <code>&lt;router-view&gt;</code> 组件，它的定义在 <code>src/components/view.js</code> 中。</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> <span>'RouterView'</span><span>,</span>
  <span>functional</span><span>:</span> <span>true</span><span>,</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>name</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> String<span>,</span>
      <span>default</span><span>:</span> <span>'default'</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>render</span> <span>(</span><span>_<span>,</span> <span>{</span> props<span>,</span> children<span>,</span> parent<span>,</span> data <span>}</span></span><span>)</span> <span>{</span>
    data<span>.</span>routerView <span>=</span> <span>true</span>
   
    <span>const</span> h <span>=</span> parent<span>.</span>$createElement
    <span>const</span> name <span>=</span> props<span>.</span>name
    <span>const</span> route <span>=</span> parent<span>.</span>$route
    <span>const</span> cache <span>=</span> parent<span>.</span>_routerViewCache <span>||</span> <span>(</span>parent<span>.</span>_routerViewCache <span>=</span> <span>{</span><span>}</span><span>)</span>

    <span>let</span> depth <span>=</span> <span>0</span>
    <span>let</span> inactive <span>=</span> <span>false</span>
    <span>while</span> <span>(</span>parent <span>&amp;&amp;</span> parent<span>.</span>_routerRoot <span>!==</span> parent<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>parent<span>.</span>$vnode <span>&amp;&amp;</span> parent<span>.</span>$vnode<span>.</span>data<span>.</span>routerView<span>)</span> <span>{</span>
        depth<span>++</span>
      <span>}</span>
      <span>if</span> <span>(</span>parent<span>.</span>_inactive<span>)</span> <span>{</span>
        inactive <span>=</span> <span>true</span>
      <span>}</span>
      parent <span>=</span> parent<span>.</span>$parent
    <span>}</span>
    data<span>.</span>routerViewDepth <span>=</span> depth

    <span>if</span> <span>(</span>inactive<span>)</span> <span>{</span>
      <span>return</span> <span>h</span><span>(</span>cache<span>[</span>name<span>]</span><span>,</span> data<span>,</span> children<span>)</span>
    <span>}</span>

    <span>const</span> matched <span>=</span> route<span>.</span>matched<span>[</span>depth<span>]</span>
    <span>if</span> <span>(</span><span>!</span>matched<span>)</span> <span>{</span>
      cache<span>[</span>name<span>]</span> <span>=</span> <span>null</span>
      <span>return</span> <span>h</span><span>(</span><span>)</span>
    <span>}</span>

    <span>const</span> component <span>=</span> cache<span>[</span>name<span>]</span> <span>=</span> matched<span>.</span>components<span>[</span>name<span>]</span>
   
    data<span>.</span><span>registerRouteInstance</span> <span>=</span> <span>(</span><span>vm<span>,</span> val</span><span>)</span> <span>=></span> <span>{</span>     
      <span>const</span> current <span>=</span> matched<span>.</span>instances<span>[</span>name<span>]</span>
      <span>if</span> <span>(</span>
        <span>(</span>val <span>&amp;&amp;</span> current <span>!==</span> vm<span>)</span> <span>||</span>
        <span>(</span><span>!</span>val <span>&amp;&amp;</span> current <span>===</span> vm<span>)</span>
      <span>)</span> <span>{</span>
        matched<span>.</span>instances<span>[</span>name<span>]</span> <span>=</span> val
      <span>}</span>
    <span>}</span>
    
    <span>;</span><span>(</span>data<span>.</span>hook <span>||</span> <span>(</span>data<span>.</span>hook <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>.</span><span>prepatch</span> <span>=</span> <span>(</span><span>_<span>,</span> vnode</span><span>)</span> <span>=></span> <span>{</span>
      matched<span>.</span>instances<span>[</span>name<span>]</span> <span>=</span> vnode<span>.</span>componentInstance
    <span>}</span>

    <span>let</span> propsToPass <span>=</span> data<span>.</span>props <span>=</span> <span>resolveProps</span><span>(</span>route<span>,</span> matched<span>.</span>props <span>&amp;&amp;</span> matched<span>.</span>props<span>[</span>name<span>]</span><span>)</span>
    <span>if</span> <span>(</span>propsToPass<span>)</span> <span>{</span>
      propsToPass <span>=</span> data<span>.</span>props <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> propsToPass<span>)</span>
      <span>const</span> attrs <span>=</span> data<span>.</span>attrs <span>=</span> data<span>.</span>attrs <span>||</span> <span>{</span><span>}</span>
      <span>for</span> <span>(</span><span>const</span> key <span>in</span> propsToPass<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>component<span>.</span>props <span>||</span> <span>!</span><span>(</span>key <span>in</span> component<span>.</span>props<span>)</span><span>)</span> <span>{</span>
          attrs<span>[</span>key<span>]</span> <span>=</span> propsToPass<span>[</span>key<span>]</span>
          <span>delete</span> propsToPass<span>[</span>key<span>]</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>return</span> <span>h</span><span>(</span>component<span>,</span> data<span>,</span> children<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>&lt;router-view&gt;</code> 是一个 <code>functional</code> 组件，它的渲染也是依赖 <code>render</code> 函数，那么 <code>&lt;router-view&gt;</code> 具体应该渲染什么组件呢，首先获取当前的路径：</p>
<div><pre><code><span>const</span> route <span>=</span> parent<span>.</span>$route
</code></pre><div aria-hidden="true"><div></div></div></div><p>我们之前分析过，在 <code>src/install.js</code> 中，我们给 Vue 的原型上定义了 <code>$route</code>：</p>
<div><pre><code>Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$route'</span><span>,</span> <span>{</span>
  <span>get</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>this</span><span>.</span>_routerRoot<span>.</span>_route <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>然后在 <code>VueRouter</code> 的实例执行 <code>router.init</code> 方法的时候，会执行如下逻辑，定义在 <code>src/index.js</code> 中：</p>
<div><pre><code>history<span>.</span><span>listen</span><span>(</span><span>route</span> <span>=></span> <span>{</span>
  <span>this</span><span>.</span>apps<span>.</span><span>forEach</span><span>(</span><span>(</span><span>app</span><span>)</span> <span>=></span> <span>{</span>
    app<span>.</span>_route <span>=</span> route
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>而 <code>history.listen</code> 方法定义在 <code>src/history/base.js</code> 中：</p>
<div><pre><code><span>listen</span> <span>(</span><span><span>cb</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>cb <span>=</span> cb
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>然后在 <code>updateRoute</code> 的时候执行 <code>this.cb</code>：</p>
<div><pre><code><span>updateRoute</span> <span>(</span><span><span>route</span><span>:</span> Route</span><span>)</span> <span>{</span>
  <span>//. ..</span>
  <span>this</span><span>.</span>current <span>=</span> route
  <span>this</span><span>.</span>cb <span>&amp;&amp;</span> <span>this</span><span>.</span><span>cb</span><span>(</span>route<span>)</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是我们执行 <code>transitionTo</code> 方法最后执行 <code>updateRoute</code> 的时候会执行回调，然后会更新 <code>this.apps</code> 保存的组件实例的 <code>_route</code> 值，<code>this.apps</code> 数组保存的实例的特点都是在初始化的时候传入了 <code>router</code> 配置项，一般的场景数组只会保存根 Vue 实例，因为我们是在 <code>new Vue</code> 传入了 <code>router</code> 实例。<code>$route</code> 是定义在 <code>Vue.prototype</code> 上。每个组件实例访问 <code>$route</code> 属性，就是访问根实例的 <code>_route</code>，也就是当前的路由线路。</p>
<p><code>&lt;router-view&gt;</code> 是支持嵌套的，回到 <code>render</code> 函数，其中定义了 <code>depth</code> 的概念，它表示 <code>&lt;router-view&gt;</code> 嵌套的深度。每个 <code>&lt;router-view&gt;</code> 在渲染的时候，执行如下逻辑：</p>
<div><pre><code>data<span>.</span>routerView <span>=</span> <span>true</span>
<span>// ...</span>
<span>while</span> <span>(</span>parent <span>&amp;&amp;</span> parent<span>.</span>_routerRoot <span>!==</span> parent<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>parent<span>.</span>$vnode <span>&amp;&amp;</span> parent<span>.</span>$vnode<span>.</span>data<span>.</span>routerView<span>)</span> <span>{</span>
    depth<span>++</span>
  <span>}</span>
  <span>if</span> <span>(</span>parent<span>.</span>_inactive<span>)</span> <span>{</span>
    inactive <span>=</span> <span>true</span>
  <span>}</span>
  parent <span>=</span> parent<span>.</span>$parent
<span>}</span>

<span>const</span> matched <span>=</span> route<span>.</span>matched<span>[</span>depth<span>]</span>
<span>// ...</span>
<span>const</span> component <span>=</span> cache<span>[</span>name<span>]</span> <span>=</span> matched<span>.</span>components<span>[</span>name<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>parent._routerRoot</code> 表示的是根 Vue 实例，那么这个循环就是从当前的 <code>&lt;router-view&gt;</code> 的父节点向上找，一直找到根 Vue 实例，在这个过程，如果碰到了父节点也是 <code>&lt;router-view&gt;</code> 的时候，说明 <code>&lt;router-view&gt;</code> 有嵌套的情况，<code>depth++</code>。遍历完成后，根据当前线路匹配的路径和 <code>depth</code> 找到对应的 <code>RouteRecord</code>，进而找到该渲染的组件。</p>
<p>除了找到了应该渲染的组件，还定义了一个注册路由实例的方法：</p>
<div><pre><code>data<span>.</span><span>registerRouteInstance</span> <span>=</span> <span>(</span><span>vm<span>,</span> val</span><span>)</span> <span>=></span> <span>{</span>     
  <span>const</span> current <span>=</span> matched<span>.</span>instances<span>[</span>name<span>]</span>
  <span>if</span> <span>(</span>
    <span>(</span>val <span>&amp;&amp;</span> current <span>!==</span> vm<span>)</span> <span>||</span>
    <span>(</span><span>!</span>val <span>&amp;&amp;</span> current <span>===</span> vm<span>)</span>
  <span>)</span> <span>{</span>
    matched<span>.</span>instances<span>[</span>name<span>]</span> <span>=</span> val
  <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>给 <code>vnode</code> 的 <code>data</code> 定义了 <code>registerRouteInstance</code> 方法，在 <code>src/install.js</code> 中，我们会调用该方法去注册路由的实例：</p>
<div><pre><code><span>const</span> <span>registerInstance</span> <span>=</span> <span>(</span><span>vm<span>,</span> callVal</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> i <span>=</span> vm<span>.</span>$options<span>.</span>_parentVnode
  <span>if</span> <span>(</span><span>isDef</span><span>(</span>i<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>data<span>)</span> <span>&amp;&amp;</span> <span>isDef</span><span>(</span>i <span>=</span> i<span>.</span>registerRouteInstance<span>)</span><span>)</span> <span>{</span>
    <span>i</span><span>(</span>vm<span>,</span> callVal<span>)</span>
  <span>}</span>
<span>}</span>

Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
  <span>beforeCreate</span> <span>(</span><span>)</span> <span>{</span>
    <span>// ...</span>
    <span>registerInstance</span><span>(</span><span>this</span><span>,</span> <span>this</span><span>)</span>
  <span>}</span><span>,</span>
  <span>destroyed</span> <span>(</span><span>)</span> <span>{</span>
    <span>registerInstance</span><span>(</span><span>this</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在混入的 <code>beforeCreate</code> 钩子函数中，会执行 <code>registerInstance</code> 方法，进而执行 <code>render</code> 函数中定义的 <code>registerRouteInstance</code> 方法，从而给 <code>matched.instances[name]</code> 赋值当前组件的 <code>vm</code> 实例。</p>
<p><code>render</code> 函数的最后根据 <code>component</code> 渲染出对应的组件 <code>vonde</code>：</p>
<div><pre><code><span>return</span> <span>h</span><span>(</span>component<span>,</span> data<span>,</span> children<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>那么当我们执行 <code>transitionTo</code> 来更改路由线路后，组件是如何重新渲染的呢？在我们混入的 <code>beforeCreate</code> 钩子函数中有这么一段逻辑：</p>
<div><pre><code>Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
  <span>beforeCreate</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isDef</span><span>(</span><span>this</span><span>.</span>$options<span>.</span>router<span>)</span><span>)</span> <span>{</span>
      Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'_route'</span><span>,</span> <span>this</span><span>.</span>_router<span>.</span>history<span>.</span>current<span>)</span>
    <span>}</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>由于我们把根 Vue 实例的 <code>_route</code> 属性定义成响应式的，我们在每个 <code>&lt;router-view&gt;</code> 执行 <code>render</code> 函数的时候，都会访问  <code>parent.$route</code>，如我们之前分析会访问 <code>this._routerRoot._route</code>，触发了它的 <code>getter</code>，相当于 <code>&lt;router-view&gt;</code> 对它有依赖，然后再执行完 <code>transitionTo</code> 后，修改 <code>app._route</code> 的时候，又触发了<code>setter</code>，因此会通知 <code>&lt;router-view&gt;</code> 的渲染 <code>watcher</code> 更新，重新渲染组件。</p>
<p>Vue-Router 还内置了另一个组件 <code>&lt;router-link&gt;</code>，
它支持用户在具有路由功能的应用中（点击）导航。 通过 <code>to</code> 属性指定目标地址，默认渲染成带有正确链接的 <code>&lt;a&gt;</code> 标签，可以通过配置 <code>tag</code> 属性生成别的标签。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</p>
<p><code>&lt;router-link&gt;</code> 比起写死的 <code>&lt;a href=&quot;...&quot;&gt;</code> 会好一些，理由如下：</p>
<p>无论是 HTML5 <code>history</code> 模式还是 <code>hash</code> 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 <code>hash</code> 模式，无须作任何变动。</p>
<p>在 HTML5 <code>history</code> 模式下，<code>router-link</code> 会守卫点击事件，让浏览器不再重新加载页面。</p>
<p>当你在 HTML5 <code>history</code> 模式下使用 <code>base</code> 选项之后，所有的 to 属性都不需要写（基路径）了。</p>
<p>那么接下来我们就来分析它的实现，它的定义在 <code>src/components/link.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> <span>'RouterLink'</span><span>,</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>to</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> toTypes<span>,</span>
      <span>required</span><span>:</span> <span>true</span>
    <span>}</span><span>,</span>
    <span>tag</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> String<span>,</span>
      <span>default</span><span>:</span> <span>'a'</span>
    <span>}</span><span>,</span>
    <span>exact</span><span>:</span> Boolean<span>,</span>
    <span>append</span><span>:</span> Boolean<span>,</span>
    <span>replace</span><span>:</span> Boolean<span>,</span>
    <span>activeClass</span><span>:</span> String<span>,</span>
    <span>exactActiveClass</span><span>:</span> String<span>,</span>
    <span>event</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> eventTypes<span>,</span>
      <span>default</span><span>:</span> <span>'click'</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>render</span> <span>(</span><span><span>h</span><span>:</span> Function</span><span>)</span> <span>{</span>
    <span>const</span> router <span>=</span> <span>this</span><span>.</span>$router
    <span>const</span> current <span>=</span> <span>this</span><span>.</span>$route
    <span>const</span> <span>{</span> location<span>,</span> route<span>,</span> href <span>}</span> <span>=</span> router<span>.</span><span>resolve</span><span>(</span><span>this</span><span>.</span>to<span>,</span> current<span>,</span> <span>this</span><span>.</span>append<span>)</span>

    <span>const</span> classes <span>=</span> <span>{</span><span>}</span>
    <span>const</span> globalActiveClass <span>=</span> router<span>.</span>options<span>.</span>linkActiveClass
    <span>const</span> globalExactActiveClass <span>=</span> router<span>.</span>options<span>.</span>linkExactActiveClass
    <span>const</span> activeClassFallback <span>=</span> globalActiveClass <span>==</span> <span>null</span>
            <span>?</span> <span>'router-link-active'</span>
            <span>:</span> globalActiveClass
    <span>const</span> exactActiveClassFallback <span>=</span> globalExactActiveClass <span>==</span> <span>null</span>
            <span>?</span> <span>'router-link-exact-active'</span>
            <span>:</span> globalExactActiveClass
    <span>const</span> activeClass <span>=</span> <span>this</span><span>.</span>activeClass <span>==</span> <span>null</span>
            <span>?</span> activeClassFallback
            <span>:</span> <span>this</span><span>.</span>activeClass
    <span>const</span> exactActiveClass <span>=</span> <span>this</span><span>.</span>exactActiveClass <span>==</span> <span>null</span>
            <span>?</span> exactActiveClassFallback
            <span>:</span> <span>this</span><span>.</span>exactActiveClass
    <span>const</span> compareTarget <span>=</span> location<span>.</span>path
      <span>?</span> <span>createRoute</span><span>(</span><span>null</span><span>,</span> location<span>,</span> <span>null</span><span>,</span> router<span>)</span>
      <span>:</span> route

    classes<span>[</span>exactActiveClass<span>]</span> <span>=</span> <span>isSameRoute</span><span>(</span>current<span>,</span> compareTarget<span>)</span>
    classes<span>[</span>activeClass<span>]</span> <span>=</span> <span>this</span><span>.</span>exact
      <span>?</span> classes<span>[</span>exactActiveClass<span>]</span>
      <span>:</span> <span>isIncludedRoute</span><span>(</span>current<span>,</span> compareTarget<span>)</span>

    <span>const</span> <span>handler</span> <span>=</span> <span>e</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span><span>guardEvent</span><span>(</span>e<span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>replace<span>)</span> <span>{</span>
          router<span>.</span><span>replace</span><span>(</span>location<span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          router<span>.</span><span>push</span><span>(</span>location<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>const</span> on <span>=</span> <span>{</span> <span>click</span><span>:</span> guardEvent <span>}</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span><span>this</span><span>.</span>event<span>)</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>event<span>.</span><span>forEach</span><span>(</span><span>e</span> <span>=></span> <span>{</span> on<span>[</span>e<span>]</span> <span>=</span> handler <span>}</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      on<span>[</span><span>this</span><span>.</span>event<span>]</span> <span>=</span> handler
    <span>}</span>

    <span>const</span> <span>data</span><span>:</span> any <span>=</span> <span>{</span>
      <span>class</span><span>:</span> classes
    <span>}</span>

    <span>if</span> <span>(</span><span>this</span><span>.</span>tag <span>===</span> <span>'a'</span><span>)</span> <span>{</span>
      data<span>.</span>on <span>=</span> on
      data<span>.</span>attrs <span>=</span> <span>{</span> href <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> a <span>=</span> <span>findAnchor</span><span>(</span><span>this</span><span>.</span>$slots<span>.</span>default<span>)</span>
      <span>if</span> <span>(</span>a<span>)</span> <span>{</span>
        a<span>.</span>isStatic <span>=</span> <span>false</span>
        <span>const</span> extend <span>=</span> _Vue<span>.</span>util<span>.</span>extend
        <span>const</span> aData <span>=</span> a<span>.</span>data <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> a<span>.</span>data<span>)</span>
        aData<span>.</span>on <span>=</span> on
        <span>const</span> aAttrs <span>=</span> a<span>.</span>data<span>.</span>attrs <span>=</span> <span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> a<span>.</span>data<span>.</span>attrs<span>)</span>
        aAttrs<span>.</span>href <span>=</span> href
      <span>}</span> <span>else</span> <span>{</span>
        data<span>.</span>on <span>=</span> on
      <span>}</span>
    <span>}</span>

    <span>return</span> <span>h</span><span>(</span><span>this</span><span>.</span>tag<span>,</span> data<span>,</span> <span>this</span><span>.</span>$slots<span>.</span>default<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>&lt;router-link&gt;</code> 标签的渲染也是基于 <code>render</code> 函数，它首先做了路由解析：</p>
<div><pre><code><span>const</span> router <span>=</span> <span>this</span><span>.</span>$router
<span>const</span> current <span>=</span> <span>this</span><span>.</span>$route
<span>const</span> <span>{</span> location<span>,</span> route<span>,</span> href <span>}</span> <span>=</span> router<span>.</span><span>resolve</span><span>(</span><span>this</span><span>.</span>to<span>,</span> current<span>,</span> <span>this</span><span>.</span>append<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>router.resolve</code> 是 <code>VueRouter</code> 的实例方法，它的定义在 <code>src/index.js</code> 中：</p>
<div><pre><code><span>resolve</span> <span>(</span>
  <span>to</span><span>:</span> RawLocation<span>,</span>
  current<span>?</span><span>:</span> Route<span>,</span>
  append<span>?</span><span>:</span> boolean
<span>)</span><span>:</span> <span>{</span>
  <span>location</span><span>:</span> Location<span>,</span>
  <span>route</span><span>:</span> Route<span>,</span>
  <span>href</span><span>:</span> string<span>,</span>
  <span>normalizedTo</span><span>:</span> Location<span>,</span>
  <span>resolved</span><span>:</span> Route
<span>}</span> <span>{</span>
  <span>const</span> location <span>=</span> <span>normalizeLocation</span><span>(</span>
    to<span>,</span>
    current <span>||</span> <span>this</span><span>.</span>history<span>.</span>current<span>,</span>
    append<span>,</span>
    <span>this</span>
  <span>)</span>
  <span>const</span> route <span>=</span> <span>this</span><span>.</span><span>match</span><span>(</span>location<span>,</span> current<span>)</span>
  <span>const</span> fullPath <span>=</span> route<span>.</span>redirectedFrom <span>||</span> route<span>.</span>fullPath
  <span>const</span> base <span>=</span> <span>this</span><span>.</span>history<span>.</span>base
  <span>const</span> href <span>=</span> <span>createHref</span><span>(</span>base<span>,</span> fullPath<span>,</span> <span>this</span><span>.</span>mode<span>)</span>
  <span>return</span> <span>{</span>
    location<span>,</span>
    route<span>,</span>
    href<span>,</span>
    <span>normalizedTo</span><span>:</span> location<span>,</span>
    <span>resolved</span><span>:</span> route
  <span>}</span>
<span>}</span>

<span>function</span> <span>createHref</span> <span>(</span><span><span>base</span><span>:</span> string<span>,</span> <span>fullPath</span><span>:</span> string<span>,</span> mode</span><span>)</span> <span>{</span>
  <span>var</span> path <span>=</span> mode <span>===</span> <span>'hash'</span> <span>?</span> <span>'#'</span> <span>+</span> fullPath <span>:</span> fullPath
  <span>return</span> base <span>?</span> <span>cleanPath</span><span>(</span>base <span>+</span> <span>'/'</span> <span>+</span> path<span>)</span> <span>:</span> path
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它先规范生成目标 <code>location</code>，再根据 <code>location</code> 和 <code>match</code> 通过 <code>this.match</code> 方法计算生成目标路径 <code>route</code>，然后再根据 <code>base</code>、<code>fullPath</code> 和 <code>this.mode</code> 通过 <code>createHref</code> 方法计算出最终跳转的 <code>href</code>。</p>
<p>解析完 <code>router</code> 获得目标 <code>location</code>、<code>route</code>、<code>href</code> 后，接下来对 <code>exactActiveClass</code> 和 <code>activeClass</code> 做处理，当配置 <code>exact</code> 为 true 的时候，只有当目标路径和当前路径完全匹配的时候，会添加 <code>exactActiveClass</code>；而当目标路径包含当前路径的时候，会添加 <code>activeClass</code>。</p>
<p>接着创建了一个守卫函数 ：</p>
<div><pre><code><span>const</span> <span>handler</span> <span>=</span> <span>e</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>guardEvent</span><span>(</span>e<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>replace<span>)</span> <span>{</span>
      router<span>.</span><span>replace</span><span>(</span>location<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      router<span>.</span><span>push</span><span>(</span>location<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>guardEvent</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>e<span>.</span>metaKey <span>||</span> e<span>.</span>altKey <span>||</span> e<span>.</span>ctrlKey <span>||</span> e<span>.</span>shiftKey<span>)</span> <span>return</span>
  <span>if</span> <span>(</span>e<span>.</span>defaultPrevented<span>)</span> <span>return</span>
  <span>if</span> <span>(</span>e<span>.</span>button <span>!==</span> <span>undefined</span> <span>&amp;&amp;</span> e<span>.</span>button <span>!==</span> <span>0</span><span>)</span> <span>return</span> 
  <span>if</span> <span>(</span>e<span>.</span>currentTarget <span>&amp;&amp;</span> e<span>.</span>currentTarget<span>.</span>getAttribute<span>)</span> <span>{</span>
    <span>const</span> target <span>=</span> e<span>.</span>currentTarget<span>.</span><span>getAttribute</span><span>(</span><span>'target'</span><span>)</span>
    <span>if</span> <span>(</span><span><span>/</span><span>\b_blank\b</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span>target<span>)</span><span>)</span> <span>return</span>
  <span>}</span>
  <span>if</span> <span>(</span>e<span>.</span>preventDefault<span>)</span> <span>{</span>
    e<span>.</span><span>preventDefault</span><span>(</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span>

<span>const</span> on <span>=</span> <span>{</span> <span>click</span><span>:</span> guardEvent <span>}</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span><span>this</span><span>.</span>event<span>)</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>event<span>.</span><span>forEach</span><span>(</span><span>e</span> <span>=></span> <span>{</span> on<span>[</span>e<span>]</span> <span>=</span> handler <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    on<span>[</span><span>this</span><span>.</span>event<span>]</span> <span>=</span> handler
  <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最终会监听点击事件或者其它可以通过 <code>prop</code> 传入的事件类型，执行 <code>hanlder</code> 函数，最终执行 <code>router.push</code> 或者 <code>router.replace</code> 函数，它们的定义在 <code>src/index.js</code> 中：</p>
<div><pre><code><span>push</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>history<span>.</span><span>push</span><span>(</span>location<span>,</span> onComplete<span>,</span> onAbort<span>)</span>
<span>}</span>

<span>replace</span> <span>(</span><span><span>location</span><span>:</span> RawLocation<span>,</span> onComplete<span>?</span><span>:</span> Function<span>,</span> onAbort<span>?</span><span>:</span> Function</span><span>)</span> <span>{</span>
 <span>this</span><span>.</span>history<span>.</span><span>replace</span><span>(</span>location<span>,</span> onComplete<span>,</span> onAbort<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上就是执行了 <code>history</code> 的 <code>push</code> 和 <code>replace</code> 方法做路由跳转。</p>
<p>最后判断当前 <code>tag</code> 是否是 <code>&lt;a&gt;</code> 标签，<code>&lt;router-link&gt;</code> 默认会渲染成 <code>&lt;a&gt;</code> 标签，当然我们也可以修改 <code>tag</code> 的 <code>prop</code> 渲染成其他节点，这种情况下会尝试找它子元素的 <code>&lt;a&gt;</code> 标签，如果有则把事件绑定到 <code>&lt;a&gt;</code> 标签上并添加 <code>href</code> 属性，否则绑定到外层元素本身。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此我们把路由的 <code>transitionTo</code> 的主体过程分析完毕了，其他一些分支比如重定向、别名、滚动行为等同学们可以自行再去分析。</p>
<p>路径变化是路由中最重要的功能，我们要记住以下内容：路由始终会维护当前的线路，路由切换的时候会把当前线路切换到目标线路，切换过程中会执行一系列的导航守卫钩子函数，会更改 url，同样也会渲染对应的组件，切换完毕后会把目标线路更新替换当前线路，这样就会作为下一次的路径切换的依据。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">API</title>
    <id>https://0808200.xyz/vue2/vuex/api.html</id>
    <link href="https://0808200.xyz/vue2/vuex/api.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="api" tabindex="-1"> API</h1>
<p>上一节我们对 Vuex 的初始化过程有了深入的分析，在我们构造好这个 <code>store</code> 后，需要提供一些 API 对这个 <code>store</code> 做存取的操作，那么这一节我们就从源码的角度对这些 API 做分析。</p>
<h2 id="数据获取" tabindex="-1"> 数据获取</h2>
<p>Vuex 最终存储的数据是在 <code>state</code> 上的，我们之前分析过在 <code>store.state</code> 存储的是 <code>root state</code>，那么对于模块上的 <code>state</code>，假设我们有 2 个嵌套的 <code>modules</code>，它们的 <code>key</code> 分别为 <code>a</code> 和 <code>b</code>，我们可以通过 <code>store.state.a.b.xxx</code> 的方式去获取。它的实现是在发生在 <code>installModule</code> 的时候：</p>
<div><pre><code><span>function</span> <span>installModule</span> <span>(</span><span>store<span>,</span> rootState<span>,</span> path<span>,</span> module<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>const</span> isRoot <span>=</span> <span>!</span>path<span>.</span>length
  
  <span>// ...</span>
  <span>// set state</span>
  <span>if</span> <span>(</span><span>!</span>isRoot <span>&amp;&amp;</span> <span>!</span>hot<span>)</span> <span>{</span>
    <span>const</span> parentState <span>=</span> <span>getNestedState</span><span>(</span>rootState<span>,</span> path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
    <span>const</span> moduleName <span>=</span> path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span>
    store<span>.</span><span>_withCommit</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      Vue<span>.</span><span>set</span><span>(</span>parentState<span>,</span> moduleName<span>,</span> module<span>.</span>state<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在递归执行 <code>installModule</code> 的过程中，就完成了整个 <code>state</code> 的建设，这样我们就可以通过 <code>module</code> 名的 <code>path</code> 去访问到一个深层 <code>module</code> 的 <code>state</code>。</p>
<p>有些时候，我们获取的数据不仅仅是一个 <code>state</code>，而是由多个 <code>state</code> 计算而来，Vuex 提供了 <code>getters</code>，允许我们定义一个 <code>getter</code> 函数，如下：</p>
<div><pre><code><span>getters</span><span>:</span> <span>{</span>
  <span>total</span> <span>(</span><span>state<span>,</span> getters<span>,</span> localState<span>,</span> localGetters</span><span>)</span> <span>{</span>
    <span>// 可访问全局 state 和 getters，以及如果是在 modules 下面，可以访问到局部 state 和 局部 getters</span>
    <span>return</span> state<span>.</span>a <span>+</span> state<span>.</span>b
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们在 <code>installModule</code> 的过程中，递归执行了所有 <code>getters</code> 定义的注册，在之后的 <code>resetStoreVM</code> 过程中，执行了 <code>store.getters</code> 的初始化工作：</p>
<div><pre><code><span>function</span> <span>installModule</span> <span>(</span><span>store<span>,</span> rootState<span>,</span> path<span>,</span> module<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> namespace <span>=</span> store<span>.</span>_modules<span>.</span><span>getNamespace</span><span>(</span>path<span>)</span>
  <span>// ...</span>
  <span>const</span> local <span>=</span> module<span>.</span>context <span>=</span> <span>makeLocalContext</span><span>(</span>store<span>,</span> namespace<span>,</span> path<span>)</span>

  <span>// ...</span>

  module<span>.</span><span>forEachGetter</span><span>(</span><span>(</span><span>getter<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> namespacedType <span>=</span> namespace <span>+</span> key
    <span>registerGetter</span><span>(</span>store<span>,</span> namespacedType<span>,</span> getter<span>,</span> local<span>)</span>
  <span>}</span><span>)</span>

  <span>// ...</span>
<span>}</span>

<span>function</span> <span>registerGetter</span> <span>(</span><span>store<span>,</span> type<span>,</span> rawGetter<span>,</span> local</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>store<span>.</span>_wrappedGetters<span>[</span>type<span>]</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] duplicate getter key: </span><span><span>${</span>type<span>}</span></span><span>`</span></span><span>)</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>
  store<span>.</span>_wrappedGetters<span>[</span>type<span>]</span> <span>=</span> <span>function</span> <span>wrappedGetter</span> <span>(</span><span>store</span><span>)</span> <span>{</span>
    <span>return</span> <span>rawGetter</span><span>(</span>
      local<span>.</span>state<span>,</span> <span>// local state</span>
      local<span>.</span>getters<span>,</span> <span>// local getters</span>
      store<span>.</span>state<span>,</span> <span>// root state</span>
      store<span>.</span>getters <span>// root getters</span>
    <span>)</span>
  <span>}</span>
<span>}</span>


<span>function</span> <span>resetStoreVM</span> <span>(</span><span>store<span>,</span> state<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>// bind store public getters</span>
  store<span>.</span>getters <span>=</span> <span>{</span><span>}</span>
  <span>const</span> wrappedGetters <span>=</span> store<span>.</span>_wrappedGetters
  <span>const</span> computed <span>=</span> <span>{</span><span>}</span>
  <span>forEachValue</span><span>(</span>wrappedGetters<span>,</span> <span>(</span><span>fn<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>// use computed to leverage its lazy-caching mechanism</span>
    computed<span>[</span>key<span>]</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>fn</span><span>(</span>store<span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>store<span>.</span>getters<span>,</span> key<span>,</span> <span>{</span>
      <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> store<span>.</span>_vm<span>[</span>key<span>]</span><span>,</span>
      <span>enumerable</span><span>:</span> <span>true</span> <span>// for local getters</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>

  <span>// use a Vue instance to store the state tree</span>
  <span>// suppress warnings just in case the user has added</span>
  <span>// some funky global mixins</span>
  <span>// ...</span>
  store<span>.</span>_vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    <span>data</span><span>:</span> <span>{</span>
      <span>$$state</span><span>:</span> state
    <span>}</span><span>,</span>
    computed
  <span>}</span><span>)</span>
  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在 <code>installModule</code> 的过程中，为建立了每个模块的上下文环境，
因此当我们访问 <code>store.getters.xxx</code> 的时候，实际上就是执行了 <code>rawGetter(local.state,...)</code>，<code>rawGetter</code> 就是我们定义的 <code>getter</code> 方法，这也就是为什么我们的 <code>getter</code> 函数支持这四个参数，并且除了全局的 <code>state</code> 和 <code>getter</code> 外，我们还可以访问到当前 <code>module</code> 下的 <code>state</code> 和 <code>getter</code>。</p>
<h2 id="数据存储" tabindex="-1"> 数据存储</h2>
<p>Vuex 对数据存储的存储本质上就是对 <code>state</code> 做修改，并且只允许我们通过提交 <code>mutaion</code> 的形式去修改 <code>state</code>，<code>mutation</code> 是一个函数，如下：</p>
<div><pre><code><span>mutations</span><span>:</span> <span>{</span>
  <span>increment</span> <span>(</span><span>state</span><span>)</span> <span>{</span>
    state<span>.</span>count<span>++</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><code>mutations</code> 的初始化也是在 <code>installModule</code> 的时候：</p>
<div><pre><code><span>function</span> <span>installModule</span> <span>(</span><span>store<span>,</span> rootState<span>,</span> path<span>,</span> module<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> namespace <span>=</span> store<span>.</span>_modules<span>.</span><span>getNamespace</span><span>(</span>path<span>)</span>

  <span>// ...</span>
  <span>const</span> local <span>=</span> module<span>.</span>context <span>=</span> <span>makeLocalContext</span><span>(</span>store<span>,</span> namespace<span>,</span> path<span>)</span>

  module<span>.</span><span>forEachMutation</span><span>(</span><span>(</span><span>mutation<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> namespacedType <span>=</span> namespace <span>+</span> key
    <span>registerMutation</span><span>(</span>store<span>,</span> namespacedType<span>,</span> mutation<span>,</span> local<span>)</span>
  <span>}</span><span>)</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>registerMutation</span> <span>(</span><span>store<span>,</span> type<span>,</span> handler<span>,</span> local</span><span>)</span> <span>{</span>
  <span>const</span> entry <span>=</span> store<span>.</span>_mutations<span>[</span>type<span>]</span> <span>||</span> <span>(</span>store<span>.</span>_mutations<span>[</span>type<span>]</span> <span>=</span> <span>[</span><span>]</span><span>)</span>
  entry<span>.</span><span>push</span><span>(</span><span>function</span> <span>wrappedMutationHandler</span> <span>(</span><span>payload</span><span>)</span> <span>{</span>
    <span>handler</span><span>.</span><span>call</span><span>(</span>store<span>,</span> local<span>.</span>state<span>,</span> payload<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>store</code> 提供了<code>commit</code> 方法让我们提交一个 <code>mutation</code>：</p>
<div><pre><code><span>commit</span> <span>(</span><span>_type<span>,</span> _payload<span>,</span> _options</span><span>)</span> <span>{</span>
  <span>// check object-style commit</span>
  <span>const</span> <span>{</span>
    type<span>,</span>
    payload<span>,</span>
    options
  <span>}</span> <span>=</span> <span>unifyObjectStyle</span><span>(</span>_type<span>,</span> _payload<span>,</span> _options<span>)</span>

  <span>const</span> mutation <span>=</span> <span>{</span> type<span>,</span> payload <span>}</span>
  <span>const</span> entry <span>=</span> <span>this</span><span>.</span>_mutations<span>[</span>type<span>]</span>
  <span>if</span> <span>(</span><span>!</span>entry<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] unknown mutation type: </span><span><span>${</span>type<span>}</span></span><span>`</span></span><span>)</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>
  <span>this</span><span>.</span><span>_withCommit</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    entry<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>commitIterator</span> <span>(</span><span>handler</span><span>)</span> <span>{</span>
      <span>handler</span><span>(</span>payload<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
  <span>this</span><span>.</span>_subscribers<span>.</span><span>forEach</span><span>(</span><span>sub</span> <span>=></span> <span>sub</span><span>(</span>mutation<span>,</span> <span>this</span><span>.</span>state<span>)</span><span>)</span>

  <span>if</span> <span>(</span>
    process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    options <span>&amp;&amp;</span> options<span>.</span>silent
  <span>)</span> <span>{</span>
    console<span>.</span><span>warn</span><span>(</span>
      <span><span>`</span><span>[vuex] mutation type: </span><span><span>${</span>type<span>}</span></span><span>. Silent option has been removed. </span><span>`</span></span> <span>+</span>
      <span>'Use the filter functionality in the vue-devtools'</span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里传入的 <code>_type</code> 就是 <code>mutation</code> 的 <code>type</code>，我们可以从 <code>store._mutations</code> 找到对应的函数数组，遍历它们执行获取到每个 <code>handler</code> 然后执行，实际上就是执行了 <code>wrappedMutationHandler(playload)</code>，接着会执行我们定义的 <code>mutation</code> 函数，并传入当前模块的 <code>state</code>，所以我们的 <code>mutation</code> 函数也就是对当前模块的 <code>state</code> 做修改。</p>
<p>需要注意的是， <code>mutation</code> 必须是同步函数，但是我们在开发实际项目中，经常会遇到要先去发送一个请求，然后根据请求的结果去修改 <code>state</code>，那么单纯只通过 <code>mutation</code> 是无法完成需求，因此 Vuex 又给我们设计了一个 <code>action</code> 的概念。</p>
<p><code>action</code> 类似于 <code>mutation</code>，不同在于 <code>action</code> 提交的是 <code>mutation</code>，而不是直接操作 <code>state</code>，并且它可以包含任意异步操作。例如：</p>
<div><pre><code><span>mutations</span><span>:</span> <span>{</span>
  <span>increment</span> <span>(</span><span>state</span><span>)</span> <span>{</span>
    state<span>.</span>count<span>++</span>
  <span>}</span>
<span>}</span><span>,</span>
<span>actions</span><span>:</span> <span>{</span>
  <span>increment</span> <span>(</span><span>context</span><span>)</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      context<span>.</span><span>commit</span><span>(</span><span>'increment'</span><span>)</span>
    <span>}</span><span>,</span> <span>0</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>actions</code> 的初始化也是在 <code>installModule</code> 的时候：</p>
<div><pre><code><span>function</span> <span>installModule</span> <span>(</span><span>store<span>,</span> rootState<span>,</span> path<span>,</span> module<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> namespace <span>=</span> store<span>.</span>_modules<span>.</span><span>getNamespace</span><span>(</span>path<span>)</span>

  <span>// ...</span>
  <span>const</span> local <span>=</span> module<span>.</span>context <span>=</span> <span>makeLocalContext</span><span>(</span>store<span>,</span> namespace<span>,</span> path<span>)</span>

  module<span>.</span><span>forEachAction</span><span>(</span><span>(</span><span>action<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> type <span>=</span> action<span>.</span>root <span>?</span> key <span>:</span> namespace <span>+</span> key
    <span>const</span> handler <span>=</span> action<span>.</span>handler <span>||</span> action
    <span>registerAction</span><span>(</span>store<span>,</span> type<span>,</span> handler<span>,</span> local<span>)</span>
<span>}</span>  <span>)</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>registerAction</span> <span>(</span><span>store<span>,</span> type<span>,</span> handler<span>,</span> local</span><span>)</span> <span>{</span>
  <span>const</span> entry <span>=</span> store<span>.</span>_actions<span>[</span>type<span>]</span> <span>||</span> <span>(</span>store<span>.</span>_actions<span>[</span>type<span>]</span> <span>=</span> <span>[</span><span>]</span><span>)</span>
  entry<span>.</span><span>push</span><span>(</span><span>function</span> <span>wrappedActionHandler</span> <span>(</span><span>payload<span>,</span> cb</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>handler</span><span>.</span><span>call</span><span>(</span>store<span>,</span> <span>{</span>
      <span>dispatch</span><span>:</span> local<span>.</span>dispatch<span>,</span>
      <span>commit</span><span>:</span> local<span>.</span>commit<span>,</span>
      <span>getters</span><span>:</span> local<span>.</span>getters<span>,</span>
      <span>state</span><span>:</span> local<span>.</span>state<span>,</span>
      <span>rootGetters</span><span>:</span> store<span>.</span>getters<span>,</span>
      <span>rootState</span><span>:</span> store<span>.</span>state
    <span>}</span><span>,</span> payload<span>,</span> cb<span>)</span>
    <span>if</span> <span>(</span><span>!</span><span>isPromise</span><span>(</span>res<span>)</span><span>)</span> <span>{</span>
      res <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span>res<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>store<span>.</span>_devtoolHook<span>)</span> <span>{</span>
      <span>return</span> res<span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
        store<span>.</span>_devtoolHook<span>.</span><span>emit</span><span>(</span><span>'vuex:error'</span><span>,</span> err<span>)</span>
        <span>throw</span> err
      <span>}</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> res
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>store</code> 提供了<code>dispatch</code> 方法让我们提交一个 <code>action</code>：</p>
<div><pre><code><span>dispatch</span> <span>(</span><span>_type<span>,</span> _payload</span><span>)</span> <span>{</span>
  <span>// check object-style dispatch</span>
  <span>const</span> <span>{</span>
    type<span>,</span>
    payload
  <span>}</span> <span>=</span> <span>unifyObjectStyle</span><span>(</span>_type<span>,</span> _payload<span>)</span>

  <span>const</span> action <span>=</span> <span>{</span> type<span>,</span> payload <span>}</span>
  <span>const</span> entry <span>=</span> <span>this</span><span>.</span>_actions<span>[</span>type<span>]</span>
  <span>if</span> <span>(</span><span>!</span>entry<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] unknown action type: </span><span><span>${</span>type<span>}</span></span><span>`</span></span><span>)</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>

  <span>this</span><span>.</span>_actionSubscribers<span>.</span><span>forEach</span><span>(</span><span>sub</span> <span>=></span> <span>sub</span><span>(</span>action<span>,</span> <span>this</span><span>.</span>state<span>)</span><span>)</span>

  <span>return</span> entry<span>.</span>length <span>></span> <span>1</span>
    <span>?</span> Promise<span>.</span><span>all</span><span>(</span>entry<span>.</span><span>map</span><span>(</span><span>handler</span> <span>=></span> <span>handler</span><span>(</span>payload<span>)</span><span>)</span><span>)</span>
    <span>:</span> entry<span>[</span><span>0</span><span>]</span><span>(</span>payload<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里传入的 <code>_type</code> 就是 <code>action</code> 的 <code>type</code>，我们可以从 <code>store._actions</code> 找到对应的函数数组，遍历它们执行获取到每个 <code>handler</code> 然后执行，实际上就是执行了 <code>wrappedActionHandler(payload)</code>，接着会执行我们定义的 <code>action</code> 函数，并传入一个对象，包含了当前模块下的 <code>dispatch</code>、<code>commit</code>、<code>getters</code>、<code>state</code>，以及全局的 <code>rootState</code> 和 <code>rootGetters</code>，所以我们定义的 <code>action</code> 函数能拿到当前模块下的 <code>commit</code> 方法。</p>
<p>因此 <code>action</code> 比我们自己写一个函数执行异步操作然后提交 <code>muataion</code> 的好处是在于它可以在参数中获取到当前模块的一些方法和状态，Vuex 帮我们做好了这些。</p>
<h2 id="语法糖" tabindex="-1"> 语法糖</h2>
<p>我们知道 <code>store</code> 是 <code>Store</code> 对象的一个实例，它是一个原生的 Javascript 对象，我们可以在任意地方使用它们。但大部分的使用场景还是在组件中使用，那么我们之前介绍过，在 Vuex 安装阶段，它会往每一个组件实例上混入 <code>beforeCreate</code> 钩子函数，然后往组件实例上添加一个 <code>$store</code> 的实例，它指向的就是我们实例化的 <code>store</code>，因此我们可以在组件中访问到 <code>store</code> 的任何属性和方法。</p>
<p>比如我们在组件中访问 <code>state</code>：</p>
<div><pre><code><span>const</span> Counter <span>=</span> <span>{</span>
  <span>template</span><span>:</span> <span><span>`</span><span>&lt;div>{{ count }}&lt;/div></span><span>`</span></span><span>,</span>
  <span>computed</span><span>:</span> <span>{</span>
    <span>count</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>this</span><span>.</span>$store<span>.</span>state<span>.</span>count
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。同样这些问题也在存于 <code>getter</code>、<code>mutation</code> 和 <code>action</code>。</p>
<p>为了解决这个问题，Vuex 提供了一系列 <code>mapXXX</code> 辅助函数帮助我们实现在组件中可以很方便的注入 <code>store</code> 的属性和方法。</p>
<h3 id="mapstate" tabindex="-1"> <code>mapState</code></h3>
<p>我们先来看一下 <code>mapState</code> 的用法：</p>
<div><pre><code><span>// 在单独构建的版本中辅助函数为 Vuex.mapState</span>
<span>import</span> <span>{</span> mapState <span>}</span> <span>from</span> <span>'vuex'</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>// ...</span>
  <span>computed</span><span>:</span> <span>mapState</span><span>(</span><span>{</span>
    <span>// 箭头函数可使代码更简练</span>
    <span>count</span><span>:</span> <span>state</span> <span>=></span> state<span>.</span>count<span>,</span>

    <span>// 传字符串参数 'count' 等同于 `state => state.count`</span>
    <span>countAlias</span><span>:</span> <span>'count'</span><span>,</span>

    <span>// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>
    <span>countPlusLocalState</span> <span>(</span><span>state</span><span>)</span> <span>{</span>
      <span>return</span> state<span>.</span>count <span>+</span> <span>this</span><span>.</span>localCount
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再来看一下 <code>mapState</code> 方法的定义，在 <code>src/helpers.js</code> 中：</p>
<div><pre><code><span>export</span> <span>const</span> mapState <span>=</span> <span>normalizeNamespace</span><span>(</span><span>(</span><span>namespace<span>,</span> states</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> res <span>=</span> <span>{</span><span>}</span>
  <span>normalizeMap</span><span>(</span>states<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>{</span> key<span>,</span> val <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    res<span>[</span>key<span>]</span> <span>=</span> <span>function</span> <span>mappedState</span> <span>(</span><span>)</span> <span>{</span>
      <span>let</span> state <span>=</span> <span>this</span><span>.</span>$store<span>.</span>state
      <span>let</span> getters <span>=</span> <span>this</span><span>.</span>$store<span>.</span>getters
      <span>if</span> <span>(</span>namespace<span>)</span> <span>{</span>
        <span>const</span> module <span>=</span> <span>getModuleByNamespace</span><span>(</span><span>this</span><span>.</span>$store<span>,</span> <span>'mapState'</span><span>,</span> namespace<span>)</span>
        <span>if</span> <span>(</span><span>!</span>module<span>)</span> <span>{</span>
          <span>return</span>
        <span>}</span>
        state <span>=</span> module<span>.</span>context<span>.</span>state
        getters <span>=</span> module<span>.</span>context<span>.</span>getters
      <span>}</span>
      <span>return</span> <span>typeof</span> val <span>===</span> <span>'function'</span>
        <span>?</span> <span>val</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> state<span>,</span> getters<span>)</span>
        <span>:</span> state<span>[</span>val<span>]</span>
    <span>}</span>
    <span>// mark vuex getter for devtools</span>
    res<span>[</span>key<span>]</span><span>.</span>vuex <span>=</span> <span>true</span>
  <span>}</span><span>)</span>
  <span>return</span> res
<span>}</span><span>)</span>

<span>function</span> <span>normalizeNamespace</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span><span>namespace<span>,</span> map</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>typeof</span> namespace <span>!==</span> <span>'string'</span><span>)</span> <span>{</span>
      map <span>=</span> namespace
      namespace <span>=</span> <span>''</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>namespace<span>.</span><span>charAt</span><span>(</span>namespace<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>!==</span> <span>'/'</span><span>)</span> <span>{</span>
      namespace <span>+=</span> <span>'/'</span>
    <span>}</span>
    <span>return</span> <span>fn</span><span>(</span>namespace<span>,</span> map<span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>normalizeMap</span> <span>(</span><span>map</span><span>)</span> <span>{</span>
  <span>return</span> Array<span>.</span><span>isArray</span><span>(</span>map<span>)</span>
    <span>?</span> map<span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> <span>(</span><span>{</span> key<span>,</span> <span>val</span><span>:</span> key <span>}</span><span>)</span><span>)</span>
    <span>:</span> Object<span>.</span><span>keys</span><span>(</span>map<span>)</span><span>.</span><span>map</span><span>(</span><span>key</span> <span>=></span> <span>(</span><span>{</span> key<span>,</span> <span>val</span><span>:</span> map<span>[</span>key<span>]</span> <span>}</span><span>)</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先 <code>mapState</code> 是通过执行 <code>normalizeNamespace</code> 返回的函数，它接收 2 个参数，其中 <code>namespace</code> 表示命名空间，<code>map</code> 表示具体的对象，<code>namespace</code> 可不传，稍后我们来介绍 <code>namespace</code> 的作用。</p>
<p>当执行 <code>mapState(map)</code> 函数的时候，实际上就是执行 <code>normalizeNamespace</code> 包裹的函数，然后把 <code>map</code> 作为参数 <code>states</code> 传入。</p>
<p><code>mapState</code> 最终是要构造一个对象，每个对象的元素都是一个方法，因为这个对象是要扩展到组件的 <code>computed</code> 计算属性中的。函数首先执行 <code>normalizeMap</code> 方法，把这个 <code>states</code> 变成一个数组，数组的每个元素都是 <code>{key, val}</code> 的形式。接着再遍历这个数组，以 <code>key</code> 作为对象的 <code>key</code>，值为一个 <code>mappedState</code> 的函数，在这个函数的内部，获取到 <code>$store.getters</code> 和 <code>$store.state</code>，然后再判断数组的 <code>val</code> 如果是一个函数，执行该函数，传入 <code>state</code> 和 <code>getters</code>，否则直接访问 <code>state[val]</code>。</p>
<p>比起一个个手动声明计算属性，<code>mapState</code> 确实要方便许多，下面我们来看一下 <code>namespace</code> 的作用。</p>
<p>当我们想访问一个子模块的 <code>state</code> 的时候，我们可能需要这样访问：</p>
<div><pre><code><span>computed</span><span>:</span> <span>{</span>
  <span>mapState</span><span>(</span><span>{</span>
    <span>a</span><span>:</span> <span>state</span> <span>=></span> state<span>.</span>some<span>.</span>nested<span>.</span>module<span>.</span>a<span>,</span>
    <span>b</span><span>:</span> <span>state</span> <span>=></span> state<span>.</span>some<span>.</span>nested<span>.</span>module<span>.</span>b
  <span>}</span><span>)</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样从写法上就很不友好，<code>mapState</code> 支持传入 <code>namespace</code>， 因此我们可以这么写：</p>
<div><pre><code><span>computed</span><span>:</span> <span>{</span>
  <span>mapState</span><span>(</span><span>'some/nested/module'</span><span>,</span> <span>{</span>
    <span>a</span><span>:</span> <span>state</span> <span>=></span> state<span>.</span>a<span>,</span>
    <span>b</span><span>:</span> <span>state</span> <span>=></span> state<span>.</span>b
  <span>}</span><span>)</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样看起来就清爽许多。在 <code>mapState</code> 的实现中，如果有 <code>namespace</code>，则尝试去通过 <code>getModuleByNamespace(this.$store, 'mapState', namespace)</code> 对应的 <code>module</code>，然后把 <code>state</code> 和 <code>getters</code> 修改为 <code>module</code> 对应的 <code>state</code> 和 <code>getters</code>。</p>
<div><pre><code><span>function</span> <span>getModuleByNamespace</span> <span>(</span><span>store<span>,</span> helper<span>,</span> namespace</span><span>)</span> <span>{</span>
  <span>const</span> module <span>=</span> store<span>.</span>_modulesNamespaceMap<span>[</span>namespace<span>]</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>module<span>)</span> <span>{</span>
    console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] module namespace not found in </span><span><span>${</span>helper<span>}</span></span><span>(): </span><span><span>${</span>namespace<span>}</span></span><span>`</span></span><span>)</span>
  <span>}</span>
  <span>return</span> module
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们在 Vuex 初始化执行 <code>installModule</code> 的过程中，初始化了这个映射表：</p>
<div><pre><code><span>function</span> <span>installModule</span> <span>(</span><span>store<span>,</span> rootState<span>,</span> path<span>,</span> module<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> namespace <span>=</span> store<span>.</span>_modules<span>.</span><span>getNamespace</span><span>(</span>path<span>)</span>

  <span>// register in namespace map</span>
  <span>if</span> <span>(</span>module<span>.</span>namespaced<span>)</span> <span>{</span>
    store<span>.</span>_modulesNamespaceMap<span>[</span>namespace<span>]</span> <span>=</span> module
  <span>}</span>

  <span>// ...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="mapgetters" tabindex="-1"> <code>mapGetters</code></h3>
<p>我们先来看一下 <code>mapGetters</code> 的用法：</p>
<div><pre><code><span>import</span> <span>{</span> mapGetters <span>}</span> <span>from</span> <span>'vuex'</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>// ...</span>
  <span>computed</span><span>:</span> <span>{</span>
    <span>// 使用对象展开运算符将 getter 混入 computed 对象中</span>
    <span>mapGetters</span><span>(</span><span>[</span>
      <span>'doneTodosCount'</span><span>,</span>
      <span>'anotherGetter'</span><span>,</span>
      <span>// ...</span>
    <span>]</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>和 <code>mapState</code> 类似，<code>mapGetters</code> 是将 <code>store</code> 中的 <code>getter</code> 映射到局部计算属性，来看一下它的定义：</p>
<div><pre><code><span>export</span> <span>const</span> mapGetters <span>=</span> <span>normalizeNamespace</span><span>(</span><span>(</span><span>namespace<span>,</span> getters</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> res <span>=</span> <span>{</span><span>}</span>
  <span>normalizeMap</span><span>(</span>getters<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>{</span> key<span>,</span> val <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>// thie namespace has been mutate by normalizeNamespace</span>
    val <span>=</span> namespace <span>+</span> val
    res<span>[</span>key<span>]</span> <span>=</span> <span>function</span> <span>mappedGetter</span> <span>(</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>namespace <span>&amp;&amp;</span> <span>!</span><span>getModuleByNamespace</span><span>(</span><span>this</span><span>.</span>$store<span>,</span> <span>'mapGetters'</span><span>,</span> namespace<span>)</span><span>)</span> <span>{</span>
        <span>return</span>
      <span>}</span>
      <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span><span>(</span>val <span>in</span> <span>this</span><span>.</span>$store<span>.</span>getters<span>)</span><span>)</span> <span>{</span>
        console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] unknown getter: </span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span>
        <span>return</span>
      <span>}</span>
      <span>return</span> <span>this</span><span>.</span>$store<span>.</span>getters<span>[</span>val<span>]</span>
    <span>}</span>
    <span>// mark vuex getter for devtools</span>
    res<span>[</span>key<span>]</span><span>.</span>vuex <span>=</span> <span>true</span>
  <span>}</span><span>)</span>
  <span>return</span> res
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>mapGetters</code> 也同样支持 <code>namespace</code>，如果不写 <code>namespace</code> ，访问一个子 <code>module</code> 的属性需要写很长的 <code>key</code>，一旦我们使用了 <code>namespace</code>，就可以方便我们的书写，每个 <code>mappedGetter</code> 的实现实际上就是取 <code>this.$store.getters[val]</code>。</p>
<h3 id="mapmutations" tabindex="-1"> <code>mapMutations</code></h3>
<p>我们可以在组件中使用 <code>this.$store.commit('xxx')</code> 提交 <code>mutation</code>，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code> 的调用。</p>
<p>我们先来看一下 <code>mapMutations</code> 的用法：</p>
<div><pre><code><span>import</span> <span>{</span> mapMutations <span>}</span> <span>from</span> <span>'vuex'</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>// ...</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>...</span><span>mapMutations</span><span>(</span><span>[</span>
      <span>'increment'</span><span>,</span> <span>// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span>

      <span>// `mapMutations` 也支持载荷：</span>
      <span>'incrementBy'</span> <span>// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span>
    <span>]</span><span>)</span><span>,</span>
    <span>...</span><span>mapMutations</span><span>(</span><span>{</span>
      <span>add</span><span>:</span> <span>'increment'</span> <span>// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>mapMutations</code> 支持传入一个数组或者一个对象，目标都是组件中对应的 <code>methods</code> 映射为 <code>store.commit</code> 的调用。来看一下它的定义：</p>
<div><pre><code><span>export</span> <span>const</span> mapMutations <span>=</span> <span>normalizeNamespace</span><span>(</span><span>(</span><span>namespace<span>,</span> mutations</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> res <span>=</span> <span>{</span><span>}</span>
  <span>normalizeMap</span><span>(</span>mutations<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>{</span> key<span>,</span> val <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    res<span>[</span>key<span>]</span> <span>=</span> <span>function</span> <span>mappedMutation</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
      <span>// Get the commit method from store</span>
      <span>let</span> commit <span>=</span> <span>this</span><span>.</span>$store<span>.</span>commit
      <span>if</span> <span>(</span>namespace<span>)</span> <span>{</span>
        <span>const</span> module <span>=</span> <span>getModuleByNamespace</span><span>(</span><span>this</span><span>.</span>$store<span>,</span> <span>'mapMutations'</span><span>,</span> namespace<span>)</span>
        <span>if</span> <span>(</span><span>!</span>module<span>)</span> <span>{</span>
          <span>return</span>
        <span>}</span>
        commit <span>=</span> module<span>.</span>context<span>.</span>commit
      <span>}</span>
      <span>return</span> <span>typeof</span> val <span>===</span> <span>'function'</span>
        <span>?</span> <span>val</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>[</span>commit<span>]</span><span>.</span><span>concat</span><span>(</span>args<span>)</span><span>)</span>
        <span>:</span> <span>commit</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>.</span>$store<span>,</span> <span>[</span>val<span>]</span><span>.</span><span>concat</span><span>(</span>args<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>return</span> res
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到 <code>mappedMutation</code> 同样支持了 <code>namespace</code>，并且支持了传入额外的参数 <code>args</code>，作为提交 <code>mutation</code> 的 <code>payload</code>，最终就是执行了 <code>store.commit</code> 方法，并且这个 <code>commit</code> 会根据传入的 <code>namespace</code> 映射到对应 <code>module</code> 的 <code>commit</code> 上。</p>
<h3 id="mapactions" tabindex="-1"> <code>mapActions</code></h3>
<p>我们可以在组件中使用 <code>this.$store.dispatch('xxx')</code> 提交 <code>action</code>，或者使用 <code>mapActions</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.dispatch</code> 的调用。</p>
<p><code>mapActions</code> 在用法上和 <code>mapMutations</code> 几乎一样，实现也很类似：</p>
<div><pre><code><span>export</span> <span>const</span> mapActions <span>=</span> <span>normalizeNamespace</span><span>(</span><span>(</span><span>namespace<span>,</span> actions</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> res <span>=</span> <span>{</span><span>}</span>
  <span>normalizeMap</span><span>(</span>actions<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>{</span> key<span>,</span> val <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    res<span>[</span>key<span>]</span> <span>=</span> <span>function</span> <span>mappedAction</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
      <span>// get dispatch function from store</span>
      <span>let</span> dispatch <span>=</span> <span>this</span><span>.</span>$store<span>.</span>dispatch
      <span>if</span> <span>(</span>namespace<span>)</span> <span>{</span>
        <span>const</span> module <span>=</span> <span>getModuleByNamespace</span><span>(</span><span>this</span><span>.</span>$store<span>,</span> <span>'mapActions'</span><span>,</span> namespace<span>)</span>
        <span>if</span> <span>(</span><span>!</span>module<span>)</span> <span>{</span>
          <span>return</span>
        <span>}</span>
        dispatch <span>=</span> module<span>.</span>context<span>.</span>dispatch
      <span>}</span>
      <span>return</span> <span>typeof</span> val <span>===</span> <span>'function'</span>
        <span>?</span> <span>val</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>[</span>dispatch<span>]</span><span>.</span><span>concat</span><span>(</span>args<span>)</span><span>)</span>
        <span>:</span> <span>dispatch</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>.</span>$store<span>,</span> <span>[</span>val<span>]</span><span>.</span><span>concat</span><span>(</span>args<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>return</span> res
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>和 <code>mapMutations</code> 的实现几乎一样，不同的是把 <code>commit</code> 方法换成了 <code>dispatch</code>。</p>
<h2 id="动态更新模块" tabindex="-1"> 动态更新模块</h2>
<p>在 Vuex 初始化阶段我们构造了模块树，初始化了模块上各个部分。在有一些场景下，我们需要动态去注入一些新的模块，Vuex 提供了模块动态注册功能，在 <code>store</code> 上提供了一个 <code>registerModule</code> 的 API。</p>
<div><pre><code><span>registerModule</span> <span>(</span><span>path<span>,</span> rawModule<span>,</span> options <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> path <span>===</span> <span>'string'</span><span>)</span> path <span>=</span> <span>[</span>path<span>]</span>

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>assert</span><span>(</span>Array<span>.</span><span>isArray</span><span>(</span>path<span>)</span><span>,</span> <span><span>`</span><span>module path must be a string or an Array.</span><span>`</span></span><span>)</span>
    <span>assert</span><span>(</span>path<span>.</span>length <span>></span> <span>0</span><span>,</span> <span>'cannot register the root module by using registerModule.'</span><span>)</span>
  <span>}</span>

  <span>this</span><span>.</span>_modules<span>.</span><span>register</span><span>(</span>path<span>,</span> rawModule<span>)</span>
  <span>installModule</span><span>(</span><span>this</span><span>,</span> <span>this</span><span>.</span>state<span>,</span> path<span>,</span> <span>this</span><span>.</span>_modules<span>.</span><span>get</span><span>(</span>path<span>)</span><span>,</span> options<span>.</span>preserveState<span>)</span>
  <span>// reset store to update getters...</span>
  <span>resetStoreVM</span><span>(</span><span>this</span><span>,</span> <span>this</span><span>.</span>state<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>registerModule</code> 支持传入一个 <code>path</code> 模块路径 和 <code>rawModule</code> 模块定义，首先执行 <code>register</code> 方法扩展我们的模块树，接着执行 <code>installModule</code> 去安装模块，最后执行 <code>resetStoreVM</code> 重新实例化 <code>store._vm</code>，并销毁旧的 <code>store._vm</code>。</p>
<p>相对的，有动态注册模块的需求就有动态卸载模块的需求，Vuex 提供了模块动态卸载功能，在 <code>store</code> 上提供了一个 <code>unregisterModule</code> 的 API。</p>
<div><pre><code><span>unregisterModule</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> path <span>===</span> <span>'string'</span><span>)</span> path <span>=</span> <span>[</span>path<span>]</span>

  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    <span>assert</span><span>(</span>Array<span>.</span><span>isArray</span><span>(</span>path<span>)</span><span>,</span> <span><span>`</span><span>module path must be a string or an Array.</span><span>`</span></span><span>)</span>
  <span>}</span>

  <span>this</span><span>.</span>_modules<span>.</span><span>unregister</span><span>(</span>path<span>)</span>
  <span>this</span><span>.</span><span>_withCommit</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> parentState <span>=</span> <span>getNestedState</span><span>(</span><span>this</span><span>.</span>state<span>,</span> path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
    Vue<span>.</span><span>delete</span><span>(</span>parentState<span>,</span> path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>)</span>
  <span>}</span><span>)</span>
  <span>resetStore</span><span>(</span><span>this</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>unregisterModule</code> 支持传入一个 <code>path</code> 模块路径，首先执行 <code>unregister</code> 方法去修剪我们的模块树：</p>
<div><pre><code><span>unregister</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>const</span> parent <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span>path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
  <span>const</span> key <span>=</span> path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span>
  <span>if</span> <span>(</span><span>!</span>parent<span>.</span><span>getChild</span><span>(</span>key<span>)</span><span>.</span>runtime<span>)</span> <span>return</span>

  parent<span>.</span><span>removeChild</span><span>(</span>key<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，这里只会移除我们运行时动态创建的模块。</p>
<p>接着会删除 <code>state</code> 在该路径下的引用，最后执行 <code>resetStore</code> 方法：</p>
<div><pre><code><span>function</span> <span>resetStore</span> <span>(</span><span>store<span>,</span> hot</span><span>)</span> <span>{</span>
  store<span>.</span>_actions <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  store<span>.</span>_mutations <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  store<span>.</span>_wrappedGetters <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  store<span>.</span>_modulesNamespaceMap <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>const</span> state <span>=</span> store<span>.</span>state
  <span>// init all modules</span>
  <span>installModule</span><span>(</span>store<span>,</span> state<span>,</span> <span>[</span><span>]</span><span>,</span> store<span>.</span>_modules<span>.</span>root<span>,</span> <span>true</span><span>)</span>
  <span>// reset vm</span>
  <span>resetStoreVM</span><span>(</span>store<span>,</span> state<span>,</span> hot<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该方法就是把 <code>store</code> 下的对应存储的 <code>_actions</code>、<code>_mutations</code>、<code>_wrappedGetters</code> 和 <code>_modulesNamespaceMap</code> 都清空，然后重新执行 <code>installModule</code> 安装所有模块以及 <code>resetStoreVM</code> 重置 <code>store._vm</code>。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，Vuex 提供的一些常用 API 我们就分析完了，包括数据的存取、语法糖、模块的动态更新等。要理解 Vuex 提供这些 API 都是方便我们在对 <code>store</code> 做各种操作来完成各种能力，尤其是 <code>mapXXX</code> 的设计，让我们在使用 API 的时候更加方便，这也是我们今后在设计一些 JavaScript 库的时候，从 API 设计角度中应该学习的方向。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vuex</title>
    <id>https://0808200.xyz/vue2/vuex/</id>
    <link href="https://0808200.xyz/vue2/vuex/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vuex" tabindex="-1"> Vuex</h1>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h2 id="什么是-状态管理模式" tabindex="-1"> 什么是“状态管理模式”？</h2>
<p>让我们从一个简单的 Vue 计数应用开始：</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>// state</span>
  <span>data</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>count</span><span>:</span> <span>0</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>// view</span>
  <span>template</span><span>:</span> <span><span>`</span><span>
    &lt;div>{{ count }}&lt;/div>
  </span><span>`</span></span><span>,</span>
  <span>// actions</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>increment</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>count<span>++</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个状态自管理应用包含以下几个部分：</p>
<ul>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将 state 映射到视图；</li>
<li>actions，响应在 view 上的用户输入导致的状态变化。</li>
</ul>
<p>以下是一个表示“单向数据流”理念的极简示意：</p>
<img :src="$withBase('/assets/vuex.png')">
<p>但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<h2 id="vuex-核心思想" tabindex="-1"> Vuex 核心思想</h2>
<p>Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。有些同学可能会问，那我定义一个全局对象，再去上层封装了一些数据存取的接口不也可以么？</p>
<p>Vuex 和单纯的全局对象有以下两点不同：</p>
<ul>
<li>
<p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li>
<p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>
</li>
</ul>
<p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。</p>
<img :src="$withBase('/assets/vuex1.png')">
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vuex 初始化</title>
    <id>https://0808200.xyz/vue2/vuex/init.html</id>
    <link href="https://0808200.xyz/vue2/vuex/init.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vuex-初始化" tabindex="-1"> Vuex 初始化</h1>
<p>这一节我们主要来分析 Vuex 的初始化过程，它包括安装、Store 实例化过程 2 个方面。</p>
<h2 id="安装" tabindex="-1"> 安装</h2>
<p>当我们在代码中通过 <code>import Vuex from 'vuex'</code> 的时候，实际上引用的是一个对象，它的定义在 <code>src/index.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  Store<span>,</span>
  install<span>,</span>
  <span>version</span><span>:</span> <span>'__VERSION__'</span><span>,</span>
  mapState<span>,</span>
  mapMutations<span>,</span>
  mapGetters<span>,</span>
  mapActions<span>,</span>
  createNamespacedHelpers
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>和 Vue-Router 一样，Vuex 也同样存在一个静态的 <code>install</code> 方法，它的定义在 <code>src/store.js</code> 中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>install</span> <span>(</span><span>_Vue</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>Vue <span>&amp;&amp;</span> _Vue <span>===</span> Vue<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      console<span>.</span><span>error</span><span>(</span>
        <span>'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>
      <span>)</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>
  Vue <span>=</span> _Vue
  <span>applyMixin</span><span>(</span>Vue<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>install</code> 的逻辑很简单，把传入的 <code>_Vue</code> 赋值给 <code>Vue</code> 并执行了 <code>applyMixin(Vue)</code> 方法，它的定义在 <code>src/mixin.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>function</span> <span>(</span><span>Vue</span><span>)</span> <span>{</span>
  <span>const</span> version <span>=</span> <span>Number</span><span>(</span>Vue<span>.</span>version<span>.</span><span>split</span><span>(</span><span>'.'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>)</span>

  <span>if</span> <span>(</span>version <span>>=</span> <span>2</span><span>)</span> <span>{</span>
    Vue<span>.</span><span>mixin</span><span>(</span><span>{</span> <span>beforeCreate</span><span>:</span> vuexInit <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// override init and inject vuex init procedure</span>
    <span>// for 1.x backwards compatibility.</span>
    <span>const</span> _init <span>=</span> <span>Vue</span><span>.</span>prototype<span>.</span>_init
    <span>Vue</span><span>.</span>prototype<span>.</span><span>_init</span> <span>=</span> <span>function</span> <span>(</span><span>options <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
      options<span>.</span>init <span>=</span> options<span>.</span>init
        <span>?</span> <span>[</span>vuexInit<span>]</span><span>.</span><span>concat</span><span>(</span>options<span>.</span>init<span>)</span>
        <span>:</span> vuexInit
      <span>_init</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> options<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>/**
   * Vuex init hook, injected into each instances init hooks list.
   */</span>

  <span>function</span> <span>vuexInit</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> options <span>=</span> <span>this</span><span>.</span>$options
    <span>// store injection</span>
    <span>if</span> <span>(</span>options<span>.</span>store<span>)</span> <span>{</span>
      <span>this</span><span>.</span>$store <span>=</span> <span>typeof</span> options<span>.</span>store <span>===</span> <span>'function'</span>
        <span>?</span> options<span>.</span><span>store</span><span>(</span><span>)</span>
        <span>:</span> options<span>.</span>store
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>options<span>.</span>parent <span>&amp;&amp;</span> options<span>.</span>parent<span>.</span>$store<span>)</span> <span>{</span>
      <span>this</span><span>.</span>$store <span>=</span> options<span>.</span>parent<span>.</span>$store
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>applyMixin</code> 就是这个 <code>export default function</code>，它还兼容了 Vue 1.0 的版本，这里我们只关注 Vue 2.0 以上版本的逻辑，它其实就全局混入了一个 <code>beforeCreate</code> 钩子函数，它的实现非常简单，就是把 <code>options.store</code> 保存在所有组件的 <code>this.$store</code> 中，这个 <code>options.store</code> 就是我们在实例化 <code>Store</code> 对象的实例，稍后我们会介绍，这也是为什么我们在组件中可以通过 <code>this.$store</code> 访问到这个实例。</p>
<h2 id="store-实例化" tabindex="-1"> Store 实例化</h2>
<p>我们在 <code>import Vuex</code> 之后，会实例化其中的 <code>Store</code> 对象，返回 <code>store</code> 实例并传入 <code>new Vue</code> 的 <code>options</code> 中，也就是我们刚才提到的 <code>options.store</code>.</p>
<p>举个简单的例子，如下：</p>
<div><pre><code><span>export</span> <span>default</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  actions<span>,</span>
  getters<span>,</span>
  state<span>,</span>
  mutations<span>,</span>
  modules
  <span>// ...</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Store</code> 对象的构造函数接收一个对象参数，它包含 <code>actions</code>、<code>getters</code>、<code>state</code>、<code>mutations</code>、<code>modules</code> 等 Vuex 的核心概念，它的定义在 <code>src/store.js</code> 中：</p>
<div><pre><code><span>export</span> <span>class</span> <span>Store</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>options <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
    <span>// Auto install if it is not done yet and `window` has `Vue`.</span>
    <span>// To allow users to avoid auto-installation in some cases,</span>
    <span>// this code should be placed here. See #731</span>
    <span>if</span> <span>(</span><span>!</span>Vue <span>&amp;&amp;</span> <span>typeof</span> window <span>!==</span> <span>'undefined'</span> <span>&amp;&amp;</span> window<span>.</span>Vue<span>)</span> <span>{</span>
      <span>install</span><span>(</span>window<span>.</span>Vue<span>)</span>
    <span>}</span>

    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>assert</span><span>(</span>Vue<span>,</span> <span><span>`</span><span>must call Vue.use(Vuex) before creating a store instance.</span><span>`</span></span><span>)</span>
      <span>assert</span><span>(</span><span>typeof</span> Promise <span>!==</span> <span>'undefined'</span><span>,</span> <span><span>`</span><span>vuex requires a Promise polyfill in this browser.</span><span>`</span></span><span>)</span>
      <span>assert</span><span>(</span><span>this</span> <span>instanceof</span> <span>Store</span><span>,</span> <span><span>`</span><span>Store must be called with the new operator.</span><span>`</span></span><span>)</span>
    <span>}</span>

    <span>const</span> <span>{</span>
      plugins <span>=</span> <span>[</span><span>]</span><span>,</span>
      strict <span>=</span> <span>false</span>
    <span>}</span> <span>=</span> options

    <span>// store internal state</span>
    <span>this</span><span>.</span>_committing <span>=</span> <span>false</span>
    <span>this</span><span>.</span>_actions <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>this</span><span>.</span>_actionSubscribers <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>_mutations <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>this</span><span>.</span>_wrappedGetters <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>this</span><span>.</span>_modules <span>=</span> <span>new</span> <span>ModuleCollection</span><span>(</span>options<span>)</span>
    <span>this</span><span>.</span>_modulesNamespaceMap <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>this</span><span>.</span>_subscribers <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>_watcherVM <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>)</span>

    <span>// bind commit and dispatch to self</span>
    <span>const</span> store <span>=</span> <span>this</span>
    <span>const</span> <span>{</span> dispatch<span>,</span> commit <span>}</span> <span>=</span> <span>this</span>
    <span>this</span><span>.</span><span>dispatch</span> <span>=</span> <span>function</span> <span>boundDispatch</span> <span>(</span><span>type<span>,</span> payload</span><span>)</span> <span>{</span>
      <span>return</span> <span>dispatch</span><span>.</span><span>call</span><span>(</span>store<span>,</span> type<span>,</span> payload<span>)</span>
    <span>}</span>
    <span>this</span><span>.</span><span>commit</span> <span>=</span> <span>function</span> <span>boundCommit</span> <span>(</span><span>type<span>,</span> payload<span>,</span> options</span><span>)</span> <span>{</span>
      <span>return</span> <span>commit</span><span>.</span><span>call</span><span>(</span>store<span>,</span> type<span>,</span> payload<span>,</span> options<span>)</span>
    <span>}</span>

    <span>// strict mode</span>
    <span>this</span><span>.</span>strict <span>=</span> strict

    <span>const</span> state <span>=</span> <span>this</span><span>.</span>_modules<span>.</span>root<span>.</span>state

    <span>// init root module.</span>
    <span>// this also recursively registers all sub-modules</span>
    <span>// and collects all module getters inside this._wrappedGetters</span>
    <span>installModule</span><span>(</span><span>this</span><span>,</span> state<span>,</span> <span>[</span><span>]</span><span>,</span> <span>this</span><span>.</span>_modules<span>.</span>root<span>)</span>

    <span>// initialize the store vm, which is responsible for the reactivity</span>
    <span>// (also registers _wrappedGetters as computed properties)</span>
    <span>resetStoreVM</span><span>(</span><span>this</span><span>,</span> state<span>)</span>

    <span>// apply plugins</span>
    plugins<span>.</span><span>forEach</span><span>(</span><span>plugin</span> <span>=></span> <span>plugin</span><span>(</span><span>this</span><span>)</span><span>)</span>

    <span>if</span> <span>(</span>Vue<span>.</span>config<span>.</span>devtools<span>)</span> <span>{</span>
      <span>devtoolPlugin</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们把 <code>Store</code> 的实例化过程拆成 3 个部分，分别是初始化模块，安装模块和初始化 <code>store._vm</code>，接下来我们来分析这 3 部分的实现。</p>
<h3 id="初始化模块" tabindex="-1"> 初始化模块</h3>
<p>在分析模块初始化之前，我们先来了解一下模块对于 Vuex 的意义：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 <code>store</code> 分割成模块（module）。每个模块拥有自己的 <code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>，甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<div><pre><code><span>const</span> moduleA <span>=</span> <span>{</span>
  <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>mutations</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>actions</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>getters</span><span>:</span> <span>{</span> <span>...</span> <span>}</span>
<span>}</span>

<span>const</span> moduleB <span>=</span> <span>{</span>
  <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>mutations</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>actions</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
  <span>getters</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
<span>}</span>

<span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  <span>modules</span><span>:</span> <span>{</span>
    <span>a</span><span>:</span> moduleA<span>,</span>
    <span>b</span><span>:</span> moduleB
  <span>}</span>
<span>}</span><span>)</span>

store<span>.</span>state<span>.</span>a <span>// -> moduleA 的状态</span>
store<span>.</span>state<span>.</span>b <span>// -> moduleB 的状态</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以从数据结构上来看，模块的设计就是一个树型结构，<code>store</code> 本身可以理解为一个 <code>root module</code>，它下面的 <code>modules</code> 就是子模块，Vuex 需要完成这颗树的构建，构建过程的入口就是：</p>
<div><pre><code><span>this</span><span>.</span>_modules <span>=</span> <span>new</span> <span>ModuleCollection</span><span>(</span>options<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>ModuleCollection</code> 的定义在 <code>src/module/module-collection.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>ModuleCollection</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>rawRootModule</span><span>)</span> <span>{</span>
    <span>// register root module (Vuex.Store options)</span>
    <span>this</span><span>.</span><span>register</span><span>(</span><span>[</span><span>]</span><span>,</span> rawRootModule<span>,</span> <span>false</span><span>)</span>
  <span>}</span>

  <span>get</span> <span>(</span>path<span>)</span> <span>{</span>
    <span>return</span> path<span>.</span><span>reduce</span><span>(</span><span>(</span><span>module<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
      <span>return</span> module<span>.</span><span>getChild</span><span>(</span>key<span>)</span>
    <span>}</span><span>,</span> <span>this</span><span>.</span>root<span>)</span>
  <span>}</span>

  <span>getNamespace</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
    <span>let</span> module <span>=</span> <span>this</span><span>.</span>root
    <span>return</span> path<span>.</span><span>reduce</span><span>(</span><span>(</span><span>namespace<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
      module <span>=</span> module<span>.</span><span>getChild</span><span>(</span>key<span>)</span>
      <span>return</span> namespace <span>+</span> <span>(</span>module<span>.</span>namespaced <span>?</span> key <span>+</span> <span>'/'</span> <span>:</span> <span>''</span><span>)</span>
    <span>}</span><span>,</span> <span>''</span><span>)</span>
  <span>}</span>

  <span>update</span> <span>(</span><span>rawRootModule</span><span>)</span> <span>{</span>
    <span>update</span><span>(</span><span>[</span><span>]</span><span>,</span> <span>this</span><span>.</span>root<span>,</span> rawRootModule<span>)</span>
  <span>}</span>

  <span>register</span> <span>(</span><span>path<span>,</span> rawModule<span>,</span> runtime <span>=</span> <span>true</span></span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>assertRawModule</span><span>(</span>path<span>,</span> rawModule<span>)</span>
    <span>}</span>

    <span>const</span> newModule <span>=</span> <span>new</span> <span>Module</span><span>(</span>rawModule<span>,</span> runtime<span>)</span>
    <span>if</span> <span>(</span>path<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>root <span>=</span> newModule
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> parent <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span>path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
      parent<span>.</span><span>addChild</span><span>(</span>path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>,</span> newModule<span>)</span>
    <span>}</span>

    <span>// register nested modules</span>
    <span>if</span> <span>(</span>rawModule<span>.</span>modules<span>)</span> <span>{</span>
      <span>forEachValue</span><span>(</span>rawModule<span>.</span>modules<span>,</span> <span>(</span><span>rawChildModule<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
        <span>this</span><span>.</span><span>register</span><span>(</span>path<span>.</span><span>concat</span><span>(</span>key<span>)</span><span>,</span> rawChildModule<span>,</span> runtime<span>)</span>
      <span>}</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>unregister</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
    <span>const</span> parent <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span>path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
    <span>const</span> key <span>=</span> path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span>
    <span>if</span> <span>(</span><span>!</span>parent<span>.</span><span>getChild</span><span>(</span>key<span>)</span><span>.</span>runtime<span>)</span> <span>return</span>

    parent<span>.</span><span>removeChild</span><span>(</span>key<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>ModuleCollection</code> 实例化的过程就是执行了 <code>register</code> 方法，
<code>register</code> 接收 3 个参数，其中 <code>path</code> 表示路径，因为我们整体目标是要构建一颗模块树，<code>path</code> 是在构建树的过程中维护的路径；<code>rawModule</code> 表示定义模块的原始配置；<code>runtime</code> 表示是否是一个运行时创建的模块。</p>
<p><code>register</code> 方法首先通过 <code>const newModule = new Module(rawModule, runtime)</code> 创建了一个 <code>Module</code> 的实例，<code>Module</code> 是用来描述单个模块的类，它的定义在 <code>src/module/module.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>Module</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>rawModule<span>,</span> runtime</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>runtime <span>=</span> runtime
    <span>// Store some children item</span>
    <span>this</span><span>.</span>_children <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
    <span>// Store the origin module object which passed by programmer</span>
    <span>this</span><span>.</span>_rawModule <span>=</span> rawModule
    <span>const</span> rawState <span>=</span> rawModule<span>.</span>state

    <span>// Store the origin module's state</span>
    <span>this</span><span>.</span>state <span>=</span> <span>(</span><span>typeof</span> rawState <span>===</span> <span>'function'</span> <span>?</span> <span>rawState</span><span>(</span><span>)</span> <span>:</span> rawState<span>)</span> <span>||</span> <span>{</span><span>}</span>
  <span>}</span>

  <span>get</span> <span>namespaced</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>!</span><span>!</span><span>this</span><span>.</span>_rawModule<span>.</span>namespaced
  <span>}</span>

  <span>addChild</span> <span>(</span><span>key<span>,</span> module</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>_children<span>[</span>key<span>]</span> <span>=</span> module
  <span>}</span>

  <span>removeChild</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
    <span>delete</span> <span>this</span><span>.</span>_children<span>[</span>key<span>]</span>
  <span>}</span>

  <span>getChild</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>_children<span>[</span>key<span>]</span>
  <span>}</span>

  <span>update</span> <span>(</span><span>rawModule</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>_rawModule<span>.</span>namespaced <span>=</span> rawModule<span>.</span>namespaced
    <span>if</span> <span>(</span>rawModule<span>.</span>actions<span>)</span> <span>{</span>
      <span>this</span><span>.</span>_rawModule<span>.</span>actions <span>=</span> rawModule<span>.</span>actions
    <span>}</span>
    <span>if</span> <span>(</span>rawModule<span>.</span>mutations<span>)</span> <span>{</span>
      <span>this</span><span>.</span>_rawModule<span>.</span>mutations <span>=</span> rawModule<span>.</span>mutations
    <span>}</span>
    <span>if</span> <span>(</span>rawModule<span>.</span>getters<span>)</span> <span>{</span>
      <span>this</span><span>.</span>_rawModule<span>.</span>getters <span>=</span> rawModule<span>.</span>getters
    <span>}</span>
  <span>}</span>

  <span>forEachChild</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>forEachValue</span><span>(</span><span>this</span><span>.</span>_children<span>,</span> fn<span>)</span>
  <span>}</span>

  <span>forEachGetter</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>_rawModule<span>.</span>getters<span>)</span> <span>{</span>
      <span>forEachValue</span><span>(</span><span>this</span><span>.</span>_rawModule<span>.</span>getters<span>,</span> fn<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>forEachAction</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>_rawModule<span>.</span>actions<span>)</span> <span>{</span>
      <span>forEachValue</span><span>(</span><span>this</span><span>.</span>_rawModule<span>.</span>actions<span>,</span> fn<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>forEachMutation</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>_rawModule<span>.</span>mutations<span>)</span> <span>{</span>
      <span>forEachValue</span><span>(</span><span>this</span><span>.</span>_rawModule<span>.</span>mutations<span>,</span> fn<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>来看一下 <code>Module</code> 的构造函数，对于每个模块而言，<code>this._rawModule</code> 表示模块的配置，<code>this._children</code> 表示它的所有子模块，<code>this.state</code> 表示这个模块定义的 <code>state</code>。</p>
<p>回到 <code>register</code>，那么在实例化一个 <code>Module</code> 后，判断当前的 <code>path</code> 的长度如果为 0，则说明它是一个根模块，所以把 <code>newModule</code> 赋值给了 <code>this.root</code>，否则就需要建立父子关系了：</p>
<div><pre><code><span>const</span> parent <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span>path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
parent<span>.</span><span>addChild</span><span>(</span>path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>,</span> newModule<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>我们先大体上了解它的逻辑：首先根据路径获取到父模块，然后再调用父模块的 <code>addChild</code> 方法建立父子关系。</p>
<p><code>register</code> 的最后一步，就是遍历当前模块定义中的所有 <code>modules</code>，根据 <code>key</code> 作为 <code>path</code>，递归调用 <code>register</code> 方法，这样我们再回过头看一下建立父子关系的逻辑，首先执行了 <code>this.get(path.slice(0, -1)</code> 方法：</p>
<div><pre><code><span>get</span> <span>(</span>path<span>)</span> <span>{</span>
  <span>return</span> path<span>.</span><span>reduce</span><span>(</span><span>(</span><span>module<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> module<span>.</span><span>getChild</span><span>(</span>key<span>)</span>
  <span>}</span><span>,</span> <span>this</span><span>.</span>root<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>传入的 <code>path</code> 是它的父模块的 <code>path</code>，然后从根模块开始，通过 <code>reduce</code> 方法一层层去找到对应的模块，查找的过程中，执行的是 <code>module.getChild(key)</code> 方法：</p>
<div><pre><code><span>getChild</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>_children<span>[</span>key<span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>其实就是返回当前模块的 <code>_children</code> 中对应 <code>key</code> 的模块，那么每个模块的 <code>_children</code> 是如何添加的呢，是通过执行 <code>parent.addChild(path[path.length - 1], newModule)</code> 方法：</p>
<div><pre><code><span>addChild</span> <span>(</span><span>key<span>,</span> module</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>_children<span>[</span>key<span>]</span> <span>=</span> module
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>所以说对于 <code>root module</code> 的下一层 <code>modules</code> 来说，它们的 <code>parent</code> 就是 <code>root module</code>，那么他们就会被添加的 <code>root module</code> 的 <code>_children</code> 中。每个子模块通过路径找到它的父模块，然后通过父模块的 <code>addChild</code> 方法建立父子关系，递归执行这样的过程，最终就建立一颗完整的模块树。</p>
<h3 id="安装模块" tabindex="-1"> 安装模块</h3>
<p>初始化模块后，执行安装模块的相关逻辑，它的目标就是对模块中的 <code>state</code>、<code>getters</code>、<code>mutations</code>、<code>actions</code> 做初始化工作，它的入口代码是：</p>
<div><pre><code><span>const</span> state <span>=</span> <span>this</span><span>.</span>_modules<span>.</span>root<span>.</span>state
<span>installModule</span><span>(</span><span>this</span><span>,</span> state<span>,</span> <span>[</span><span>]</span><span>,</span> <span>this</span><span>.</span>_modules<span>.</span>root<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>来看一下 <code>installModule</code> 的定义：</p>
<div><pre><code><span>function</span> <span>installModule</span> <span>(</span><span>store<span>,</span> rootState<span>,</span> path<span>,</span> module<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>const</span> isRoot <span>=</span> <span>!</span>path<span>.</span>length
  <span>const</span> namespace <span>=</span> store<span>.</span>_modules<span>.</span><span>getNamespace</span><span>(</span>path<span>)</span>

  <span>// register in namespace map</span>
  <span>if</span> <span>(</span>module<span>.</span>namespaced<span>)</span> <span>{</span>
    store<span>.</span>_modulesNamespaceMap<span>[</span>namespace<span>]</span> <span>=</span> module
  <span>}</span>

  <span>// set state</span>
  <span>if</span> <span>(</span><span>!</span>isRoot <span>&amp;&amp;</span> <span>!</span>hot<span>)</span> <span>{</span>
    <span>const</span> parentState <span>=</span> <span>getNestedState</span><span>(</span>rootState<span>,</span> path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
    <span>const</span> moduleName <span>=</span> path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span>
    store<span>.</span><span>_withCommit</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      Vue<span>.</span><span>set</span><span>(</span>parentState<span>,</span> moduleName<span>,</span> module<span>.</span>state<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>const</span> local <span>=</span> module<span>.</span>context <span>=</span> <span>makeLocalContext</span><span>(</span>store<span>,</span> namespace<span>,</span> path<span>)</span>

  module<span>.</span><span>forEachMutation</span><span>(</span><span>(</span><span>mutation<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> namespacedType <span>=</span> namespace <span>+</span> key
    <span>registerMutation</span><span>(</span>store<span>,</span> namespacedType<span>,</span> mutation<span>,</span> local<span>)</span>
  <span>}</span><span>)</span>

  module<span>.</span><span>forEachAction</span><span>(</span><span>(</span><span>action<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> type <span>=</span> action<span>.</span>root <span>?</span> key <span>:</span> namespace <span>+</span> key
    <span>const</span> handler <span>=</span> action<span>.</span>handler <span>||</span> action
    <span>registerAction</span><span>(</span>store<span>,</span> type<span>,</span> handler<span>,</span> local<span>)</span>
  <span>}</span><span>)</span>

  module<span>.</span><span>forEachGetter</span><span>(</span><span>(</span><span>getter<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> namespacedType <span>=</span> namespace <span>+</span> key
    <span>registerGetter</span><span>(</span>store<span>,</span> namespacedType<span>,</span> getter<span>,</span> local<span>)</span>
  <span>}</span><span>)</span>

  module<span>.</span><span>forEachChild</span><span>(</span><span>(</span><span>child<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>installModule</span><span>(</span>store<span>,</span> rootState<span>,</span> path<span>.</span><span>concat</span><span>(</span>key<span>)</span><span>,</span> child<span>,</span> hot<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>installModule</code> 方法支持 5 个参数，<code>store</code> 表示 <code>root store</code>；<code>state</code> 表示 <code>root state</code>；<code>path</code> 表示模块的访问路径；<code>module</code> 表示当前的模块，<code>hot</code> 表示是否是热更新。</p>
<p>接下来看函数逻辑，这里涉及到了命名空间的概念，默认情况下，模块内部的 <code>action</code>、<code>mutation</code> 和 <code>getter</code> 是注册在全局命名空间的——这样使得多个模块能够对同一 <code>mutation</code> 或 <code>action</code> 作出响应。如果我们希望模块具有更高的封装度和复用性，可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 <code>getter</code>、<code>action</code> 及 <code>mutation</code> 都会自动根据模块注册的路径调整命名。例如：</p>
<div><pre><code><span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  <span>modules</span><span>:</span> <span>{</span>
    <span>account</span><span>:</span> <span>{</span>
      <span>namespaced</span><span>:</span> <span>true</span><span>,</span>

      <span>// 模块内容（module assets）</span>
      <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span> <span>// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>
      <span>getters</span><span>:</span> <span>{</span>
        <span>isAdmin</span> <span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span> <span>// -> getters['account/isAdmin']</span>
      <span>}</span><span>,</span>
      <span>actions</span><span>:</span> <span>{</span>
        <span>login</span> <span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span> <span>// -> dispatch('account/login')</span>
      <span>}</span><span>,</span>
      <span>mutations</span><span>:</span> <span>{</span>
        <span>login</span> <span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span> <span>// -> commit('account/login')</span>
      <span>}</span><span>,</span>

      <span>// 嵌套模块</span>
      <span>modules</span><span>:</span> <span>{</span>
        <span>// 继承父模块的命名空间</span>
        <span>myPage</span><span>:</span> <span>{</span>
          <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
          <span>getters</span><span>:</span> <span>{</span>
            <span>profile</span> <span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span> <span>// -> getters['account/profile']</span>
          <span>}</span>
        <span>}</span><span>,</span>

        <span>// 进一步嵌套命名空间</span>
        <span>posts</span><span>:</span> <span>{</span>
          <span>namespaced</span><span>:</span> <span>true</span><span>,</span>

          <span>state</span><span>:</span> <span>{</span> <span>...</span> <span>}</span><span>,</span>
          <span>getters</span><span>:</span> <span>{</span>
            <span>popular</span> <span>(</span><span>)</span> <span>{</span> <span>...</span> <span>}</span> <span>// -> getters['account/posts/popular']</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>回到 <code>installModule</code> 方法，我们首先根据 <code>path</code> 获取 <code>namespace</code>：</p>
<div><pre><code><span>const</span> namespace <span>=</span> store<span>.</span>_modules<span>.</span><span>getNamespace</span><span>(</span>path<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>getNamespace</code> 的定义在 <code>src/module/module-collection.js</code> 中：</p>
<div><pre><code><span>getNamespace</span> <span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>let</span> module <span>=</span> <span>this</span><span>.</span>root
  <span>return</span> path<span>.</span><span>reduce</span><span>(</span><span>(</span><span>namespace<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    module <span>=</span> module<span>.</span><span>getChild</span><span>(</span>key<span>)</span>
    <span>return</span> namespace <span>+</span> <span>(</span>module<span>.</span>namespaced <span>?</span> key <span>+</span> <span>'/'</span> <span>:</span> <span>''</span><span>)</span>
  <span>}</span><span>,</span> <span>''</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>从 <code>root module</code> 开始，通过 <code>reduce</code> 方法一层层找子模块，如果发现该模块配置了 <code>namespaced</code> 为 true，则把该模块的 <code>key</code> 拼到 <code>namesapce</code> 中，最终返回完整的 <code>namespace</code> 字符串。</p>
<p>回到 <code>installModule</code> 方法，接下来把 <code>namespace</code> 对应的模块保存下来，为了方便以后能根据 <code>namespace</code> 查找模块：</p>
<div><pre><code><span>if</span> <span>(</span>module<span>.</span>namespaced<span>)</span> <span>{</span>
  store<span>.</span>_modulesNamespaceMap<span>[</span>namespace<span>]</span> <span>=</span> module
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>接下来判断非 <code>root module</code> 且非 <code>hot</code> 的情况执行一些逻辑，我们稍后再看。</p>
<p>接着是很重要的逻辑，构造了一个本地上下文环境：</p>
<div><pre><code><span>const</span> local <span>=</span> module<span>.</span>context <span>=</span> <span>makeLocalContext</span><span>(</span>store<span>,</span> namespace<span>,</span> path<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>来看一下 <code>makeLocalContext</code> 实现：</p>
<div><pre><code><span>function</span> <span>makeLocalContext</span> <span>(</span><span>store<span>,</span> namespace<span>,</span> path</span><span>)</span> <span>{</span>
  <span>const</span> noNamespace <span>=</span> namespace <span>===</span> <span>''</span>

  <span>const</span> local <span>=</span> <span>{</span>
    <span>dispatch</span><span>:</span> noNamespace <span>?</span> store<span>.</span><span>dispatch</span> <span>:</span> <span>(</span><span>_type<span>,</span> _payload<span>,</span> _options</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> args <span>=</span> <span>unifyObjectStyle</span><span>(</span>_type<span>,</span> _payload<span>,</span> _options<span>)</span>
      <span>const</span> <span>{</span> payload<span>,</span> options <span>}</span> <span>=</span> args
      <span>let</span> <span>{</span> type <span>}</span> <span>=</span> args

      <span>if</span> <span>(</span><span>!</span>options <span>||</span> <span>!</span>options<span>.</span>root<span>)</span> <span>{</span>
        type <span>=</span> namespace <span>+</span> type
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>store<span>.</span>_actions<span>[</span>type<span>]</span><span>)</span> <span>{</span>
          console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] unknown local action type: </span><span><span>${</span>args<span>.</span>type<span>}</span></span><span>, global type: </span><span><span>${</span>type<span>}</span></span><span>`</span></span><span>)</span>
          <span>return</span>
        <span>}</span>
      <span>}</span>

      <span>return</span> store<span>.</span><span>dispatch</span><span>(</span>type<span>,</span> payload<span>)</span>
    <span>}</span><span>,</span>

    <span>commit</span><span>:</span> noNamespace <span>?</span> store<span>.</span><span>commit</span> <span>:</span> <span>(</span><span>_type<span>,</span> _payload<span>,</span> _options</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> args <span>=</span> <span>unifyObjectStyle</span><span>(</span>_type<span>,</span> _payload<span>,</span> _options<span>)</span>
      <span>const</span> <span>{</span> payload<span>,</span> options <span>}</span> <span>=</span> args
      <span>let</span> <span>{</span> type <span>}</span> <span>=</span> args

      <span>if</span> <span>(</span><span>!</span>options <span>||</span> <span>!</span>options<span>.</span>root<span>)</span> <span>{</span>
        type <span>=</span> namespace <span>+</span> type
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>store<span>.</span>_mutations<span>[</span>type<span>]</span><span>)</span> <span>{</span>
          console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] unknown local mutation type: </span><span><span>${</span>args<span>.</span>type<span>}</span></span><span>, global type: </span><span><span>${</span>type<span>}</span></span><span>`</span></span><span>)</span>
          <span>return</span>
        <span>}</span>
      <span>}</span>

      store<span>.</span><span>commit</span><span>(</span>type<span>,</span> payload<span>,</span> options<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// getters and state object must be gotten lazily</span>
  <span>// because they will be changed by vm update</span>
  Object<span>.</span><span>defineProperties</span><span>(</span>local<span>,</span> <span>{</span>
    <span>getters</span><span>:</span> <span>{</span>
      <span>get</span><span>:</span> noNamespace
        <span>?</span> <span>(</span><span>)</span> <span>=></span> store<span>.</span><span>getters</span>
        <span>:</span> <span>(</span><span>)</span> <span>=></span> <span>makeLocalGetters</span><span>(</span>store<span>,</span> namespace<span>)</span>
    <span>}</span><span>,</span>
    <span>state</span><span>:</span> <span>{</span>
      <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>getNestedState</span><span>(</span>store<span>.</span>state<span>,</span> path<span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>

  <span>return</span> local
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>makeLocalContext</code> 支持 3 个参数相关，<code>store</code> 表示 <code>root store</code>；<code>namespace</code> 表示模块的命名空间，<code>path</code> 表示模块的 <code>path</code>。</p>
<p>该方法定义了 <code>local</code> 对象，对于 <code>dispatch</code> 和 <code>commit</code> 方法，如果没有 <code>namespace</code>，它们就直接指向了 <code>root store</code> 的 <code>dispatch</code> 和 <code>commit</code> 方法，否则会创建方法，把 <code>type</code> 自动拼接上 <code>namespace</code>，然后执行 <code>store</code> 上对应的方法。</p>
<p>对于 <code>getters</code> 而言，如果没有 <code>namespace</code>，则直接返回 <code>root store</code> 的 <code>getters</code>，否则返回 <code>makeLocalGetters(store, namespace)</code> 的返回值：</p>
<div><pre><code><span>function</span> <span>makeLocalGetters</span> <span>(</span><span>store<span>,</span> namespace</span><span>)</span> <span>{</span>
  <span>const</span> gettersProxy <span>=</span> <span>{</span><span>}</span>

  <span>const</span> splitPos <span>=</span> namespace<span>.</span>length
  Object<span>.</span><span>keys</span><span>(</span>store<span>.</span>getters<span>)</span><span>.</span><span>forEach</span><span>(</span><span>type</span> <span>=></span> <span>{</span>
    <span>// skip if the target getter is not match this namespace</span>
    <span>if</span> <span>(</span>type<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> splitPos<span>)</span> <span>!==</span> namespace<span>)</span> <span>return</span>

    <span>// extract local getter type</span>
    <span>const</span> localType <span>=</span> type<span>.</span><span>slice</span><span>(</span>splitPos<span>)</span>

    <span>// Add a port to the getters proxy.</span>
    <span>// Define as getter property because</span>
    <span>// we do not want to evaluate the getters in this time.</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>gettersProxy<span>,</span> localType<span>,</span> <span>{</span>
      <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> store<span>.</span>getters<span>[</span>type<span>]</span><span>,</span>
      <span>enumerable</span><span>:</span> <span>true</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>

  <span>return</span> gettersProxy
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>makeLocalGetters</code> 首先获取了 <code>namespace</code> 的长度，然后遍历 <code>root store</code> 下的所有 <code>getters</code>，先判断它的类型是否匹配 <code>namespace</code>，只有匹配的时候我们从 <code>namespace</code> 的位置截取后面的字符串得到 <code>localType</code>，接着用 <code>Object.defineProperty</code> 定义了 <code>gettersProxy</code>，获取 <code>localType</code> 实际上是访问了 <code>store.getters[type]</code>。</p>
<p>回到 <code>makeLocalContext</code> 方法，再来看一下对 <code>state</code> 的实现，它的获取则是通过 <code>getNestedState(store.state, path)</code> 方法：</p>
<div><pre><code><span>function</span> <span>getNestedState</span> <span>(</span><span>state<span>,</span> path</span><span>)</span> <span>{</span>
  <span>return</span> path<span>.</span>length
    <span>?</span> path<span>.</span><span>reduce</span><span>(</span><span>(</span><span>state<span>,</span> key</span><span>)</span> <span>=></span> state<span>[</span>key<span>]</span><span>,</span> state<span>)</span>
    <span>:</span> state
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><code>getNestedState</code> 逻辑很简单，从 <code>root state</code> 开始，通过 <code>path.reduce</code> 方法一层层查找子模块 <code>state</code>，最终找到目标模块的 <code>state</code>。</p>
<p>那么构造完 <code>local</code> 上下文后，我们再回到 <code>installModule</code> 方法，接下来它就会遍历模块中定义的 <code>mutations</code>、<code>actions</code>、<code>getters</code>，分别执行它们的注册工作，它们的注册逻辑都大同小异。</p>
<ul>
<li><code>registerMutation</code></li>
</ul>
<div><pre><code>module<span>.</span><span>forEachMutation</span><span>(</span><span>(</span><span>mutation<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> namespacedType <span>=</span> namespace <span>+</span> key
  <span>registerMutation</span><span>(</span>store<span>,</span> namespacedType<span>,</span> mutation<span>,</span> local<span>)</span>
<span>}</span><span>)</span>

<span>function</span> <span>registerMutation</span> <span>(</span><span>store<span>,</span> type<span>,</span> handler<span>,</span> local</span><span>)</span> <span>{</span>
  <span>const</span> entry <span>=</span> store<span>.</span>_mutations<span>[</span>type<span>]</span> <span>||</span> <span>(</span>store<span>.</span>_mutations<span>[</span>type<span>]</span> <span>=</span> <span>[</span><span>]</span><span>)</span>
  entry<span>.</span><span>push</span><span>(</span><span>function</span> <span>wrappedMutationHandler</span> <span>(</span><span>payload</span><span>)</span> <span>{</span>
    <span>handler</span><span>.</span><span>call</span><span>(</span>store<span>,</span> local<span>.</span>state<span>,</span> payload<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先遍历模块中的 <code>mutations</code> 的定义，拿到每一个 <code>mutation</code> 和 <code>key</code>，并把 <code>key</code> 拼接上 <code>namespace</code>，然后执行 <code>registerMutation</code> 方法。该方法实际上就是给 <code>root store</code> 上的 <code>_mutations[types]</code> 添加 <code>wrappedMutationHandler</code> 方法，该方法的具体实现我们之后会提到。注意，同一 <code>type</code> 的 <code>_mutations</code> 可以对应多个方法。</p>
<ul>
<li><code>registerAction</code></li>
</ul>
<div><pre><code>module<span>.</span><span>forEachAction</span><span>(</span><span>(</span><span>action<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> type <span>=</span> action<span>.</span>root <span>?</span> key <span>:</span> namespace <span>+</span> key
  <span>const</span> handler <span>=</span> action<span>.</span>handler <span>||</span> action
  <span>registerAction</span><span>(</span>store<span>,</span> type<span>,</span> handler<span>,</span> local<span>)</span>
<span>}</span><span>)</span>

<span>function</span> <span>registerAction</span> <span>(</span><span>store<span>,</span> type<span>,</span> handler<span>,</span> local</span><span>)</span> <span>{</span>
  <span>const</span> entry <span>=</span> store<span>.</span>_actions<span>[</span>type<span>]</span> <span>||</span> <span>(</span>store<span>.</span>_actions<span>[</span>type<span>]</span> <span>=</span> <span>[</span><span>]</span><span>)</span>
  entry<span>.</span><span>push</span><span>(</span><span>function</span> <span>wrappedActionHandler</span> <span>(</span><span>payload<span>,</span> cb</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>handler</span><span>.</span><span>call</span><span>(</span>store<span>,</span> <span>{</span>
      <span>dispatch</span><span>:</span> local<span>.</span>dispatch<span>,</span>
      <span>commit</span><span>:</span> local<span>.</span>commit<span>,</span>
      <span>getters</span><span>:</span> local<span>.</span>getters<span>,</span>
      <span>state</span><span>:</span> local<span>.</span>state<span>,</span>
      <span>rootGetters</span><span>:</span> store<span>.</span>getters<span>,</span>
      <span>rootState</span><span>:</span> store<span>.</span>state
    <span>}</span><span>,</span> payload<span>,</span> cb<span>)</span>
    <span>if</span> <span>(</span><span>!</span><span>isPromise</span><span>(</span>res<span>)</span><span>)</span> <span>{</span>
      res <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span>res<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>store<span>.</span>_devtoolHook<span>)</span> <span>{</span>
      <span>return</span> res<span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
        store<span>.</span>_devtoolHook<span>.</span><span>emit</span><span>(</span><span>'vuex:error'</span><span>,</span> err<span>)</span>
        <span>throw</span> err
      <span>}</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> res
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先遍历模块中的 <code>actions</code> 的定义，拿到每一个 <code>action</code> 和 <code>key</code>，并判断 <code>action.root</code>，如果否的情况把 <code>key</code> 拼接上 <code>namespace</code>，然后执行 <code>registerAction</code> 方法。该方法实际上就是给 <code>root store</code> 上的 <code>_actions[types]</code> 添加 <code>wrappedActionHandler</code> 方法，该方法的具体实现我们之后会提到。注意，同一 <code>type</code> 的 <code>_actions</code> 可以对应多个方法。</p>
<ul>
<li><code>registerGetter</code></li>
</ul>
<div><pre><code>module<span>.</span><span>forEachGetter</span><span>(</span><span>(</span><span>getter<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> namespacedType <span>=</span> namespace <span>+</span> key
  <span>registerGetter</span><span>(</span>store<span>,</span> namespacedType<span>,</span> getter<span>,</span> local<span>)</span>
<span>}</span><span>)</span>


<span>function</span> <span>registerGetter</span> <span>(</span><span>store<span>,</span> type<span>,</span> rawGetter<span>,</span> local</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>store<span>.</span>_wrappedGetters<span>[</span>type<span>]</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>[vuex] duplicate getter key: </span><span><span>${</span>type<span>}</span></span><span>`</span></span><span>)</span>
    <span>}</span>
    <span>return</span>
  <span>}</span>
  store<span>.</span>_wrappedGetters<span>[</span>type<span>]</span> <span>=</span> <span>function</span> <span>wrappedGetter</span> <span>(</span><span>store</span><span>)</span> <span>{</span>
    <span>return</span> <span>rawGetter</span><span>(</span>
      local<span>.</span>state<span>,</span> <span>// local state</span>
      local<span>.</span>getters<span>,</span> <span>// local getters</span>
      store<span>.</span>state<span>,</span> <span>// root state</span>
      store<span>.</span>getters <span>// root getters</span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>首先遍历模块中的 <code>getters</code> 的定义，拿到每一个 <code>getter</code> 和 <code>key</code>，并把 <code>key</code> 拼接上 <code>namespace</code>，然后执行 <code>registerGetter</code> 方法。该方法实际上就是给 <code>root store</code> 上的 <code>_wrappedGetters[key]</code> 指定 <code>wrappedGetter</code> 方法，该方法的具体实现我们之后会提到。注意，同一 <code>type</code> 的 <code>_wrappedGetters</code> 只能定义一个。</p>
<p>再回到 <code>installModule</code> 方法，最后一步就是遍历模块中的所有子 <code>modules</code>，递归执行 <code>installModule</code> 方法：</p>
<div><pre><code>module<span>.</span><span>forEachChild</span><span>(</span><span>(</span><span>child<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
  <span>installModule</span><span>(</span>store<span>,</span> rootState<span>,</span> path<span>.</span><span>concat</span><span>(</span>key<span>)</span><span>,</span> child<span>,</span> hot<span>)</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>之前我们忽略了非 <code>root module</code> 下的 <code>state</code> 初始化逻辑，现在来看一下：</p>
<div><pre><code><span>if</span> <span>(</span><span>!</span>isRoot <span>&amp;&amp;</span> <span>!</span>hot<span>)</span> <span>{</span>
  <span>const</span> parentState <span>=</span> <span>getNestedState</span><span>(</span>rootState<span>,</span> path<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span>
  <span>const</span> moduleName <span>=</span> path<span>[</span>path<span>.</span>length <span>-</span> <span>1</span><span>]</span>
  store<span>.</span><span>_withCommit</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    Vue<span>.</span><span>set</span><span>(</span>parentState<span>,</span> moduleName<span>,</span> module<span>.</span>state<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>之前我们提到过 <code>getNestedState</code> 方法，它是从 <code>root state</code> 开始，一层层根据模块名能访问到对应 <code>path</code> 的 <code>state</code>，那么它每一层关系的建立实际上就是通过这段 <code>state</code> 的初始化逻辑。<code>store._withCommit</code> 方法我们之后再介绍。</p>
<p>所以 <code>installModule</code> 实际上就是完成了模块下的 <code>state</code>、<code>getters</code>、<code>actions</code>、<code>mutations</code> 的初始化工作，并且通过递归遍历的方式，就完成了所有子模块的安装工作。</p>
<h3 id="初始化-store-vm" tabindex="-1"> 初始化 <code>store._vm</code></h3>
<p><code>Store</code> 实例化的最后一步，就是执行初始化 <code>store._vm</code> 的逻辑，它的入口代码是：</p>
<div><pre><code><span>resetStoreVM</span><span>(</span><span>this</span><span>,</span> state<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>来看一下 <code>resetStoreVM</code> 的定义：</p>
<div><pre><code><span>function</span> <span>resetStoreVM</span> <span>(</span><span>store<span>,</span> state<span>,</span> hot</span><span>)</span> <span>{</span>
  <span>const</span> oldVm <span>=</span> store<span>.</span>_vm

  <span>// bind store public getters</span>
  store<span>.</span>getters <span>=</span> <span>{</span><span>}</span>
  <span>const</span> wrappedGetters <span>=</span> store<span>.</span>_wrappedGetters
  <span>const</span> computed <span>=</span> <span>{</span><span>}</span>
  <span>forEachValue</span><span>(</span>wrappedGetters<span>,</span> <span>(</span><span>fn<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>// use computed to leverage its lazy-caching mechanism</span>
    computed<span>[</span>key<span>]</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>fn</span><span>(</span>store<span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>store<span>.</span>getters<span>,</span> key<span>,</span> <span>{</span>
      <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> store<span>.</span>_vm<span>[</span>key<span>]</span><span>,</span>
      <span>enumerable</span><span>:</span> <span>true</span> <span>// for local getters</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>

  <span>// use a Vue instance to store the state tree</span>
  <span>// suppress warnings just in case the user has added</span>
  <span>// some funky global mixins</span>
  <span>const</span> silent <span>=</span> Vue<span>.</span>config<span>.</span>silent
  Vue<span>.</span>config<span>.</span>silent <span>=</span> <span>true</span>
  store<span>.</span>_vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    <span>data</span><span>:</span> <span>{</span>
      <span>$$state</span><span>:</span> state
    <span>}</span><span>,</span>
    computed
  <span>}</span><span>)</span>
  Vue<span>.</span>config<span>.</span>silent <span>=</span> silent

  <span>// enable strict mode for new vm</span>
  <span>if</span> <span>(</span>store<span>.</span>strict<span>)</span> <span>{</span>
    <span>enableStrictMode</span><span>(</span>store<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span>oldVm<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>hot<span>)</span> <span>{</span>
      <span>// dispatch changes in all subscribed watchers</span>
      <span>// to force getter re-evaluation for hot reloading.</span>
      store<span>.</span><span>_withCommit</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        oldVm<span>.</span>_data<span>.</span>$$state <span>=</span> <span>null</span>
      <span>}</span><span>)</span>
    <span>}</span>
    Vue<span>.</span><span>nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> oldVm<span>.</span><span>$destroy</span><span>(</span><span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>resetStoreVM</code> 的作用实际上是想建立 <code>getters</code> 和 <code>state</code> 的联系，因为从设计上  <code>getters</code> 的获取就依赖了 <code>state</code> ，并且希望它的依赖能被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。因此这里利用了 Vue 中用 <code>computed</code> 计算属性来实现。</p>
<p><code>resetStoreVM</code> 首先遍历了 <code>_wrappedGetters</code> 获得每个 <code>getter</code> 的函数 <code>fn</code> 和 <code>key</code>，然后定义了 <code>computed[key] = () =&gt; fn(store)</code>。我们之前提到过 <code>_wrappedGetters</code> 的初始化过程，这里 <code>fn(store)</code> 相当于执行如下方法：</p>
<div><pre><code>store<span>.</span>_wrappedGetters<span>[</span>type<span>]</span> <span>=</span> <span>function</span> <span>wrappedGetter</span> <span>(</span><span>store</span><span>)</span> <span>{</span>
  <span>return</span> <span>rawGetter</span><span>(</span>
    local<span>.</span>state<span>,</span> <span>// local state</span>
    local<span>.</span>getters<span>,</span> <span>// local getters</span>
    store<span>.</span>state<span>,</span> <span>// root state</span>
    store<span>.</span>getters <span>// root getters</span>
  <span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>返回的就是 <code>rawGetter</code> 的执行函数，<code>rawGetter</code> 就是用户定义的 <code>getter</code> 函数，它的前 2 个参数是 <code>local state</code> 和 <code>local getters</code>，后 2 个参数是 <code>root state</code> 和 <code>root getters</code>。</p>
<p>接着实例化一个 Vue 实例 <code>store._vm</code>，并把 <code>computed</code> 传入：</p>
<div><pre><code>store<span>.</span>_vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>$$state</span><span>:</span> state
  <span>}</span><span>,</span>
  computed
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们发现 <code>data</code> 选项里定义了 <code>$$state</code> 属性，而我们访问 <code>store.state</code> 的时候，实际上会访问 <code>Store</code> 类上定义的 <code>state</code> 的 <code>get</code> 方法：</p>
<div><pre><code><span>get</span> <span>state</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>_vm<span>.</span>_data<span>.</span>$$state
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>它实际上就访问了 <code>store._vm._data.$$state</code>。那么 <code>getters</code> 和 <code>state</code> 是如何建立依赖逻辑的呢，我们再看这段代码逻辑：</p>
<div><pre><code><span>forEachValue</span><span>(</span>wrappedGetters<span>,</span> <span>(</span><span>fn<span>,</span> key</span><span>)</span> <span>=></span> <span>{</span>
    <span>// use computed to leverage its lazy-caching mechanism</span>
    computed<span>[</span>key<span>]</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>fn</span><span>(</span>store<span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>store<span>.</span>getters<span>,</span> key<span>,</span> <span>{</span>
      <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> store<span>.</span>_vm<span>[</span>key<span>]</span><span>,</span>
      <span>enumerable</span><span>:</span> <span>true</span> <span>// for local getters</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当我根据 <code>key</code> 访问 <code>store.getters</code> 的某一个 <code>getter</code> 的时候，实际上就是访问了 <code>store._vm[key]</code>，也就是 <code>computed[key]</code>，在执行 <code>computed[key]</code> 对应的函数的时候，会执行 <code>rawGetter(local.state,...)</code> 方法，那么就会访问到 <code>store.state</code>，进而访问到 <code>store._vm._data.$$state</code>，这样就建立了一个依赖关系。当 <code>store.state</code> 发生变化的时候，下一次再访问 <code>store.getters</code> 的时候会重新计算。</p>
<p>我们再来看一下 <code>strict mode</code> 的逻辑：</p>
<div><pre><code><span>if</span> <span>(</span>store<span>.</span>strict<span>)</span> <span>{</span>
  <span>enableStrictMode</span><span>(</span>store<span>)</span>
<span>}</span>

<span>function</span> <span>enableStrictMode</span> <span>(</span><span>store</span><span>)</span> <span>{</span>
  store<span>.</span>_vm<span>.</span><span>$watch</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>this</span><span>.</span>_data<span>.</span>$$state <span>}</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
      <span>assert</span><span>(</span>store<span>.</span>_committing<span>,</span> <span><span>`</span><span>Do not mutate vuex store state outside mutation handlers.</span><span>`</span></span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>{</span> <span>deep</span><span>:</span> <span>true</span><span>,</span> <span>sync</span><span>:</span> <span>true</span> <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当严格模式下，<code>store._vm</code> 会添加一个 <code>wathcer</code> 来观测 <code>this._data.$$state</code> 的变化，也就是当 <code>store.state</code> 被修改的时候, <code>store._committing</code> 必须为 true，否则在开发阶段会报警告。<code>store._committing</code> 默认值是 <code>false</code>，那么它什么时候会 true 呢，<code>Store</code> 定义了 <code>_withCommit</code> 实例方法：</p>
<div><pre><code><span>_withCommit</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>const</span> committing <span>=</span> <span>this</span><span>.</span>_committing
  <span>this</span><span>.</span>_committing <span>=</span> <span>true</span>
  <span>fn</span><span>(</span><span>)</span>
  <span>this</span><span>.</span>_committing <span>=</span> committing
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它就是对 <code>fn</code> 包装了一个环境，确保在 <code>fn</code> 中执行任何逻辑的时候 <code>this._committing = true</code>。所以外部任何非通过 Vuex 提供的接口直接操作修改 <code>state</code> 的行为都会在开发阶段触发警告。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此，Vuex 的初始化过程就分析完毕了，除了安装部分，我们重点分析了 <code>Store</code> 的实例化过程。我们要把 <code>store</code> 想象成一个数据仓库，为了更方便的管理仓库，我们把一个大的 <code>store</code> 拆成一些 <code>modules</code>，整个 <code>modules</code> 是一个树型结构。每个 <code>module</code> 又分别定义了 <code>state</code>，<code>getters</code>，<code>mutations</code>、<code>actions</code>，我们也通过递归遍历模块的方式都完成了它们的初始化。为了 <code>module</code> 具有更高的封装度和复用性，还定义了 <code>namespace</code> 的概念。最后我们还定义了一个内部的 <code>Vue</code> 实例，用来建立 <code>state</code> 到 <code>getters</code> 的联系，并且可以在严格模式下监测 <code>state</code> 的变化是不是来自外部，确保改变 <code>state</code> 的唯一途径就是显式地提交 <code>mutation</code>。</p>
<p>这一节我们已经建立好 <code>store</code>，接下来就是对外提供了一些 API 方便我们对这个 <code>store</code> 做数据存取的操作，下一节我们就来从源码角度来分析 <code>Vuex</code> 提供的一系列 API。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">插件</title>
    <id>https://0808200.xyz/vue2/vuex/plugin.html</id>
    <link href="https://0808200.xyz/vue2/vuex/plugin.html"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="插件" tabindex="-1"> 插件</h1>
<p>Vuex 除了提供的存取能力，还提供了一种插件能力，让我们可以监控 <code>store</code> 的变化过程来做一些事情。</p>
<p>Vuex 的 <code>store</code> 接受 <code>plugins</code> 选项，我们在实例化 <code>Store</code> 的时候可以传入插件，它是一个数组，然后在执行 <code>Store</code> 构造函数的时候，会执行这些插件：</p>
<div><pre><code><span>const</span> <span>{</span>
  plugins <span>=</span> <span>[</span><span>]</span><span>,</span>
  strict <span>=</span> <span>false</span>
<span>}</span> <span>=</span> options
<span>// apply plugins</span>
plugins<span>.</span><span>forEach</span><span>(</span><span>plugin</span> <span>=></span> <span>plugin</span><span>(</span><span>this</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在我们实际项目中，我们用到的最多的就是 Vuex 内置的 <code>Logger</code> 插件，它能够帮我们追踪 <code>state</code> 变化，然后输出一些格式化日志。下面我们就来分析这个插件的实现。</p>
<h2 id="logger-插件" tabindex="-1"> <code>Logger</code> 插件</h2>
<p><code>Logger</code> 插件的定义在 <code>src/plugins/logger.js</code> 中：</p>
<div><pre><code><span>export</span> <span>default</span> <span>function</span> <span>createLogger</span> <span>(</span><span>{</span>
  collapsed <span>=</span> <span>true</span><span>,</span>
  <span>filter</span> <span>=</span> <span>(</span><span>mutation<span>,</span> stateBefore<span>,</span> stateAfter</span><span>)</span> <span>=></span> <span>true</span><span>,</span>
  <span>transformer</span> <span>=</span> <span>state</span> <span>=></span> state<span>,</span>
  <span>mutationTransformer</span> <span>=</span> <span>mut</span> <span>=></span> mut<span>,</span>
  logger <span>=</span> console
<span>}</span> <span>=</span> <span>{</span><span>}</span><span>)</span> <span>{</span>
  <span>return</span> <span>store</span> <span>=></span> <span>{</span>
    <span>let</span> prevState <span>=</span> <span>deepCopy</span><span>(</span>store<span>.</span>state<span>)</span>

    store<span>.</span><span>subscribe</span><span>(</span><span>(</span><span>mutation<span>,</span> state</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> logger <span>===</span> <span>'undefined'</span><span>)</span> <span>{</span>
        <span>return</span>
      <span>}</span>
      <span>const</span> nextState <span>=</span> <span>deepCopy</span><span>(</span>state<span>)</span>

      <span>if</span> <span>(</span><span>filter</span><span>(</span>mutation<span>,</span> prevState<span>,</span> nextState<span>)</span><span>)</span> <span>{</span>
        <span>const</span> time <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span>
        <span>const</span> formattedTime <span>=</span> <span><span>`</span><span> @ </span><span><span>${</span><span>pad</span><span>(</span>time<span>.</span><span>getHours</span><span>(</span><span>)</span><span>,</span> <span>2</span><span>)</span><span>}</span></span><span>:</span><span><span>${</span><span>pad</span><span>(</span>time<span>.</span><span>getMinutes</span><span>(</span><span>)</span><span>,</span> <span>2</span><span>)</span><span>}</span></span><span>:</span><span><span>${</span><span>pad</span><span>(</span>time<span>.</span><span>getSeconds</span><span>(</span><span>)</span><span>,</span> <span>2</span><span>)</span><span>}</span></span><span>.</span><span><span>${</span><span>pad</span><span>(</span>time<span>.</span><span>getMilliseconds</span><span>(</span><span>)</span><span>,</span> <span>3</span><span>)</span><span>}</span></span><span>`</span></span>
        <span>const</span> formattedMutation <span>=</span> <span>mutationTransformer</span><span>(</span>mutation<span>)</span>
        <span>const</span> message <span>=</span> <span><span>`</span><span>mutation </span><span><span>${</span>mutation<span>.</span>type<span>}</span></span><span><span>${</span>formattedTime<span>}</span></span><span>`</span></span>
        <span>const</span> startMessage <span>=</span> collapsed
          <span>?</span> logger<span>.</span>groupCollapsed
          <span>:</span> logger<span>.</span>group

        <span>// render</span>
        <span>try</span> <span>{</span>
          <span>startMessage</span><span>.</span><span>call</span><span>(</span>logger<span>,</span> message<span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span>message<span>)</span>
        <span>}</span>

        logger<span>.</span><span>log</span><span>(</span><span>'%c prev state'</span><span>,</span> <span>'color: #9E9E9E; font-weight: bold'</span><span>,</span> <span>transformer</span><span>(</span>prevState<span>)</span><span>)</span>
        logger<span>.</span><span>log</span><span>(</span><span>'%c mutation'</span><span>,</span> <span>'color: #03A9F4; font-weight: bold'</span><span>,</span> formattedMutation<span>)</span>
        logger<span>.</span><span>log</span><span>(</span><span>'%c next state'</span><span>,</span> <span>'color: #4CAF50; font-weight: bold'</span><span>,</span> <span>transformer</span><span>(</span>nextState<span>)</span><span>)</span>

        <span>try</span> <span>{</span>
          logger<span>.</span><span>groupEnd</span><span>(</span><span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
          logger<span>.</span><span>log</span><span>(</span><span>'—— log end ——'</span><span>)</span>
        <span>}</span>
      <span>}</span>

      prevState <span>=</span> nextState
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>repeat</span> <span>(</span><span>str<span>,</span> times</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span><span>new</span> <span>Array</span><span>(</span>times <span>+</span> <span>1</span><span>)</span><span>)</span><span>.</span><span>join</span><span>(</span>str<span>)</span>
<span>}</span>

<span>function</span> <span>pad</span> <span>(</span><span>num<span>,</span> maxLength</span><span>)</span> <span>{</span>
  <span>return</span> <span>repeat</span><span>(</span><span>'0'</span><span>,</span> maxLength <span>-</span> num<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span>length<span>)</span> <span>+</span> num
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>插件函数接收的参数是 <code>store</code> 实例，它执行了 <code>store.subscribe</code> 方法，先来看一下 <code>subscribe</code> 的定义：</p>
<div><pre><code><span>subscribe</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>return</span> <span>genericSubscribe</span><span>(</span>fn<span>,</span> <span>this</span><span>.</span>_subscribers<span>)</span>
<span>}</span>

<span>function</span> <span>genericSubscribe</span> <span>(</span><span>fn<span>,</span> subs</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>subs<span>.</span><span>indexOf</span><span>(</span>fn<span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
    subs<span>.</span><span>push</span><span>(</span>fn<span>)</span>
  <span>}</span>
  <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> i <span>=</span> subs<span>.</span><span>indexOf</span><span>(</span>fn<span>)</span>
    <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      subs<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>subscribe</code> 的逻辑很简单，就是往 <code>this._subscribers</code> 去添加一个函数，并返回一个 <code>unsubscribe</code> 的方法。</p>
<p>而我们在执行 <code>store.commit</code> 的方法的时候，会遍历 <code>this._subscribers</code> 执行它们对应的回调函数：</p>
<div><pre><code><span>commit</span> <span>(</span><span>_type<span>,</span> _payload<span>,</span> _options</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span>
    type<span>,</span>
    payload<span>,</span>
    options
  <span>}</span> <span>=</span> <span>unifyObjectStyle</span><span>(</span>_type<span>,</span> _payload<span>,</span> _options<span>)</span>

  <span>const</span> mutation <span>=</span> <span>{</span> type<span>,</span> payload <span>}</span>
  <span>// ...</span>
  <span>this</span><span>.</span>_subscribers<span>.</span><span>forEach</span><span>(</span><span>sub</span> <span>=></span> <span>sub</span><span>(</span>mutation<span>,</span> <span>this</span><span>.</span>state<span>)</span><span>)</span>  
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>回到我们的 <code>Logger</code> 函数，它相当于订阅了 <code>mutation</code> 的提交，它的 <code>prevState</code> 表示之前的 <code>state</code>，<code>nextState</code> 表示提交 <code>mutation</code> 后的 <code>state</code>，这两个 <code>state</code> 都需要执行 <code>deepCopy</code> 方法拷贝一份对象的副本，这样对他们的修改就不会影响原始 <code>store.state</code>。</p>
<p>接下来就构造一些格式化的消息，打印出一些时间消息 <code>message</code>， 之前的状态 <code>prevState</code>，对应的 <code>mutation</code> 操作 <code>formattedMutation</code> 以及下一个状态 <code>nextState</code>。</p>
<p>最后更新 <code>prevState = nextState</code>，为下一次提交 <code>mutation</code> 输出日志做准备。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>那么至此 Vuex 的插件分析就结束了，Vuex 从设计上支持了插件，让我们很好地从外部追踪 <code>store</code> 内部的变化，<code>Logger</code> 插件在我们的开发阶段也提供了很好地指引作用。当然我们也可以自己去实现 <code>Vuex</code> 的插件，来帮助我们实现一些特定的需求。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue.js 3.x 源码解析先导</title>
    <id>https://0808200.xyz/vue3/guide/</id>
    <link href="https://0808200.xyz/vue3/guide/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vue-js-3-x-源码解析先导" tabindex="-1"> Vue.js 3.x 源码解析先导</h1>
<h2 id="前言" tabindex="-1"> 前言</h2>
<p>2018 年 6 月我在慕课网发布了 Vue.js 2.x 的源码解析课程 <a href="https://coding.imooc.com/class/228.html" target="_blank" rel="noopener noreferrer">《Vue.js 源码全方位深入解析》</a>，同时也开源了课程配套<a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener noreferrer">电子书</a>。时隔一年多，Vue 官方也开源了 Vue.js 3.x，那么在不久的将来，我也会系统化地做 Vue.js 3.x 的源码分析，同时更新我的这门课程视频以及电子书。</p>
<p>Vue.js 3.x 源码刚开源不久，很多人都非常兴奋，我也不例外。我写下这篇文章作为 Vue.js 3.x 源码解析课程的先导片，和大家聊聊我对 Vue.js 源码的一些感悟。</p>
<h2 id="聊聊-vue-js-3-x" tabindex="-1"> 聊聊 Vue.js 3.x</h2>
<h3 id="vue-js-3-x-目前的状态" tabindex="-1"> Vue.js 3.x 目前的状态</h3>
<p>Vue.js 3.x 目前处于 <strong>Pre-Alpha</strong> 的状态，从 Vue 官方的 <a href="https://github.com/vuejs/vue/projects/6" target="_blank" rel="noopener noreferrer">Roadmap</a> 来看，2019 年 Q3 结束前开源 Vue 3.x 的源码，Q4 除了继续完善 Vue.js 核心源码之外，还要补齐周边的生态建设：如 <code>vue-router</code>、<code>vuex</code>、<code>vue-cli</code>、<code>Vue Devtools</code>、<code>JSX</code> 等，在 Q4 结束前才会发布 Alpha 版本。但是 Alpha 版本也只是内部测试版本，之后还要经历 Beta 对外测试版本，RC 候选发布版本、最后才会到正式的 Realase 版本，所以距离大家在生产环境投入使用还有很长的时间。那么这段时间，对于 Vue.js 3.x 我可以做哪些事情呢。</p>
<h3 id="vue-js-rfc" tabindex="-1"> Vue.js RFC</h3>
<p>Vue.js 官方设立 RFC 的初衷是为了让 Vue.js 本身的开发流程更加规范化，当有一个新功能的想法出现，会先发布一份 RFC 的提案，由社区在一起讨论，当提案通过后再去开发实现。</p>
<p>Vue.js 3.x 在开发之前也发布了多份 RFC 提案，其中讨论比较多的是 Vue.js 3.x 关于组件的写法，由最初的 <a href="https://github.com/vuejs/rfcs/pull/17" target="_blank" rel="noopener noreferrer">Class-API</a> 提案被废弃到之后热烈讨论的 <a href="https://github.com/vuejs/rfcs/pull/42" target="_blank" rel="noopener noreferrer">Function-based component API</a>，再到最后确认的基于 <code>Function-based component API</code> 修订的 <a href="https://github.com/vuejs/rfcs/pull/78" target="_blank" rel="noopener noreferrer">Composition API</a>，经历了很长一段的时间，期间社区出现了不少反对的声音，比如 “和 React 更像了，为啥我不直接用 React”、“Class API 更好”、“Vue.js 变得一点都不简单了” 等等，官方都做了很好的<a href="https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md" target="_blank" rel="noopener noreferrer">回应</a>，因此学习 Vue.js 3.x，你应该先去学习这份 <a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener noreferrer">RFC</a>。</p>
<p>通过这份 RFC 的学习，你会大致了解 Vue.js 3.x 组件的写法、详细设计、甚至是一些”缺点“。Vue.js 3.x 摒弃了 2.x <code>Options API</code>，拥抱了 <code>Composition API</code>，为了更好的逻辑复用、代码组织以及更好的类型推导。</p>
<h3 id="vue-js-3-x-尝鲜" tabindex="-1"> Vue.js 3.x 尝鲜</h3>
<p>Vue.js 3.x <a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener noreferrer">源码</a>已经开放，虽然没有发布，但是我们可以 clone 下来，安装好相关依赖，构建一份打包后的代码为自己所用。</p>
<p>在阅读完 <code>Composition API</code> 的 RFC 后，我们已经对 Vue.js 3.x 组件的写法有了一定了解，并且 2.x 的大部分 feature 3.x 都已经支持，我们用 3.x 写一个简单的 demo 问题应该不大。我前段时间就基于 Vue 3.x 写了一个 todomvc 的 demo，感兴趣的同学可以去 <a href="https://github.com/ustbhuangyi/vue-3.x-demos" target="_blank" rel="noopener noreferrer">GitHub</a>  clone 下来跑跑看看。</p>
<p>在写 demo 的时候我还遇到了 <code>v-model</code> 实现的坑，对源码一番调试后大致定位了原因，不过由于牵涉到核心的改动会比较多，所以我和尤大反馈了一下（微信提 issue），官方很快就修复了这个问题。</p>
<h3 id="vue-js-3-x-源码" tabindex="-1"> Vue.js 3.x 源码</h3>
<p>Vue.js 3.x 源码放出来的第二天，社区就有出来源码分析的文章，不过看了好几篇都是在分析 <code>Reactive</code> 相关的 API，给人的错觉好像 Vue 只有响应式一样，甚至还有某些培训机构也跟着蹭起了热度。有些文章写的还是很不错的，比如我记得掘金有一篇是教大家从单测看起，确实是一个很好的学习源码的思路，但还有几篇也未免有蹭热度之嫌。对我而言，除了 <code>Reactive</code>，我更愿意去关注 <code>Setup</code> 函数的初始化逻辑、<code>Compile</code> 过程的优化、<code>Render</code> 写法的变化、以及 <code>Patch</code> 过程的优化。</p>
<p>Vue.js 3.x 源码采用了 monorepo 的管理方式，采用 TypeScript 编写，对于 Vue.js 的开发者而言，这种方式是更易于维护源码的。如果你想学习 Vue.js 3.x 的源码，首先你得学会 TypeScript。</p>
<p>对于大部分人而言，现在去看 Vue.js 3.x 的源码还为时过早了，主要是你现在还用不到，我之前在掘金发布过一篇文章<a href="https://juejin.im/post/5b18d2d7f265da6e410e0e20" target="_blank" rel="noopener noreferrer">来聊聊源码学习</a>，现在还不是学习 Vue.js 3.x 源码的好时机。</p>
<p>但是如果你是一个对技术非常有热情的人，在早期去学习 Vue.js 3.x 源码，甚至去参与 Vue.js 3.x 的开发共建，对自己的技术提升还是有很大帮助的。</p>
<h2 id="vue-js-2-x-源码过时了吗" tabindex="-1"> Vue.js 2.x 源码过时了吗</h2>
<p>Vue.js 3.x 源码开放了，很多小伙伴不免担心，我现在学习 Vue.js 2.x 的源码过时了吗？</p>
<h3 id="成熟稳定的-vue-js-2-x" tabindex="-1"> 成熟稳定的 Vue.js 2.x</h3>
<p>Vue.js 2.x 从 16 年底发布距今已接近 3 年，有无数大厂已经使用 Vue.js 重构和开发项目，Vue.js 2.x 的 npm 下载量每月有 90 多万，Jsdelivr CDN 每月有 5 亿次引用，Chrome DevTools 每周有 90 万的活跃用户。如此庞大的用户量足以说明 Vue.js 是一个非常靠谱和成熟的框架，另外官网对 Issue、Pull Request 的响应也是比较快的，除了高达 97% 的单元测试之外，官方还尝试做了一些<a href="https://github.com/vuejs/regression-testing" target="_blank" rel="noopener noreferrer">回归测试</a>。</p>
<p>我们知道 Vue.js 是一个渐进式框架，除了官方提供的一些生态插件 <code>vue-router</code>、<code>vuex</code>、<code>vue-cli</code> 之外，社区还有非常多的优秀的轮子如 <code>element-ui</code>、<code>cube-ui</code>、<code>vue-lazyload</code>、<code>vue-i18n</code> 等，这些插件能很好地辅助我们平时的业务开发。</p>
<h3 id="升级的成本" tabindex="-1"> 升级的成本</h3>
<p>Vue .js 2.x -&gt; Vue.js 3.x 升级还是有一定的成本的，虽然说官方会出一个保留 <code>Options API</code> 的写法的版本，但是未免还会有一些 breaking change 的，比如手写 <code>render</code> 函数部分语法就已经发生了改变，模板写法也会发生一些变化。未来应该会出一个代码升级的指南，甚至会用工具帮我们做一部分工作，但是大规模的产线项目做核心框架升级，还是有相当大的成本和风险的。</p>
<p>如果你的业务代码升级到 Vue.js 3.x，也就意味着你依赖的生态插件也需要升级到 Vue.js 3.x，比如 <code>element-ui</code> 这种大型项目，升级起来也是有相当大的工作量的，所以你需要先等到你依赖的生态插件升级到 Vue.js 3.x 并且稳定后，你才能考虑在你的业务中做框架升级。</p>
<p>Vue.js 1.x -&gt; Vue.js 2.x 的升级似乎没有那么麻烦，那是因为 Vue.js 1.x 的时候用户规模还很小，生态也没有起来，甚至很多公司直接上手的 Vue.js 2.x，并没有历史包袱。</p>
<h3 id="痛点" tabindex="-1"> 痛点</h3>
<p>Vue.js 1.x -&gt; Vue.js 2.x 的升级变化还是很明显的，虚拟 DOM 在 Vue.js 2.x 中得以实现，它让服务端渲染、跨端渲染成为可能。我们来看一下 Vue.js 3.x 的设计目标：更小、更快、加强 TypeScript 支持、加强 API 设计一致性、提升自身可维护性、开放更多的底层功能。对大部分用户而言，更小更快是一个吸引点，对于 TypeScript 用户而言，加强 TypeScript 支持是一个吸引点，但是这些能解决开发中的痛点么？</p>
<p>除非  Vue.js 3.x 能解决 Vue.js 2.x 开发中的痛点（比如我这个项目有性能瓶颈，性能的提升能帮助我解决这个性能瓶颈），否则重构的成本和它来带来的收益就是一个需要权衡的问题。另外考虑到 Vue.js 3.x 用了一些 ES6 的新特性如 Proxy，在浏览器兼容性这块也是需要考虑的。</p>
<p>老板通常是不会允许你做这种纯技术重构的，如果你想用 Vue.js 3.x 做重构，一定要抓到痛点，把重构的收益和老板说清楚。</p>
<p>虽然老项目用 Vue.js 3.x 重构会有很大的成本和风险，我们也可以在一些非核心的新项目中去尝试新技术，当然这一切也是需要等待 Vue.js 3.x 正式发布以及依赖的 Vue 插件都更新支持 Vue.js 3.x 才可以。</p>
<h3 id="结论" tabindex="-1"> 结论</h3>
<p>Vue.js 3.x 想全面替代 Vue.js 2.x 需要有相当长的路要走，未来相当长一段时间 Vue.js 2.x 仍然是主流，Vue.js 2.x 的源码学习并没有过时，如果你是一个 Vue.js 2.x 的使用者，就应该去学习 Vue.js 2.x 的源码。</p>
<h2 id="我应该学习源码吗" tabindex="-1"> 我应该学习源码吗</h2>
<p>很多人都有困惑，我会使用不就行了吗，为什么还要学习源码呢？</p>
<h3 id="学习源码的好处" tabindex="-1"> 学习源码的好处</h3>
<p>学习是为了更好的工作，工作中难免会遇到一些问题，学习源码最直接的好处是能帮你直接定位问题的根本原因，从而帮助你解决问题。很多人抱怨加班多，不妨问问自己，有多少时间是在写业务，多少时间是在写（找） bug。快速定位问题解决 bug，可以有效地提升你的工作效率，很可能就不用加班了，甚至会多出学习的时间，形成一个良性循环。</p>
<p>学习源码可以很好地巩固基础，修炼内功，提升技术。前端几乎都会学习 JS 的基础知识，如类型、变量、函数、作用域、闭包、原型链、event loop 等知识，但很多人很难把这些知识在实践中运用自如，主要原因还是实践的少了，大部分时间都在写业务的胶水代码。学习 Vue.js 这类框架的源码，会不断去巩固这些知识点，如果你源码看熟练了，那么你的 JS 基础就会更扎实。</p>
<p>学习源码有助于你更好地理解所用的技术栈，更熟练地在工作中运用。比如你深入学习了 Vue.js 的核心源码，你会理解 Vue.js 框架产生的意义、Vue.js 的职责边界、数据驱动的本质；你还会知道如何实现的组件化，在什么生命周期应该做什么事情，如何编写 Vue.js 的插件，如何和其它第三方 JS 库深度结合。你再也不会问“如何用 Vue 实现 XXX” 的傻问题了。</p>
<p>学习源码可以让我们站在巨人的肩膀上，Vue.js 这么优秀，尤大也是参考了很多其他优秀源码的实现，比如 Vue.js 2.x  <code>Virtual DOM</code> 部分参考了 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">snabbdom</a>，Vue.js 3.x <code>Reactive</code> 的实现参考了<a href="https://docs.meteor.com/api/tracker.html" target="_blank" rel="noopener noreferrer">Meteor Tracker</a> 和 <a href="https://github.com/salesforce/observable-membrane" target="_blank" rel="noopener noreferrer">salesforce/observable-membrane</a> 等。我们在阅读的源码的时候，也可以把源码中的优秀的设计思想、代码实现吸纳到我们平时的开发工作中。</p>
<p>学习源码还有一个偏功利的作用，应付面试。越来越多的公司在面试环节会考察候选人对所用技术栈实现原理的考察，主要目的还是考察候选人的技术能力以及技术热情和追求，因为通常对技术热爱的人通常都会保持技术好奇，乐于探究所用到的技术栈的实现原理。但是往往以这个目的去学习源码的同学是学不好的，对源码的理解很浅，甚至出现了死记硬背的情况。所以学习好源码可以帮助我们在面试中应答自如，但是我们不应该为了面试去学习源码。</p>
<h3 id="学源码的时机" tabindex="-1"> 学源码的时机</h3>
<p>通常我们去学习一个技术栈的源码的时机是在我们对他的使用已经很熟练的情况，比如你是一个 Vue.js 的一年以上经验的使用者，那么你已经可以去学习它的源码了，这时候你的学习应该是系统化地学习。</p>
<p>当你工作中使用某一个新框架的时候遇到一个奇怪的问题，通过查阅文档也未能解决，这个时候你也可以去看源码，当然这个时候并不需要系统地去学习，只需要把和你问题相关的源码理解了，找到问题即可。当然想达到这一步就需要你有快速阅读源码定位问题的能力，这个能力也是在你不断去阅读大量优秀源码过程中锻炼的。</p>
<h3 id="学不动了怎么办" tabindex="-1"> 学不动了怎么办</h3>
<p>源码学习的好处我们已经介绍了很多，但是源码学习的本身是枯燥的，抽象的，它没有直观酷炫的效果，学习起来费脑子，是很多人直呼学不动的原因。</p>
<p>其实学不动的主要原因还是因为没掌握好的学习方法，好的方法能让你事半功倍，正如我在<a href="https://juejin.im/post/5b18d2d7f265da6e410e0e20" target="_blank" rel="noopener noreferrer">来聊聊源码学习</a> 文章中提到的几个方法，全盘了解、问题驱动、主线优先、参与共建、阅读技巧、辅助资料。除了这些方法，根据我源码课程中一些学的不错的同学的经验，自己在学习的过程中多记笔记，多在课程问答区提问，甚至最后自己产出源码分析系列文章，都能非常好的辅助学习源码。其实做这些事情都是不断在帮助自己建立自信和成就感，激发学习兴趣，把无趣的事情变得有趣和有意义。</p>
<h2 id="课程后续计划" tabindex="-1"> 课程后续计划</h2>
<p><s>源码课程会等待 Vue.js 3.x 发布正式版本且稳定后会开始准备重新录制，仍然是电子书和视频的方式。</s></p>
<p><s>重新录制的源码课程不仅仅会讲清楚源码实现流程，还会多加入一些使用场景、设计原因的分析。</s></p>
<p><s>翻新课程是在原课程的基础上增加 Vue.js 3.x 的章节，已购买课程的同学可以继续学习，无需购买新课程。</s></p>
<p><s>先学会用再学原理，因此在 Vue.js 3.x 正式发布后，我会优先重新录制 <a href="https://coding.imooc.com/class/107.html" target="_blank" rel="noopener noreferrer">《Vue2.0开发企业级移动端音乐Web App》</a>课程，同样是免费升级喔。</s></p>
<p><s>音乐课程 + 源码课程的重新录制，是我明年的主要计划，暂无计划出新课程了。除了版本的升级，我会像<a href="https://coding.imooc.com/class/74.html" target="_blank" rel="noopener noreferrer">《Vue.js2.5 + cube-ui重构饿了么App》</a>升级课程那样尽量往课程中加入一些新东西的，敬请期待</s></p>
<p>参考 <RouterLink to="/vue3/guide/">聊聊我的新课《Vue.js 3.0 核心源码解析》​
</RouterLink></p>
<p>Vue.js 3.0 源码解析课程制作完毕后，我会启动<a href="https://coding.imooc.com/class/107.html" target="_blank" rel="noopener noreferrer">《Vue2.0开发企业级移动端音乐Web App》</a>课程的 Vue.js 3.0 的重构 + 重新录制，免费升级。</p>
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">Vue.js 3.0 核心源码解析​</title>
    <id>https://0808200.xyz/vue3/new/</id>
    <link href="https://0808200.xyz/vue3/new/"/>
    <updated>2022-08-29T09:14:21.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>聊聊我的新课《Vue.js 3.0 核心源码解析》​</p>
</blockquote>
<h2 id="我为什么做这门课程" tabindex="-1"> 我为什么做这门课程</h2>
<p>2020 年 7 月 6 日，我的课程 《Vue.js 3.0 核心源码解析》在拉勾教育平台上线了，我想和大家聊聊我为什么做这门课，源码学习的心得以及与拉勾合作的一些感受。</p>
<p>从 16 年底到现在，我每年都会出一门新课，截止到去年，我在慕课网已经上线了 4 门视频课程了。不过出视频课对我来说确实效率太低了，因为我个人的毛病，如果我在录制过程中有一些小瑕疵或者是讲错了，我是不会继续讲然后让后期剪辑，而是会停下来重新录制，结果就导致一小段视频不断地 NG，录制效率非常低下。</p>
<p>所以 19 年我录完 《TypeScript 重构 Axios》课程后，就不打算做新课了，心想着维护一下现有的几门课程得了。但后来想想是不是还得产出点啥，于是 19 年下半年注册了公众号，写写原创文章应该也不错，因为工作相关的原因，我打算写系列 ElementUI 源码分析的文章，但不幸的是，我写着写着，突然有一天就不想写了。</p>
<p>到现在我的草稿里还有一篇没发出去的文章，因为我发现 ElementUI 的源码对我来说太简单了，而且有些地方的实现也很粗糙，写完一看阅读数还没有一些撒鸡汤的文章多，评论也很少，我写下去没有动力和成就感了，对自己的提升也非常有限。于是，我鸽了，是的，我第一次在公开场合承认我鸽了，对不起。</p>
<p>2020 年 4 月，拉勾的运营找到了我，问我愿不愿意合作一门 Vue.js 3.0 的课程。原本我是拒绝的，但是她说就是做一个专栏类的课程，主要通过文字 + 音频的形式呈现，我心想写文章那不是我擅长的么，也不会占用太多时间，于是我就说我考虑一下。</p>
<p>从我 18 年做 《Vue.js 2.x 源码解析》课程的经验来看，源码这类抽象的技术用视频的方式呈现，对讲师来说是一个极大的挑战，我录完课程发现自己的发际线都明显高了一截，因为录起来实在太累了，一些比较深入的知识点，视频方式也不利于呈现。但是如果是写文章，那么就可以写的非常深入，而且不用担心过程中出错，因为写文章出错，改改就好了，最终呈现给用户就是完美的，而录视频的过程中是音画同步的，出一点错就得重来。</p>
<p>Vue.js 3.0 从去年下半年开始的 alpha 版本出来，社区就出来一些源码解析类文章，不过大部分都是分析 Vue.js 3.0 的响应式模块的实现，搞的就跟 Vue.js 3.0 就只有响应式一样。当然，响应式确实是一个很大的变化，但除此之外，Composition API，组件的渲染更新方式，编译的实现和优化，新的内置组件这些都是我感兴趣的东西，于是我系统地研究了一波 Vue.js 3.0 的源码，当然也希望自己能系统地输出 Vue.js 3.0 的源码解析文章。</p>
<p>所以我最终答应了和拉勾的合作，并且你们也不用担心这门课程被鸽了，因为有合同呢，如果擅自鸽的话要支付一大笔违约金：）</p>
<h2 id="学习源码在工作中的收益" tabindex="-1"> 学习源码在工作中的收益</h2>
<p>有些人可能会好奇，我平时去研究这些源码有用吗？对我来说，用处非常大。</p>
<p>今年 5 月份，我所在的公司 Zoom 在我们的 Web 项目中开启了 CSP 安全策略，其中把 <code>unsafe-eval</code> 从 <code>script-src</code> 中拿掉了，但是这么操作导致了一个很严重的问题，由于运行在 Web 的项目有一部分组件是通过 Vue.js 开发的，这部分代码全部不能正常工作了。</p>
<p>虽然我到了 Zoom 后在公司推行了前后端分离的解决方案，并用该方案重构了十几个项目，但是还有很多项目并没有来得及重构，他们仍然是直接通过 CDN 的方式引入 Vue.js，并在后端的 Java 模板中写组件的 template，然后用在运行时编译模板。我们知道编译的过程最后是生成一段 code 字符串，然后通过 <code>new Function</code> 的方式转成 render 函数，但是 CSP 安全策略开启后，<code>new Function</code>  和 <code>eval</code> 都被禁用了，导致整个编译后的流程不能进行下去。</p>
<p>既然有问题，我就得想办法解决。其实解决这个问题有两个思路，一个是全面推进前后端分离方案，使用 runtime-only 版本的 Vue.js，但这么做牵涉到所有使用 Vue.js 页面的改动，成本很高，短期不现实，是终极目标。另一个就是使用一个 CSP 兼容版本的 Vue.js，早在 Vue.js 1.x 版本的时代，Vue.js 官方提供了 Vue.js CSP 兼容版本，但是到了 Vue.js 2.x 后，官方就不再提供 CSP 兼容版本了，因为从官方的视角看，我都提供了 runtime-only 版本的解决方案了，完全没必要提供 CSP 兼容版本了。</p>
<p>但实际上 CSP 兼容版本还是有需求的，比如社区有人提过一个 <a href="https://github.com/vuejs/vue/issues/9895" target="_blank" rel="noopener noreferrer">issue</a>，然而官方压根就没搭理（从我做的经验来看，做这玩意成本还是不小的，花 99% 的精力解决 1% 的人的问题的买卖显然不会做）。</p>
<p>虽然官方没有直接支持 CSP 兼容版本的 Vue.js，但对于我们来说，现阶段最小成本解决问题的方式就是使用一个 CSP 兼容版本的 Vue.js，所以只能魔改 Vue.js 了。</p>
<p>那么，我们应该改哪些部分呢？</p>
<p>首先，<code>new Function</code> 不能用了，那么生成的 code 字符串如何执行呢？经过调研，我选用了 notevil 这个库，它其实就是用 JavaScript 去实现 JavsScript 的解析引擎，大致原理是先把源码解析成 AST 树，再去遍历 AST 树，对不同类型的节点做不同的处理，达到最终执行 JavaScript 代码的目的。但是 notevil 的实现还是不够完整，比如一些 ES6 的语法，像箭头函数、数组对象的解构赋值，是不支持的；此外，还有一个致命的影响：对 <code>with</code> 的语法不支持。</p>
<p>Vue.js 2.x 组件模板最终编译的代码，是使用 <code>with</code> 语法做了一层包装，举个例子：</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>  
  {{ message }}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上述组件模板，最终编译生成的 code 如下：</p>
<div><pre><code><span>with</span><span>(</span><span>this</span><span>)</span><span>{</span><span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>message<span>)</span><span>)</span><span>]</span><span>)</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这是什么意思呢，首先，Vue.js 为了让用户使用方便，在模板中访问数据不用手动加 <code>this</code>，但是实际上在模板中引用的变量都是定义在组件实例中的。比如我们上述例子中的 <code>message</code> 和 <code>text</code>，都是定义在组件实例上的，所以如果不用 <code>with(this)</code> 的话，我们需要生成如下的代码：</p>
<div><pre><code><span>function</span><span>(</span><span>_ctx</span><span>)</span> <span>{</span>
  <span>return</span> _ctx<span>.</span><span>_c</span><span>(</span>'div<span>,</span><span>[</span>_ctx<span>.</span><span>_v</span><span>(</span>_ctx<span>.</span><span>_s</span><span>(</span>_ctx<span>.</span>message<span>)</span><span>)</span><span>]</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>我们定义一个函数，接受一个 <code>_ctx</code>  参数，这个 <code>_ctx</code> 在运行时就是组件传入的实例对象 <code>this</code>。</p>
<p>这个时候，你可能会说，这有何难的，我们给所有的变量和函数的对象前面加上 <code>_ctx</code> 前缀不就可以了吗，但事情并没有你想的那么简单，我们简单地对上述示例做个变形：</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>  
  {{ message + text }}
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>显然，由于模板中可能存在复杂的表达式，我们最终希望的结果如下：</p>
<div><pre><code><span>function</span><span>(</span><span>_ctx</span><span>)</span> <span>{</span>
  <span>return</span> _ctx<span>.</span><span>_c</span><span>(</span>'div<span>,</span><span>[</span>_ctx<span>.</span><span>_v</span><span>(</span>_ctx<span>.</span><span>_s</span><span>(</span>_ctx<span>.</span>message <span>+</span> _ctx<span>.</span>text<span>)</span><span>)</span><span>]</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>整个事情就变成了，我需要给生成代码中该加 <code>this</code> 的地方加 <code>this</code>。所以抛开了 <code>with this</code>，我们需要实现上述需求，怎么搞呢？</p>
<p>Vue.js 2.x 的编译会经过三个过程：template 解析生成 AST ——&gt; AST 优化 ——&gt; AST 生成 code。我的思路是尽量不改这三个过程，然后到最后再去加一个过程：转换生成的 code。对于前面的例子，也就是想办法把</p>
<div><pre><code><span>return</span> <span>_c</span><span>(</span><span>'div'</span><span>,</span><span>[</span><span>_v</span><span>(</span><span>_s</span><span>(</span>message <span>+</span> text<span>)</span><span>)</span><span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转换成</p>
<div><pre><code><span>function</span><span>(</span><span>_ctx</span><span>)</span> <span>{</span>
  <span>return</span> _ctx<span>.</span><span>_c</span><span>(</span>'div<span>,</span><span>[</span>_ctx<span>.</span><span>_v</span><span>(</span>_ctx<span>.</span><span>_s</span><span>(</span>_ctx<span>.</span>message <span>+</span> _ctx<span>.</span>text<span>)</span><span>)</span><span>]</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>具体怎么做呢，因为模板的可能性有千万种，所以最靠谱的方式就是先把转换前的代码解析生成 AST，再去遍历这颗 AST，根据语法在相关的位置上加上前缀（修改 AST 的 节点），最后再把修改后的 AST 转换成代码。</p>
<p>我利用了 recast 库完成了code → AST 和  AST → code ，estree-walker 库去遍历 AST 的节点，通过一系列判断条件去判断这个节点需不需要加前缀。我们需要注意的是，函数的参数不能加前缀，局部变量不能加前缀，全局内置变量不能加前缀，已经加过前缀的节点不能加前缀等。</p>
<p>这里比较有意思的地方是要考虑函数嵌套函数，也就是有闭包的情况。需要设计一个堆栈的数据结构，在函数进入入栈，函数退出出栈，如果是外层函数中定义的变量，内部函数是不能加前缀的。</p>
<p>这里的第三方依赖 recast、estree-walker 原本都是在 node.js 端跑的，为了让它们在前端运行，我也分别 clone 了它们的代码， 用 rollup 对它们做打包，并删除了内部一些 node only 的代码和一定程度的魔改，最终编译出一份在 web 端跑的代码，放到了 lib 目录。</p>
<p>具体代码细节我就不介绍了，我之所以有上述思路，其实是因为我研究过 Vue.js 3.0 的编译过程，发现它在离线编译的时候也会把结果编译成带前缀的，然后我就把它的实现原理搞清楚了，核心代码借过来，然后再做一些修改来支持自己特定的一些 feature，这个难题就被我解决了。最终魔改版的 Vue.js 也在主流浏览器下跑通了的 12 个 demo 以及跑通了 1300 多个单测。</p>
<p>之前一直不太理解为什么 Vue.js 编译生成的代码需要用 <code>with</code> 包一层，因为 <code>with</code> 在 ECMAScript 5 的严格模式中是被禁用的，现在终于理解了对于模板内部用到了一些复杂表达式，利用 <code>with</code> 的特性动去指定的对象中查找即可，完全不用做多余的转换，也不用引入这些 AST 解析库了，因为引入这些库要让 Vue.js 最终打包的体积大了约四倍。</p>
<p>另外，我们平时经常会强调技术选型的能力，其实技术选型的一个标准，就是你选择的第三方依赖，你能不能 hold 住。首先是你知道它的职责边界，知道它能做什么不能做什么，怎么利用它帮助你开发需求；其次是出了错你能不能快速定位到原因，知道是依赖的问题还是自身使用的问题；最后就是当它不能满足你的需求，并且官方不愿意解决或者不维护的情况下，你能不能去 fork 这个库，自己开发解决并实现。那么显然拥有这些能力就需要你对它的源码实现非常了解，所以这也是一些高阶岗位为什么会在面试中考察你对技术原理掌握的一方面原因。</p>
<h2 id="和拉勾合作的一些感受" tabindex="-1"> 和拉勾合作的一些感受</h2>
<p>最后聊聊和拉勾合作的一些感受吧，拉勾的编辑们真的很用心，每一篇稿子，他们都会反复地跟我磨稿，我课程中的图，他们也会帮我再重新美化一遍，另外他们也会根据我的文字课程做成视频 PPT，一门课出来他们真的投入了很多资源，另外拉勾的编辑小姐姐为了能看懂我的文章还特地自学了 Vue.js。</p>
<p>此外，拉勾教育真的是慈善教育，1 元购课的活动，对用户而言，几乎没有任何的决策成本，买就对了，另外买完课程还可以分销。</p>
<p>对我而言，赚钱从来就不是我做课程的主要目的，我的目的就是去输出优质的课程，帮助更多的人进阶技术，并且也在做课程的过程中提升自己，而赚钱就是它的一个附属价值，你的课程质量好，有价值，自然就会有很多人来购买学习。</p>
<p>相信通过和拉勾的合作，这门课会以最优质的状态呈现给大家，总之，如果你买了这门课程，一定要认真学习，并且有所收获，这样我和拉勾的付出就是值得的。</p>
<h2 id="写给我之前的学生" tabindex="-1"> 写给我之前的学生</h2>
<p>我在慕课的《Vue.js 2.x 的源码解析》课程，之前是计划更新的，不过目前看来是不会再更新了，如果你是这门课的学生， 并且是冲着 Vue.js 3.0 来的，那么你看到这篇文章的时候，抓紧去拉勾花 1 元购买这门课，如果错过了 1 元活动，也不要紧，你可以在公众号后台或者是 issue 区给我留言，贴上你的慕课网源码课程的购买订单，我会给你发私信，帮你们去申请 1 元购的链接。</p>
<p>另外，Vue.js 2.x 和 3.x 的源码学习不冲突，两者都很重要，并且很多思想是相同的，如果你是一个 Vue.js 的用户，你迟早都要去学习它们的。</p>
<h2 id="广告时间" tabindex="-1"> 广告时间</h2>
<p>最后，放出<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=326#/content" target="_blank" rel="noopener noreferrer">拉勾课程的链接</a></p>
<p>你可以扫下方二维码购买学习：</p>
<img :src="$withBase('/assets/qrcode.png')" alt="qrcode">
<p>也可以关注我的公众号，在后台给我留言</p>
<img :src="$withBase('/assets/qrcode_mp.jpg')" alt="qrcode_mp">
]]></content>
    <author>
      <name>ustbhuangyi</name>
    </author>
    <contributor>
      <name>ustbhuangyi</name>
    </contributor>
    <published>2022-08-29T09:14:21.000Z</published>
    <rights>Copyright by ustbhuangyi</rights>
  </entry>
  <entry>
    <title type="html">人生感悟</title>
    <id>https://0808200.xyz/note/inOnLife/</id>
    <link href="https://0808200.xyz/note/inOnLife/"/>
    <updated>2022-06-30T09:39:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="心情随笔" tabindex="-1"> 心情随笔</h2>
<div><p>介绍</p>
<p>醉生梦死</p>
</div>
]]></content>
    <published>2022-06-29T10:08:18.000Z</published>
  </entry>
  <entry>
    <title type="html">笑谈人生【一】</title>
    <id>https://0808200.xyz/note/lifeDiary/1.html</id>
    <link href="https://0808200.xyz/note/lifeDiary/1.html"/>
    <updated>2022-06-29T10:08:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="笑谈人生【一】" tabindex="-1"> 笑谈人生【一】</h1>
<div style="text-align: center"><p>精打细算你失去了多少，</p>
<p>求而不得你烦恼了多少，</p>
<p>斤斤计较你结怨了多少，</p>
<p>贪心不灭你造恶了多少，</p>
<p>日复一日你能放下多少，</p>
<p>千方百计你能得到多少，</p>
<p>人生在世你能享受多少，</p>
<p>临命终时你能带走多少?</p>
<p>唯大肚能容，</p>
<p>容天下难容之事，</p>
<p>只开口一笑，</p>
<p>笑世上可笑之人。</p>
</div>
]]></content>
    <category term="随笔" scheme=""/>
    <published>2018-08-18T00:00:00.000Z</published>
  </entry>
  <entry>
    <title type="html">笑谈人生【二】</title>
    <id>https://0808200.xyz/note/lifeDiary/2.html</id>
    <link href="https://0808200.xyz/note/lifeDiary/2.html"/>
    <updated>2022-06-29T10:08:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="笑谈人生【二】" tabindex="-1"> 笑谈人生【二】</h1>
<div style="text-align: center"><p>梦，不能做得太深，深了，难以清醒；</p>
<p>话，不能说得太满，满了，难以相通；</p>
<p>调，不能定得太高，高了，难以合声；</p>
<p>事，不能做得太绝，绝了，难以进退；</p>
<p>情，不能陷得太深，深了，难以自拔；</p>
<p>利，不能看得太重，重了，难以明志；</p>
<p>人，不能做得太假，假了，难以交心。</p>
</div>
]]></content>
    <category term="随笔" scheme=""/>
    <published>2018-08-19T00:00:00.000Z</published>
  </entry>
  <entry>
    <title type="html">笑谈人生【三】</title>
    <id>https://0808200.xyz/note/lifeDiary/3.html</id>
    <link href="https://0808200.xyz/note/lifeDiary/3.html"/>
    <updated>2022-06-29T10:08:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="笑谈人生【三】" tabindex="-1"> 笑谈人生【三】</h1>
<div style="text-align: center"><p>人生就是一阵风，起了，没了。</p>
<p>理想就是一盏灯，燃了，灭了。</p>
<p>人情就是一阵雨，下了，干了。</p>
<p>朋友就是一层云，聚了，散了。</p>
<p>闲愁就是一壶酒，醉了，醒了。</p>
<p>寂寞就是一颗星，闪了，灭了。</p>
<p>孤独就是一轮月，升了，落了。</p>
<p>死亡就是一场梦，累了，睡了。</p>
</div>
]]></content>
    <category term="随笔" scheme=""/>
    <published>2018-08-17T00:00:00.000Z</published>
  </entry>
  <entry>
    <title type="html">笑谈人生【四】</title>
    <id>https://0808200.xyz/note/lifeDiary/4.html</id>
    <link href="https://0808200.xyz/note/lifeDiary/4.html"/>
    <updated>2022-06-29T10:08:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="笑谈人生【四】" tabindex="-1"> 笑谈人生【四】</h1>
<div style="text-align: center"><p>只有淡然的心态，</p>
<p>才是人生的成熟。</p>
<p>越长大就越孤单，</p>
<p>越长大就越无奈。</p>
<p>曾经我们可以</p>
<p>肆无忌惮说的话，</p>
<p>不计后果做的事，</p>
<p>在长大的那一天，</p>
<p>终于被硬生生地</p>
<p>压回到了心底。</p>
<p>长大了，懂事了，</p>
<p>心却复杂起来了。</p>
<p>还是觉得淡然最好，</p>
<p>简单心态最快乐。</p>
<p>人生之事，计较越多，烦恼越多。</p>
<p>淡然，才是一种彻悟。</p>
<p>怀着淡然，笑看人生。</p>
</div>
]]></content>
    <category term="随笔" scheme=""/>
    <published>2018-08-26T00:00:00.000Z</published>
  </entry>
  <entry>
    <title type="html">笑谈人生【五】</title>
    <id>https://0808200.xyz/note/lifeDiary/5.html</id>
    <link href="https://0808200.xyz/note/lifeDiary/5.html"/>
    <updated>2022-06-29T10:08:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="笑谈人生【五】" tabindex="-1"> 笑谈人生【五】</h1>
<div style="text-align: center"><p>人生犹如一首歌，</p>
<p>音调高低起伏，</p>
<p>旋律抑扬顿挫；</p>
<p>人生仿佛一本书，</p>
<p>写满酸甜苦辣，</p>
<p>记录喜怒哀乐；</p>
<p>人生就像一局棋，</p>
<p>处处布满危险，</p>
<p>也撒遍了机遇；</p>
<p>人生恰似一条路，</p>
<p>有山重水复的坎坷，</p>
<p>也有柳暗花明的坦途；</p>
<p>人生如同一条河，</p>
<p>有时九曲回肠，</p>
<p>有时一泻千里。</p>
<p>成败自清醒，</p>
<p>是非一笑过。</p>
</div>
]]></content>
    <category term="随笔" scheme=""/>
    <published>2018-08-29T00:00:00.000Z</published>
  </entry>
</feed>