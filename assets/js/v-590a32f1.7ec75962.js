"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[43046],{72791:(e,n,a)=>{a.r(n),a.d(n,{default:()=>c});var t=a(60329);const s=[(0,t.uE)('<h2 id="vue2-vue3的区别" tabindex="-1"><a class="header-anchor" href="#vue2-vue3的区别" aria-hidden="true">#</a> vue2/vue3的区别</h2><p>Vue 3 的 Template 支持多个根标签，Vue 2 不支持</p><p>Vue 3 有 createApp()，而 Vue 2 的是 new Vue() createApp(组件)，new Vue({template, render})</p><p>context.emit</p><p>新增context.emit，与this.$emit（vue3中只能在methods里使用）作用相同</p><p>Vue3中的属性绑定</p><p>默认所有属性都绑定到根元素 使用inheritAttrs: false可以取消默认绑定 使用attrs或者context.attrs获取所有属性 使用v-bind=&quot;$attrs&quot;批量绑定属性 使用 const {size, level, ...rest} = context.attrs 将属性分开</p><p>使用场景 在vue2中我们在父组件绑定click事件，子组件必须内部触发click，而vue3中在父组件绑定子组件的根元素上也会跟着绑定</p><h2 id="vue3为什么要使用组合式api" tabindex="-1"><a class="header-anchor" href="#vue3为什么要使用组合式api" aria-hidden="true">#</a> vue3为什么要使用组合式API</h2><p>通过组合式 API 解决了两个问题。</p><p>我们让组件拥有了更加良好的代码组织结构</p><p>我们让相同的代码逻辑在不同的组件中进行了完整的复用</p><h2 id="vue3跨组件传值" tabindex="-1"><a class="header-anchor" href="#vue3跨组件传值" aria-hidden="true">#</a> vue3跨组件传值</h2><p>props + emit</p><p>vuex</p><p>provide 和 inject 的注入方法</p><h2 id="vue组合式api有哪些" tabindex="-1"><a class="header-anchor" href="#vue组合式api有哪些" aria-hidden="true">#</a> vue组合式API有哪些</h2><ul><li>ref()</li><li>reactive()</li><li>watch()</li><li>生命周期()</li><li>computed</li><li>watch()</li></ul><h2 id="watcheffect用来代替生命周期里的onmounted和onupdated" tabindex="-1"><a class="header-anchor" href="#watcheffect用来代替生命周期里的onmounted和onupdated" aria-hidden="true">#</a> watchEffect用来代替生命周期里的onMounted和onUpdated</h2><p>初始化页面的时候watchEffect里的代码会执行，当watchEffect里的数据有更新的时候同样会执行</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// -&gt; logs 0</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  count<span class="token punctuation">.</span>value<span class="token operator">++</span>\n  <span class="token comment">// -&gt; logs 1</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>\n注意watchEffect第一次运行是在组件挂载之前，如果需要访问<span class="token constant">DOM</span>需要将我们的watchEffect放在onMounted里\n\n<span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vite和webpack的区别" tabindex="-1"><a class="header-anchor" href="#vite和webpack的区别" aria-hidden="true">#</a> vite和webpack的区别</h2><p>vite是按需加载,他的优势在开发环境,启动是不打包,即不需要分析模块依赖,也不需要编译,启动速度就快,动态编译模块缩短了编译的时间</p><p>webpack是全部加载,在启动开发服务器时会先打包再启动开发服务器</p><h2 id="vite创建vue项目和vue-cli创建项目的区别" tabindex="-1"><a class="header-anchor" href="#vite创建vue项目和vue-cli创建项目的区别" aria-hidden="true">#</a> vite创建vue项目和vue-cli创建项目的区别</h2><p>vite是web开发构建工具</p><p>vue-cli是官方的vue.js项目脚手架</p>',27)],p={},c=(0,a(13860).Z)(p,[["render",function(e,n){return(0,t.wg)(),(0,t.iD)("div",null,s)}]])},13860:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,t]of n)a[e]=t;return a}},40735:(e,n,a)=>{a.r(n),a.d(n,{data:()=>t});const t=JSON.parse('{"key":"v-590a32f1","path":"/Interview/h5/vue3.html","title":"Vue3","lang":"zh-CN","frontmatter":{"title":"Vue3","icon":null,"date":"2023-02-18T00:00:00.000Z","category":["Interview"],"summary":"vue2/vue3的区别 Vue 3 的 Template 支持多个根标签，Vue 2 不支持 Vue 3 有 createApp()，而 Vue 2 的是 new Vue() createApp(组件)，new Vue({template, render}) context.emit 新增context.emit，与this.$emit（vue3中只能在m","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/Interview/h5/vue3.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"Vue3"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-22T05:24:57.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2023-02-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-22T05:24:57.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"vue2/vue3的区别","slug":"vue2-vue3的区别","children":[]},{"level":2,"title":"vue3为什么要使用组合式API","slug":"vue3为什么要使用组合式api","children":[]},{"level":2,"title":"vue3跨组件传值","slug":"vue3跨组件传值","children":[]},{"level":2,"title":"vue组合式API有哪些","slug":"vue组合式api有哪些","children":[]},{"level":2,"title":"watchEffect用来代替生命周期里的onMounted和onUpdated","slug":"watcheffect用来代替生命周期里的onmounted和onupdated","children":[]},{"level":2,"title":"vite和webpack的区别","slug":"vite和webpack的区别","children":[]},{"level":2,"title":"vite创建vue项目和vue-cli创建项目的区别","slug":"vite创建vue项目和vue-cli创建项目的区别","children":[]}],"git":{"createdTime":1677043497000,"updatedTime":1677043497000,"contributors":[{"name":"googxh","email":"49309686+googxho@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":1.71,"words":514},"filePathRelative":"Interview/h5/vue3.md","localizedDate":"2023年2月18日"}')}}]);