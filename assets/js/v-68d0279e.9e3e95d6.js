"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[55677],{97290:(n,s,a)=>{a.r(s),a.d(s,{default:()=>c});var e=a(60329);const t=[(0,e.uE)('<h3 id="如何解决跨域问题" tabindex="-1"><a class="header-anchor" href="#如何解决跨域问题" aria-hidden="true">#</a> 如何解决跨域问题</h3><hr><p><strong>JSONP：</strong></p><ul><li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li><li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li><li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li><li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token keyword">function</span> <span class="token function">createJs</span><span class="token punctuation">(</span><span class="token parameter">sUrl</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n\n      <span class="token keyword">var</span> oScript <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;script&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      oScript<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&#39;text/javascript&#39;</span><span class="token punctuation">;</span>\n      oScript<span class="token punctuation">.</span>src <span class="token operator">=</span> sUrl<span class="token punctuation">;</span>\n      document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&#39;head&#39;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oScript<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">createJs</span><span class="token punctuation">(</span><span class="token string">&#39;jsonp.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n     <span class="token string-property property">&#39;name&#39;</span><span class="token operator">:</span> <span class="token string">&#39;test&#39;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token function">alert</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>CORS</strong></p><ul><li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li></ul><p><strong>通过修改document.domain来跨子域</strong></p><ul><li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li></ul><p><strong>使用window.name来进行跨域</strong></p><ul><li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li></ul><p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p><ul><li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li></ul><p><strong>如何解决跨域问题?</strong></p><ul><li><p><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</p></li><li><p>如何解决跨域问题?</p><ul><li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li><li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li><li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li><li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code> //兼容性 IE8+</li><li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li><li>服务器端设置代理请求：服务器端不受同源策略限制</li></ul></li></ul>',15)],o={},c=(0,a(13860).Z)(o,[["render",function(n,s){return(0,e.wg)(),(0,e.iD)("div",null,t)}]])},13860:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},30250:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e=JSON.parse('{"key":"v-68d0279e","path":"/Interview/base/cross-domain.html","title":"如何解决跨域问题？","lang":"zh-CN","frontmatter":{"title":"如何解决跨域问题？","icon":null,"date":"2022-12-15T00:00:00.000Z","category":["Interview"],"summary":"如何解决跨域问题 --- JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入; 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/Interview/base/cross-domain.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"如何解决跨域问题？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-01-17T08:24:10.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2022-12-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-17T08:24:10.000Z"}]]},"excerpt":"","headers":[{"level":3,"title":"如何解决跨域问题","slug":"如何解决跨域问题","children":[]}],"git":{"createdTime":1673943850000,"updatedTime":1673943850000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":2.15,"words":644},"filePathRelative":"Interview/base/cross-domain.md","localizedDate":"2022年12月15日"}')}}]);