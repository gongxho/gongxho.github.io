"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[40493],{59767:(e,n,s)=>{s.r(n),s.d(n,{default:()=>U});var a=s(60329);const t=(0,a.uE)('<p>在本节正式开始前，让我们复习下这一章到目前为止所学的。</p><p><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。<code>commit</code>阶段可以分为三个子阶段：</p><ul><li><p>before mutation阶段（执行<code>DOM</code>操作前）</p></li><li><p>mutation阶段（执行<code>DOM</code>操作）</p></li><li><p>layout阶段（执行<code>DOM</code>操作后）</p></li></ul><p>本节我们看看<code>before mutation阶段</code>（执行<code>DOM</code>操作前）都做了什么。</p><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h2><p><code>before mutation阶段</code>的代码很短，整个过程就是遍历<code>effectList</code>并调用<code>commitBeforeMutationEffects</code>函数处理。</p>',6),o={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127",target:"_blank",rel:"noopener noreferrer"},c=(0,a.uE)('<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span>\n<span class="token keyword">const</span> previousLanePriority <span class="token operator">=</span> <span class="token function">getCurrentUpdateLanePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">setCurrentUpdateLanePriority</span><span class="token punctuation">(</span>SyncLanePriority<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span>\n<span class="token keyword">const</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>\nexecutionContext <span class="token operator">|=</span> CommitContext<span class="token punctuation">;</span>\n\n<span class="token comment">// 处理focus状态</span>\nfocusedInstanceHandle <span class="token operator">=</span> <span class="token function">prepareForCommit</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\nshouldFireAfterActiveInstanceBlur <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\n<span class="token comment">// beforeMutation阶段的主函数</span>\n<span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfocusedInstanceHandle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们重点关注<code>beforeMutation</code>阶段的主函数<code>commitBeforeMutationEffects</code>做了什么。</p><h2 id="commitbeforemutationeffects" tabindex="-1"><a class="header-anchor" href="#commitbeforemutationeffects" aria-hidden="true">#</a> commitBeforeMutationEffects</h2><p>大体代码逻辑：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldFireAfterActiveInstanceBlur <span class="token operator">&amp;&amp;</span> focusedInstanceHandle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...focus blur相关</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>\n\n    <span class="token comment">// 调用getSnapshotBeforeUpdate</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Snapshot<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">commitBeforeMutationEffectOnFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 调度useEffect</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n          <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体可以分为三部分：</p><ol><li><p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code> 逻辑。</p></li><li><p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子。</p></li><li><p>调度<code>useEffect</code>。</p></li></ol><p>我们讲解下2、3两点。</p><h2 id="调用getsnapshotbeforeupdate" tabindex="-1"><a class="header-anchor" href="#调用getsnapshotbeforeupdate" aria-hidden="true">#</a> 调用getSnapshotBeforeUpdate</h2><p><code>commitBeforeMutationEffectOnFiber</code>是<code>commitBeforeMutationLifeCycles</code>的别名。</p><p>在该方法内会调用<code>getSnapshotBeforeUpdate</code>。</p>',11),p={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222",target:"_blank",rel:"noopener noreferrer"},i=(0,a.uE)("<p>从<code>React</code>v16开始，<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。</p><p>究其原因，是因为<code>Stack Reconciler</code>重构为<code>Fiber Reconciler</code>后，<code>render阶段</code>的任务可能中断/重新开始，对应的组件在<code>render阶段</code>的生命周期钩子（即<code>componentWillXXX</code>）可能触发多次。</p><p>这种行为和<code>React</code>v15不一致，所以标记为<code>UNSAFE_</code>。</p>",3),l={href:"https://juejin.im/post/6847902224287285255#comment",target:"_blank",rel:"noopener noreferrer"},u=(0,a.uE)('<p>为此，<code>React</code>提供了替代的生命周期钩子<code>getSnapshotBeforeUpdate</code>。</p><p>我们可以看见，<code>getSnapshotBeforeUpdate</code>是在<code>commit阶段</code>内的<code>before mutation阶段</code>调用的，由于<code>commit阶段</code>是同步的，所以不会遇到多次调用的问题。</p><h2 id="调度useeffect" tabindex="-1"><a class="header-anchor" href="#调度useeffect" aria-hidden="true">#</a> 调度<code>useEffect</code></h2><p>在这几行代码内，<code>scheduleCallback</code>方法由<code>Scheduler</code>模块提供，用于以某个优先级异步调度一个回调函数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 调度useEffect</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 触发useEffect</span>\n      <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此处，被异步调度的回调函数就是触发<code>useEffect</code>的方法<code>flushPassiveEffects</code>。</p><p>我们接下来讨论<code>useEffect</code>如何被异步调度，以及为什么要异步（而不是同步）调度。</p><h3 id="如何异步调度" tabindex="-1"><a class="header-anchor" href="#如何异步调度" aria-hidden="true">#</a> 如何异步调度</h3><p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。</p>',9),d=(0,a._)("code",null,"flushPassiveEffects",-1),r=(0,a._)("code",null,"effectList",-1),f=(0,a._)("code",null,"Fiber节点",-1),k=(0,a.uE)("<ul><li>插入<code>DOM节点</code>（Placement）</li><li>更新<code>DOM节点</code>（Update）</li><li>删除<code>DOM节点</code>（Deletion）</li></ul><p>除此外，当一个<code>FunctionComponent</code>含有<code>useEffect</code>或<code>useLayoutEffect</code>，他对应的<code>Fiber节点</code>也会被赋值<code>effectTag</code>。</p>",2),m={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js",target:"_blank",rel:"noopener noreferrer"},v=(0,a._)("code",null,"hook",-1),b=(0,a._)("code",null,"effectTag",-1),h=(0,a.uE)('<p>在<code>flushPassiveEffects</code>方法内部会遍历<code>rootWithPendingPassiveEffects</code>（即<code>effectList</code>）执行<code>effect</code>回调函数。</p><p>如果在此时直接执行，<code>rootWithPendingPassiveEffects === null</code>。</p><p>那么<code>rootWithPendingPassiveEffects</code>会在何时赋值呢？</p><p>在上一节<code>layout之后</code>的代码片段中会根据<code>rootDoesHavePassiveEffects === true?</code>决定是否赋值<code>rootWithPendingPassiveEffects</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> rootDidHavePassiveEffects <span class="token operator">=</span> rootDoesHavePassiveEffects<span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  rootWithPendingPassiveEffects <span class="token operator">=</span> root<span class="token punctuation">;</span>\n  pendingPassiveEffectsLanes <span class="token operator">=</span> lanes<span class="token punctuation">;</span>\n  pendingPassiveEffectsRenderPriority <span class="token operator">=</span> renderPriorityLevel<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以整个<code>useEffect</code>异步调用分为三步：</p><ol><li><code>before mutation阶段</code>在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code></li><li><code>layout阶段</code>之后将<code>effectList</code>赋值给<code>rootWithPendingPassiveEffects</code></li><li><code>scheduleCallback</code>触发<code>flushPassiveEffects</code>，<code>flushPassiveEffects</code>内部遍历<code>rootWithPendingPassiveEffects</code></li></ol><h3 id="为什么需要异步调用" tabindex="-1"><a class="header-anchor" href="#为什么需要异步调用" aria-hidden="true">#</a> 为什么需要异步调用</h3>',8),g=(0,a._)("code",null,"React",-1),E={href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects",target:"_blank",rel:"noopener noreferrer"},y=(0,a.uE)('<blockquote><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p></blockquote><p>可见，<code>useEffect</code>异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>经过本节学习，我们知道了在<code>before mutation阶段</code>，会遍历<code>effectList</code>，依次执行：</p><ol><li><p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code>逻辑</p></li><li><p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子</p></li><li><p>调度<code>useEffect</code></p></li></ol>',5),P={},U=(0,s(13860).Z)(P,[["render",function(e,n){const s=(0,a.up)("ExternalLinkIcon"),P=(0,a.up)("RouterLink");return(0,a.wg)(),(0,a.iD)("div",null,[t,(0,a._)("blockquote",null,[(0,a._)("p",null,[(0,a.Uk)("这部分"),(0,a._)("a",o,[(0,a.Uk)("源码在这里"),(0,a.Wm)(s)]),(0,a.Uk)("。为了增加可读性，示例代码中删除了不相关的逻辑")])]),c,(0,a._)("blockquote",null,[(0,a._)("p",null,[(0,a.Uk)("你可以在"),(0,a._)("a",p,[(0,a.Uk)("这里"),(0,a.Wm)(s)]),(0,a.Uk)("看到这段逻辑")])]),i,(0,a._)("blockquote",null,[(0,a._)("p",null,[(0,a.Uk)("更详细的解释参照"),(0,a._)("a",l,[(0,a.Uk)("这里"),(0,a.Wm)(s)])])]),u,(0,a._)("p",null,[(0,a.Uk)("关于"),d,(0,a.Uk)("的具体讲解参照"),(0,a.Wm)(P,{to:"/react/hooks/useeffect.html"},{default:(0,a.w5)((()=>[(0,a.Uk)("useEffect与useLayoutEffect一节")])),_:1})]),(0,a._)("p",null,[(0,a.Uk)("在"),(0,a.Wm)(P,{to:"/react/process/completeWork.html#effectlist"},{default:(0,a.w5)((()=>[(0,a.Uk)("completeWork一节")])),_:1}),(0,a.Uk)("我们讲到，"),r,(0,a.Uk)("中保存了需要执行副作用的"),f,(0,a.Uk)("。其中副作用包括")]),k,(0,a._)("blockquote",null,[(0,a._)("p",null,[(0,a.Uk)("你可以从"),(0,a._)("a",m,[(0,a.Uk)("这里"),(0,a.Wm)(s)]),(0,a.Uk)("看到"),v,(0,a.Uk)("相关的"),b])]),h,(0,a._)("p",null,[(0,a.Uk)("摘录自"),g,(0,a.Uk)("文档"),(0,a._)("a",E,[(0,a.Uk)("effect 的执行时机"),(0,a.Wm)(s)]),(0,a.Uk)("：")]),y])}]])},13860:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,a]of n)s[e]=a;return s}},93904:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a=JSON.parse('{"key":"v-606db68e","path":"/react/renderer/beforeMutation.html","title":"before mutation阶段","lang":"zh-CN","frontmatter":{"title":"before mutation阶段","author":"BetaSu","tag":["React"],"summary":"在本节正式开始前，让我们复习下这一章到目前为止所学的。 Renderer工作的阶段被称为commit阶段。commit阶段可以分为三个子阶段： before mutation阶段（执行DOM操作前）; mutation阶段（执行DOM操作）; layout阶段（执行DOM操作后）; 本节我们看看before mutation阶段（执行DOM操作前）都做了什么","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/renderer/beforeMutation.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"before mutation阶段"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"概览","slug":"概览","children":[]},{"level":2,"title":"commitBeforeMutationEffects","slug":"commitbeforemutationeffects","children":[]},{"level":2,"title":"调用getSnapshotBeforeUpdate","slug":"调用getsnapshotbeforeupdate","children":[]},{"level":2,"title":"调度useEffect","slug":"调度useeffect","children":[{"level":3,"title":"如何异步调度","slug":"如何异步调度","children":[]},{"level":3,"title":"为什么需要异步调用","slug":"为什么需要异步调用","children":[]}]},{"level":2,"title":"总结","slug":"总结","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":3.8,"words":1140},"filePathRelative":"react/renderer/beforeMutation.md","localizedDate":"2022年8月29日"}')}}]);