"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[35247],{38876:(n,s,a)=>{a.r(s),a.d(s,{default:()=>nn});var e=a(78e3);const t=(0,e.Uk)("在"),p=(0,e.Uk)("新的React架构一节"),o=(0,e.Uk)("中，我们提到的"),c=(0,e._)("strong",null,"虚拟DOM",-1),l=(0,e.Uk)("在"),i=(0,e._)("code",null,"React",-1),r=(0,e.Uk)("中有个正式的称呼——"),d=(0,e._)("code",null,"Fiber",-1),u=(0,e.Uk)("。在之后的学习中，我们会逐渐用"),k=(0,e._)("code",null,"Fiber",-1),v=(0,e.Uk)("来取代"),m=(0,e._)("strong",null,"React16虚拟DOM",-1),b=(0,e.Uk)("这一称呼。"),h=(0,e._)("p",null,[(0,e.Uk)("接下来让我们了解下"),(0,e._)("code",null,"Fiber"),(0,e.Uk)("因何而来？他的作用是什么？")],-1),y=(0,e._)("h2",{id:"fiber的起源",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#fiber的起源","aria-hidden":"true"},"#"),(0,e.Uk)(" Fiber的起源")],-1),g=(0,e.Uk)("最早的"),w=(0,e._)("code",null,"Fiber",-1),f=(0,e.Uk)("官方解释来源于"),F={href:"https://github.com/acdlite/react-fiber-architecture",target:"_blank",rel:"noopener noreferrer"},_=(0,e.Uk)("2016年React团队成员Acdlite的一篇介绍"),U=(0,e.Uk)("。"),R=(0,e.uE)('<p>从上一章的学习我们知道：</p><p>在<code>React15</code>及以前，<code>Reconciler</code>采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p><p>为了解决这个问题，<code>React16</code>将<strong>递归的无法中断的更新</strong>重构为<strong>异步的可中断更新</strong>，由于曾经用于递归的<strong>虚拟DOM</strong>数据结构已经无法满足需要。于是，全新的<code>Fiber</code>架构应运而生。</p><h2 id="fiber的含义" tabindex="-1"><a class="header-anchor" href="#fiber的含义" aria-hidden="true">#</a> Fiber的含义</h2><p><code>Fiber</code>包含三层含义：</p><ol><li><p>作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</p></li><li><p>作为静态的数据结构来说，每个<code>Fiber节点</code>对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。</p></li><li><p>作为动态的工作单元来说，每个<code>Fiber节点</code>保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。</p></li></ol><h2 id="fiber的结构" tabindex="-1"><a class="header-anchor" href="#fiber的结构" aria-hidden="true">#</a> Fiber的结构</h2>',7),x=(0,e.Uk)("你可以从这里看到"),j={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117",target:"_blank",rel:"noopener noreferrer"},O=(0,e.Uk)("Fiber节点的属性定义"),C=(0,e.Uk)("。虽然属性很多，但我们可以按三层含义将他们分类来看"),D=(0,e.uE)('<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>\n  <span class="token parameter"><span class="token literal-property property">tag</span><span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>\n  <span class="token literal-property property">pendingProps</span><span class="token operator">:</span> mixed<span class="token punctuation">,</span>\n  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>\n  <span class="token literal-property property">mode</span><span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span></span>\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 作为静态数据结构的属性</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 用于连接其他Fiber节点形成Fiber树</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 作为动态的工作单元的属性</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 调度优先级相关</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n\n  <span class="token comment">// 指向该fiber在另一次更新时对应的fiber</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="作为架构来说" tabindex="-1"><a class="header-anchor" href="#作为架构来说" aria-hidden="true">#</a> 作为架构来说</h3><p>每个Fiber节点有个对应的<code>React element</code>，多个<code>Fiber节点</code>是如何连接形成树呢？靠如下三个属性：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 指向父级Fiber节点</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token comment">// 指向子Fiber节点</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token comment">// 指向右边第一个兄弟Fiber节点</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举个例子，如下的组件结构：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n      i am\n      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',6),E=(0,e.Uk)("对应的"),M=(0,e._)("code",null,"Fiber树",-1),N=(0,e.Uk)("结构： "),T=["src"],L=(0,e.uE)('<blockquote><p>这里需要提一下，为什么父级指针叫做<code>return</code>而不是<code>parent</code>或者<code>father</code>呢？因为作为一个工作单元，<code>return</code>指节点执行完<code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子<code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用<code>return</code>指代父级节点。</p></blockquote><h3 id="作为静态的数据结构" tabindex="-1"><a class="header-anchor" href="#作为静态的数据结构" aria-hidden="true">#</a> 作为静态的数据结构</h3><p>作为一种静态的数据结构，保存了组件相关的信息：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// Fiber对应组件的类型 Function/Class/Host...</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>\n<span class="token comment">// key属性</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>\n<span class="token comment">// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token comment">// Fiber对应的真实DOM节点</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="作为动态的工作单元" tabindex="-1"><a class="header-anchor" href="#作为动态的工作单元" aria-hidden="true">#</a> 作为动态的工作单元</h3><p>作为动态的工作单元，<code>Fiber</code>中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>\n<span class="token comment">// 保存本次更新造成的状态改变相关信息</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>\n\n<span class="token comment">// 保存本次更新会造成的DOM操作</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如下两个字段保存调度优先级相关的信息，会在讲解<code>Scheduler</code>时介绍。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 调度优先级相关</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',9),P={class:"custom-container warning"},z=(0,e._)("p",{class:"custom-container-title"},"注意",-1),W=(0,e.Uk)("在2020年5月，调度优先级策略经历了比较大的重构。以"),S=(0,e._)("code",null,"expirationTime",-1),q=(0,e.Uk)("属性为代表的优先级模型被"),A=(0,e._)("code",null,"lane",-1),B=(0,e.Uk)("取代。详见"),Z={href:"https://github.com/facebook/react/pull/18796",target:"_blank",rel:"noopener noreferrer"},H=(0,e.Uk)("这个PR"),I=(0,e.Uk)("如果你的源码中"),Q=(0,e._)("code",null,"fiber.expirationTime",-1),J=(0,e.Uk)("仍存在，请参照"),K=(0,e.Uk)("调试源码"),V=(0,e.Uk)("章节获取最新代码。"),$=(0,e.uE)('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本节我们了解了<code>Fiber</code>的起源与架构，其中<code>Fiber节点</code>可以构成<code>Fiber树</code>。那么<code>Fiber树</code>和页面呈现的<code>DOM树</code>有什么关系，<code>React</code>又是如何更新<code>DOM</code>的呢？</p><p>我们会在下一节讲解。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',4),G={href:"https://www.bilibili.com/video/BV1it411p7v6?from=search&seid=3508901752524570226",target:"_blank",rel:"noopener noreferrer"},X=(0,e.Uk)("Lin Clark - A Cartoon Intro to Fiber - React Conf 2017"),Y={},nn=(0,a(13860).Z)(Y,[["render",function(n,s){const a=(0,e.up)("RouterLink"),Y=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[(0,e._)("p",null,[t,(0,e.Wm)(a,{to:"/react/preparation/newConstructure.html"},{default:(0,e.w5)((()=>[p])),_:1}),o,c,l,i,r,d,u,k,v,m,b]),h,y,(0,e._)("blockquote",null,[(0,e._)("p",null,[g,w,f,(0,e._)("a",F,[_,(0,e.Wm)(Y)]),U])]),R,(0,e._)("p",null,[x,(0,e._)("a",j,[O,(0,e.Wm)(Y)]),C]),D,(0,e._)("p",null,[E,M,N,(0,e._)("img",{src:n.$withBase("/img/fiber.png"),alt:"Fiber架构"},null,8,T)]),L,(0,e._)("div",P,[z,(0,e._)("p",null,[W,S,q,A,B,(0,e._)("a",Z,[H,(0,e.Wm)(Y)])]),(0,e._)("p",null,[I,Q,J,(0,e.Wm)(a,{to:"/react/preparation/source.html"},{default:(0,e.w5)((()=>[K])),_:1}),V])]),$,(0,e._)("p",null,[(0,e._)("a",G,[X,(0,e.Wm)(Y)])])])}]])},13860:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},62854:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e=JSON.parse('{"key":"v-900d9cd4","path":"/react/process/fiber.html","title":"Fiber架构的实现原理","lang":"zh-CN","frontmatter":{"title":"Fiber架构的实现原理","author":"BetaSu","tag":["React"],"summary":"在新的React架构一节中，我们提到的虚拟DOM在React中有个正式的称呼——Fiber。在之后的学习中，我们会逐渐用Fiber来取代React16虚拟DOM这一称呼。 接下来让我们了解下Fiber因何而来？他的作用是什么？ Fiber的起源 \\" 最早的Fiber官方解释来源于2016年React团队成员Acdlite的一篇介绍。\\" 从上一章的学习我们知道","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/process/fiber.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"Fiber架构的实现原理"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"Fiber的起源","slug":"fiber的起源","children":[]},{"level":2,"title":"Fiber的含义","slug":"fiber的含义","children":[]},{"level":2,"title":"Fiber的结构","slug":"fiber的结构","children":[{"level":3,"title":"作为架构来说","slug":"作为架构来说","children":[]},{"level":3,"title":"作为静态的数据结构","slug":"作为静态的数据结构","children":[]},{"level":3,"title":"作为动态的工作单元","slug":"作为动态的工作单元","children":[]}]},{"level":2,"title":"总结","slug":"总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":4.03,"words":1209},"filePathRelative":"react/process/fiber.md","localizedDate":"2022年8月29日"}')}}]);