"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[69032],{25377:(e,a,n)=>{n.r(a),n.d(a,{default:()=>ze});var s=n(78e3);const t=(0,s.Uk)("通过"),p=(0,s.Uk)("更新的心智模型"),o=(0,s.Uk)("，我们了解到"),c=(0,s._)("code",null,"更新",-1),r=(0,s.Uk)("具有"),l=(0,s._)("code",null,"优先级",-1),d=(0,s.Uk)("。"),i=(0,s._)("p",null,[(0,s.Uk)("那么什么是"),(0,s._)("code",null,"优先级"),(0,s.Uk)("？"),(0,s._)("code",null,"优先级"),(0,s.Uk)("以什么为依据？如何通过"),(0,s._)("code",null,"优先级"),(0,s.Uk)("决定哪个状态应该先被更新？")],-1),u=(0,s._)("p",null,"本节我们会详细讲解。",-1),k=(0,s._)("h2",{id:"什么是优先级",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#什么是优先级","aria-hidden":"true"},"#"),(0,s.Uk)(" 什么是优先级")],-1),m=(0,s.Uk)("在"),v=(0,s.Uk)("React理念一节"),b=(0,s.Uk)("我们聊到"),U=(0,s._)("code",null,"React",-1),h=(0,s.Uk)("将人机交互研究的结果整合到真实的"),g=(0,s._)("code",null,"UI",-1),y=(0,s.Uk)("中。具体到"),_=(0,s._)("code",null,"React",-1),f=(0,s.Uk)("运行上这是什么意思呢？"),w=(0,s.uE)('<p><code>状态更新</code>由<code>用户交互</code>产生，用户心里对<code>交互</code>执行顺序有个预期。<code>React</code>根据<code>人机交互研究的结果</code>中用户对<code>交互</code>的预期顺序为<code>交互</code>产生的<code>状态更新</code>赋予不同优先级。</p><p>具体如下：</p><ul><li><p>生命周期方法：同步执行。</p></li><li><p>受控的用户输入：比如输入框内输入文字，同步执行。</p></li><li><p>交互事件：比如动画，高优先级执行。</p></li><li><p>其他：比如数据请求，低优先级执行。</p></li></ul><h2 id="如何调度优先级" tabindex="-1"><a class="header-anchor" href="#如何调度优先级" aria-hidden="true">#</a> 如何调度优先级</h2>',4),j=(0,s.Uk)("我们在"),B=(0,s.Uk)("新的React结构一节"),x=(0,s.Uk)("讲到，"),S=(0,s._)("code",null,"React",-1),R=(0,s.Uk)("通过"),E=(0,s._)("code",null,"Scheduler",-1),W=(0,s.Uk)("调度任务。"),A=(0,s.uE)("<p>具体到代码，每当需要调度任务时，<code>React</code>会调用<code>Scheduler</code>提供的方法<code>runWithPriority</code>。</p><p>该方法接收一个<code>优先级</code>常量与一个<code>回调函数</code>作为参数。<code>回调函数</code>会以<code>优先级</code>高低为顺序排列在一个<code>定时器</code>中并在合适的时间触发。</p>",2),Q=(0,s.Uk)("对于更新来讲，传递的"),C=(0,s._)("code",null,"回调函数",-1),D=(0,s.Uk)("一般为"),I=(0,s.Uk)("状态更新流程概览一节"),T=(0,s.Uk)("讲到的"),P=(0,s._)("code",null,"render阶段的入口函数",-1),z=(0,s.Uk)("。"),q=(0,s.Uk)("你可以在"),L={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217",target:"_blank",rel:"noopener noreferrer"},X=(0,s.Uk)("==unstable_runWithPriority== 这里"),F=(0,s.Uk)("看到"),N=(0,s._)("code",null,"runWithPriority",-1),Z=(0,s.Uk)("方法的定义。在"),H={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js",target:"_blank",rel:"noopener noreferrer"},O=(0,s.Uk)("这里"),J=(0,s.Uk)("看到"),$=(0,s._)("code",null,"Scheduler",-1),G=(0,s.Uk)("对优先级常量的定义。"),K=(0,s._)("h2",{id:"例子",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#例子","aria-hidden":"true"},"#"),(0,s.Uk)(" 例子")],-1),M=(0,s._)("p",null,[(0,s.Uk)("优先级最终会反映到"),(0,s._)("code",null,"update.lane"),(0,s.Uk)("变量上。当前我们只需要知道这个变量能够区分"),(0,s._)("code",null,"Update"),(0,s.Uk)("的优先级。")],-1),V=(0,s._)("p",null,[(0,s.Uk)("接下来我们通过一个例子结合上一节介绍的"),(0,s._)("code",null,"Update"),(0,s.Uk)("相关字段讲解优先级如何决定更新的顺序。")],-1),Y=(0,s.Uk)("该例子来自"),ee={href:"https://twitter.com/acdlite/status/978412930973687808",target:"_blank",rel:"noopener noreferrer"},ae=(0,s.Uk)("React Core Team Andrew向网友讲解Update工作流程的推文"),ne=["src"],se=(0,s.uE)('<p>在这个例子中，有两个<code>Update</code>。我们将“关闭黑夜模式”产生的<code>Update</code>称为<code>u1</code>，输入字母“I”产生的<code>Update</code>称为<code>u2</code>。</p><p>其中<code>u1</code>先触发并进入<code>render阶段</code>。其优先级较低，执行时间较长。此时：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">blackTheme</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;H&#39;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">firstBaseUpdate</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">lastBaseUpdate</span><span class="token operator">:</span> <span class="token keyword">null</span>\n  <span class="token literal-property property">shared</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">pending</span><span class="token operator">:</span> u1\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">effects</span><span class="token operator">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>u1</code>完成<code>render阶段</code>前用户通过键盘输入字母“I”，产生了<code>u2</code>。<code>u2</code>属于<strong>受控的用户输入</strong>，优先级高于<code>u1</code>，于是中断<code>u1</code>产生的<code>render阶段</code>。</p><p>此时：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">===</span> u2 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">&gt;</span> u1\n                                     <span class="token operator">^</span>        <span class="token operator">|</span>\n                                     <span class="token operator">|</span>________<span class="token operator">|</span>\n<span class="token comment">// 即</span>\nu2<span class="token punctuation">.</span>next <span class="token operator">===</span> u1<span class="token punctuation">;</span>\nu1<span class="token punctuation">.</span>next <span class="token operator">===</span> u2<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>u2</code>优先级高于<code>u1</code>。</p><p>接下来进入<code>u2</code>产生的<code>render阶段</code>。</p><p>在<code>processUpdateQueue</code>方法中，<code>shared.pending</code>环状链表会被剪开并拼接在<code>baseUpdate</code>后面。</p><p>需要明确一点，<code>shared.pending</code>指向最后一个<code>pending</code>的<code>update</code>，所以实际执行时<code>update</code>的顺序为：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>u1 <span class="token operator">--</span> u2\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来遍历<code>baseUpdate</code>，处理优先级合适的<code>Update</code>（这一次处理的是更高优的<code>u2</code>）。</p><p>由于<code>u2</code>不是<code>baseUpdate</code>中的第一个<code>update</code>，在其之前的<code>u1</code>由于优先级不够被跳过。</p><p><code>update</code>之间可能有依赖关系，所以被跳过的<code>update</code>及其后面所有<code>update</code>会成为下次更新的<code>baseUpdate</code>。（即<code>u1 -- u2</code>）。</p><p>最终<code>u2</code>完成<code>render - commit阶段</code>。</p><p>此时：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">blackTheme</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;HI&#39;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">firstBaseUpdate</span><span class="token operator">:</span> u1<span class="token punctuation">,</span>\n  <span class="token literal-property property">lastBaseUpdate</span><span class="token operator">:</span> u2\n  <span class="token literal-property property">shared</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">pending</span><span class="token operator">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">effects</span><span class="token operator">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>commit</code>阶段结尾会再调度一次更新。在该次更新中会基于<code>baseState</code>中<code>firstBaseUpdate</code>保存的<code>u1</code>，开启一次新的<code>render阶段</code>。</p><p>最终两次<code>Update</code>都完成后的结果如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">blackTheme</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;HI&#39;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">firstBaseUpdate</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">lastBaseUpdate</span><span class="token operator">:</span> <span class="token keyword">null</span>\n  <span class="token literal-property property">shared</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">pending</span><span class="token operator">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">effects</span><span class="token operator">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看见，<code>u2</code>对应的更新执行了两次，相应的<code>render阶段</code>的生命周期勾子<code>componentWillXXX</code>也会触发两次。这也是为什么这些勾子会被标记为<code>unsafe_</code>。</p><h2 id="如何保证状态正确" tabindex="-1"><a class="header-anchor" href="#如何保证状态正确" aria-hidden="true">#</a> 如何保证状态正确</h2><p>现在我们基本掌握了<code>updateQueue</code>的工作流程。还有两个疑问：</p><ul><li><p><code>render阶段</code>可能被中断。如何保证<code>updateQueue</code>中保存的<code>Update</code>不丢失？</p></li><li><p>有时候当前<code>状态</code>需要依赖前一个<code>状态</code>。如何在支持跳过<code>低优先级状态</code>的同时保证<strong>状态依赖的连续性</strong>？</p></li></ul><p>我们分别讲解下。</p><h3 id="如何保证update不丢失" tabindex="-1"><a class="header-anchor" href="#如何保证update不丢失" aria-hidden="true">#</a> 如何保证<code>Update</code>不丢失</h3>',26),te=(0,s.Uk)("在"),pe=(0,s.Uk)("上一节例子"),oe=(0,s.Uk)("中我们讲到，在"),ce=(0,s._)("code",null,"render阶段",-1),re=(0,s.Uk)("，"),le=(0,s._)("code",null,"shared.pending",-1),de=(0,s.Uk)("的环被剪开并连接在"),ie=(0,s._)("code",null,"updateQueue.lastBaseUpdate",-1),ue=(0,s.Uk)("后面。"),ke=(0,s._)("p",null,[(0,s.Uk)("实际上"),(0,s._)("code",null,"shared.pending"),(0,s.Uk)("会被同时连接在"),(0,s._)("code",null,"workInProgress updateQueue.lastBaseUpdate"),(0,s.Uk)("与"),(0,s._)("code",null,"current updateQueue.lastBaseUpdate"),(0,s.Uk)("后面。")],-1),me=(0,s.Uk)("具体代码见"),ve={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L424",target:"_blank",rel:"noopener noreferrer"},be=(0,s.Uk)("这里"),Ue=(0,s.uE)('<p>当<code>render阶段</code>被中断后重新开始时，会基于<code>current updateQueue</code>克隆出<code>workInProgress updateQueue</code>。由于<code>current updateQueue.lastBaseUpdate</code>已经保存了上一次的<code>Update</code>，所以不会丢失。</p><p>当<code>commit阶段</code>完成渲染，由于<code>workInProgress updateQueue.lastBaseUpdate</code>中保存了上一次的<code>Update</code>，所以 <code>workInProgress Fiber树</code>变成<code>current Fiber树</code>后也不会造成<code>Update</code>丢失。</p><h3 id="如何保证状态依赖的连续性" tabindex="-1"><a class="header-anchor" href="#如何保证状态依赖的连续性" aria-hidden="true">#</a> 如何保证状态依赖的连续性</h3><p>当某个<code>Update</code>由于优先级低而被跳过时，保存在<code>baseUpdate</code>中的不仅是该<code>Update</code>，还包括链表中该<code>Update</code>之后的所有<code>Update</code>。</p><p>考虑如下例子：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span>\nshared<span class="token punctuation">.</span>pending<span class="token operator">:</span> <span class="token constant">A1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">B2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">C1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">D2</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>字母</code>代表该<code>Update</code>要在页面插入的字母，<code>数字</code>代表<code>优先级</code>，值越低<code>优先级</code>越高。</p><p>第一次<code>render</code>，<code>优先级</code>为1。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span>\n<span class="token literal-property property">baseUpdate</span><span class="token operator">:</span> <span class="token keyword">null</span>\n<span class="token literal-property property">render阶段使用的Update</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">A1</span><span class="token punctuation">,</span> <span class="token constant">C1</span><span class="token punctuation">]</span>\n<span class="token literal-property property">memoizedState</span><span class="token operator">:</span> <span class="token string">&#39;AC&#39;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>B2</code>由于优先级为2，低于当前优先级，所以他及其后面的所有<code>Update</code>会被保存在<code>baseUpdate</code>中作为下次更新的<code>Update</code>（即<code>B2 C1 D2</code>）。</p><p>这么做是为了保持<code>状态</code>的前后依赖顺序。</p><p>第二次<code>render</code>，<code>优先级</code>为2。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token string">&#39;A&#39;</span>\n<span class="token literal-property property">baseUpdate</span><span class="token operator">:</span> <span class="token constant">B2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">C1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">D2</span>\n<span class="token literal-property property">render阶段使用的Update</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">B2</span><span class="token punctuation">,</span> <span class="token constant">C1</span><span class="token punctuation">,</span> <span class="token constant">D2</span><span class="token punctuation">]</span>\n<span class="token literal-property property">memoizedState</span><span class="token operator">:</span> <span class="token string">&#39;ABCD&#39;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里<code>baseState</code>并不是上一次更新的<code>memoizedState</code>。这是由于<code>B2</code>被跳过了。</p><p>即当有<code>Update</code>被跳过时，<code>下次更新的baseState !== 上次更新的memoizedState</code>。</p>',15),he=(0,s.Uk)("跳过"),ge=(0,s._)("code",null,"B2",-1),ye=(0,s.Uk)("的逻辑见"),_e={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L479",target:"_blank",rel:"noopener noreferrer"},fe=(0,s.Uk)("这里"),we=(0,s._)("p",null,[(0,s.Uk)("通过以上例子我们可以发现，"),(0,s._)("code",null,"React"),(0,s.Uk)("保证最终的状态一定和用户触发的"),(0,s._)("code",null,"交互"),(0,s.Uk)("一致，但是中间过程"),(0,s._)("code",null,"状态"),(0,s.Uk)("可能由于设备不同而不同。")],-1),je={class:"custom-container details"},Be=(0,s._)("summary",null,"高优先级任务打断低优先级任务Demo",-1),xe=(0,s.Uk)("关注公众号"),Se=(0,s.Uk)("，后台回复"),Re=(0,s._)("strong",null,"815",-1),Ee=(0,s.Uk)("获得在线Demo地址"),We=(0,s._)("h2",{id:"参考资料",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),(0,s.Uk)(" 参考资料")],-1),Ae={href:"https://juejin.im/post/5f05a3e25188252e5c576cdb",target:"_blank",rel:"noopener noreferrer"},Qe=(0,s.Uk)("深入源码剖析componentWillXXX为什么UNSAFE"),Ce={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L10",target:"_blank",rel:"noopener noreferrer"},De=(0,s.Uk)("React源码中讲解Update工作流程及优先级的注释"),Ie={href:"https://twitter.com/acdlite/status/978412930973687808",target:"_blank",rel:"noopener noreferrer"},Te=(0,s.Uk)("React Core Team Andrew向网友讲解Update工作流程的推文"),Pe={},ze=(0,n(13860).Z)(Pe,[["render",function(e,a){const n=(0,s.up)("RouterLink"),Pe=(0,s.up)("ExternalLinkIcon");return(0,s.wg)(),(0,s.iD)("div",null,[(0,s._)("p",null,[t,(0,s.Wm)(n,{to:"/react/state/mental.html"},{default:(0,s.w5)((()=>[p])),_:1}),o,c,r,l,d]),i,u,k,(0,s._)("p",null,[m,(0,s.Wm)(n,{to:"/react/preparation/idea.html#%E7%90%86%E8%A7%A3-%E5%93%8D%E5%BA%94%E8%87%AA%E7%84%B6"},{default:(0,s.w5)((()=>[v])),_:1}),b,U,h,g,y,_,f]),w,(0,s._)("p",null,[j,(0,s.Wm)(n,{to:"/react/preparation/newConstructure.html"},{default:(0,s.w5)((()=>[B])),_:1}),x,S,R,E,W]),A,(0,s._)("p",null,[Q,C,D,(0,s.Wm)(n,{to:"/react/state/prepare.html#render%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%80%E5%A7%8B"},{default:(0,s.w5)((()=>[I])),_:1}),T,P,z]),(0,s._)("blockquote",null,[(0,s._)("p",null,[q,(0,s._)("a",L,[X,(0,s.Wm)(Pe)]),F,N,Z,(0,s._)("a",H,[O,(0,s.Wm)(Pe)]),J,$,G])]),K,M,V,(0,s._)("blockquote",null,[(0,s._)("p",null,[Y,(0,s._)("a",ee,[ae,(0,s.Wm)(Pe)])])]),(0,s._)("img",{src:e.$withBase("/img/update-process.png"),alt:"优先级如何决定更新的顺序"},null,8,ne),se,(0,s._)("p",null,[te,(0,s.Wm)(n,{to:"/react/state/update.html#%E4%BE%8B%E5%AD%90"},{default:(0,s.w5)((()=>[pe])),_:1}),oe,ce,re,le,de,ie,ue]),ke,(0,s._)("blockquote",null,[(0,s._)("p",null,[me,(0,s._)("a",ve,[be,(0,s.Wm)(Pe)])])]),Ue,(0,s._)("blockquote",null,[(0,s._)("p",null,[he,ge,ye,(0,s._)("a",_e,[fe,(0,s.Wm)(Pe)])])]),we,(0,s._)("details",je,[Be,(0,s._)("p",null,[(0,s.Wm)(n,{to:"/react/me.html"},{default:(0,s.w5)((()=>[xe])),_:1}),Se,Re,Ee])]),We,(0,s._)("p",null,[(0,s._)("a",Ae,[Qe,(0,s.Wm)(Pe)])]),(0,s._)("p",null,[(0,s._)("a",Ce,[De,(0,s.Wm)(Pe)])]),(0,s._)("p",null,[(0,s._)("a",Ie,[Te,(0,s.Wm)(Pe)])]),(0,s.kq)(" beginWork getStateFromUpdate ")])}]])},13860:(e,a)=>{a.Z=(e,a)=>{const n=e.__vccOpts||e;for(const[e,s]of a)n[e]=s;return n}},63949:(e,a,n)=>{n.r(a),n.d(a,{data:()=>s});const s=JSON.parse('{"key":"v-4684cb4e","path":"/react/state/priority.html","title":"深入理解优先级","lang":"zh-CN","frontmatter":{"title":"深入理解优先级","author":"BetaSu","tag":["React"],"summary":"通过更新的心智模型，我们了解到更新具有优先级。 那么什么是优先级？优先级以什么为依据？如何通过优先级决定哪个状态应该先被更新？ 本节我们会详细讲解。 什么是优先级 在React理念一节我们聊到React将人机交互研究的结果整合到真实的UI中。具体到React运行上这是什么意思呢？ 状态更新由用户交互产生，用户心里对交互执行顺序有个预期。React根据人机交互","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/state/priority.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"深入理解优先级"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"什么是优先级","slug":"什么是优先级","children":[]},{"level":2,"title":"如何调度优先级","slug":"如何调度优先级","children":[]},{"level":2,"title":"例子","slug":"例子","children":[]},{"level":2,"title":"如何保证状态正确","slug":"如何保证状态正确","children":[{"level":3,"title":"如何保证Update不丢失","slug":"如何保证update不丢失","children":[]},{"level":3,"title":"如何保证状态依赖的连续性","slug":"如何保证状态依赖的连续性","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":5.8,"words":1739},"filePathRelative":"react/state/priority.md","localizedDate":"2022年8月29日"}')}}]);