"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[13157],{40634:(n,e,s)=>{s.r(e),s.d(e,{default:()=>qn});var a=s(78e3);const o=(0,a._)("p",null,[(0,a.Uk)("上一节我们了解到"),(0,a._)("code",null,"render阶段"),(0,a.Uk)("的工作可以分为“递”阶段和“归”阶段。其中“递”阶段会执行"),(0,a._)("code",null,"beginWork"),(0,a.Uk)("，“归”阶段会执行"),(0,a._)("code",null,"completeWork"),(0,a.Uk)("。这一节我们看看“递”阶段的"),(0,a._)("code",null,"beginWork"),(0,a.Uk)("方法究竟做了什么。")],-1),c=(0,a._)("h2",{id:"方法概览",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#方法概览","aria-hidden":"true"},"#"),(0,a.Uk)(" 方法概览")],-1),t=(0,a.Uk)("可以从"),p={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075",target:"_blank",rel:"noopener noreferrer"},l=(0,a.Uk)("源码这里"),r=(0,a.Uk)("看到"),i=(0,a._)("code",null,"beginWork",-1),d=(0,a.Uk)("的定义。整个方法大概有500行代码。"),u=(0,a.uE)('<p>从上一节我们已经知道，<code>beginWork</code>的工作是传入<code>当前Fiber节点</code>，创建<code>子Fiber节点</code>，我们从传参来看看具体是如何做的。</p><h3 id="从传参看方法执行" tabindex="-1"><a class="header-anchor" href="#从传参看方法执行" aria-hidden="true">#</a> 从传参看方法执行</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>\n  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>\n  <span class="token literal-property property">renderLanes</span><span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>\n<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...省略函数体</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中传参：</p><ul><li>current：当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>workInProgress.alternate</code></li><li>workInProgress：当前组件对应的<code>Fiber节点</code></li><li>renderLanes：优先级相关，在讲解<code>Scheduler</code>时再讲解</li></ul>',5),k=(0,a.Uk)("从"),m=(0,a.Uk)("双缓存机制一节"),b=(0,a.Uk)("我们知道，除"),v=(0,a._)("code",null,"rootFiber",-1),g=(0,a.Uk)("以外， 组件"),f=(0,a._)("code",null,"mount",-1),h=(0,a.Uk)("时，由于是首次渲染，是不存在当前组件对应的"),y=(0,a._)("code",null,"Fiber节点",-1),w=(0,a.Uk)("在上一次更新时的"),_=(0,a._)("code",null,"Fiber节点",-1),F=(0,a.Uk)("，即"),U=(0,a._)("code",null,"mount",-1),W=(0,a.Uk)("时"),C=(0,a._)("code",null,"current === null",-1),P=(0,a.Uk)("。"),x=(0,a.uE)('<p>组件<code>update</code>时，由于之前已经<code>mount</code>过，所以<code>current !== null</code>。</p><p>所以我们可以通过<code>current === null ?</code>来区分组件是处于<code>mount</code>还是<code>update</code>。</p><p>基于此原因，<code>beginWork</code>的工作可以分为两部分：</p><ul><li><p><code>update</code>时：如果<code>current</code>存在，在满足一定条件时可以复用<code>current</code>节点，这样就能克隆<code>current.child</code>作为<code>workInProgress.child</code>，而不需要新建<code>workInProgress.child</code>。</p></li><li><p><code>mount</code>时：除<code>fiberRootNode</code>以外，<code>current === null</code>。会根据<code>fiber.tag</code>不同，创建不同类型的<code>子Fiber节点</code></p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>\n  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>\n  <span class="token literal-property property">renderLanes</span><span class="token operator">:</span> Lanes</span>\n<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n\n  <span class="token comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...省略</span>\n\n    <span class="token comment">// 复用current</span>\n    <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>\n      current<span class="token punctuation">,</span>\n      workInProgress<span class="token punctuation">,</span>\n      renderLanes<span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// mount时：根据tag不同，创建不同的子Fiber节点</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">IndeterminateComponent</span><span class="token operator">:</span> \n      <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">LazyComponent</span><span class="token operator">:</span> \n      <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">FunctionComponent</span><span class="token operator">:</span> \n      <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">ClassComponent</span><span class="token operator">:</span> \n      <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">HostRoot</span><span class="token operator">:</span>\n      <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">HostComponent</span><span class="token operator">:</span>\n      <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> <span class="token literal-property property">HostText</span><span class="token operator">:</span>\n      <span class="token comment">// ...省略</span>\n    <span class="token comment">// ...省略其他类型</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="update时" tabindex="-1"><a class="header-anchor" href="#update时" aria-hidden="true">#</a> update时</h2><p>我们可以看到，满足如下情况时<code>didReceiveUpdate === false</code>（即可以直接复用前一次更新的<code>子Fiber</code>，不需要新建<code>子Fiber</code>）</p><ol><li><code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code>，即<code>props</code>与<code>fiber.type</code>不变</li><li><code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前<code>Fiber节点</code>优先级不够，会在讲解<code>Scheduler</code>时介绍</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> oldProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>\n      oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span>\n      <span class="token function">hasLegacyContextChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>\n      <span class="token punctuation">(</span>__DEV__ <span class="token operator">?</span> workInProgress<span class="token punctuation">.</span>type <span class="token operator">!==</span> current<span class="token punctuation">.</span>type <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">includesSomeLane</span><span class="token punctuation">(</span>renderLanes<span class="token punctuation">,</span> updateLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n      <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 省略处理</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>\n        current<span class="token punctuation">,</span>\n        workInProgress<span class="token punctuation">,</span>\n        renderLanes<span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mount时" tabindex="-1"><a class="header-anchor" href="#mount时" aria-hidden="true">#</a> mount时</h2><p>当不满足优化路径时，我们就进入第二部分，新建<code>子Fiber</code>。</p><p>我们可以看到，根据<code>fiber.tag</code>不同，进入不同类型<code>Fiber</code>的创建逻辑。</p>',12),L=(0,a.Uk)("可以从"),j={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js",target:"_blank",rel:"noopener noreferrer"},I=(0,a.Uk)("这里"),R=(0,a.Uk)("看到"),T=(0,a._)("code",null,"tag",-1),D=(0,a.Uk)("对应的组件类型"),O=(0,a.uE)('<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// mount时：根据tag不同，创建不同的Fiber节点</span>\n<span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">IndeterminateComponent</span><span class="token operator">:</span> \n    <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">LazyComponent</span><span class="token operator">:</span> \n    <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">FunctionComponent</span><span class="token operator">:</span> \n    <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">ClassComponent</span><span class="token operator">:</span> \n    <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">HostRoot</span><span class="token operator">:</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">HostComponent</span><span class="token operator">:</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> <span class="token literal-property property">HostText</span><span class="token operator">:</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token comment">// ...省略其他类型</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',1),E=(0,a.Uk)("对于我们常见的组件类型，如（"),M=(0,a._)("code",null,"FunctionComponent",-1),B=(0,a.Uk)("/"),S=(0,a._)("code",null,"ClassComponent",-1),q=(0,a.Uk)("/"),z=(0,a._)("code",null,"HostComponent",-1),H=(0,a.Uk)("），最终会进入"),N={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233",target:"_blank",rel:"noopener noreferrer"},Z=(0,a.Uk)("reconcileChildren"),A=(0,a.Uk)("方法。"),J=(0,a.uE)('<h2 id="reconcilechildren" tabindex="-1"><a class="header-anchor" href="#reconcilechildren" aria-hidden="true">#</a> reconcileChildren</h2><p>从该函数名就能看出这是<code>Reconciler</code>模块的核心部分。那么他究竟做了什么呢？</p><ul><li><p>对于<code>mount</code>的组件，他会创建新的<code>子Fiber节点</code></p></li><li><p>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的<code>Fiber节点</code>比较（也就是俗称的<code>Diff</code>算法），将比较的结果生成新<code>Fiber节点</code></p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span>\n  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>\n  <span class="token literal-property property">nextChildren</span><span class="token operator">:</span> any<span class="token punctuation">,</span>\n  <span class="token literal-property property">renderLanes</span><span class="token operator">:</span> Lanes</span>\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 对于mount的组件</span>\n    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>\n      workInProgress<span class="token punctuation">,</span>\n      <span class="token keyword">null</span><span class="token punctuation">,</span>\n      nextChildren<span class="token punctuation">,</span>\n      renderLanes<span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 对于update的组件</span>\n    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>\n      workInProgress<span class="token punctuation">,</span>\n      current<span class="token punctuation">.</span>child<span class="token punctuation">,</span>\n      nextChildren<span class="token punctuation">,</span>\n      renderLanes<span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码可以看出，和<code>beginWork</code>一样，他也是通过<code>current === null ?</code>区分<code>mount</code>与<code>update</code>。</p>',5),V=(0,a.Uk)("不论走哪个逻辑，最终他会生成新的子"),$=(0,a._)("code",null,"Fiber节点",-1),G=(0,a.Uk)("并赋值给"),K=(0,a._)("code",null,"workInProgress.child",-1),Q=(0,a.Uk)("，作为本次"),X=(0,a._)("code",null,"beginWork",-1),Y={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1158",target:"_blank",rel:"noopener noreferrer"},nn=(0,a.Uk)("返回值"),en=(0,a.Uk)("，并作为下次"),sn=(0,a._)("code",null,"performUnitOfWork",-1),an=(0,a.Uk)("执行时"),on=(0,a._)("code",null,"workInProgress",-1),cn=(0,a.Uk)("的"),tn={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1702",target:"_blank",rel:"noopener noreferrer"},pn=(0,a.Uk)("传参"),ln=(0,a.Uk)("。"),rn=(0,a.uE)('<div class="custom-container warning"><p class="custom-container-title">注意</p><p>值得一提的是，<code>mountChildFibers</code>与<code>reconcileChildFibers</code>这两个方法的逻辑基本一致。唯一的区别是：<code>reconcileChildFibers</code>会为生成的<code>Fiber节点</code>带上<code>effectTag</code>属性，而<code>mountChildFibers</code>不会。</p></div><h2 id="effecttag" tabindex="-1"><a class="header-anchor" href="#effecttag" aria-hidden="true">#</a> effectTag</h2><p>我们知道，<code>render阶段</code>的工作是在内存中进行，当工作结束后会通知<code>Renderer</code>需要执行的<code>DOM</code>操作。要执行<code>DOM</code>操作的具体类型就保存在<code>fiber.effectTag</code>中。</p>',3),dn=(0,a.Uk)("你可以从"),un={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js",target:"_blank",rel:"noopener noreferrer"},kn=(0,a.Uk)("这里"),mn=(0,a.Uk)("看到"),bn=(0,a._)("code",null,"effectTag",-1),vn=(0,a.Uk)("对应的"),gn=(0,a._)("code",null,"DOM",-1),fn=(0,a.Uk)("操作"),hn=(0,a.uE)('<p>比如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// DOM需要插入到页面中</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b00000000000010</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM需要更新</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b00000000000100</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM需要插入到页面中并更新</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*       */</span> <span class="token number">0b00000000000110</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM需要删除</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*                 */</span> <span class="token number">0b00000000001000</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>通过二进制表示<code>effectTag</code>，可以方便的使用位操作为<code>fiber.effectTag</code>赋值多个<code>effect</code>。</p></blockquote><p>那么，如果要通知<code>Renderer</code>将<code>Fiber节点</code>对应的<code>DOM节点</code>插入页面中，需要满足两个条件：</p><ol><li><p><code>fiber.stateNode</code>存在，即<code>Fiber节点</code>中保存了对应的<code>DOM节点</code></p></li><li><p><code>(fiber.effectTag &amp; Placement) !== 0</code>，即<code>Fiber节点</code>存在<code>Placement effectTag</code></p></li></ol><p>我们知道，<code>mount</code>时，<code>fiber.stateNode === null</code>，且在<code>reconcileChildren</code>中调用的<code>mountChildFibers</code>不会为<code>Fiber节点</code>赋值<code>effectTag</code>。那么首屏渲染如何完成呢？</p><p>针对第一个问题，<code>fiber.stateNode</code>会在<code>completeWork</code>中创建，我们会在下一节介绍。</p><p>第二个问题的答案十分巧妙：假设<code>mountChildFibers</code>也会赋值<code>effectTag</code>，那么可以预见<code>mount</code>时整棵<code>Fiber树</code>所有节点都会有<code>Placement effectTag</code>。那么<code>commit阶段</code>在执行<code>DOM</code>操作时每个节点都会执行一次插入操作，这样大量的<code>DOM</code>操作是极低效的。</p><p>为了解决这个问题，在<code>mount</code>时只有<code>rootFiber</code>会赋值<code>Placement effectTag</code>，在<code>commit阶段</code>只会执行一次插入操作。</p>',9),yn={class:"custom-container details"},wn=(0,a.uE)("<summary>根Fiber节点 Demo</summary><p>借用上一节的Demo，第一个进入<code>beginWork</code>方法的<code>Fiber节点</code>就是<code>rootFiber</code>，他的<code>alternate</code>指向<code>current rootFiber</code>（即他存在<code>current</code>）。</p>",2),_n=(0,a.Uk)("为什么"),Fn=(0,a._)("code",null,"rootFiber",-1),Un=(0,a.Uk)("节点存在"),Wn=(0,a._)("code",null,"current",-1),Cn=(0,a.Uk)("（即"),Pn=(0,a._)("code",null,"rootFiber.alternate",-1),xn=(0,a.Uk)("），我们在"),Ln=(0,a.Uk)("双缓存机制一节mount时的第二步"),jn=(0,a.Uk)("已经讲过"),In=(0,a.uE)("<p>由于存在<code>current</code>，<code>rootFiber</code>在<code>reconcileChildren</code>时会走<code>reconcileChildFibers</code>逻辑。</p><p>而之后通过<code>beginWork</code>创建的<code>Fiber节点</code>是不存在<code>current</code>的（即 <code>fiber.alternate === null</code>），会走<code>mountChildFibers</code>逻辑</p>",2),Rn=(0,a.Uk)("关注公众号"),Tn=(0,a.Uk)("，后台回复"),Dn=(0,a._)("strong",null,"531",-1),On=(0,a.Uk)("获得在线Demo地址"),En=(0,a._)("h2",{id:"参考资料",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),(0,a.Uk)(" 参考资料")],-1),Mn=(0,a._)("p",null,[(0,a._)("code",null,"beginWork"),(0,a.Uk)("流程图")],-1),Bn=["src"],Sn={},qn=(0,s(13860).Z)(Sn,[["render",function(n,e){const s=(0,a.up)("ExternalLinkIcon"),Sn=(0,a.up)("RouterLink");return(0,a.wg)(),(0,a.iD)("div",null,[o,c,(0,a._)("p",null,[t,(0,a._)("a",p,[l,(0,a.Wm)(s)]),r,i,d]),u,(0,a._)("p",null,[k,(0,a.Wm)(Sn,{to:"/react/process/doubleBuffer.html"},{default:(0,a.w5)((()=>[m])),_:1}),b,(0,a.Wm)(Sn,{to:"/react/process/doubleBuffer.html#mount%E6%97%B6"},{default:(0,a.w5)((()=>[v])),_:1}),g,f,h,y,w,_,F,U,W,C,P]),x,(0,a._)("blockquote",null,[(0,a._)("p",null,[L,(0,a._)("a",j,[I,(0,a.Wm)(s)]),R,T,D])]),O,(0,a._)("p",null,[E,M,B,S,q,z,H,(0,a._)("a",N,[Z,(0,a.Wm)(s)]),A]),J,(0,a._)("p",null,[V,$,G,K,Q,X,(0,a._)("a",Y,[nn,(0,a.Wm)(s)]),en,sn,an,on,cn,(0,a._)("a",tn,[pn,(0,a.Wm)(s)]),ln]),rn,(0,a._)("blockquote",null,[(0,a._)("p",null,[dn,(0,a._)("a",un,[kn,(0,a.Wm)(s)]),mn,bn,vn,gn,fn])]),hn,(0,a._)("details",yn,[wn,(0,a._)("blockquote",null,[(0,a._)("p",null,[_n,Fn,Un,Wn,Cn,Pn,xn,(0,a.Wm)(Sn,{to:"/react/process/doubleBuffer.html"},{default:(0,a.w5)((()=>[Ln])),_:1}),jn])]),In,(0,a._)("p",null,[(0,a.Wm)(Sn,{to:"/react/me.html"},{default:(0,a.w5)((()=>[Rn])),_:1}),Tn,Dn,On])]),En,Mn,(0,a._)("img",{src:n.$withBase("/img/beginWork.png"),alt:"beginWork流程图"},null,8,Bn)])}]])},13860:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}},92493:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a=JSON.parse('{"key":"v-5b4ba768","path":"/react/process/beginWork.html","title":"beginWork","lang":"zh-CN","frontmatter":{"title":"beginWork","author":"BetaSu","tag":["React"],"summary":"上一节我们了解到render阶段的工作可以分为“递”阶段和“归”阶段。其中“递”阶段会执行beginWork，“归”阶段会执行completeWork。这一节我们看看“递”阶段的beginWork方法究竟做了什么。 方法概览 可以从源码这里看到beginWork的定义。整个方法大概有500行代码。 从上一节我们已经知道，beginWork的工作是传入当前Fi","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/process/beginWork.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"beginWork"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"方法概览","slug":"方法概览","children":[{"level":3,"title":"从传参看方法执行","slug":"从传参看方法执行","children":[]}]},{"level":2,"title":"update时","slug":"update时","children":[]},{"level":2,"title":"mount时","slug":"mount时","children":[]},{"level":2,"title":"reconcileChildren","slug":"reconcilechildren","children":[]},{"level":2,"title":"effectTag","slug":"effecttag","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":5.42,"words":1626},"filePathRelative":"react/process/beginWork.md","localizedDate":"2022年8月29日"}')}}]);