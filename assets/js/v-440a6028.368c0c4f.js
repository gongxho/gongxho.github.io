"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[79650],{25961:(n,e,s)=>{s.r(e),s.d(e,{default:()=>q});var a=s(60329);const o=(0,a.uE)('<p>本章我们会讲解<code>Fiber节点</code>是如何被创建并构建<code>Fiber树</code>的。</p><p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p><p>我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// performSyncWorkOnRoot会调用该方法</span>\n<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// performConcurrentWorkOnRoot会调用该方法</span>\n<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，他们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p><p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p><p><code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber节点</code>连接起来构成<code>Fiber树</code>。</p>',7),t={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599",target:"_blank",rel:"noopener noreferrer"},c=(0,a._)("code",null,"workLoopConcurrent",-1),r=(0,a._)("p",null,[(0,a.Uk)("我们知道"),(0,a._)("code",null,"Fiber Reconciler"),(0,a.Uk)("是从"),(0,a._)("code",null,"Stack Reconciler"),(0,a.Uk)("重构而来，通过遍历的方式实现可中断的递归，所以"),(0,a._)("code",null,"performUnitOfWork"),(0,a.Uk)("的工作可以分为两部分：“递”和“归”。")],-1),p=(0,a._)("h2",{id:"递-阶段",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#递-阶段","aria-hidden":"true"},"#"),(0,a.Uk)(" “递”阶段")],-1),i=(0,a._)("code",null,"rootFiber",-1),l=(0,a._)("code",null,"Fiber节点",-1),u={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058",target:"_blank",rel:"noopener noreferrer"},d=(0,a._)("p",null,[(0,a.Uk)("该方法会根据传入的"),(0,a._)("code",null,"Fiber节点"),(0,a.Uk)("创建"),(0,a._)("code",null,"子Fiber节点"),(0,a.Uk)("，并将这两个"),(0,a._)("code",null,"Fiber节点"),(0,a.Uk)("连接起来。")],-1),k=(0,a._)("p",null,"当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。",-1),b=(0,a._)("h2",{id:"归-阶段",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#归-阶段","aria-hidden":"true"},"#"),(0,a.Uk)(" “归”阶段")],-1),m={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652",target:"_blank",rel:"noopener noreferrer"},v=(0,a._)("code",null,"Fiber节点",-1),f=(0,a.uE)('<p>当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。</p><p>如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p><p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p><h2 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h2><p>以上一节的例子举例：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n      i am\n      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\nReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',6),g=(0,a._)("code",null,"Fiber树",-1),h=["src"],_=(0,a.uE)('<p><code>render阶段</code>会依次执行：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token number">1</span>. rootFiber beginWork\n<span class="token number">2</span>. App Fiber beginWork\n<span class="token number">3</span>. div Fiber beginWork\n<span class="token number">4</span>. <span class="token string">&quot;i am&quot;</span> Fiber beginWork\n<span class="token number">5</span>. <span class="token string">&quot;i am&quot;</span> Fiber completeWork\n<span class="token number">6</span>. span Fiber beginWork\n<span class="token number">7</span>. span Fiber completeWork\n<span class="token number">8</span>. div Fiber completeWork\n<span class="token number">9</span>. App Fiber completeWork\n<span class="token number">10</span>. rootFiber completeWork\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container warning"><p class="custom-container-title">注意</p><p>之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的<code>Fiber</code>，<code>React</code>会特殊处理。</p></div>',3),U={class:"custom-container details"},W=(0,a._)("summary",null,"自己试一试 Demo",-1),w=(0,a._)("p",null,[(0,a.Uk)("我在"),(0,a._)("code",null,"beginWork"),(0,a.Uk)("和"),(0,a._)("code",null,"completeWork"),(0,a.Uk)("调用时打印"),(0,a._)("code",null,"fiber.tag"),(0,a.Uk)("和"),(0,a._)("code",null,"fiber.type"),(0,a.Uk)("。")],-1),F={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactWorkTags.js",target:"_blank",rel:"noopener noreferrer"},y=(0,a._)("code",null,"Fiber节点",-1),R=(0,a._)("code",null,"tag",-1),O=(0,a._)("p",null,"相信多调试几次，你一定能明白方法的调用顺序",-1),j=(0,a._)("strong",null,"904",-1),x=(0,a.uE)('<details class="custom-container details"><summary>performUnitOfWork 的递归版本</summary><p>如果将<code>performUnitOfWork</code>转化为递归版本，大体代码如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 执行beginWork</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 执行completeWork</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本节我们介绍了<code>render阶段</code>会调用的方法。在接下来两节中，我们会讲解<code>beginWork</code>和<code>completeWork</code>做的具体工作。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',4),I={href:"https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/",target:"_blank",rel:"noopener noreferrer"},C={href:"https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/",target:"_blank",rel:"noopener noreferrer"},S={},q=(0,s(13860).Z)(S,[["render",function(n,e){const s=(0,a.up)("ExternalLinkIcon"),S=(0,a.up)("RouterLink");return(0,a.wg)(),(0,a.iD)("div",null,[o,(0,a._)("blockquote",null,[(0,a._)("p",null,[(0,a.Uk)("你可以从"),(0,a._)("a",t,[(0,a.Uk)("这里"),(0,a.Wm)(s)]),(0,a.Uk)("看到"),c,(0,a.Uk)("的源码")])]),r,p,(0,a._)("p",null,[(0,a.Uk)("首先从"),i,(0,a.Uk)("开始向下深度优先遍历。为遍历到的每个"),l,(0,a.Uk)("调用"),(0,a._)("a",u,[(0,a.Uk)("beginWork方法"),(0,a.Wm)(s)]),(0,a.Uk)("。")]),d,k,b,(0,a._)("p",null,[(0,a.Uk)("在“归”阶段会调用"),(0,a._)("a",m,[(0,a.Uk)("completeWork"),(0,a.Wm)(s)]),(0,a.Uk)("处理"),v,(0,a.Uk)("。")]),f,(0,a._)("p",null,[(0,a.Uk)("对应的"),g,(0,a.Uk)("结构： "),(0,a._)("img",{src:n.$withBase("/img/fiber.png"),alt:"Fiber架构"},null,8,h)]),_,(0,a._)("details",U,[W,w,(0,a._)("p",null,[(0,a.Uk)("你可以从"),(0,a._)("a",F,[(0,a.Uk)("ReactWorkTags.js"),(0,a.Wm)(s)]),(0,a.Uk)("看到"),y,(0,a.Uk)("的所有"),R,(0,a.Uk)("定义。")]),O,(0,a._)("p",null,[(0,a.Wm)(S,{to:"/react/me.html"},{default:(0,a.w5)((()=>[(0,a.Uk)("关注公众号")])),_:1}),(0,a.Uk)("，后台回复"),j,(0,a.Uk)("获得在线Demo地址")])]),x,(0,a._)("p",null,[(0,a._)("a",I,[(0,a.Uk)("The how and why on React’s usage of linked list in Fiber to walk the component’s tree"),(0,a.Wm)(s)])]),(0,a._)("p",null,[(0,a._)("a",C,[(0,a.Uk)("Inside Fiber: in-depth overview of the new reconciliation algorithm in React"),(0,a.Wm)(s)])])])}]])},13860:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}},47892:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a=JSON.parse('{"key":"v-440a6028","path":"/react/process/reconciler.html","title":"流程概览","lang":"zh-CN","frontmatter":{"title":"流程概览","author":"BetaSu","tag":["React"],"summary":"本章我们会讲解Fiber节点是如何被创建并构建Fiber树的。 render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。 我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法： 可以看到，他们唯一的区别是是否调用shoul","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/process/reconciler.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"流程概览"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"“递”阶段","slug":"递-阶段","children":[]},{"level":2,"title":"“归”阶段","slug":"归-阶段","children":[]},{"level":2,"title":"例子","slug":"例子","children":[]},{"level":2,"title":"总结","slug":"总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":2.89,"words":868},"filePathRelative":"react/process/reconciler.md","localizedDate":"2022年8月29日"}')}}]);