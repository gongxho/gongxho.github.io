"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[16153],{10204:(n,e,a)=>{a.r(e),a.d(e,{default:()=>dn});var s=a(78e3);const t=(0,s._)("p",null,"软件的设计是为了服务理念。只有懂了设计理念，才能明白为了实现这样的理念需要如何架构。",-1),o=(0,s._)("p",null,[(0,s.Uk)("所以，在我们深入源码架构之前，先来聊聊"),(0,s._)("code",null,"React"),(0,s.Uk)("理念。")],-1),p=(0,s._)("h2",{id:"react理念",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#react理念","aria-hidden":"true"},"#"),(0,s.Uk)(" React理念")],-1),l=(0,s.Uk)("我们可以从"),c={href:"https://zh-hans.reactjs.org/docs/thinking-in-react.html",target:"_blank",rel:"noopener noreferrer"},r=(0,s.Uk)("官网"),i=(0,s.Uk)("看到"),u=(0,s._)("code",null,"React",-1),d=(0,s.Uk)("的理念："),k=(0,s.uE)('<blockquote><p>我们认为，React 是用 JavaScript 构建<strong>快速响应</strong>的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p></blockquote><p>可见，关键是实现<code>快速响应</code>。那么制约<code>快速响应</code>的因素是什么呢？</p><p>我们日常使用App，浏览网页时，有两类场景会制约<code>快速响应</code>：</p><ul><li><p>当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</p></li><li><p>发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</p></li></ul><p>这两类场景可以概括为：</p><ul><li><p>CPU的瓶颈</p></li><li><p>IO的瓶颈</p></li></ul><p><code>React</code>是如何解决这两个瓶颈的呢？</p><h2 id="cpu的瓶颈" tabindex="-1"><a class="header-anchor" href="#cpu的瓶颈" aria-hidden="true">#</a> CPU的瓶颈</h2><p>当项目变得庞大、组件数量繁多时，就容易遇到CPU的瓶颈。</p><p>考虑如下Demo，我们向视图中渲染3000个<code>li</code>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>\n      <span class="token punctuation">{</span><span class="token function">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> rootEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>  \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主流浏览器刷新频率为60Hz，即每（1000ms / 60Hz）16.6ms浏览器刷新一次。</p><p>我们知道，JS可以操作DOM，<code>GUI渲染线程</code>与<code>JS线程</code>是互斥的。所以<strong>JS脚本执行</strong>和<strong>浏览器布局、绘制</strong>不能同时执行。</p><p>在每16.6ms时间内，需要完成如下工作：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>JS脚本执行 -----  样式布局 ----- 样式绘制\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>了。</p><p>在Demo中，由于组件数量繁多（3000个），JS脚本执行时间过长，页面掉帧，造成卡顿。</p><p>可以从打印的执行堆栈图看到，JS执行时间为73.65ms，远远多于一帧的时间。</p>',18),m=["src"],g=(0,s._)("p",null,"如何解决这个问题呢？",-1),h=(0,s.Uk)("答案是：在浏览器每一帧的时间中，预留一些时间给JS线程，"),_=(0,s._)("code",null,"React",-1),v=(0,s.Uk)("利用这部分时间更新组件（可以看到，在"),b={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119",target:"_blank",rel:"noopener noreferrer"},U=(0,s.Uk)("源码"),f=(0,s.Uk)("中，预留的初始时间是5ms）。"),R=(0,s.uE)('<p>当预留的时间不够用时，<code>React</code>将线程控制权交还给浏览器使其有时间渲染UI，<code>React</code>则等待下一帧时间到来继续被中断的工作。</p><blockquote><p>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为<code>时间切片</code>（time slice）</p></blockquote><p>接下来我们开启<code>Concurrent Mode</code>（后续章节会讲到，当前你只需了解开启后会启用<code>时间切片</code>）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode</span>\n<span class="token comment">// ReactDOM.render(&lt;App/&gt;, rootEl);  </span>\nReactDOM<span class="token punctuation">.</span><span class="token function">unstable_createRoot</span><span class="token punctuation">(</span>rootEl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="highlight-lines"><br><br><div class="highlight-line"> </div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的长任务被拆分到每一帧不同的<code>task</code>中，<code>JS脚本</code>执行时间大体在<code>5ms</code>左右，这样浏览器就有剩余时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>，减少掉帧的可能性。</p>',5),S=["src"],y=(0,s._)("p",null,[(0,s.Uk)("所以，解决"),(0,s._)("code",null,"CPU瓶颈"),(0,s.Uk)("的关键是实现"),(0,s._)("code",null,"时间切片"),(0,s.Uk)("，而"),(0,s._)("code",null,"时间切片"),(0,s.Uk)("的关键是：将"),(0,s._)("strong",null,"同步的更新"),(0,s.Uk)("变为"),(0,s._)("strong",null,"可中断的异步更新"),(0,s.Uk)("。")],-1),w={class:"custom-container details"},x=(0,s._)("summary",null,"同步更新 vs 异步更新 Demo",-1),C=(0,s._)("p",null,[(0,s.Uk)("我们有个更新很耗时的大列表，让我们看看"),(0,s._)("strong",null,"同步更新"),(0,s.Uk)("和"),(0,s._)("strong",null,"异步更新"),(0,s.Uk)("时，输入框的响应速度")],-1),D=(0,s.Uk)("关注公众号"),J=(0,s.Uk)("，后台回复"),O=(0,s._)("strong",null,"323",-1),j=(0,s.Uk)("获得在线Demo地址"),I=(0,s._)("p",null,[(0,s.Uk)("可以从Demo看到，当牺牲了列表的更新速度，"),(0,s._)("code",null,"React"),(0,s.Uk)("大幅提高了输入响应速度，使交互更自然。")],-1),z=(0,s._)("h2",{id:"io的瓶颈",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#io的瓶颈","aria-hidden":"true"},"#"),(0,s.Uk)(" IO的瓶颈")],-1),W=(0,s._)("p",null,[(0,s._)("code",null,"网络延迟"),(0,s.Uk)("是前端开发者无法解决的。如何在"),(0,s._)("code",null,"网络延迟"),(0,s.Uk)("客观存在的情况下，减少用户对"),(0,s._)("code",null,"网络延迟"),(0,s.Uk)("的感知？")],-1),q=(0,s._)("code",null,"React",-1),E=(0,s.Uk)("给出的答案是"),B={href:"https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production",target:"_blank",rel:"noopener noreferrer"},M=(0,s.Uk)("将人机交互研究的结果整合到真实的 UI 中"),P=(0,s.Uk)("。"),A=(0,s._)("p",null,"这里我们以业界人机交互最顶尖的苹果举例，在IOS系统中：",-1),T=(0,s._)("p",null,"点击“设置”面板中的“通用”，进入“通用”界面：",-1),Z=["src"],$=(0,s._)("p",null,"作为对比，再点击“设置”面板中的“Siri与搜索”，进入“Siri与搜索”界面：",-1),H=["src"],L=(0,s._)("p",null,"你能感受到两者体验上的区别么？",-1),N=(0,s._)("p",null,"事实上，点击“通用”后的交互是同步的，直接显示后续界面。而点击“Siri与搜索”后的交互是异步的，需要等待请求返回后再显示后续界面。但从用户感知来看，这两者的区别微乎其微。",-1),F=(0,s._)("p",null,"这里的窍门在于：点击“Siri与搜索”后，先在当前页面停留了一小段时间，这一小段时间被用来请求数据。",-1),V=(0,s._)("p",null,[(0,s.Uk)("当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示"),(0,s._)("code",null,"loading"),(0,s.Uk)("的效果。")],-1),G=(0,s._)("p",null,[(0,s.Uk)("试想如果我们一点击“Siri与搜索”就显示"),(0,s._)("code",null,"loading"),(0,s.Uk)("效果，即使数据请求时间很短，"),(0,s._)("code",null,"loading"),(0,s.Uk)("效果一闪而过。用户也是可以感知到的。")],-1),K=(0,s.Uk)("为此，"),Q=(0,s._)("code",null,"React",-1),X=(0,s.Uk)("实现了"),Y={href:"https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html",target:"_blank",rel:"noopener noreferrer"},nn=(0,s.Uk)("Suspense"),en=(0,s.Uk)("功能及配套的"),an=(0,s._)("code",null,"hook",-1),sn=(0,s.Uk)("——"),tn={href:"https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue",target:"_blank",rel:"noopener noreferrer"},on=(0,s.Uk)("useDeferredValue"),pn=(0,s.Uk)("。"),ln=(0,s.uE)('<p>而在源码内部，为了支持这些特性，同样需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过以上内容，我们可以看到，<code>React</code>为了践行“构建<strong>快速响应</strong>的大型 Web 应用程序”理念做出的努力。</p><p>其中的关键是解决CPU的瓶颈与IO的瓶颈。而落实到实现上，则需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',5),cn={href:"https://www.bilibili.com/video/BV134411c7Sk?from=search&seid=17404881291635824595",target:"_blank",rel:"noopener noreferrer"},rn=(0,s.Uk)("「英文」尤雨溪论JavaScript框架设计哲学：平衡"),un={},dn=(0,a(13860).Z)(un,[["render",function(n,e){const a=(0,s.up)("ExternalLinkIcon"),un=(0,s.up)("RouterLink");return(0,s.wg)(),(0,s.iD)("div",null,[t,o,p,(0,s._)("p",null,[l,(0,s._)("a",c,[r,(0,s.Wm)(a)]),i,u,d]),k,(0,s._)("img",{src:n.$withBase("/img/long-task.png"),alt:"长任务"},null,8,m),g,(0,s._)("p",null,[h,_,v,(0,s._)("a",b,[U,(0,s.Wm)(a)]),f]),R,(0,s._)("img",{src:n.$withBase("/img/time-slice.png"),alt:"长任务"},null,8,S),y,(0,s._)("details",w,[x,C,(0,s._)("p",null,[(0,s.Wm)(un,{to:"/react/me.html"},{default:(0,s.w5)((()=>[D])),_:1}),J,O,j]),I]),z,W,(0,s._)("p",null,[q,E,(0,s._)("a",B,[M,(0,s.Wm)(a)]),P]),A,T,(0,s._)("img",{src:n.$withBase("/img/legacy-move.gif"),alt:"同步"},null,8,Z),$,(0,s._)("img",{src:n.$withBase("/img/concurrent-mov.gif"),alt:"异步"},null,8,H),L,N,F,V,G,(0,s._)("p",null,[K,Q,X,(0,s._)("a",Y,[nn,(0,s.Wm)(a)]),en,an,sn,(0,s._)("a",tn,[on,(0,s.Wm)(a)]),pn]),ln,(0,s._)("p",null,[(0,s._)("a",cn,[rn,(0,s.Wm)(a)])])])}]])},13860:(n,e)=>{e.Z=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},47401:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s=JSON.parse('{"key":"v-297e08be","path":"/react/preparation/idea.html","title":"React理念","lang":"zh-CN","frontmatter":{"title":"React理念","author":"BetaSu","tag":["React"],"summary":"软件的设计是为了服务理念。只有懂了设计理念，才能明白为了实现这样的理念需要如何架构。 所以，在我们深入源码架构之前，先来聊聊React理念。 React理念 我们可以从官网看到React的理念： \\" 我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。\\"","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/preparation/idea.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"React理念"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"React理念","slug":"react理念","children":[]},{"level":2,"title":"CPU的瓶颈","slug":"cpu的瓶颈","children":[]},{"level":2,"title":"IO的瓶颈","slug":"io的瓶颈","children":[]},{"level":2,"title":"总结","slug":"总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":5.02,"words":1507},"filePathRelative":"react/preparation/idea.md","localizedDate":"2022年8月29日"}')}}]);