"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[49944],{63442:(e,r,t)=>{t.r(r),t.d(r,{default:()=>fe});var n=t(78e3);const o=(0,n.uE)('<p>在上一节中我们了解了<code>React</code>的理念，简单概括就是<strong>快速响应</strong>。</p><p><code>React</code>从v15升级到v16后重构了整个架构。本节我们聊聊v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构。</p><h2 id="react15架构" tabindex="-1"><a class="header-anchor" href="#react15架构" aria-hidden="true">#</a> React15架构</h2><p>React15架构可以分为两层：</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="reconciler-协调器" tabindex="-1"><a class="header-anchor" href="#reconciler-协调器" aria-hidden="true">#</a> Reconciler（协调器）</h3><p>我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等API触发更新。</p><p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p><ul><li>调用函数组件、或class组件的<code>render</code>方法，将返回的JSX转化为虚拟DOM</li><li>将虚拟DOM和上次更新时的虚拟DOM对比</li><li>通过对比找出本次更新中变化的虚拟DOM</li><li>通知<strong>Renderer</strong>将变化的虚拟DOM渲染到页面上</li></ul>',9),l=(0,n.Uk)("你可以在"),a={href:"https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers",target:"_blank",rel:"noopener noreferrer"},c=(0,n.Uk)("这里"),d=(0,n.Uk)("看到"),s=(0,n._)("code",null,"React",-1),i=(0,n.Uk)("官方对"),p=(0,n._)("strong",null,"Reconciler",-1),u=(0,n.Uk)("的解释"),h=(0,n._)("h3",{id:"renderer-渲染器",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#renderer-渲染器","aria-hidden":"true"},"#"),(0,n.Uk)(" Renderer（渲染器）")],-1),m=(0,n.Uk)("由于"),k=(0,n._)("code",null,"React",-1),g=(0,n.Uk)("支持跨平台，所以不同平台有不同的"),_=(0,n._)("strong",null,"Renderer",-1),R=(0,n.Uk)("。我们前端最熟悉的是负责在浏览器环境渲染的"),U=(0,n._)("strong",null,"Renderer",-1),f=(0,n.Uk)(" —— "),b={href:"https://www.npmjs.com/package/react-dom",target:"_blank",rel:"noopener noreferrer"},v=(0,n.Uk)("ReactDOM"),w=(0,n.Uk)("。"),y=(0,n._)("p",null,"除此之外，还有：",-1),D={href:"https://www.npmjs.com/package/react-native",target:"_blank",rel:"noopener noreferrer"},O=(0,n.Uk)("ReactNative"),C=(0,n.Uk)("渲染器，渲染App原生组件"),M={href:"https://www.npmjs.com/package/react-test-renderer",target:"_blank",rel:"noopener noreferrer"},x=(0,n.Uk)("ReactTest"),W=(0,n.Uk)("渲染器，渲染出纯Js对象用于测试"),j={href:"https://www.npmjs.com/package/react-art",target:"_blank",rel:"noopener noreferrer"},z=(0,n.Uk)("ReactArt"),S=(0,n.Uk)("渲染器，渲染到Canvas, SVG 或 VML (IE8)"),T=(0,n._)("p",null,[(0,n.Uk)("在每次更新发生时，"),(0,n._)("strong",null,"Renderer"),(0,n.Uk)("接到"),(0,n._)("strong",null,"Reconciler"),(0,n.Uk)("通知，将变化的组件渲染在当前宿主环境。")],-1),E=(0,n.Uk)("你可以在"),L={href:"https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers",target:"_blank",rel:"noopener noreferrer"},q=(0,n.Uk)("这里"),B=(0,n.Uk)("看到"),N=(0,n._)("code",null,"React",-1),Z=(0,n.Uk)("官方对"),A=(0,n._)("strong",null,"Renderer",-1),I=(0,n.Uk)("的解释"),J=(0,n._)("h2",{id:"react15架构的缺点",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#react15架构的缺点","aria-hidden":"true"},"#"),(0,n.Uk)(" React15架构的缺点")],-1),P=(0,n.Uk)("在"),V=(0,n._)("strong",null,"Reconciler",-1),$=(0,n.Uk)("中，"),G=(0,n._)("code",null,"mount",-1),X=(0,n.Uk)("的组件会调用"),F={href:"https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498",target:"_blank",rel:"noopener noreferrer"},H=(0,n.Uk)("mountComponent"),K=(0,n.Uk)("，"),Q=(0,n._)("code",null,"update",-1),Y=(0,n.Uk)("的组件会调用"),ee={href:"https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877",target:"_blank",rel:"noopener noreferrer"},re=(0,n.Uk)("updateComponent"),te=(0,n.Uk)("。这两个方法都会递归更新子组件。"),ne=(0,n._)("h3",{id:"递归更新的缺点",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#递归更新的缺点","aria-hidden":"true"},"#"),(0,n.Uk)(" 递归更新的缺点")],-1),oe=(0,n._)("p",null,"由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。",-1),le=(0,n._)("p",null,[(0,n.Uk)("在上一节中，我们已经提出了解决办法——用"),(0,n._)("strong",null,"可中断的异步更新"),(0,n.Uk)("代替"),(0,n._)("strong",null,"同步的更新"),(0,n.Uk)("。那么React15的架构支持异步更新么？让我们看一个例子：")],-1),ae={class:"custom-container details"},ce=(0,n._)("summary",null,"乘法小Demo",-1),de=(0,n.Uk)("关注公众号"),se=(0,n.Uk)("，后台回复"),ie=(0,n._)("strong",null,"222",-1),pe=(0,n.Uk)("获得在线Demo地址"),ue=(0,n._)("p",null,[(0,n.Uk)("初始化时"),(0,n._)("code",null,"state.count = 1"),(0,n.Uk)("，每次点击按钮"),(0,n._)("code",null,"state.count++")],-1),he=(0,n._)("p",null,[(0,n.Uk)("列表中3个元素的值分别为1，2，3乘以"),(0,n._)("code",null,"state.count"),(0,n.Uk)("的结果")],-1),me=(0,n.Uk)("我用红色标注了更新的步骤。 "),ke=["src"],ge=(0,n.uE)('<p>我们可以看到，<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，当第一个<code>li</code>在页面上已经变化后，第二个<code>li</code>再进入<strong>Reconciler</strong>。</p><p>由于整个过程都是同步的，所以在用户看来所有DOM是同时更新的。</p><p>接下来，让我们模拟一下，如果中途中断更新会怎么样？</p><div class="custom-container danger"><p class="custom-container-title">注意</p><p>以下是我们模拟中断的情况，实际上<code>React15</code>并不会中断进行中的更新</p></div>',4),_e=["src"],Re=(0,n.uE)("<p>当第一个<code>li</code>完成更新时中断更新，即步骤3完成后中断更新，此时后面的步骤都还未执行。</p><p>用户本来期望<code>123</code>变为<code>246</code>。实际却看见更新不完全的DOM！（即<code>223</code>）</p><p>基于这个原因，<code>React</code>决定重写整个架构。</p>",3),Ue={},fe=(0,t(13860).Z)(Ue,[["render",function(e,r){const t=(0,n.up)("ExternalLinkIcon"),Ue=(0,n.up)("RouterLink");return(0,n.wg)(),(0,n.iD)("div",null,[o,(0,n._)("blockquote",null,[(0,n._)("p",null,[l,(0,n._)("a",a,[c,(0,n.Wm)(t)]),d,s,i,p,u])]),h,(0,n._)("p",null,[m,k,g,_,R,U,f,(0,n._)("a",b,[v,(0,n.Wm)(t)]),w]),y,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",D,[O,(0,n.Wm)(t)]),C]),(0,n._)("li",null,[(0,n._)("a",M,[x,(0,n.Wm)(t)]),W]),(0,n._)("li",null,[(0,n._)("a",j,[z,(0,n.Wm)(t)]),S])]),T,(0,n._)("blockquote",null,[(0,n._)("p",null,[E,(0,n._)("a",L,[q,(0,n.Wm)(t)]),B,N,Z,A,I])]),J,(0,n._)("p",null,[P,V,$,G,X,(0,n._)("a",F,[H,(0,n.Wm)(t)]),K,Q,Y,(0,n._)("a",ee,[re,(0,n.Wm)(t)]),te]),ne,oe,le,(0,n._)("details",ae,[ce,(0,n._)("p",null,[(0,n.Wm)(Ue,{to:"/react/me.html"},{default:(0,n.w5)((()=>[de])),_:1}),se,ie,pe]),ue,he]),(0,n._)("p",null,[me,(0,n._)("img",{src:e.$withBase("/img/v15.png"),alt:"更新流程"},null,8,ke)]),ge,(0,n._)("img",{src:e.$withBase("/img/dist.png"),alt:"中断更新流程"},null,8,_e),Re])}]])},13860:(e,r)=>{r.Z=(e,r)=>{const t=e.__vccOpts||e;for(const[e,n]of r)t[e]=n;return t}},80114:(e,r,t)=>{t.r(r),t.d(r,{data:()=>n});const n=JSON.parse('{"key":"v-5c7c75bc","path":"/react/preparation/oldConstructure.html","title":"老的React架构","lang":"zh-CN","frontmatter":{"title":"老的React架构","author":"BetaSu","tag":["React"],"summary":"在上一节中我们了解了React的理念，简单概括就是快速响应。 React从v15升级到v16后重构了整个架构。本节我们聊聊v15，看看他为什么不能满足快速响应的理念，以至于被重构。 React15架构 React15架构可以分为两层： Reconciler（协调器）—— 负责找出变化的组件; Renderer（渲染器）—— 负责将变化的组件渲染到页面上; R","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/preparation/oldConstructure.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"老的React架构"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"React15架构","slug":"react15架构","children":[{"level":3,"title":"Reconciler（协调器）","slug":"reconciler-协调器","children":[]},{"level":3,"title":"Renderer（渲染器）","slug":"renderer-渲染器","children":[]}]},{"level":2,"title":"React15架构的缺点","slug":"react15架构的缺点","children":[{"level":3,"title":"递归更新的缺点","slug":"递归更新的缺点","children":[]}]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":2.88,"words":864},"filePathRelative":"react/preparation/oldConstructure.md","localizedDate":"2022年8月29日"}')}}]);