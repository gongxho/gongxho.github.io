"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[60558],{18630:(e,i,l)=>{l.r(i),l.d(i,{default:()=>a});var d=l(60329);const t=[(0,d.uE)('<h2 id="什么是mvvm" tabindex="-1"><a class="header-anchor" href="#什么是mvvm" aria-hidden="true">#</a> 什么是mvvm？</h2><blockquote><p>MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象</p></blockquote><ul><li>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</li><li>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</li></ul><h2 id="vue的优点是什么" tabindex="-1"><a class="header-anchor" href="#vue的优点是什么" aria-hidden="true">#</a> vue的优点是什么？</h2><ul><li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变</li><li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li></ul><h2 id="请详细说下你对vue生命周期的理解" tabindex="-1"><a class="header-anchor" href="#请详细说下你对vue生命周期的理解" aria-hidden="true">#</a> 请详细说下你对vue生命周期的理解</h2><blockquote><p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote><ul><li>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有</li><li>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</li><li>更新前/后：当data变化时，会触发beforeUpdate和updated方法</li><li>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</li></ul><h2 id="组件之间的传值" tabindex="-1"><a class="header-anchor" href="#组件之间的传值" aria-hidden="true">#</a> 组件之间的传值？</h2><p><strong>父组件与子组件传值</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//父组件通过标签上面定义传值\n&lt;template&gt;\n    &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    //引入子组件\n    import Main form &quot;./main&quot;\n    \n    exprot default{\n        name:&quot;parent&quot;,\n        data(){\n            return {\n                data:&quot;我要向子组件传递数据&quot;\n            }\n        },\n        //初始化组件\n        components:{\n            Main\n        }\n    }\n&lt;/script&gt;\n\n\n//子组件通过props方法接受数据\n\n&lt;template&gt;\n    &lt;div&gt;{{data}}&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    exprot default{\n        name:&quot;son&quot;,\n        //接受父组件传值\n        props:[&quot;data&quot;]\n    }\n&lt;/script&gt;\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>子组件向父组件传递数据</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//子组件通过$emit方法传递参数\n&lt;template&gt;\n   &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    //引入子组件\n    import Main form &quot;./main&quot;\n    \n    exprot default{\n        methods:{\n            events:function(){\n                \n            }\n        }\n    }\n&lt;/script&gt;\n\n\n//\n\n&lt;template&gt;\n    &lt;div&gt;{{data}}&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    exprot default{\n        name:&quot;son&quot;,\n        //接受父组件传值\n        props:[&quot;data&quot;]\n    }\n&lt;/script&gt;\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="路由之间跳转" tabindex="-1"><a class="header-anchor" href="#路由之间跳转" aria-hidden="true">#</a> 路由之间跳转？</h2><p><strong>声明式（标签跳转）</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;router-link :to=&quot;index&quot;&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>编程式（ js跳转）</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>router.push(&#39;index&#39;)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="vuex是什么-怎么使用-哪种功能场景使用它" tabindex="-1"><a class="header-anchor" href="#vuex是什么-怎么使用-哪种功能场景使用它" aria-hidden="true">#</a> vuex是什么？怎么使用？哪种功能场景使用它？</h2><blockquote><p>vue框架中状态管理。在main.js引入store，注入。新建了一个目录<code>store</code>，….. <code>export</code> 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p></blockquote><h2 id="实现-vue-ssr" tabindex="-1"><a class="header-anchor" href="#实现-vue-ssr" aria-hidden="true">#</a> 实现 Vue SSR</h2><p><img src="http://7xq6al.com1.z0.glb.clouddn.com/vue-ssr.jpg" alt=""></p><p><strong>其基本实现原理</strong></p><ul><li>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。</li><li>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。</li><li>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。</li><li>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__ </code>发送到客户端</li></ul><blockquote><p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的</p></blockquote><ul><li><code>Vue SSR </code>需要做的事多点（输出完整 HTML），除了<code> complier -&gt; vnode</code>，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。 相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点</li></ul><h2 id="vue-组件-data-为什么必须是函数" tabindex="-1"><a class="header-anchor" href="#vue-组件-data-为什么必须是函数" aria-hidden="true">#</a> Vue 组件 data 为什么必须是函数</h2><ul><li>每个组件都是 Vue 的实例。</li><li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul><h2 id="vue-computed-实现" tabindex="-1"><a class="header-anchor" href="#vue-computed-实现" aria-hidden="true">#</a> Vue computed 实现</h2><ul><li>建立与其他属性（如：data、 Store）的联系；</li><li>属性改变后，通知计算属性重新计算</li></ul><blockquote><p>实现时，主要如下</p></blockquote><ul><li>初始化 data， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li><li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。</li><li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li><li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集</li></ul><h2 id="vue-complier-实现" tabindex="-1"><a class="header-anchor" href="#vue-complier-实现" aria-hidden="true">#</a> Vue complier 实现</h2><ul><li>模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。</li><li>总的来说，Vue complier 是将 template 转化成一个 render 字符串。</li></ul><blockquote><p>可以简单理解成以下步骤：</p></blockquote><ul><li>parse 过程，将 template 利用正则转化成 AST 抽象语法树。</li><li>optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。</li><li>generate 过程，生成 render 字符串</li></ul><h2 id="怎么快速定位哪个组件出现性能问题" tabindex="-1"><a class="header-anchor" href="#怎么快速定位哪个组件出现性能问题" aria-hidden="true">#</a> 怎么快速定位哪个组件出现性能问题</h2><blockquote><p>用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote>',38)],n={},a=(0,l(13860).Z)(n,[["render",function(e,i){return(0,d.wg)(),(0,d.iD)("div",null,t)}]])},13860:(e,i)=>{i.Z=(e,i)=>{const l=e.__vccOpts||e;for(const[e,d]of i)l[e]=d;return l}},19389:(e,i,l)=>{l.r(i),l.d(i,{data:()=>d});const d=JSON.parse('{"key":"v-30ce2d4a","path":"/Interview/base/vue.html","title":"Vue 相关问题","lang":"zh-CN","frontmatter":{"title":"Vue 相关问题","icon":null,"date":"2022-12-15T00:00:00.000Z","category":["Interview"],"summary":"什么是mvvm？ --- \\" MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象\\" 在MVVM架构下，View 和 Model","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/Interview/base/vue.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"Vue 相关问题"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-01-17T08:24:10.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2022-12-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-17T08:24:10.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"什么是mvvm？","slug":"什么是mvvm","children":[]},{"level":2,"title":"vue的优点是什么？","slug":"vue的优点是什么","children":[]},{"level":2,"title":"请详细说下你对vue生命周期的理解","slug":"请详细说下你对vue生命周期的理解","children":[]},{"level":2,"title":"组件之间的传值？","slug":"组件之间的传值","children":[]},{"level":2,"title":"路由之间跳转？","slug":"路由之间跳转","children":[]},{"level":2,"title":"vuex是什么？怎么使用？哪种功能场景使用它？","slug":"vuex是什么-怎么使用-哪种功能场景使用它","children":[]},{"level":2,"title":"实现 Vue SSR","slug":"实现-vue-ssr","children":[]},{"level":2,"title":"Vue 组件 data 为什么必须是函数","slug":"vue-组件-data-为什么必须是函数","children":[]},{"level":2,"title":"Vue computed 实现","slug":"vue-computed-实现","children":[]},{"level":2,"title":"Vue complier 实现","slug":"vue-complier-实现","children":[]},{"level":2,"title":"怎么快速定位哪个组件出现性能问题","slug":"怎么快速定位哪个组件出现性能问题","children":[]}],"git":{"createdTime":1673943850000,"updatedTime":1673943850000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":5.56,"words":1669},"filePathRelative":"Interview/base/vue.md","localizedDate":"2022年12月15日"}')}}]);