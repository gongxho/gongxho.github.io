"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[73926],{58368:(e,n,a)=>{a.r(n),a.d(n,{default:()=>G});var t=a(60329);const r=(0,t.uE)('<p>上一节我们聊到React15架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的React16是如何支持异步更新的。</p><h2 id="react16架构" tabindex="-1"><a class="header-anchor" href="#react16架构" aria-hidden="true">#</a> React16架构</h2><p>React16架构可以分为三层：</p><ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><p>可以看到，相较于React15，React16中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p><h3 id="scheduler-调度器" tabindex="-1"><a class="header-anchor" href="#scheduler-调度器" aria-hidden="true">#</a> Scheduler（调度器）</h3><p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>',7),s={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback",target:"_blank",rel:"noopener noreferrer"},l=(0,t._)("code",null,"React",-1),o=(0,t.uE)("<ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低</li></ul><p>基于以上原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，<strong>Scheduler</strong>还提供了多种调度优先级供任务设置。</p>",2),c={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md",target:"_blank",rel:"noopener noreferrer"},p=(0,t._)("code",null,"React",-1),i=(0,t._)("h3",{id:"reconciler-协调器",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#reconciler-协调器","aria-hidden":"true"},"#"),(0,t.Uk)(" Reconciler（协调器）")],-1),u=(0,t._)("strong",null,"Reconciler",-1),d={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673",target:"_blank",rel:"noopener noreferrer"},k=(0,t.uE)('<p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/** <span class="token keyword">@noinline</span> */</span>\n<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Perform work until Scheduler asks us to yield</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</p><p>在React16中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b0000000000010</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000100</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b0000000000110</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b0000000001000</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',5),m={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js",target:"_blank",rel:"noopener noreferrer"},h=(0,t._)("p",null,[(0,t.Uk)("整个"),(0,t._)("strong",null,"Scheduler"),(0,t.Uk)("与"),(0,t._)("strong",null,"Reconciler"),(0,t.Uk)("的工作都在内存中进行。只有当所有组件都完成"),(0,t._)("strong",null,"Reconciler"),(0,t.Uk)("的工作，才会统一交给"),(0,t._)("strong",null,"Renderer"),(0,t.Uk)("。")],-1),g={href:"https://zh-hans.reactjs.org/docs/codebase-overview.html#fiber-reconciler",target:"_blank",rel:"noopener noreferrer"},b=(0,t._)("code",null,"React",-1),_=(0,t._)("strong",null,"Reconciler",-1),R=(0,t._)("h3",{id:"renderer-渲染器",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#renderer-渲染器","aria-hidden":"true"},"#"),(0,t.Uk)(" Renderer（渲染器）")],-1),f=(0,t._)("p",null,[(0,t._)("strong",null,"Renderer"),(0,t.Uk)("根据"),(0,t._)("strong",null,"Reconciler"),(0,t.Uk)("为虚拟DOM打的标记，同步执行对应的DOM操作。")],-1),v=(0,t._)("p",null,"所以，对于我们在上一节使用过的Demo",-1),U={class:"custom-container details"},w=(0,t._)("summary",null,"乘法小Demo",-1),y=(0,t._)("strong",null,"222",-1),x=(0,t._)("p",null,[(0,t._)("code",null,"state.count = 1"),(0,t.Uk)("，每次点击按钮"),(0,t._)("code",null,"state.count++")],-1),D=(0,t._)("p",null,[(0,t.Uk)("列表中3个元素的值分别为1，2，3乘以"),(0,t._)("code",null,"state.count"),(0,t.Uk)("的结果")],-1),S=(0,t._)("p",null,"在React16架构中整个更新流程为：",-1),C=["src"],W=(0,t._)("p",null,"其中红框中的步骤随时可能由于以下原因被中断：",-1),P=(0,t._)("ul",null,[(0,t._)("li",null,"有其他更高优任务需要先更新"),(0,t._)("li",null,"当前帧没有剩余时间")],-1),j=(0,t._)("p",null,"由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。",-1),q=(0,t._)("strong",null,"Scheduler",-1),O=(0,t._)("strong",null,"Reconciler",-1),I=(0,t._)("code",null,"React",-1),M={href:"https://www.npmjs.com/package/react-reconciler",target:"_blank",rel:"noopener noreferrer"},E=(0,t._)("code",null,"ReactDOM",-1),T=(0,t._)("strong",null,"参考资料",-1),z=(0,t.uE)('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过本节我们知道了<code>React16</code>采用新的<code>Reconciler</code>。</p><p><code>Reconciler</code>内部采用了<code>Fiber</code>的架构。</p><p><code>Fiber</code>是什么？他和<code>Reconciler</code>或者说和<code>React</code>之间是什么关系？我们会在接下来三节解答。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',5),L={href:"https://www.youtube.com/watch?v=CGpMlWVcHok&list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&index=7",target:"_blank",rel:"noopener noreferrer"},A={href:"https://agent-hunt.medium.com/hello-world-custom-react-renderer-9a95b7cd04bc",target:"_blank",rel:"noopener noreferrer"},N={class:"custom-container details"},Z=(0,t._)("summary",null,"同步/Debounce/Throttle/并发 情况下性能对比Demo",-1),B=(0,t._)("strong",null,"323",-1),F={},G=(0,a(13860).Z)(F,[["render",function(e,n){const a=(0,t.up)("ExternalLinkIcon"),F=(0,t.up)("RouterLink");return(0,t.wg)(),(0,t.iD)("div",null,[r,(0,t._)("p",null,[(0,t.Uk)("其实部分浏览器已经实现了这个API，这就是"),(0,t._)("a",s,[(0,t.Uk)("requestIdleCallback"),(0,t.Wm)(a)]),(0,t.Uk)("。但是由于以下因素，"),l,(0,t.Uk)("放弃使用：")]),o,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t._)("a",c,[(0,t.Uk)("Scheduler"),(0,t.Wm)(a)]),(0,t.Uk)("是独立于"),p,(0,t.Uk)("的库")])]),i,(0,t._)("p",null,[(0,t.Uk)("我们知道，在React15中"),u,(0,t.Uk)("是递归处理虚拟DOM的。让我们看看"),(0,t._)("a",d,[(0,t.Uk)("React16的Reconciler"),(0,t.Wm)(a)]),(0,t.Uk)("。")]),k,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t.Uk)("全部的标记见"),(0,t._)("a",m,[(0,t.Uk)("这里"),(0,t.Wm)(a)])])]),h,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t.Uk)("你可以在"),(0,t._)("a",g,[(0,t.Uk)("这里"),(0,t.Wm)(a)]),(0,t.Uk)("看到"),b,(0,t.Uk)("官方对React16新"),_,(0,t.Uk)("的解释")])]),R,f,v,(0,t._)("details",U,[w,(0,t._)("p",null,[(0,t.Wm)(F,{to:"/react/me.html"},{default:(0,t.w5)((()=>[(0,t.Uk)("关注公众号")])),_:1}),(0,t.Uk)("，后台回复"),y,(0,t.Uk)("获得在线Demo地址")]),x,D]),S,(0,t._)("img",{src:e.$withBase("/img/process.png"),alt:"更新流程"},null,8,C),W,P,j,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t.Uk)("实际上，由于"),q,(0,t.Uk)("和"),O,(0,t.Uk)("都是平台无关的，所以"),I,(0,t.Uk)("为他们单独发了一个包"),(0,t._)("a",M,[(0,t.Uk)("react-Reconciler"),(0,t.Wm)(a)]),(0,t.Uk)("。你可以用这个包自己实现一个"),E,(0,t.Uk)("，具体见"),T])]),z,(0,t._)("p",null,[(0,t._)("a",L,[(0,t.Uk)("「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert"),(0,t.Wm)(a)]),(0,t._)("a",A,[(0,t.Uk)("hello-world-custom-react-renderer"),(0,t.Wm)(a)])]),(0,t._)("details",N,[Z,(0,t._)("p",null,[(0,t.Wm)(F,{to:"/react/me.html"},{default:(0,t.w5)((()=>[(0,t.Uk)("关注公众号")])),_:1}),(0,t.Uk)("，后台回复"),B,(0,t.Uk)("获得在线Demo地址")])])])}]])},13860:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,t]of n)a[e]=t;return a}},71858:(e,n,a)=>{a.r(n),a.d(n,{data:()=>t});const t=JSON.parse('{"key":"v-3d69ea6e","path":"/react/preparation/newConstructure.html","title":"新的React架构","lang":"zh-CN","frontmatter":{"title":"新的React架构","author":"BetaSu","tag":["React"],"summary":"上一节我们聊到React15架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的React16是如何支持异步更新的。 React16架构 React16架构可以分为三层： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler; Reconciler（协调器）—— 负责找出变化的组件; Renderer（渲染器）","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/preparation/newConstructure.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝑔𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"新的React架构"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"React16架构","slug":"react16架构","children":[{"level":3,"title":"Scheduler（调度器）","slug":"scheduler-调度器","children":[]},{"level":3,"title":"Reconciler（协调器）","slug":"reconciler-协调器","children":[]},{"level":3,"title":"Renderer（渲染器）","slug":"renderer-渲染器","children":[]}]},{"level":2,"title":"总结","slug":"总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":3.43,"words":1029},"filePathRelative":"react/preparation/newConstructure.md","localizedDate":"2022年8月29日"}')}}]);