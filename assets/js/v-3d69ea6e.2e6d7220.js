"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[73926],{58368:(e,n,a)=>{a.r(n),a.d(n,{default:()=>ye});var t=a(78e3);const r=(0,t.uE)('<p>上一节我们聊到React15架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的React16是如何支持异步更新的。</p><h2 id="react16架构" tabindex="-1"><a class="header-anchor" href="#react16架构" aria-hidden="true">#</a> React16架构</h2><p>React16架构可以分为三层：</p><ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><p>可以看到，相较于React15，React16中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p><h3 id="scheduler-调度器" tabindex="-1"><a class="header-anchor" href="#scheduler-调度器" aria-hidden="true">#</a> Scheduler（调度器）</h3><p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>',7),s=(0,t.Uk)("其实部分浏览器已经实现了这个API，这就是"),l={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback",target:"_blank",rel:"noopener noreferrer"},o=(0,t.Uk)("requestIdleCallback"),c=(0,t.Uk)("。但是由于以下因素，"),p=(0,t._)("code",null,"React",-1),i=(0,t.Uk)("放弃使用："),u=(0,t.uE)("<ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低</li></ul><p>基于以上原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，<strong>Scheduler</strong>还提供了多种调度优先级供任务设置。</p>",2),d={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md",target:"_blank",rel:"noopener noreferrer"},k=(0,t.Uk)("Scheduler"),m=(0,t.Uk)("是独立于"),h=(0,t._)("code",null,"React",-1),g=(0,t.Uk)("的库"),b=(0,t._)("h3",{id:"reconciler-协调器",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#reconciler-协调器","aria-hidden":"true"},"#"),(0,t.Uk)(" Reconciler（协调器）")],-1),_=(0,t.Uk)("我们知道，在React15中"),R=(0,t._)("strong",null,"Reconciler",-1),f=(0,t.Uk)("是递归处理虚拟DOM的。让我们看看"),v={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673",target:"_blank",rel:"noopener noreferrer"},U=(0,t.Uk)("React16的Reconciler"),w=(0,t.Uk)("。"),y=(0,t.uE)('<p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/** <span class="token keyword">@noinline</span> */</span>\n<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Perform work until Scheduler asks us to yield</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</p><p>在React16中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b0000000000010</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000100</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b0000000000110</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b0000000001000</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',5),x=(0,t.Uk)("全部的标记见"),D={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js",target:"_blank",rel:"noopener noreferrer"},S=(0,t.Uk)("这里"),C=(0,t._)("p",null,[(0,t.Uk)("整个"),(0,t._)("strong",null,"Scheduler"),(0,t.Uk)("与"),(0,t._)("strong",null,"Reconciler"),(0,t.Uk)("的工作都在内存中进行。只有当所有组件都完成"),(0,t._)("strong",null,"Reconciler"),(0,t.Uk)("的工作，才会统一交给"),(0,t._)("strong",null,"Renderer"),(0,t.Uk)("。")],-1),W=(0,t.Uk)("你可以在"),P={href:"https://zh-hans.reactjs.org/docs/codebase-overview.html#fiber-reconciler",target:"_blank",rel:"noopener noreferrer"},j=(0,t.Uk)("这里"),q=(0,t.Uk)("看到"),O=(0,t._)("code",null,"React",-1),I=(0,t.Uk)("官方对React16新"),M=(0,t._)("strong",null,"Reconciler",-1),E=(0,t.Uk)("的解释"),T=(0,t._)("h3",{id:"renderer-渲染器",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#renderer-渲染器","aria-hidden":"true"},"#"),(0,t.Uk)(" Renderer（渲染器）")],-1),z=(0,t._)("p",null,[(0,t._)("strong",null,"Renderer"),(0,t.Uk)("根据"),(0,t._)("strong",null,"Reconciler"),(0,t.Uk)("为虚拟DOM打的标记，同步执行对应的DOM操作。")],-1),L=(0,t._)("p",null,"所以，对于我们在上一节使用过的Demo",-1),A={class:"custom-container details"},N=(0,t._)("summary",null,"乘法小Demo",-1),Z=(0,t.Uk)("关注公众号"),B=(0,t.Uk)("，后台回复"),F=(0,t._)("strong",null,"222",-1),G=(0,t.Uk)("获得在线Demo地址"),H=(0,t._)("p",null,[(0,t._)("code",null,"state.count = 1"),(0,t.Uk)("，每次点击按钮"),(0,t._)("code",null,"state.count++")],-1),J=(0,t._)("p",null,[(0,t.Uk)("列表中3个元素的值分别为1，2，3乘以"),(0,t._)("code",null,"state.count"),(0,t.Uk)("的结果")],-1),Y=(0,t._)("p",null,"在React16架构中整个更新流程为：",-1),V=["src"],$=(0,t._)("p",null,"其中红框中的步骤随时可能由于以下原因被中断：",-1),K=(0,t._)("ul",null,[(0,t._)("li",null,"有其他更高优任务需要先更新"),(0,t._)("li",null,"当前帧没有剩余时间")],-1),Q=(0,t._)("p",null,"由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。",-1),X=(0,t.Uk)("实际上，由于"),ee=(0,t._)("strong",null,"Scheduler",-1),ne=(0,t.Uk)("和"),ae=(0,t._)("strong",null,"Reconciler",-1),te=(0,t.Uk)("都是平台无关的，所以"),re=(0,t._)("code",null,"React",-1),se=(0,t.Uk)("为他们单独发了一个包"),le={href:"https://www.npmjs.com/package/react-reconciler",target:"_blank",rel:"noopener noreferrer"},oe=(0,t.Uk)("react-Reconciler"),ce=(0,t.Uk)("。你可以用这个包自己实现一个"),pe=(0,t._)("code",null,"ReactDOM",-1),ie=(0,t.Uk)("，具体见"),ue=(0,t._)("strong",null,"参考资料",-1),de=(0,t.uE)('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过本节我们知道了<code>React16</code>采用新的<code>Reconciler</code>。</p><p><code>Reconciler</code>内部采用了<code>Fiber</code>的架构。</p><p><code>Fiber</code>是什么？他和<code>Reconciler</code>或者说和<code>React</code>之间是什么关系？我们会在接下来三节解答。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',5),ke={href:"https://www.youtube.com/watch?v=CGpMlWVcHok&list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&index=7",target:"_blank",rel:"noopener noreferrer"},me=(0,t.Uk)("「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert"),he={href:"https://agent-hunt.medium.com/hello-world-custom-react-renderer-9a95b7cd04bc",target:"_blank",rel:"noopener noreferrer"},ge=(0,t.Uk)("hello-world-custom-react-renderer"),be={class:"custom-container details"},_e=(0,t._)("summary",null,"同步/Debounce/Throttle/并发 情况下性能对比Demo",-1),Re=(0,t.Uk)("关注公众号"),fe=(0,t.Uk)("，后台回复"),ve=(0,t._)("strong",null,"323",-1),Ue=(0,t.Uk)("获得在线Demo地址"),we={},ye=(0,a(13860).Z)(we,[["render",function(e,n){const a=(0,t.up)("ExternalLinkIcon"),we=(0,t.up)("RouterLink");return(0,t.wg)(),(0,t.iD)("div",null,[r,(0,t._)("p",null,[s,(0,t._)("a",l,[o,(0,t.Wm)(a)]),c,p,i]),u,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t._)("a",d,[k,(0,t.Wm)(a)]),m,h,g])]),b,(0,t._)("p",null,[_,R,f,(0,t._)("a",v,[U,(0,t.Wm)(a)]),w]),y,(0,t._)("blockquote",null,[(0,t._)("p",null,[x,(0,t._)("a",D,[S,(0,t.Wm)(a)])])]),C,(0,t._)("blockquote",null,[(0,t._)("p",null,[W,(0,t._)("a",P,[j,(0,t.Wm)(a)]),q,O,I,M,E])]),T,z,L,(0,t._)("details",A,[N,(0,t._)("p",null,[(0,t.Wm)(we,{to:"/react/me.html"},{default:(0,t.w5)((()=>[Z])),_:1}),B,F,G]),H,J]),Y,(0,t._)("img",{src:e.$withBase("/img/process.png"),alt:"更新流程"},null,8,V),$,K,Q,(0,t._)("blockquote",null,[(0,t._)("p",null,[X,ee,ne,ae,te,re,se,(0,t._)("a",le,[oe,(0,t.Wm)(a)]),ce,pe,ie,ue])]),de,(0,t._)("p",null,[(0,t._)("a",ke,[me,(0,t.Wm)(a)]),(0,t._)("a",he,[ge,(0,t.Wm)(a)])]),(0,t._)("details",be,[_e,(0,t._)("p",null,[(0,t.Wm)(we,{to:"/react/me.html"},{default:(0,t.w5)((()=>[Re])),_:1}),fe,ve,Ue])])])}]])},13860:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,t]of n)a[e]=t;return a}},71858:(e,n,a)=>{a.r(n),a.d(n,{data:()=>t});const t=JSON.parse('{"key":"v-3d69ea6e","path":"/react/preparation/newConstructure.html","title":"新的React架构","lang":"zh-CN","frontmatter":{"title":"新的React架构","author":"BetaSu","tag":["React"],"summary":"上一节我们聊到React15架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的React16是如何支持异步更新的。 React16架构 React16架构可以分为三层： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler; Reconciler（协调器）—— 负责找出变化的组件; Renderer（渲染器）","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/preparation/newConstructure.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"新的React架构"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"React16架构","slug":"react16架构","children":[{"level":3,"title":"Scheduler（调度器）","slug":"scheduler-调度器","children":[]},{"level":3,"title":"Reconciler（协调器）","slug":"reconciler-协调器","children":[]},{"level":3,"title":"Renderer（渲染器）","slug":"renderer-渲染器","children":[]}]},{"level":2,"title":"总结","slug":"总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":3.43,"words":1029},"filePathRelative":"react/preparation/newConstructure.md","localizedDate":"2022年8月29日"}')}}]);