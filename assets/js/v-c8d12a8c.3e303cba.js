"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[86768],{33771:(e,o,c)=>{c.r(o),c.d(o,{default:()=>P});var n=c(78e3);const t={class:"custom-container warning"},a=(0,n._)("p",{class:"custom-container-title"},"注意",-1),d=(0,n._)("p",null,[(0,n.Uk)("在开始本章学习前，你需要了解"),(0,n._)("code",null,"Hooks"),(0,n.Uk)("的基本用法。")],-1),s=(0,n.Uk)("如果你还未使用过"),p=(0,n._)("code",null,"Hooks",-1),r=(0,n.Uk)("，可以从"),l={href:"https://zh-hans.reactjs.org/docs/hooks-intro.html",target:"_blank",rel:"noopener noreferrer"},i=(0,n.Uk)("官方文档"),u=(0,n.Uk)("开始。"),k=(0,n.Uk)("你可以从"),m={href:"https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation",target:"_blank",rel:"noopener noreferrer"},h=(0,n.Uk)("这里"),g=(0,n.Uk)("了解"),f=(0,n._)("code",null,"Hooks",-1),_=(0,n.Uk)("的设计动机。作为一名"),b=(0,n._)("code",null,"框架使用者",-1),H=(0,n.Uk)("，了解"),C=(0,n._)("code",null,"设计动机",-1),v=(0,n.Uk)("对于我们日常开发就足够了。"),U=(0,n.uE)('<p>但是，为了更好的理解<code>Hooks</code>的<code>源码架构</code>，我们需要转换身份，以<code>框架开发者</code>的角度来看待<code>Hooks</code>的<code>设计理念</code>。</p><h2 id="从logo聊起" tabindex="-1"><a class="header-anchor" href="#从logo聊起" aria-hidden="true">#</a> 从LOGO聊起</h2>',2),R=["src"],y=(0,n.uE)('<p><code>React</code> <code>LOGO</code>的图案是代表<code>原子</code>（<code>atom</code>）的符号。世间万物由<code>原子</code>组成，<code>原子</code>的<code>类型</code>与<code>属性</code>决定了事物的外观与表现。</p><p>同样，在<code>React</code>中，我们可以将<code>UI</code>拆分为很多独立的单元，每个单元被称为<code>Component</code>。这些<code>Component</code>的<code>属性</code>与<code>类型</code>决定了<code>UI</code>的外观与表现。</p><p>讽刺的是，<code>原子</code>在希腊语中的意思为<code>不可分割的</code>（<code>indivisible</code>），但随后科学家在原子中发现了更小的粒子 —— 电子（<code>electron</code>）。电子可以很好的解释<code>原子</code>是如何工作的。</p><p>在<code>React</code>中，我们可以说<code>ClassComponent</code>是一类<code>原子</code>。</p><p>但对于<code>Hooks</code>来说，与其说是一类<code>原子</code>，不如说他是更贴近事物<code>运行规律</code>的<code>电子</code>。</p><p>我们知道，<code>React</code>的架构遵循<code>schedule - render - commit</code>的运行流程，这个流程是<code>React</code>世界最底层的<code>运行规律</code>。</p><p><code>ClassComponent</code>作为<code>React</code>世界的<code>原子</code>，他的<code>生命周期</code>（<code>componentWillXXX</code>/<code>componentDidXXX</code>）是为了介入<code>React</code>的运行流程而实现的更上层抽象，这么做是为了方便<code>框架使用者</code>更容易上手。</p><p>相比于<code>ClassComponent</code>的更上层抽象，<code>Hooks</code>则更贴近<code>React</code>内部运行的各种概念（<code>state</code> | <code>context</code> | <code>life-cycle</code>）。</p><p>作为使用<code>React</code>技术栈的开发者，当我们初次学习<code>Hooks</code>时，不管是官方文档还是身边有经验的同事，总会拿<code>ClassComponent</code>的生命周期来类比<code>Hooks API</code>的执行时机。</p><p>这固然是很好的上手方式，但是当我们熟练运用<code>Hooks</code>时，就会发现，这两者的概念有很多割裂感，并不是同一抽象层次可以互相替代的概念。</p><p>比如：替代<code>componentWillReceiveProps</code>的<code>Hooks</code>是什么呢？</p><p>可能有些同学会回答，是<code>useEffect</code>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token function">useEffect</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;something updated&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>something<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是<code>componentWillReceiveProps</code>是在<code>render阶段</code>执行，而<code>useEffect</code>是在<code>commit阶段</code>完成渲染后异步执行。</p>',14),O=(0,n.Uk)("这篇文章可以帮你更好理解"),w=(0,n._)("code",null,"componentWillReceiveProps",-1),x=(0,n.Uk)("："),D={href:"https://juejin.im/post/5f05a3e25188252e5c576cdb",target:"_blank",rel:"noopener noreferrer"},j=(0,n.Uk)("深入源码剖析componentWillXXX为什么UNSAFE"),E=(0,n._)("p",null,[(0,n.Uk)("所以，从源码运行规律的角度看待"),(0,n._)("code",null,"Hooks"),(0,n.Uk)("，可能是更好的角度。这也是为什么上文说"),(0,n._)("code",null,"Hooks"),(0,n.Uk)("是"),(0,n._)("code",null,"React"),(0,n.Uk)("世界的"),(0,n._)("code",null,"电子"),(0,n.Uk)("而不是"),(0,n._)("code",null,"原子"),(0,n.Uk)("的原因。")],-1),W=(0,n.Uk)("以上见解参考自"),X={href:"https://www.youtube.com/watch?v=dpw9EHDh2bM&feature=youtu.be",target:"_blank",rel:"noopener noreferrer"},L=(0,n.Uk)("React Core Team Dan在 React Conf2018的演讲"),z=(0,n.uE)('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><code>Concurrent Mode</code>是<code>React</code>未来的发展方向，而<code>Hooks</code>是能够最大限度发挥<code>Concurrent Mode</code>潜力的<code>Component</code>构建方式。</p><p>正如Dan在<code>React Conf 2018</code>演讲结尾所说：你可以从<code>React</code>的<code>LOGO</code>中看到这些围绕着<code>核心</code>的<code>电子飞行轨道</code>，<code>Hooks</code>可能一直就在其中。</p>',3),G={},P=(0,c(13860).Z)(G,[["render",function(e,o){const c=(0,n.up)("ExternalLinkIcon");return(0,n.wg)(),(0,n.iD)("div",null,[(0,n._)("div",t,[a,d,(0,n._)("p",null,[s,p,r,(0,n._)("a",l,[i,(0,n.Wm)(c)]),u])]),(0,n._)("p",null,[k,(0,n._)("a",m,[h,(0,n.Wm)(c)]),g,f,_,b,H,C,v]),U,(0,n._)("img",{src:e.$withBase("/img/logo.png"),alt:"LOGO"},null,8,R),y,(0,n._)("blockquote",null,[(0,n._)("p",null,[O,w,x,(0,n._)("a",D,[j,(0,n.Wm)(c)])])]),E,(0,n._)("blockquote",null,[(0,n._)("p",null,[W,(0,n._)("a",X,[L,(0,n.Wm)(c)])])]),(0,n.kq)(' ## Hooks设计动机\n\n那么真的有`Hooks`能做而`ClassComponent`无法实现的`feature`么？\n\n是的。\n\n让我们再来看看`React`耗时三年重构完成的`Fiber结构`。在之前的章节我们讲过，这次重构的一大目的是**使更新可以异步执行并且可中断**。\n\n现在让我们看看另一大目的：**使同一组件在同一时间可以拥有多个状态，即同一个组件可以拥有多条时间线**。\n\n<img :src="$withBase(\'/img/hooks-mental.png\')" alt="hooks设计理念">\n\n> [React Core Team Sebastian谈Hooks设计动机](https://twitter.com/sebmarkbage/status/1084539728743956481)\n\n`fiber`可以直译为`光纤`。\n\n<img :src="$withBase(\'/img/lightfiber.jpg\')" alt="fiber">\n\n可以看到，一束`光纤`内部存在多束同时工作的玻璃芯。在`React`中，每条玻璃芯代表一个`Component`的时间线。\n\n由于`ClassComponent`遵循`OOP`原则，`逻辑`和`状态`耦合在`实例`内部，无法在同一时间拥有多个`状态`（即同一时间只存在一个`this.state`）。\n\n对于`Hooks`来说，`FunctionComponent`契合`FP`的编程思想（即`无状态`），更新组件时`Hooks`的`状态`保存在`闭包`中。换言之，同一`FunctionComponent`在同一时间可以拥有保存在不同`闭包`中的多个`状态`。\n\n::: details 多条时间线 Demo\n\n你可以使用[useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue)使同一组件的某个`状态`在同一时间拥有多条时间线。\n\n不同时间线重合的时间视**用户设备的性能**不同而不同。\n\n在Demo中，你可以从控制台看到不同`状态`的`值`与`更新时间`\n\n[Demo](https://codesandbox.io/s/friendly-bush-hk5co)\n\n::: '),z])}]])},13860:(e,o)=>{o.Z=(e,o)=>{const c=e.__vccOpts||e;for(const[e,n]of o)c[e]=n;return c}},52349:(e,o,c)=>{c.r(o),c.d(o,{data:()=>n});const n=JSON.parse('{"key":"v-c8d12a8c","path":"/react/hooks/prepare.html","title":"Hooks理念","lang":"zh-CN","frontmatter":{"title":"Hooks理念","author":"BetaSu","tag":["React"],"summary":"注意 在开始本章学习前，你需要了解Hooks的基本用法。 如果你还未使用过Hooks，可以从官方文档开始。 你可以从这里了解Hooks的设计动机。作为一名框架使用者，了解设计动机对于我们日常开发就足够了。 但是，为了更好的理解Hooks的源码架构，我们需要转换身份，以框架开发者的角度来看待Hooks的设计理念。 从LOGO聊起 React LOGO的图案是代","head":[["meta",{"property":"og:url","content":"https://0808200.xyz/react/hooks/prepare.html"}],["meta",{"property":"og:site_name","content":"𝑀𝑟.𝐺𝑜𝑜𝑔𝑥ℎ"}],["meta",{"property":"og:title","content":"Hooks理念"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-08-29T09:14:21.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BetaSu"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:modified_time","content":"2022-08-29T09:14:21.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"从LOGO聊起","slug":"从logo聊起","children":[]},{"level":2,"title":"总结","slug":"总结","children":[]}],"git":{"createdTime":1661764461000,"updatedTime":1661764461000,"contributors":[{"name":"googxh","email":"gxh522@qq.com","commits":1}]},"readingTime":{"minutes":4.04,"words":1211},"filePathRelative":"react/hooks/prepare.md","localizedDate":"2022年8月29日"}')}}]);